{"chunks": [{"id": "/home/deeog/Desktop/KnowCode/test_mcp_workflow.md::module::0", "entity_id": "/home/deeog/Desktop/KnowCode/test_mcp_workflow.md::module", "content": "# MCP Workflow Test Plan\n## After IDE Restart - Test These Questions\nOnce you've restarted Antigravity IDE, test the MCP workflow with these questions:\n### Test 1: Simple Code Query (Expected: High Sufficiency)\n```\nHow does search work in KnowCode?\n```\n**Expected Result:**\n- `sufficiency_score >= 0.88`\n- Agent answers from context only\n- No external LLM call\n- Response includes details about SearchEngine, HybridIndex, etc.\n---\n### Test 2: Specific Function Query (Expected: High Sufficiency)\n```\nWhat does the retrieve_context_for_query method do?\n```\n**Expected Result:**\n- `sufficiency_score >= 0.88`\n- Agent answers from context only\n- Response includes method signature, parameters, and logic\n---\n### Test 3: Architecture Query (Expected: Medium Sufficiency)\n```\nExplain the overall architecture of KnowCode\n```\n**Expected Result:**\n- `sufficiency_score` may be 0.70-0.85\n- Agent may use external LLM for synthesis\n- But context should be retrieved first\n---\n### Test 4: Implementation Query (Expected: High Sufficiency)\n```\nShow me how semantic search is implemented\n```\n**Expected Result:**\n- `sufficiency_score >= 0.88`\n- Agent answers from context only\n- Response includes HybridIndex, VectorStore, embeddings\n---\n### Test 5: Out-of-Scope Query (Expected: Low Sufficiency)\n```\nWhat are the best practices for Python async programming?\n```\n**Expected Result:**\n- `sufficiency_score < 0.50`\n- Agent uses external LLM\n- This is correct behavior (not in codebase)\n---\n## How to Verify MCP is Working\n### Check 1: Tool Availability\nThe agent should have access to `retrieve_context_for_query` tool.\n### Check 2: Agent Behavior\nLook for these indicators in the agent's response:\n- \"Retrieving context from codebase...\"\n- \"Sufficiency score: X.XX\"\n- \"Answering from local context\" (when score >= 0.88)\n### Check 3: MCP Server Process\n```bash\nps aux | grep \"knowcode mcp-server\"\n```\nShould show the server running with the venv path.\n### Check 4: No Manual Server Needed\nYou should NOT need to manually run `knowcode mcp-server` - Antigravity starts it automatically.\n---\n## Troubleshooting\n### If MCP Tool Not Available\n1. Check MCP server is running:\n   ```bash\n   ./verify_mcp_connection.sh\n   ```\n2. Verify configuration:\n   ```bash\n   cat ~/.gemini/mcp_servers.json\n   ```\n3. Check IDE logs (if available)\n4. Restart IDE again\n### If Sufficiency Scores Always Low\n1. Verify semantic index exists:\n   ```bash\n   ls -la knowcode_index/\n   ```\n2. Rebuild index if needed:\n   ```bash\n   source .venv/bin/activate\n   knowcode index . --output knowcode_index\n   ```\n3. Check embedding configuration in `aimodels.yaml`\n### If Agent Doesn't Follow Rules\n1. Verify `.agent/context.md` exists and contains the rules\n2. Check the rules are properly formatted\n3. Try rephrasing your query to be more specific\n---\n## Success Criteria\n\u2705 MCP server starts automatically when IDE starts\n\u2705 `retrieve_context_for_query` tool is available\n\u2705 Agent retrieves context before answering\n\u2705 High sufficiency scores (>0.88) for codebase questions\n\u2705 Agent answers from context only when sufficient\n\u2705 Agent uses external LLM only when needed (score < 0.88)\n---\n## Next Steps After Successful Test\n1. **Monitor token usage** - Track how much you save\n2. **Adjust thresholds** - Fine-tune sufficiency_score threshold\n3. **Update knowledge store** - Re-analyze after code changes\n4. **Expand to other projects** - Set up MCP for other codebases\n5. **Document learnings** - Note what works best for your workflow\n---\n## Performance Benchmarks\nTrack these metrics over time:\n| Metric | Target | Current |\n|--------|--------|---------|\n| % Queries with score >= 0.88 | >70% | TBD |\n| Avg response time (local) | <2s | TBD |\n| Avg response time (external) | <10s | TBD |\n| Token savings per day | >50% | TBD |\n| Answer accuracy (local) | >95% | TBD |\n---\n## Questions to Test Different Features\n### Dependency Expansion\n```\nWhat functions does SearchEngine.search call?\n```\n### Multi-Entity Context\n```\nHow do SearchEngine, HybridIndex, and Reranker work together?\n```\n### Temporal Queries (if coverage data available)\n```\nWhich functions were recently modified?\n```\n### Impact Analysis\n```\nWhat would break if I change the HybridIndex.search method?\n```\n---\n## Remember\nThe goal is **local-first retrieval** to:\n- \u2705 Reduce external LLM token consumption\n- \u2705 Get faster responses for codebase questions\n- \u2705 Maintain privacy (code stays local)\n- \u2705 Improve answer quality (direct from source)\nGood luck with your testing! \ud83d\ude80", "tokens": ["mcp", "workflow", "test", "plan", "after", "ide", "restart", "test", "these", "questions", "once", "you", "ve", "restarted", "antigravity", "ide", "test", "the", "mcp", "workflow", "with", "these", "questions", "test", "simple", "code", "query", "expected", "high", "sufficiency", "how", "does", "search", "work", "in", "know", "code", "expected", "result", "sufficiency", "score", "88", "agent", "answers", "from", "context", "only", "no", "external", "llm", "call", "response", "includes", "details", "about", "search", "engine", "hybrid", "index", "etc", "test", "specific", "function", "query", "expected", "high", "sufficiency", "what", "does", "the", "retrieve", "context", "for", "query", "method", "do", "expected", "result", "sufficiency", "score", "88", "agent", "answers", "from", "context", "only", "response", "includes", "method", "signature", "parameters", "and", "logic", "test", "architecture", "query", "expected", "medium", "sufficiency", "explain", "the", "overall", "architecture", "of", "know", "code", "expected", "result", "sufficiency", "score", "may", "be", "70", "85", "agent", "may", "use", "external", "llm", "for", "synthesis", "but", "context", "should", "be", "retrieved", "first", "test", "implementation", "query", "expected", "high", "sufficiency", "show", "me", "how", "semantic", "search", "is", "implemented", "expected", "result", "sufficiency", "score", "88", "agent", "answers", "from", "context", "only", "response", "includes", "hybrid", "index", "vector", "store", "embeddings", "test", "out", "of", "scope", "query", "expected", "low", "sufficiency", "what", "are", "the", "best", "practices", "for", "python", "async", "programming", "expected", "result", "sufficiency", "score", "50", "agent", "uses", "external", "llm", "this", "is", "correct", "behavior", "not", "in", "codebase", "how", "to", "verify", "mcp", "is", "working", "check", "tool", "availability", "the", "agent", "should", "have", "access", "to", "retrieve", "context", "for", "query", "tool", "check", "agent", "behavior", "look", "for", "these", "indicators", "in", "the", "agent", "response", "retrieving", "context", "from", "codebase", "sufficiency", "score", "xx", "answering", "from", "local", "context", "when", "score", "88", "check", "mcp", "server", "process", "bash", "ps", "aux", "grep", "knowcode", "mcp", "server", "should", "show", "the", "server", "running", "with", "the", "venv", "path", "check", "no", "manual", "server", "needed", "you", "should", "not", "need", "to", "manually", "run", "knowcode", "mcp", "server", "antigravity", "starts", "it", "automatically", "troubleshooting", "if", "mcp", "tool", "not", "available", "check", "mcp", "server", "is", "running", "bash", "verify", "mcp", "connection", "sh", "verify", "configuration", "bash", "cat", "gemini", "mcp", "servers", "json", "check", "ide", "logs", "if", "available", "restart", "ide", "again", "if", "sufficiency", "scores", "always", "low", "verify", "semantic", "index", "exists", "bash", "ls", "la", "knowcode", "index", "rebuild", "index", "if", "needed", "bash", "source", "venv", "bin", "activate", "knowcode", "index", "output", "knowcode", "index", "check", "embedding", "configuration", "in", "aimodels", "yaml", "if", "agent", "doesn", "follow", "rules", "verify", "agent", "context", "md", "exists", "and", "contains", "the", "rules", "check", "the", "rules", "are", "properly", "formatted", "try", "rephrasing", "your", "query", "to", "be", "more", "specific", "success", "criteria", "mcp", "server", "starts", "automatically", "when", "ide", "starts", "retrieve", "context", "for", "query", "tool", "is", "available", "agent", "retrieves", "context", "before", "answering", "high", "sufficiency", "scores", "88", "for", "codebase", "questions", "agent", "answers", "from", "context", "only", "when", "sufficient", "agent", "uses", "external", "llm", "only", "when", "needed", "score", "88", "next", "steps", "after", "successful", "test", "monitor", "token", "usage", "track", "how", "much", "you", "save", "adjust", "thresholds", "fine", "tune", "sufficiency", "score", "threshold", "update", "knowledge", "store", "re", "analyze", "after", "code", "changes", "expand", "to", "other", "projects", "set", "up", "mcp", "for", "other", "codebases", "document", "learnings", "note", "what", "works", "best", "for", "your", "workflow", "performance", "benchmarks", "track", "these", "metrics", "over", "time", "metric", "target", "current", "queries", "with", "score", "88", "70", "tbd", "avg", "response", "time", "local", "2s", "tbd", "avg", "response", "time", "external", "10s", "tbd", "token", "savings", "per", "day", "50", "tbd", "answer", "accuracy", "local", "95", "tbd", "questions", "to", "test", "different", "features", "dependency", "expansion", "what", "functions", "does", "search", "engine", "search", "call", "multi", "entity", "context", "how", "do", "search", "engine", "hybrid", "index", "and", "reranker", "work", "together", "temporal", "queries", "if", "coverage", "data", "available", "which", "functions", "were", "recently", "modified", "impact", "analysis", "what", "would", "break", "if", "change", "the", "hybrid", "index", "search", "method", "remember", "the", "goal", "is", "local", "first", "retrieval", "to", "reduce", "external", "llm", "token", "consumption", "get", "faster", "responses", "for", "codebase", "questions", "maintain", "privacy", "code", "stays", "local", "improve", "answer", "quality", "direct", "from", "source", "good", "luck", "with", "your", "testing"], "metadata": {"type": "module_header"}}, {"id": "/home/deeog/Desktop/KnowCode/test_mcp_workflow.md::test_mcp_workflow::0", "entity_id": "/home/deeog/Desktop/KnowCode/test_mcp_workflow.md::test_mcp_workflow", "content": "\"\"\"Once you've restarted Antigravity IDE, test the MCP workflow with these questions:\"\"\"\ntest_mcp_workflow", "tokens": ["once", "you", "ve", "restarted", "antigravity", "ide", "test", "the", "mcp", "workflow", "with", "these", "questions", "test", "mcp", "workflow"], "metadata": {"kind": "document", "has_docstring": "true", "last_modified": "1768289627.063532"}}, {"id": "/home/deeog/Desktop/KnowCode/test_mcp_workflow.md::mcp-workflow-test-plan::0", "entity_id": "/home/deeog/Desktop/KnowCode/test_mcp_workflow.md::mcp-workflow-test-plan", "content": "MCP Workflow Test Plan", "tokens": ["mcp", "workflow", "test", "plan"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768289627.063532"}}, {"id": "/home/deeog/Desktop/KnowCode/test_mcp_workflow.md::after-ide-restart-test-these-questions::0", "entity_id": "/home/deeog/Desktop/KnowCode/test_mcp_workflow.md::after-ide-restart-test-these-questions", "content": "After IDE Restart - Test These Questions", "tokens": ["after", "ide", "restart", "test", "these", "questions"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768289627.063532"}}, {"id": "/home/deeog/Desktop/KnowCode/test_mcp_workflow.md::test-1-simple-code-query-expected-high-sufficiency::0", "entity_id": "/home/deeog/Desktop/KnowCode/test_mcp_workflow.md::test-1-simple-code-query-expected-high-sufficiency", "content": "Test 1: Simple Code Query (Expected: High Sufficiency)", "tokens": ["test", "simple", "code", "query", "expected", "high", "sufficiency"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768289627.063532"}}, {"id": "/home/deeog/Desktop/KnowCode/test_mcp_workflow.md::test-2-specific-function-query-expected-high-sufficiency::0", "entity_id": "/home/deeog/Desktop/KnowCode/test_mcp_workflow.md::test-2-specific-function-query-expected-high-sufficiency", "content": "Test 2: Specific Function Query (Expected: High Sufficiency)", "tokens": ["test", "specific", "function", "query", "expected", "high", "sufficiency"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768289627.063532"}}, {"id": "/home/deeog/Desktop/KnowCode/test_mcp_workflow.md::test-3-architecture-query-expected-medium-sufficiency::0", "entity_id": "/home/deeog/Desktop/KnowCode/test_mcp_workflow.md::test-3-architecture-query-expected-medium-sufficiency", "content": "Test 3: Architecture Query (Expected: Medium Sufficiency)", "tokens": ["test", "architecture", "query", "expected", "medium", "sufficiency"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768289627.063532"}}, {"id": "/home/deeog/Desktop/KnowCode/test_mcp_workflow.md::test-4-implementation-query-expected-high-sufficiency::0", "entity_id": "/home/deeog/Desktop/KnowCode/test_mcp_workflow.md::test-4-implementation-query-expected-high-sufficiency", "content": "Test 4: Implementation Query (Expected: High Sufficiency)", "tokens": ["test", "implementation", "query", "expected", "high", "sufficiency"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768289627.063532"}}, {"id": "/home/deeog/Desktop/KnowCode/test_mcp_workflow.md::test-5-out-of-scope-query-expected-low-sufficiency::0", "entity_id": "/home/deeog/Desktop/KnowCode/test_mcp_workflow.md::test-5-out-of-scope-query-expected-low-sufficiency", "content": "Test 5: Out-of-Scope Query (Expected: Low Sufficiency)", "tokens": ["test", "out", "of", "scope", "query", "expected", "low", "sufficiency"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768289627.063532"}}, {"id": "/home/deeog/Desktop/KnowCode/test_mcp_workflow.md::how-to-verify-mcp-is-working::0", "entity_id": "/home/deeog/Desktop/KnowCode/test_mcp_workflow.md::how-to-verify-mcp-is-working", "content": "How to Verify MCP is Working", "tokens": ["how", "to", "verify", "mcp", "is", "working"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768289627.063532"}}, {"id": "/home/deeog/Desktop/KnowCode/test_mcp_workflow.md::check-1-tool-availability::0", "entity_id": "/home/deeog/Desktop/KnowCode/test_mcp_workflow.md::check-1-tool-availability", "content": "Check 1: Tool Availability", "tokens": ["check", "tool", "availability"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768289627.063532"}}, {"id": "/home/deeog/Desktop/KnowCode/test_mcp_workflow.md::check-2-agent-behavior::0", "entity_id": "/home/deeog/Desktop/KnowCode/test_mcp_workflow.md::check-2-agent-behavior", "content": "Check 2: Agent Behavior", "tokens": ["check", "agent", "behavior"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768289627.063532"}}, {"id": "/home/deeog/Desktop/KnowCode/test_mcp_workflow.md::check-3-mcp-server-process::0", "entity_id": "/home/deeog/Desktop/KnowCode/test_mcp_workflow.md::check-3-mcp-server-process", "content": "Check 3: MCP Server Process", "tokens": ["check", "mcp", "server", "process"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768289627.063532"}}, {"id": "/home/deeog/Desktop/KnowCode/test_mcp_workflow.md::check-4-no-manual-server-needed::0", "entity_id": "/home/deeog/Desktop/KnowCode/test_mcp_workflow.md::check-4-no-manual-server-needed", "content": "Check 4: No Manual Server Needed", "tokens": ["check", "no", "manual", "server", "needed"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768289627.063532"}}, {"id": "/home/deeog/Desktop/KnowCode/test_mcp_workflow.md::troubleshooting::0", "entity_id": "/home/deeog/Desktop/KnowCode/test_mcp_workflow.md::troubleshooting", "content": "Troubleshooting", "tokens": ["troubleshooting"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768289627.063532"}}, {"id": "/home/deeog/Desktop/KnowCode/test_mcp_workflow.md::if-mcp-tool-not-available::0", "entity_id": "/home/deeog/Desktop/KnowCode/test_mcp_workflow.md::if-mcp-tool-not-available", "content": "If MCP Tool Not Available", "tokens": ["if", "mcp", "tool", "not", "available"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768289627.063532"}}, {"id": "/home/deeog/Desktop/KnowCode/test_mcp_workflow.md::if-sufficiency-scores-always-low::0", "entity_id": "/home/deeog/Desktop/KnowCode/test_mcp_workflow.md::if-sufficiency-scores-always-low", "content": "If Sufficiency Scores Always Low", "tokens": ["if", "sufficiency", "scores", "always", "low"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768289627.063532"}}, {"id": "/home/deeog/Desktop/KnowCode/test_mcp_workflow.md::if-agent-doesnt-follow-rules::0", "entity_id": "/home/deeog/Desktop/KnowCode/test_mcp_workflow.md::if-agent-doesnt-follow-rules", "content": "If Agent Doesn't Follow Rules", "tokens": ["if", "agent", "doesn", "follow", "rules"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768289627.063532"}}, {"id": "/home/deeog/Desktop/KnowCode/test_mcp_workflow.md::success-criteria::0", "entity_id": "/home/deeog/Desktop/KnowCode/test_mcp_workflow.md::success-criteria", "content": "Success Criteria", "tokens": ["success", "criteria"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768289627.063532"}}, {"id": "/home/deeog/Desktop/KnowCode/test_mcp_workflow.md::next-steps-after-successful-test::0", "entity_id": "/home/deeog/Desktop/KnowCode/test_mcp_workflow.md::next-steps-after-successful-test", "content": "Next Steps After Successful Test", "tokens": ["next", "steps", "after", "successful", "test"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768289627.063532"}}, {"id": "/home/deeog/Desktop/KnowCode/test_mcp_workflow.md::performance-benchmarks::0", "entity_id": "/home/deeog/Desktop/KnowCode/test_mcp_workflow.md::performance-benchmarks", "content": "Performance Benchmarks", "tokens": ["performance", "benchmarks"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768289627.063532"}}, {"id": "/home/deeog/Desktop/KnowCode/test_mcp_workflow.md::questions-to-test-different-features::0", "entity_id": "/home/deeog/Desktop/KnowCode/test_mcp_workflow.md::questions-to-test-different-features", "content": "Questions to Test Different Features", "tokens": ["questions", "to", "test", "different", "features"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768289627.063532"}}, {"id": "/home/deeog/Desktop/KnowCode/test_mcp_workflow.md::dependency-expansion::0", "entity_id": "/home/deeog/Desktop/KnowCode/test_mcp_workflow.md::dependency-expansion", "content": "Dependency Expansion", "tokens": ["dependency", "expansion"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768289627.063532"}}, {"id": "/home/deeog/Desktop/KnowCode/test_mcp_workflow.md::multi-entity-context::0", "entity_id": "/home/deeog/Desktop/KnowCode/test_mcp_workflow.md::multi-entity-context", "content": "Multi-Entity Context", "tokens": ["multi", "entity", "context"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768289627.063532"}}, {"id": "/home/deeog/Desktop/KnowCode/test_mcp_workflow.md::temporal-queries-if-coverage-data-available::0", "entity_id": "/home/deeog/Desktop/KnowCode/test_mcp_workflow.md::temporal-queries-if-coverage-data-available", "content": "Temporal Queries (if coverage data available)", "tokens": ["temporal", "queries", "if", "coverage", "data", "available"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768289627.063532"}}, {"id": "/home/deeog/Desktop/KnowCode/test_mcp_workflow.md::impact-analysis::0", "entity_id": "/home/deeog/Desktop/KnowCode/test_mcp_workflow.md::impact-analysis", "content": "Impact Analysis", "tokens": ["impact", "analysis"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768289627.063532"}}, {"id": "/home/deeog/Desktop/KnowCode/test_mcp_workflow.md::remember::0", "entity_id": "/home/deeog/Desktop/KnowCode/test_mcp_workflow.md::remember", "content": "Remember", "tokens": ["remember"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768289627.063532"}}, {"id": "/home/deeog/Desktop/KnowCode/README_MCP.md::module::0", "entity_id": "/home/deeog/Desktop/KnowCode/README_MCP.md::module", "content": "# MCP Setup - Quick Reference\n## \u2705 What We Fixed\n1. **MCP Configuration Path Issue**\n   - **Problem**: Used `\"command\": \"knowcode\"` (not in PATH)\n   - **Solution**: Changed to `\"/home/deeog/Desktop/KnowCode/.venv/bin/knowcode\"`\n   - **File**: `/home/deeog/.gemini/mcp_servers.json`\n## \ud83d\udccb Current Status\n### \u2705 Ready\n- [x] MCP configuration file updated with absolute path\n- [x] Knowledge store exists (1.1M, 1 day old)\n- [x] KnowCode CLI working (v0.2.1)\n- [x] Virtual environment configured\n- [x] Agent rules defined in `.agent/context.md`\n### \u26a0\ufe0f Needs Attention\n- [ ] **Semantic index missing** - Will use lexical search only\n- [ ] **Knowledge store is 1 day old** - Consider re-analyzing\n### \ud83d\udd04 Next Actions Required\n1. **Stop the manual MCP server** (Ctrl+C in terminal)\n2. **Restart Antigravity IDE**\n3. **Test the workflow** (see test_mcp_workflow.md)\n## \ud83c\udfaf Expected Workflow After Restart\n```\nUser asks: \"How does search work in KnowCode?\"\n    \u2193\nAgent calls: retrieve_context_for_query(\n    query=\"How does search work in KnowCode?\",\n    task_type=\"auto\",\n    max_tokens=3000,\n    limit_entities=3,\n    expand_deps=true\n)\n    \u2193\nKnowCode MCP Server returns:\n{\n    \"context_text\": \"...\",\n    \"sufficiency_score\": 0.92,\n    \"evidence\": [...],\n    ...\n}\n    \u2193\nAgent checks: sufficiency_score >= 0.88?\n    \u2193\nYES \u2192 Answer from context_text only (no external LLM)\nNO  \u2192 Use external LLM (Claude Sonnet 4.5)\n```\n## \ud83d\udcc1 Files Created\n1. **`verify_mcp_connection.sh`** - Check MCP setup status\n2. **`test_mcp_workflow.md`** - Test questions after restart\n3. **`docs/MCP_SETUP.md`** - Complete setup documentation\n4. **`README_MCP.md`** - This quick reference (you are here)\n## \ud83d\ude80 Quick Commands\n### Check MCP Status\n```bash\n./verify_mcp_connection.sh\n```\n### Check MCP Server Process\n```bash\nps aux | grep \"knowcode mcp-server\"\n```\n### View MCP Configuration\n```bash\ncat ~/.gemini/mcp_servers.json\n```\n### Rebuild Knowledge Store (if needed)\n```bash\nsource .venv/bin/activate\nknowcode analyze . -o .\n```\n**Note:** This automatically rebuilds both the knowledge store AND the semantic index!\n## \ud83d\udc1b Troubleshooting\n### MCP Tool Not Available After Restart?\n1. Check server is running:\n   ```bash\n   ps aux | grep \"knowcode mcp-server\"\n   ```\n2. Check configuration:\n   ```bash\n   cat ~/.gemini/mcp_servers.json\n   ```\n3. Restart IDE again\n### Low Sufficiency Scores?\n1. Verify index exists (should be created by analyze):\n   ```bash\n   ls -la knowcode_index/\n   ```\n2. If missing, re-run analyze (it will rebuild the index):\n   ```bash\n   knowcode analyze . -o .\n   ```\n3. Increase token budget in `.agent/context.md`:\n   ```markdown\n   Use max_tokens=6000, limit_entities=5\n   ```\n## \ud83d\udcca Success Metrics\nAfter setup, you should see:\n- \u2705 70%+ queries with `sufficiency_score >= 0.88`\n- \u2705 Faster responses for codebase questions\n- \u2705 50%+ reduction in external LLM token usage\n- \u2705 Accurate answers from local context\n## \ud83d\udcda Documentation\n- **Full Setup Guide**: `docs/MCP_SETUP.md`\n- **Test Plan**: `test_mcp_workflow.md`\n- **KnowCode Docs**: `README.md`\n## \ud83c\udf93 Key Concepts\n**Sufficiency Score**: Confidence that retrieved context is enough to answer the query\n- `>= 0.88` \u2192 Answer locally\n- `< 0.88` \u2192 Use external LLM\n**Retrieval Modes**:\n- **Semantic**: Uses embeddings + vector search (better)\n- **Lexical**: Uses keyword matching (fallback)\n**Dependency Expansion**: Includes related code (callees, callers) for complete context\n## \u26a1 Performance Tips\n1. **Build semantic index** - Much better than lexical\n2. **Keep knowledge store updated** - Re-analyze after major changes\n3. **Tune parameters** - Adjust max_tokens and limit_entities\n4. **Monitor scores** - Track sufficiency_score distribution\n## \ud83d\udd12 Security Notes\n- MCP server runs **locally** (no external data transmission)\n- Knowledge store contains your **source code** (keep secure)\n- Embeddings may be sent to **external providers** (VoyageAI, OpenAI)\n- Store API keys in `.env` (never commit)\n## \ud83c\udf89 You're Almost There!\nJust need to:\n1. Stop the manual MCP server (Ctrl+C)\n2. Restart Antigravity IDE\n3. Ask a test question\nGood luck! \ud83d\ude80\n---\n*Last updated: 2026-01-13*", "tokens": ["mcp", "setup", "quick", "reference", "what", "we", "fixed", "mcp", "configuration", "path", "issue", "problem", "used", "command", "knowcode", "not", "in", "path", "solution", "changed", "to", "home", "deeog", "desktop", "know", "code", "venv", "bin", "knowcode", "file", "home", "deeog", "gemini", "mcp", "servers", "json", "current", "status", "ready", "mcp", "configuration", "file", "updated", "with", "absolute", "path", "knowledge", "store", "exists", "1m", "day", "old", "know", "code", "cli", "working", "v0", "virtual", "environment", "configured", "agent", "rules", "defined", "in", "agent", "context", "md", "needs", "attention", "semantic", "index", "missing", "will", "use", "lexical", "search", "only", "knowledge", "store", "is", "day", "old", "consider", "re", "analyzing", "next", "actions", "required", "stop", "the", "manual", "mcp", "server", "ctrl", "in", "terminal", "restart", "antigravity", "ide", "test", "the", "workflow", "see", "test", "mcp", "workflow", "md", "expected", "workflow", "after", "restart", "user", "asks", "how", "does", "search", "work", "in", "know", "code", "agent", "calls", "retrieve", "context", "for", "query", "query", "how", "does", "search", "work", "in", "know", "code", "task", "type", "auto", "max", "tokens", "3000", "limit", "entities", "expand", "deps", "true", "know", "code", "mcp", "server", "returns", "context", "text", "sufficiency", "score", "92", "evidence", "agent", "checks", "sufficiency", "score", "88", "yes", "answer", "from", "context", "text", "only", "no", "external", "llm", "no", "use", "external", "llm", "claude", "sonnet", "files", "created", "verify", "mcp", "connection", "sh", "check", "mcp", "setup", "status", "test", "mcp", "workflow", "md", "test", "questions", "after", "restart", "docs", "mcp", "setup", "md", "complete", "setup", "documentation", "readme", "mcp", "md", "this", "quick", "reference", "you", "are", "here", "quick", "commands", "check", "mcp", "status", "bash", "verify", "mcp", "connection", "sh", "check", "mcp", "server", "process", "bash", "ps", "aux", "grep", "knowcode", "mcp", "server", "view", "mcp", "configuration", "bash", "cat", "gemini", "mcp", "servers", "json", "rebuild", "knowledge", "store", "if", "needed", "bash", "source", "venv", "bin", "activate", "knowcode", "analyze", "note", "this", "automatically", "rebuilds", "both", "the", "knowledge", "store", "and", "the", "semantic", "index", "troubleshooting", "mcp", "tool", "not", "available", "after", "restart", "check", "server", "is", "running", "bash", "ps", "aux", "grep", "knowcode", "mcp", "server", "check", "configuration", "bash", "cat", "gemini", "mcp", "servers", "json", "restart", "ide", "again", "low", "sufficiency", "scores", "verify", "index", "exists", "should", "be", "created", "by", "analyze", "bash", "ls", "la", "knowcode", "index", "if", "missing", "re", "run", "analyze", "it", "will", "rebuild", "the", "index", "bash", "knowcode", "analyze", "increase", "token", "budget", "in", "agent", "context", "md", "markdown", "use", "max", "tokens", "6000", "limit", "entities", "success", "metrics", "after", "setup", "you", "should", "see", "70", "queries", "with", "sufficiency", "score", "88", "faster", "responses", "for", "codebase", "questions", "50", "reduction", "in", "external", "llm", "token", "usage", "accurate", "answers", "from", "local", "context", "documentation", "full", "setup", "guide", "docs", "mcp", "setup", "md", "test", "plan", "test", "mcp", "workflow", "md", "know", "code", "docs", "readme", "md", "key", "concepts", "sufficiency", "score", "confidence", "that", "retrieved", "context", "is", "enough", "to", "answer", "the", "query", "88", "answer", "locally", "88", "use", "external", "llm", "retrieval", "modes", "semantic", "uses", "embeddings", "vector", "search", "better", "lexical", "uses", "keyword", "matching", "fallback", "dependency", "expansion", "includes", "related", "code", "callees", "callers", "for", "complete", "context", "performance", "tips", "build", "semantic", "index", "much", "better", "than", "lexical", "keep", "knowledge", "store", "updated", "re", "analyze", "after", "major", "changes", "tune", "parameters", "adjust", "max", "tokens", "and", "limit", "entities", "monitor", "scores", "track", "sufficiency", "score", "distribution", "security", "notes", "mcp", "server", "runs", "locally", "no", "external", "data", "transmission", "knowledge", "store", "contains", "your", "source", "code", "keep", "secure", "embeddings", "may", "be", "sent", "to", "external", "providers", "voyage", "ai", "open", "ai", "store", "api", "keys", "in", "env", "never", "commit", "you", "re", "almost", "there", "just", "need", "to", "stop", "the", "manual", "mcp", "server", "ctrl", "restart", "antigravity", "ide", "ask", "test", "question", "good", "luck", "last", "updated", "2026", "01", "13"], "metadata": {"type": "module_header"}}, {"id": "/home/deeog/Desktop/KnowCode/README_MCP.md::README_MCP::0", "entity_id": "/home/deeog/Desktop/KnowCode/README_MCP.md::README_MCP", "content": "\"\"\"1. **MCP Configuration Path Issue**\n   - **Problem**: Used `\"command\": \"knowcode\"` (not in PATH)\n   - **Solution**: Changed to `\"/home/deeog/Desktop/KnowCode/.venv/bin/knowcode\"`\n   - **File**: `/home/deeog/.gemini/mcp_servers.json`\"\"\"\nREADME_MCP", "tokens": ["mcp", "configuration", "path", "issue", "problem", "used", "command", "knowcode", "not", "in", "path", "solution", "changed", "to", "home", "deeog", "desktop", "know", "code", "venv", "bin", "knowcode", "file", "home", "deeog", "gemini", "mcp", "servers", "json", "readme", "mcp"], "metadata": {"kind": "document", "has_docstring": "true", "last_modified": "1768290042.744398"}}, {"id": "/home/deeog/Desktop/KnowCode/README_MCP.md::mcp-setup-quick-reference::0", "entity_id": "/home/deeog/Desktop/KnowCode/README_MCP.md::mcp-setup-quick-reference", "content": "MCP Setup - Quick Reference", "tokens": ["mcp", "setup", "quick", "reference"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768290042.744398"}}, {"id": "/home/deeog/Desktop/KnowCode/README_MCP.md::what-we-fixed::0", "entity_id": "/home/deeog/Desktop/KnowCode/README_MCP.md::what-we-fixed", "content": "\u2705 What We Fixed", "tokens": ["what", "we", "fixed"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768290042.744398"}}, {"id": "/home/deeog/Desktop/KnowCode/README_MCP.md::current-status::0", "entity_id": "/home/deeog/Desktop/KnowCode/README_MCP.md::current-status", "content": "\ud83d\udccb Current Status", "tokens": ["current", "status"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768290042.744398"}}, {"id": "/home/deeog/Desktop/KnowCode/README_MCP.md::ready::0", "entity_id": "/home/deeog/Desktop/KnowCode/README_MCP.md::ready", "content": "\u2705 Ready", "tokens": ["ready"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768290042.744398"}}, {"id": "/home/deeog/Desktop/KnowCode/README_MCP.md::needs-attention::0", "entity_id": "/home/deeog/Desktop/KnowCode/README_MCP.md::needs-attention", "content": "\u26a0\ufe0f Needs Attention", "tokens": ["needs", "attention"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768290042.744398"}}, {"id": "/home/deeog/Desktop/KnowCode/README_MCP.md::next-actions-required::0", "entity_id": "/home/deeog/Desktop/KnowCode/README_MCP.md::next-actions-required", "content": "\ud83d\udd04 Next Actions Required", "tokens": ["next", "actions", "required"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768290042.744398"}}, {"id": "/home/deeog/Desktop/KnowCode/README_MCP.md::expected-workflow-after-restart::0", "entity_id": "/home/deeog/Desktop/KnowCode/README_MCP.md::expected-workflow-after-restart", "content": "\ud83c\udfaf Expected Workflow After Restart", "tokens": ["expected", "workflow", "after", "restart"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768290042.744398"}}, {"id": "/home/deeog/Desktop/KnowCode/README_MCP.md::files-created::0", "entity_id": "/home/deeog/Desktop/KnowCode/README_MCP.md::files-created", "content": "\ud83d\udcc1 Files Created", "tokens": ["files", "created"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768290042.744398"}}, {"id": "/home/deeog/Desktop/KnowCode/README_MCP.md::quick-commands::0", "entity_id": "/home/deeog/Desktop/KnowCode/README_MCP.md::quick-commands", "content": "\ud83d\ude80 Quick Commands", "tokens": ["quick", "commands"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768290042.744398"}}, {"id": "/home/deeog/Desktop/KnowCode/README_MCP.md::check-mcp-status::0", "entity_id": "/home/deeog/Desktop/KnowCode/README_MCP.md::check-mcp-status", "content": "Check MCP Status", "tokens": ["check", "mcp", "status"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768290042.744398"}}, {"id": "/home/deeog/Desktop/KnowCode/README_MCP.md::check-mcp-server-process::0", "entity_id": "/home/deeog/Desktop/KnowCode/README_MCP.md::check-mcp-server-process", "content": "Check MCP Server Process", "tokens": ["check", "mcp", "server", "process"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768290042.744398"}}, {"id": "/home/deeog/Desktop/KnowCode/README_MCP.md::view-mcp-configuration::0", "entity_id": "/home/deeog/Desktop/KnowCode/README_MCP.md::view-mcp-configuration", "content": "View MCP Configuration", "tokens": ["view", "mcp", "configuration"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768290042.744398"}}, {"id": "/home/deeog/Desktop/KnowCode/README_MCP.md::rebuild-knowledge-store-if-needed::0", "entity_id": "/home/deeog/Desktop/KnowCode/README_MCP.md::rebuild-knowledge-store-if-needed", "content": "Rebuild Knowledge Store (if needed)", "tokens": ["rebuild", "knowledge", "store", "if", "needed"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768290042.744398"}}, {"id": "/home/deeog/Desktop/KnowCode/README_MCP.md::troubleshooting::0", "entity_id": "/home/deeog/Desktop/KnowCode/README_MCP.md::troubleshooting", "content": "\ud83d\udc1b Troubleshooting", "tokens": ["troubleshooting"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768290042.744398"}}, {"id": "/home/deeog/Desktop/KnowCode/README_MCP.md::mcp-tool-not-available-after-restart::0", "entity_id": "/home/deeog/Desktop/KnowCode/README_MCP.md::mcp-tool-not-available-after-restart", "content": "MCP Tool Not Available After Restart?", "tokens": ["mcp", "tool", "not", "available", "after", "restart"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768290042.744398"}}, {"id": "/home/deeog/Desktop/KnowCode/README_MCP.md::low-sufficiency-scores::0", "entity_id": "/home/deeog/Desktop/KnowCode/README_MCP.md::low-sufficiency-scores", "content": "Low Sufficiency Scores?", "tokens": ["low", "sufficiency", "scores"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768290042.744398"}}, {"id": "/home/deeog/Desktop/KnowCode/README_MCP.md::success-metrics::0", "entity_id": "/home/deeog/Desktop/KnowCode/README_MCP.md::success-metrics", "content": "\ud83d\udcca Success Metrics", "tokens": ["success", "metrics"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768290042.744398"}}, {"id": "/home/deeog/Desktop/KnowCode/README_MCP.md::documentation::0", "entity_id": "/home/deeog/Desktop/KnowCode/README_MCP.md::documentation", "content": "\ud83d\udcda Documentation", "tokens": ["documentation"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768290042.744398"}}, {"id": "/home/deeog/Desktop/KnowCode/README_MCP.md::key-concepts::0", "entity_id": "/home/deeog/Desktop/KnowCode/README_MCP.md::key-concepts", "content": "\ud83c\udf93 Key Concepts", "tokens": ["key", "concepts"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768290042.744398"}}, {"id": "/home/deeog/Desktop/KnowCode/README_MCP.md::performance-tips::0", "entity_id": "/home/deeog/Desktop/KnowCode/README_MCP.md::performance-tips", "content": "\u26a1 Performance Tips", "tokens": ["performance", "tips"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768290042.744398"}}, {"id": "/home/deeog/Desktop/KnowCode/README_MCP.md::security-notes::0", "entity_id": "/home/deeog/Desktop/KnowCode/README_MCP.md::security-notes", "content": "\ud83d\udd12 Security Notes", "tokens": ["security", "notes"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768290042.744398"}}, {"id": "/home/deeog/Desktop/KnowCode/README_MCP.md::youre-almost-there::0", "entity_id": "/home/deeog/Desktop/KnowCode/README_MCP.md::youre-almost-there", "content": "\ud83c\udf89 You're Almost There!", "tokens": ["you", "re", "almost", "there"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768290042.744398"}}, {"id": "/home/deeog/Desktop/KnowCode/KnowCode.md::module::0", "entity_id": "/home/deeog/Desktop/KnowCode/KnowCode.md::module", "content": "# **Reference Architecture: KnowCode**\n## **0\\. Guiding Principle (sets the tone)**\nA codebase is deterministic. So, information extraction from it should be 100% local and 100% deterministic. Making it consumable by a human (to help one understand what the code is/ does) or an AI agent (to save the pricey tokens consumption of the frontier LLMs you set it to work with) should therefore be a simple, local-to-your-machine solution at negligible cost.\nThis is what drives KnowCode!\n---\n## **1\\. Source Ingestion & Canonicalization Layer**\n### **Purpose**\nIngest all raw artifacts that define or influence the codebase and normalize them into stable, traceable representations.\n### **Responsibilities**\n* Discover and ingest:\n  * Source code\n  * Build files\n  * Configuration\n  * Tests\n  * Documentation\n  * Version history metadata\n* Normalize formats (e.g., line endings, encodings)\n* Maintain identity and versioning of artifacts\n* Track provenance (where did this come from, when, and why)\n* **[HARDENED]** Content-addressable hashing (SHA-256) for delta detection\n* **[HARDENED]** Streaming ingestion via VCS webhooks (push) or polling (pull)\n* **[HARDENED]** Distinguish monorepo vs. polyrepo topology\n* **[HARDENED]** Handle binary artifacts (compiled code, Docker images, WASM)\n### **Inputs**\n* Source repositories\n* VCS metadata\n* Documentation files\n* Configuration manifests\n* **[HARDENED]** Change events (file added/modified/deleted/renamed)\n* **[HARDENED]** Webhook payloads (GitHub, GitLab, Bitbucket)\n### **Outputs**\n* Canonical artifact store\n* Artifact metadata graph (file \u2192 repo \u2192 commit \u2192 author)\n* **[HARDENED]** Delta artifact stream (incremental updates, not full snapshots)\n* **[HARDENED]** Provenance chain with cryptographic verification\n### **Downstream Consumers**\n* Parsing & analysis layer\n* Intent extraction layer\n---\n## **2\\. Structural Parsing & Intermediate Representation Layer**\n### **Purpose**\nConvert raw code into **language-aware, lossless structural representations** suitable for higher-order reasoning.\n### **Responsibilities**\n* Parse source code into ASTs or equivalent IRs\n* Preserve:\n  * Symbol definitions\n  * Scopes\n  * Types\n  * Control structures\n* Maintain bidirectional mappings:\n  * Source text \u2194 structural nodes\n* **[HARDENED]** Support language-agnostic intermediate representation\n* **[HARDENED]** Detect cross-language boundaries (FFI, RPC, WASM)\n* **[HARDENED]** Graceful degradation on parse errors (partial ASTs)\n* **[HARDENED]** Track macro/metaprogramming expansion (Rust, C, Lisp)\n* **[HARDENED]** Flag generated code vs. authored code (protobuf, codegen)\n### **Inputs**\n* Canonical source artifacts\n### **Outputs**\n* Parsed structural representations\n* Symbol tables\n* Source-to-structure mappings\n* **[HARDENED]** Parse error entities (first-class, not silent failures)\n* **[HARDENED]** Generated-code markers\n### **Downstream Consumers**\n* Semantic graph builder\n* Static analysis\n* Documentation synthesis\n---\n## **3\\. Semantic Graph Construction Layer**\n### **Purpose**\nBuild a **unified semantic graph** representing what the code *is*, *does*, and *depends on*.\nThis is the heart of the system.\n### **Responsibilities**\n* Create semantic entities:\n  * Functions, classes, modules\n  * Types, interfaces\n  * APIs, schemas\n  * Config keys, feature flags\n* Establish relationships:\n  * Call relationships\n  * Import / dependency edges\n  * Type usage\n  * Data flow edges\n  * Ownership / domain boundaries\n* Encode semantic attributes:\n  * Visibility\n  * Mutability\n  * Side effects\n  * Error behavior\n* **[HARDENED]** Schema versioning with migration strategy\n* **[HARDENED]** Conflict resolution for parallel analysis\n* **[HARDENED]** Temporal modeling (entity history, not just current state)\n* **[HARDENED]** Confidence scores on all entities and edges\n* **[HARDENED]** Entity lifecycle tracking (birth, deprecation, death)\n### **Enhanced Entity Model**\n```yaml\nEntity:\n  id: UUID\n  kind: function | class | module | config_key | feature_flag | api_endpoint\n  source_location: Location\n  embeddings: vector (1536d)\n  confidence: float (0.0-1.0)\n  provenance: static_analysis | runtime_trace | llm_inference | human_annotation\n  created_at: timestamp\n  deprecated_at: timestamp?\n  superseded_by: UUID?\n```\n### **Inputs**\n* Structural representations\n* Symbol tables\n### **Outputs**\n* Unified semantic graph\n* Entity and relationship metadata\n* **[HARDENED]** Versioned graph snapshots\n* **[HARDENED]** Confidence-annotated edges\n### **Downstream Consumers**\n* Documentation generation\n* Impact analysis\n* Query & reasoning engines\n* Context synthesis\n---\n---\n## **4a. [NEW] Semantic Search & Indexing Layer (v2.1)**\n### **Purpose**\nEnable **retrieval-augmented generation (RAG)** by indexing code semantics in a high-dimensional vector space alongside traditional lexical search.\n### **Responsibilities**\n* **Chunking**: Break code into logical units (functions, classes, module headers)\n* **Embedding**: Generate dense vector representations (config-driven: OpenAI or VoyageAI)\n* **Vector Storage**: Persist vectors for fast nearest-neighbor search\n* **Hybrid Retrieval**: Combine dense (vector) and sparse (BM25) search results\n* **Reranking**: Upgrade to **Cross-Encoder** (e.g., ms-marco-MiniLM) for high-precision relevance scoring vs. simple cosine similarity.\n* **Graph-Enhanced Query Expansion**: usage of the Semantic Graph to expand search terms (e.g. synonyms, child classes, interfaces)\n* **[HARDENED]** Sliding window chunking with overlap\n* **[HARDENED]** Real-time incremental indexing (Watch Mode)\n* **[HARDENED]** Dependency-aware result expansion (Completeness)\n### **Inputs**\n* Code entities from Semantic Graph\n* Raw source code\n### **Outputs**\n* FAISS Vector Index\n* In-memory Chunk Repository\n* Ranked search results\n### **Downstream Consumers**\n* API `/context/query` endpoint\n* CLI `semantic-search` command\n* Context Synthesis Layer\n---\n## **4\\. Static Behavioral Analysis Layer**\n### **Purpose**\nExtract *behavioral meaning* that is not explicit in structure alone.\n### **Responsibilities**\n* Identify:\n  * Control flow\n  * Data flow\n  * State transitions\n  * Invariants and assumptions\n* Derive:\n  * Pre-conditions / post-conditions\n  * Error propagation paths\n  * Resource lifecycles\n* **[HARDENED]** Analysis depth tiers (quick/shallow vs. deep/expensive)\n* **[HARDENED]** Side effect classification: pure, IO, state-mutating, non-deterministic\n* **[HARDENED]** Termination analysis (infinite loops, unbounded recursion)\n* **[HARDENED]** Thread safety markers (unsafe patterns, lock requirements)\n* **[HARDENED]** Memory ownership tracking (C/C++, Rust)\n### **Inputs**\n* Semantic graph\n* Structural IRs\n### **Outputs**\n* Behavioral annotations attached to semantic graph\n* Explicit control/data flow subgraphs\n* **[HARDENED]** Complexity metrics (cyclomatic, cognitive)\n* **[HARDENED]** Purity annotations (pure/impure/unknown)\n* **[HARDENED]** Resource acquisition/release graph (RAII tracking)\n### **Downstream Consumers**\n* Debugging context synthesis\n* Change impact reasoning\n* Q\\&A engine\n---\n## **5\\. Runtime & Execution Signal Layer (Optional but Powerful)**\n### **Purpose**\nAugment static understanding with **ground truth about execution**.\nAccuracy beats theory.\n### **Responsibilities**\n* Ingest:\n  * Test execution traces\n  * Logs\n  * Runtime metrics\n* Map runtime events back to semantic entities\n* Capture:\n  * Hot paths\n  * Rare branches\n  * Exception patterns\n* **[HARDENED]** Define max overhead budget (<5% latency impact)\n* **[HARDENED]** Adaptive sampling based on path frequency\n* **[HARDENED]** Data sanitization for sensitive runtime values\n* **[HARDENED]** OpenTelemetry-compatible trace format\n* **[HARDENED]** Deterministic correlation IDs to semantic graph\n### **Inputs**\n* Execution traces\n* Logs\n* Runtime metadata\n### **Outputs**\n* Execution-annotated semantic graph\n* Observed behavior overlays\n* **[HARDENED]** Trace retention policies\n* **[HARDENED]** Anonymized/redacted sensitive data\n### **Downstream Consumers**\n* Debugging workflows\n* Behavior explanation\n* Confidence scoring\n---\n## **6\\. Intent & Rationale Extraction Layer**\n### **Purpose**\nAnswer the hardest question in codebases: **\"Why does this exist?\"**\n### **Responsibilities**\n* Extract intent from:\n  * Commit messages\n  * PR descriptions\n  * ADRs\n  * Comments\n* Associate intent with:\n  * Code entities\n  * Architectural decisions\n* Track evolution of intent over time\n* **[HARDENED]** Staleness detection (doc age vs. code modification time)\n* **[HARDENED]** Intent conflict resolution with precedence rules\n* **[HARDENED]** Implicit intent inference from code patterns\n* **[HARDENED]** Organizational signals (CODEOWNERS, team boundaries)\n* **[HARDENED]** Regulatory intent markers (HIPAA, PCI compliance)\n### **Intent Source Ranking**\n```\nADR > PR Description > Commit Message > Inline Comment > Inferred\n```\n### **Inputs**\n* Version control metadata\n* Documentation artifacts\n* Semantic graph\n### **Outputs**\n* Intent annotations\n* Decision-to-code mappings\n* **[HARDENED]** Intent freshness score (0.0-1.0)\n* **[HARDENED]** Unintentional behavior warnings (code \u2260 docs)\n### **Downstream Consumers**\n* Documentation synthesis\n* Q\\&A\n* Change risk analysis\n---\n## **7\\. Documentation Synthesis Layer (Multi-Level)**\n### **Purpose**\nGenerate **explainable, navigable, abstraction-aware documentation** directly from the semantic model.\n### **Responsibilities**\n* Produce documentation at multiple levels:\n  * System architecture\n  * Subsystem/module\n  * Component\n  * Function/class\n* Ensure:\n  * Consistency with actual code\n  * Traceability back to source\n* Keep docs incrementally up-to-date\n* **[HARDENED]** Multiple output formats: Markdown, HTML, IDE tooltips, OpenAPI, AsyncAPI\n* **[HARDENED]** Audience targeting: new engineers, domain experts, API consumers\n* **[HARDENED]** Auto-generate \"what changed since version X\" summaries\n* **[HARDENED]** Dead documentation detection and removal\n* **[HARDENED]** Example synthesis from test cases\n### **Abstraction Levels**\n```\n1. Executive    (1 paragraph per system)\n2. Architectural (component interaction diagrams)\n3. Module       (API contracts, dependencies)\n4. Function     (signature, behavior, edge cases)\n5. Code-inline  (contextual tooltips)\n```\n### **Inputs**\n* Semantic graph\n* Behavioral annotations\n* Intent metadata\n### **Outputs**\n* Structured documentation artifacts\n* Machine-readable documentation indices\n### **Downstream Consumers**\n* Human readers\n* Local Q\\&A\n* Context synthesis\n---\n## **8\\. Local Knowledge Store & Reasoning Substrate**\n### **Purpose**\nProvide a **local, authoritative knowledge base** for answering questions *without frontier LLMs*.\n### **Responsibilities**\n* Store:\n  * Semantic graph\n  * Documentation\n  * Intent\n  * Behavioral data\n* Support:\n  * Graph queries\n  * Symbolic reasoning\n  * Evidence-backed answers\n* Provide explanations with traceability\n* **[HARDENED]** Define query language (Cypher-like graph queries)\n* **[HARDENED]** Indexing strategy for common query patterns\n* **[HARDENED]** Storage backend specification (embedded vs. graph DB)\n* **[HARDENED]** Team-wide replication vs. local-only modes\n* **[HARDENED]** Cache invalidation on code changes\n### **Supported Query Types**\n```yaml\nQueries:\n  - kind: reachability\n    example: \"What functions can call X?\"\n  - kind: impact\n    example: \"What breaks if I delete Y?\"\n  - kind: dependency\n    example: \"What does Z depend on?\"\n  - kind: similarity\n    example: \"What functions are similar to W?\"\n  - kind: invariant\n    example: \"What assumptions does V make?\"\n```\n### **Inputs**\n* All enriched semantic artifacts\n### **Outputs**\n* Verified answers\n* Supporting evidence paths\n### **Downstream Consumers**\n* Developer Q\\&A interface\n* Context distillation layer\n---\n## **9\\. Task-Aware Context Synthesis Layer**\n### **Purpose**\nCreate **high-signal, minimal context bundles** tailored to the developer's current task.\n### **Responsibilities**\n* Identify task intent (debug, refactor, extend, review)\n* Traverse semantic graph selectively\n* Synthesize:\n  * Relevant entities\n  * Key behaviors\n  * Critical invariants\n  * Known risks\n* Produce compact, lossless summaries\n* **[HARDENED]** Token budget allocation (e.g., max 8K context tokens)\n* **[HARDENED]** Priority ranking when budget constrained\n* **[HARDENED]** Context compression (summarization, deduplication, reference-by-ID)\n* **[HARDENED]** Multi-turn conversation memory\n* **[HARDENED]** Negative context (what to explicitly exclude)\n### **Task-Specific Templates**\n```yaml\ndebug:\n  priority: [stack_trace, related_functions, recent_changes, known_bugs]\n  exclude: [unrelated_modules, documentation]\nrefactor:\n  priority: [code_structure, dependencies, tests, invariants]\n  exclude: [implementation_details_of_dependencies]\nextend:\n  priority: [patterns_used, architecture_constraints, related_features]\n  exclude: [deprecated_code]\nreview:\n  priority: [changed_lines, test_coverage, impact_analysis, security_concerns]\n  exclude: [unchanged_dependencies]\n```\n### **Inputs**\n* Semantic graph\n* Knowledge store\n* Task metadata\n### **Outputs**\n* Task-specific context artifacts\n* **[HARDENED]** Token usage reports\n* **[HARDENED]** Context compression metrics\n### **Downstream Consumers**\n* Frontier LLM interface\n* Human-in-the-loop workflows\n---\n## **10\\. Frontier LLM Interface Layer**\n### **Purpose**\nUse frontier LLMs **only where they add leverage**, not as a crutch.\n### **Responsibilities**\n* Inject synthesized context\n* Frame precise tasks/questions\n* Consume minimal tokens\n* Capture and ground responses\n* **[HARDENED]** Model abstraction (OpenAI, Anthropic, local Ollama)\n* **[HARDENED]** Cost tracking per query (tokens, dollars)\n* **[HARDENED]** Latency SLAs with fallback strategy\n* **[HARDENED]** Response validation against known constraints\n* **[HARDENED]** Prompt injection prevention (sandboxed prompts)\n### **Inputs**\n* Task-specific context bundles\n### **Outputs**\n* Generated code\n* Explanations\n* Recommendations (always traceable)\n* **[HARDENED]** Token usage metrics\n* **[HARDENED]** Validation results (alignment with known facts)\n* **[HARDENED]** Cost attribution per query\n### **Downstream Consumers**\n* Developer\n* Knowledge store (optional feedback loop)\n---\n---\n ## **10a. [NEW] Agent & Configuration Layer**\n ### **Purpose**\n Provide a robust, configurable interface to external LLMs with failover, rate limiting, and multi-provider support.\n ### **Responsibilities**\n * **Configuration**: Load model priorities and settings from `aimodels.yaml` or `knowcode.yaml`.\n * **Model Selection**: Iterate through prioritized models.\n * **Failover**: Automatically retry with the next model on `429 ResourceExhausted` errors.\n * **Rate Limiting (New)**: Persistently track RPM (Requests Per Minute) and RPD (Requests Per Day) limit usage locally in `~/.knowcode/usage_stats.json` to avoid API bans.\n * **Multi-Provider Support**: \n   * **Google Gemini**: Native `google.genai` client.\n   * **OpenAI/OpenRouter**: Generic `openai` client support (e.g. Mistral via OpenRouter).\n * **Reasoning Loop (ReAct)**: Dynamic capability to call tools (`list_files`, `find_references`, `search_history`) to disambiguate queries or explore before answering.\n * **Temporal Integration**: Query `TemporalAnalyzer` to answer \"why\" and \"when\" questions based on git history.\n * **Structured Output**: Support JSON/YAML schemas for automation tasks.\n * **Task-Aware Context**: Dynamically adjust context prioritization (debug vs. explain) based on user intent.\n ### **Inputs**\n * `aimodels.yaml` configuration\n * User query\n * Retrieved context bundle\n ### **Outputs**\n * LLM Answer\n * Updated usage statistics\n ### **Downstream Consumers**\n * `knowcode ask` command\n * External IDE agents via MCP (Layer 10b)\n ---\n ## **10b. [NEW] Tool Exposure Layer (MCP)**\n ### **Purpose**\n Expose KnowCode's intelligence capabilities as **callable tools** for external AI agents (e.g., IDE-integrated agents like Google's Antigravity) via the Model Context Protocol (MCP).\n ### **Responsibilities**\n * **MCP Server**: Run a compliant MCP server discoverable by IDE agents.\n * **Tool Registration**: Expose structured tools aligned with Layer 8 query types.\n * **Sufficiency Scoring**: Return confidence metrics so agents can decide whether to use external LLMs.\n * **Structured Responses**: JSON schemas for programmatic consumption.\n * **[HARDENED]** Tool versioning for backward compatibility.\n * **[HARDENED]** Rate limiting per-tool for resource protection.\n * **[HARDENED]** Telemetry for tool usage analytics.\n ### **Exposed Tools**\n ```yaml\n Tools:\n   - name: search_codebase\n     description: \"Lexical search for code entities by name/pattern\"\n     parameters: { query: string, limit: int }\n     returns: List of {id, name, qualified_name, kind, file, line}\n   - name: get_entity_context\n     description: \"Token-budgeted context bundle with sufficiency score\"\n     parameters: { entity_id: string, max_tokens: int, task_type: explain|debug|extend|review|locate|general }\n     returns: {entity_id, qualified_name, context_text, total_tokens, sufficiency_score, task_type}\n   - name: trace_calls\n     description: \"Multi-hop call graph traversal\"\n     parameters: { entity_id: string, direction: callers|callees, depth: int }\n     returns: List of {entity_id, qualified_name, kind, file, line, call_depth}\n   - name: retrieve_context_for_query\n     description: \"Unified query\u2192retrieval\u2192context-bundle pipeline (same as `knowcode ask`) with evidence + sufficiency score\"\n     parameters: { query: string, task_type: auto|explain|debug|extend|review|locate|general, max_tokens: int, limit_entities: int, expand_deps: bool }\n     returns: {context_text, total_tokens, sufficiency_score, retrieval_mode, evidence, selected_entities, task_type}\n # Planned (not yet exposed via MCP):\n # - get_impact: available via KnowledgeStore + REST API (/api/v1/impact/{entity_id})\n # - explain_flow: step-by-step execution trace\n ```\n ### **Inputs**\n * MCP tool invocation from external agent\n * Tool parameters\n ### **Outputs**\n * Structured JSON responses\n * Sufficiency scores for context adequacy\n * Token estimates for budget planning\n ### **Downstream Consumers**\n * External IDE agents (Antigravity, Cursor, etc.)\n * CI/CD pipelines\n * Automation scripts\n ---\n ## **11. Feedback, Validation & Evolution Layer**\n### **Purpose**\nContinuously improve accuracy and completeness over time.\n### **Responsibilities**\n* Capture:\n  * Developer corrections\n  * False assumptions\n  * Knowledge gaps\n* Validate:\n  * Documentation vs reality\n  * Static vs runtime behavior\n* Trigger re-analysis where needed\n* **[HARDENED]** Classify feedback: correction, enhancement, gap report, false positive\n* **[HARDENED]** Confidence decay for unvalidated knowledge\n* **[HARDENED]** A/B testing for analysis strategies\n* **[HARDENED]** Metrics dashboard (accuracy over time, coverage gaps)\n* **[HARDENED]** Human-in-loop escalation triggers\n### **Inputs**\n* Developer feedback\n* LLM outputs\n* Code changes\n### **Outputs**\n* Updated semantic model\n* Confidence adjustments\n* **[HARDENED]** Trend analytics\n---\n## **12\\. Cross-Cutting Concerns [NEW]**\n### **Security Model**\n* Code access permissions (who can query what repositories/modules)\n* Sensitive code detection (credentials, PII handlers, crypto keys)\n* Audit logging for all queries and modifications\n* Sandboxed LLM prompts to prevent injection attacks\n* Data residency compliance (EU data stays in EU infrastructure)\n### **Scalability Architecture**\n* Maximum codebase size specification (lines of code, file count)\n* Horizontal scaling strategy for large monorepos (>10M LOC)\n* Partial analysis for PR-scoped understanding\n* Background reprocessing vs. on-demand analysis trade-offs\n* Sharding strategy for distributed graph storage\n### **Observability**\n* System metrics: latency (p50, p95, p99), throughput, queue depth\n* Analysis coverage tracking per repository\n* Knowledge freshness monitoring and alerting\n* User engagement analytics (queries per day, satisfaction scores)\n* Error rate dashboards with drill-down capability\n### **Configuration Management**\n* Language-specific parser configuration\n* Analysis depth toggles (quick scan vs. deep analysis)\n* Output format preferences per user/team\n* Model selection preferences and cost limits\n* Feature flags for experimental capabilities\n---\n# **High-Level Interaction Flow (Simplified)**\n`Source Artifacts`  \n   `\u2193`  \n`Parsing & IR`  \n   `\u2193`  \n`Semantic Graph`  \n   `\u2193`  \n`Behavior + Intent + Runtime`  \n   `\u2193`  \n`Knowledge Store`  \n   `\u2193`  \n`Documentation & Local Q&A`  \n   `\u2193`  \n`Task-Aware Context Synthesis`  \n   `\u2193`  \n`Frontier LLM (minimal tokens)`\n---\n## **Enhanced Layer Interaction Diagram**\n```mermaid\nflowchart TB\n    subgraph Ingestion\n        L1[Layer 1: Source Ingestion]\n    end\n    subgraph Analysis\n        L2[Layer 2: Structural Parsing]\n        L3[Layer 3: Semantic Graph]\n        L4[Layer 4: Behavioral Analysis]\n        L5[Layer 5: Runtime Signals]\n        L6[Layer 6: Intent Extraction]\n    end\n    subgraph Intelligence\n        L7[Layer 7: Doc Synthesis]\n        L8[Layer 8: Knowledge Store]\n        L9[Layer 9: Context Synthesis]\n    end\n    subgraph Interface\n        L10[Layer 10: LLM Interface]\n        DEV[Developer]\n    end\n    subgraph Evolution\n        L11[Layer 11: Feedback Loop]\n    end\n    subgraph Cross-Cutting\n        SEC[Security]\n        OBS[Observability]\n        CFG[Configuration]\n    end\n    L1 --> L2\n    L2 --> L3\n    L3 --> L4\n    L3 --> L6\n    L4 --> L8\n    L5 -.-> L8\n    L6 --> L8\n    L8 --> L7\n    L8 --> L9\n    L9 --> L10\n    L10 --> DEV\n    DEV --> L11\n    L11 --> L8\n    L11 --> L3\n    SEC -.-> L1 & L8 & L10\n    OBS -.-> L1 & L3 & L8 & L10\n    CFG -.-> L2 & L4 & L9\n```\n---\n## **Why this architecture fits your stated priorities**\n* **Accuracy** \u2192 grounded in structure, behavior, and execution; confidence-scored\n* **Relevance** \u2192 task-aware synthesis, not blind retrieval; token-budgeted\n* **Completeness** \u2192 intent + runtime + static analysis; lifecycle-tracked\n* **Performance trade-offs accepted** \u2192 deeper analysis allowed; tiered depth\n* **Production-Ready** \u2192 scalability, security, observability built-in\n* **Trust** \u2192 provenance tracking, human-in-loop validation, audit logging\nYou've essentially defined a **code intelligence system**, not a chatbot with embeddings.\n---\n## **Implementation Status & Roadmap**\n### **Phase 1: Foundation (COMPLETED)**\n1. **[x] Source Scanning + Parsing (Layers 1-2)**: Scanner with gitignore support; parsers for Python (AST), JS/TS + Java (Tree-sitter), Markdown, YAML.\n2. **[x] Unified Semantic Graph (Layer 3)**: Entity/relationship model with reference resolution (calls/imports/contains/inherits).\n3. **[x] Local Knowledge Store (Layer 8)**: In-memory graph with JSON persistence and query helpers.\n4. **[x] Token-Budgeted Context Synthesis (Layer 9)**: Priority-ordered sections with truncation handling.\n5. **[x] Service Layer**: Shared business logic for CLI and API.\n### **Phase 2: Intelligence Server & RAG (COMPLETED)**\n6. **[x] FastAPI Server (Layer 10)**: Health, stats, search, context, semantic query, reload, entity details, callers/callees.\n7. **[x] Semantic Search & Indexing (Layer 4a)**: Chunker (module header/imports/entities), config-driven embeddings (OpenAI or VoyageAI), FAISS vector store, hybrid BM25+vector retrieval (RRF), reranking, dependency expansion.\n8. **[x] Indexer Persistence + CLI**: `index`/`semantic-search` commands with save/load.\n9. **[x] Watch Mode**: Background indexer + filesystem monitor for incremental re-indexing.\n10. **[x] CLI Workflows**: `analyze`, `query`, `context`, `export`, `stats`, `server`, `history`, `ask`.\n### **Phase 3: Temporal & Runtime Signals (COMPLETED)**\n11. **[x] Git History Ingestion (Temporal)**: Commit/author entities, authored/modified/changed_by relationships; surfaced via `--temporal` and `history`.\n12. **[x] Coverage Signals (Layer 5)**: Cobertura ingestion with coverage report entities and covers/executed_by relationships.\n### **Phase 4: Documentation Synthesis (PARTIAL)**\n13. **[x] Markdown Export (MVP)**: CLI `export` produces an index-style Markdown doc (see `docs_test/index.md`).\n14. **[ ] Multi-Level Doc Synthesis (Layer 7)**: Architecture/module/function narratives, change summaries, and freshness tracking.\n### **Phase 5: Deep Analysis (NEXT)**\n15. **[ ] Static Behavioral Analysis (Layer 4)**: Data flow, state transitions, side-effect classification.\n16. **[ ] Intent Extraction (Layer 6)**: ADR/PR/commit intent linking beyond commit metadata.\n17. **[ ] Confidence Scoring (Layer 3)**: Weighted edges/entities by evidence source.\n### **Phase 6: Enterprise (FUTURE)**\n18. **[ ] Security & RBAC**: Permissioned access and audit trails.\n19. **[ ] Scalability**: Large monorepo support and distributed processing.\n20. **[ ] Team Sharing**: Remote knowledge store sync and collaboration.\n### **Phase 7: Agentic Capabilities (COMPLETED v2.2)**\n21. **[x] Agent Architecture**: `Agent` class with configuration-driven model selection.\n22. **[x] Multi-Provider Support**: Google Gemini and OpenRouter/OpenAI integration.\n23. **[x] Rate Limiting**: Persistent RPM/RPD tracking and enforcement.\n24. **[x] Query Classification**: 6 task types (explain, debug, extend, review, locate, general).\n25. **[x] Smart Answer**: Local-first answering with configurable sufficiency threshold.\n26. **[x] VoyageAI Reranking**: Cross-encoder reranking with signal-based fallback.\n### **Phase 8: IDE Integration (COMPLETED v2.2)**\n27. **[x] MCP Server (Layer 10b)**: Tool exposure via STDIO for IDE agents.\n28. **[x] Core 4 Tools**: `search_codebase`, `get_entity_context`, `trace_calls`, `retrieve_context_for_query`.\n29. **[x] Sufficiency Scoring**: Context confidence metrics for local-first answering.\n30. **[x] Task-Specific Templates**: Debug/extend/review/explain/locate prioritization.\n31. **[x] Multi-hop Queries**: `trace_calls(depth=N)` and `get_impact()` analysis.\n32. **[x] Structured Responses**: JSON with `task_type` and `sufficiency_score`.\n### **Supporting Tooling & QA (COMPLETED)**\n- **[x] Tests**: Unit/integration/e2e coverage for parsing, indexing, retrieval, API, CLI, storage, and analysis.\n- **[x] CI/CD**: Ruff linting, pytest + coverage, MkDocs build, and automated changelog generation (last-tag range + optional human summary input).\n- **[x] Evaluation Utilities**: Retrieval-quality evaluation script (`scripts/evaluate.py`).\n---\n## **Primary Use-Cases**\n### **Use-Case 1: Developer Q&A with Detailed Answers**\n> As a developer, I want to ask questions about my codebase in plain English and get detailed, step-by-step answers with code snippets.\n**Workflow**:\n1. Developer asks: \"Explain what happens when 'knowcode ask' runs\"\n2. System identifies question type (explanation)\n3. Agent calls the unified retrieval kernel (`retrieve_context_for_query`) to retrieve ranked evidence + context bundles\n4. Context synthesizer builds token-budgeted bundles (task-aware templates + sufficiency scoring)\n5. LLM generates step-by-step explanation with code snippets\n**Key Capabilities Required**:\n- Query-type detection (Layer 10a)\n- Task-specific templates (Layer 9)\n- Multi-hop call graph traversal (Layer 8)\n- ReAct tool-use for complex queries (Layer 10a)\n### **Use-Case 2: IDE Agent Integration for Token Efficiency**\n> When prompting an IDE agent (e.g., Antigravity), it invokes KnowCode tools to retrieve context locally, minimizing expensive external LLM token usage.\n**Workflow**:\n1. User prompts IDE agent\n2. IDE agent invokes `retrieve_context_for_query` via MCP (single high-level call)\n3. KnowCode returns the same context bundle + sufficiency score as CLI Q&A (consistent retrieval quality)\n4. If score >= 0.8: Agent answers locally (zero external tokens)\n5. If score < 0.8: Agent uses returned context with external LLM (controlled tokens)\n**Key Capabilities Required**:\n- MCP Server (Layer 10b)\n- Sufficiency scoring (Layer 9)\n- Structured tool responses (Layer 10b)\n- Token budget reporting (Layer 9)", "tokens": ["reference", "architecture", "know", "code", "guiding", "principle", "sets", "the", "tone", "codebase", "is", "deterministic", "so", "information", "extraction", "from", "it", "should", "be", "100", "local", "and", "100", "deterministic", "making", "it", "consumable", "by", "human", "to", "help", "one", "understand", "what", "the", "code", "is", "does", "or", "an", "ai", "agent", "to", "save", "the", "pricey", "tokens", "consumption", "of", "the", "frontier", "llms", "you", "set", "it", "to", "work", "with", "should", "therefore", "be", "simple", "local", "to", "your", "machine", "solution", "at", "negligible", "cost", "this", "is", "what", "drives", "know", "code", "source", "ingestion", "canonicalization", "layer", "purpose", "ingest", "all", "raw", "artifacts", "that", "define", "or", "influence", "the", "codebase", "and", "normalize", "them", "into", "stable", "traceable", "representations", "responsibilities", "discover", "and", "ingest", "source", "code", "build", "files", "configuration", "tests", "documentation", "version", "history", "metadata", "normalize", "formats", "line", "endings", "encodings", "maintain", "identity", "and", "versioning", "of", "artifacts", "track", "provenance", "where", "did", "this", "come", "from", "when", "and", "why", "hardened", "content", "addressable", "hashing", "sha", "256", "for", "delta", "detection", "hardened", "streaming", "ingestion", "via", "vcs", "webhooks", "push", "or", "polling", "pull", "hardened", "distinguish", "monorepo", "vs", "polyrepo", "topology", "hardened", "handle", "binary", "artifacts", "compiled", "code", "docker", "images", "wasm", "inputs", "source", "repositories", "vcs", "metadata", "documentation", "files", "configuration", "manifests", "hardened", "change", "events", "file", "added", "modified", "deleted", "renamed", "hardened", "webhook", "payloads", "git", "hub", "git", "lab", "bitbucket", "outputs", "canonical", "artifact", "store", "artifact", "metadata", "graph", "file", "repo", "commit", "author", "hardened", "delta", "artifact", "stream", "incremental", "updates", "not", "full", "snapshots", "hardened", "provenance", "chain", "with", "cryptographic", "verification", "downstream", "consumers", "parsing", "analysis", "layer", "intent", "extraction", "layer", "structural", "parsing", "intermediate", "representation", "layer", "purpose", "convert", "raw", "code", "into", "language", "aware", "lossless", "structural", "representations", "suitable", "for", "higher", "order", "reasoning", "responsibilities", "parse", "source", "code", "into", "asts", "or", "equivalent", "irs", "preserve", "symbol", "definitions", "scopes", "types", "control", "structures", "maintain", "bidirectional", "mappings", "source", "text", "structural", "nodes", "hardened", "support", "language", "agnostic", "intermediate", "representation", "hardened", "detect", "cross", "language", "boundaries", "ffi", "rpc", "wasm", "hardened", "graceful", "degradation", "on", "parse", "errors", "partial", "asts", "hardened", "track", "macro", "metaprogramming", "expansion", "rust", "lisp", "hardened", "flag", "generated", "code", "vs", "authored", "code", "protobuf", "codegen", "inputs", "canonical", "source", "artifacts", "outputs", "parsed", "structural", "representations", "symbol", "tables", "source", "to", "structure", "mappings", "hardened", "parse", "error", "entities", "first", "class", "not", "silent", "failures", "hardened", "generated", "code", "markers", "downstream", "consumers", "semantic", "graph", "builder", "static", "analysis", "documentation", "synthesis", "semantic", "graph", "construction", "layer", "purpose", "build", "unified", "semantic", "graph", "representing", "what", "the", "code", "is", "does", "and", "depends", "on", "this", "is", "the", "heart", "of", "the", "system", "responsibilities", "create", "semantic", "entities", "functions", "classes", "modules", "types", "interfaces", "apis", "schemas", "config", "keys", "feature", "flags", "establish", "relationships", "call", "relationships", "import", "dependency", "edges", "type", "usage", "data", "flow", "edges", "ownership", "domain", "boundaries", "encode", "semantic", "attributes", "visibility", "mutability", "side", "effects", "error", "behavior", "hardened", "schema", "versioning", "with", "migration", "strategy", "hardened", "conflict", "resolution", "for", "parallel", "analysis", "hardened", "temporal", "modeling", "entity", "history", "not", "just", "current", "state", "hardened", "confidence", "scores", "on", "all", "entities", "and", "edges", "hardened", "entity", "lifecycle", "tracking", "birth", "deprecation", "death", "enhanced", "entity", "model", "yaml", "entity", "id", "uuid", "kind", "function", "class", "module", "config", "key", "feature", "flag", "api", "endpoint", "source", "location", "location", "embeddings", "vector", "1536d", "confidence", "float", "provenance", "static", "analysis", "runtime", "trace", "llm", "inference", "human", "annotation", "created", "at", "timestamp", "deprecated", "at", "timestamp", "superseded", "by", "uuid", "inputs", "structural", "representations", "symbol", "tables", "outputs", "unified", "semantic", "graph", "entity", "and", "relationship", "metadata", "hardened", "versioned", "graph", "snapshots", "hardened", "confidence", "annotated", "edges", "downstream", "consumers", "documentation", "generation", "impact", "analysis", "query", "reasoning", "engines", "context", "synthesis", "4a", "new", "semantic", "search", "indexing", "layer", "v2", "purpose", "enable", "retrieval", "augmented", "generation", "rag", "by", "indexing", "code", "semantics", "in", "high", "dimensional", "vector", "space", "alongside", "traditional", "lexical", "search", "responsibilities", "chunking", "break", "code", "into", "logical", "units", "functions", "classes", "module", "headers", "embedding", "generate", "dense", "vector", "representations", "config", "driven", "open", "ai", "or", "voyage", "ai", "vector", "storage", "persist", "vectors", "for", "fast", "nearest", "neighbor", "search", "hybrid", "retrieval", "combine", "dense", "vector", "and", "sparse", "bm25", "search", "results", "reranking", "upgrade", "to", "cross", "encoder", "ms", "marco", "mini", "lm", "for", "high", "precision", "relevance", "scoring", "vs", "simple", "cosine", "similarity", "graph", "enhanced", "query", "expansion", "usage", "of", "the", "semantic", "graph", "to", "expand", "search", "terms", "synonyms", "child", "classes", "interfaces", "hardened", "sliding", "window", "chunking", "with", "overlap", "hardened", "real", "time", "incremental", "indexing", "watch", "mode", "hardened", "dependency", "aware", "result", "expansion", "completeness", "inputs", "code", "entities", "from", "semantic", "graph", "raw", "source", "code", "outputs", "faiss", "vector", "index", "in", "memory", "chunk", "repository", "ranked", "search", "results", "downstream", "consumers", "api", "context", "query", "endpoint", "cli", "semantic", "search", "command", "context", "synthesis", "layer", "static", "behavioral", "analysis", "layer", "purpose", "extract", "behavioral", "meaning", "that", "is", "not", "explicit", "in", "structure", "alone", "responsibilities", "identify", "control", "flow", "data", "flow", "state", "transitions", "invariants", "and", "assumptions", "derive", "pre", "conditions", "post", "conditions", "error", "propagation", "paths", "resource", "lifecycles", "hardened", "analysis", "depth", "tiers", "quick", "shallow", "vs", "deep", "expensive", "hardened", "side", "effect", "classification", "pure", "io", "state", "mutating", "non", "deterministic", "hardened", "termination", "analysis", "infinite", "loops", "unbounded", "recursion", "hardened", "thread", "safety", "markers", "unsafe", "patterns", "lock", "requirements", "hardened", "memory", "ownership", "tracking", "rust", "inputs", "semantic", "graph", "structural", "irs", "outputs", "behavioral", "annotations", "attached", "to", "semantic", "graph", "explicit", "control", "data", "flow", "subgraphs", "hardened", "complexity", "metrics", "cyclomatic", "cognitive", "hardened", "purity", "annotations", "pure", "impure", "unknown", "hardened", "resource", "acquisition", "release", "graph", "raii", "tracking", "downstream", "consumers", "debugging", "context", "synthesis", "change", "impact", "reasoning", "engine", "runtime", "execution", "signal", "layer", "optional", "but", "powerful", "purpose", "augment", "static", "understanding", "with", "ground", "truth", "about", "execution", "accuracy", "beats", "theory", "responsibilities", "ingest", "test", "execution", "traces", "logs", "runtime", "metrics", "map", "runtime", "events", "back", "to", "semantic", "entities", "capture", "hot", "paths", "rare", "branches", "exception", "patterns", "hardened", "define", "max", "overhead", "budget", "latency", "impact", "hardened", "adaptive", "sampling", "based", "on", "path", "frequency", "hardened", "data", "sanitization", "for", "sensitive", "runtime", "values", "hardened", "open", "telemetry", "compatible", "trace", "format", "hardened", "deterministic", "correlation", "ids", "to", "semantic", "graph", "inputs", "execution", "traces", "logs", "runtime", "metadata", "outputs", "execution", "annotated", "semantic", "graph", "observed", "behavior", "overlays", "hardened", "trace", "retention", "policies", "hardened", "anonymized", "redacted", "sensitive", "data", "downstream", "consumers", "debugging", "workflows", "behavior", "explanation", "confidence", "scoring", "intent", "rationale", "extraction", "layer", "purpose", "answer", "the", "hardest", "question", "in", "codebases", "why", "does", "this", "exist", "responsibilities", "extract", "intent", "from", "commit", "messages", "pr", "descriptions", "adrs", "comments", "associate", "intent", "with", "code", "entities", "architectural", "decisions", "track", "evolution", "of", "intent", "over", "time", "hardened", "staleness", "detection", "doc", "age", "vs", "code", "modification", "time", "hardened", "intent", "conflict", "resolution", "with", "precedence", "rules", "hardened", "implicit", "intent", "inference", "from", "code", "patterns", "hardened", "organizational", "signals", "codeowners", "team", "boundaries", "hardened", "regulatory", "intent", "markers", "hipaa", "pci", "compliance", "intent", "source", "ranking", "adr", "pr", "description", "commit", "message", "inline", "comment", "inferred", "inputs", "version", "control", "metadata", "documentation", "artifacts", "semantic", "graph", "outputs", "intent", "annotations", "decision", "to", "code", "mappings", "hardened", "intent", "freshness", "score", "hardened", "unintentional", "behavior", "warnings", "code", "docs", "downstream", "consumers", "documentation", "synthesis", "change", "risk", "analysis", "documentation", "synthesis", "layer", "multi", "level", "purpose", "generate", "explainable", "navigable", "abstraction", "aware", "documentation", "directly", "from", "the", "semantic", "model", "responsibilities", "produce", "documentation", "at", "multiple", "levels", "system", "architecture", "subsystem", "module", "component", "function", "class", "ensure", "consistency", "with", "actual", "code", "traceability", "back", "to", "source", "keep", "docs", "incrementally", "up", "to", "date", "hardened", "multiple", "output", "formats", "markdown", "html", "ide", "tooltips", "open", "api", "async", "api", "hardened", "audience", "targeting", "new", "engineers", "domain", "experts", "api", "consumers", "hardened", "auto", "generate", "what", "changed", "since", "version", "summaries", "hardened", "dead", "documentation", "detection", "and", "removal", "hardened", "example", "synthesis", "from", "test", "cases", "abstraction", "levels", "executive", "paragraph", "per", "system", "architectural", "component", "interaction", "diagrams", "module", "api", "contracts", "dependencies", "function", "signature", "behavior", "edge", "cases", "code", "inline", "contextual", "tooltips", "inputs", "semantic", "graph", "behavioral", "annotations", "intent", "metadata", "outputs", "structured", "documentation", "artifacts", "machine", "readable", "documentation", "indices", "downstream", "consumers", "human", "readers", "local", "context", "synthesis", "local", "knowledge", "store", "reasoning", "substrate", "purpose", "provide", "local", "authoritative", "knowledge", "base", "for", "answering", "questions", "without", "frontier", "llms", "responsibilities", "store", "semantic", "graph", "documentation", "intent", "behavioral", "data", "support", "graph", "queries", "symbolic", "reasoning", "evidence", "backed", "answers", "provide", "explanations", "with", "traceability", "hardened", "define", "query", "language", "cypher", "like", "graph", "queries", "hardened", "indexing", "strategy", "for", "common", "query", "patterns", "hardened", "storage", "backend", "specification", "embedded", "vs", "graph", "db", "hardened", "team", "wide", "replication", "vs", "local", "only", "modes", "hardened", "cache", "invalidation", "on", "code", "changes", "supported", "query", "types", "yaml", "queries", "kind", "reachability", "example", "what", "functions", "can", "call", "kind", "impact", "example", "what", "breaks", "if", "delete", "kind", "dependency", "example", "what", "does", "depend", "on", "kind", "similarity", "example", "what", "functions", "are", "similar", "to", "kind", "invariant", "example", "what", "assumptions", "does", "make", "inputs", "all", "enriched", "semantic", "artifacts", "outputs", "verified", "answers", "supporting", "evidence", "paths", "downstream", "consumers", "developer", "interface", "context", "distillation", "layer", "task", "aware", "context", "synthesis", "layer", "purpose", "create", "high", "signal", "minimal", "context", "bundles", "tailored", "to", "the", "developer", "current", "task", "responsibilities", "identify", "task", "intent", "debug", "refactor", "extend", "review", "traverse", "semantic", "graph", "selectively", "synthesize", "relevant", "entities", "key", "behaviors", "critical", "invariants", "known", "risks", "produce", "compact", "lossless", "summaries", "hardened", "token", "budget", "allocation", "max", "8k", "context", "tokens", "hardened", "priority", "ranking", "when", "budget", "constrained", "hardened", "context", "compression", "summarization", "deduplication", "reference", "by", "id", "hardened", "multi", "turn", "conversation", "memory", "hardened", "negative", "context", "what", "to", "explicitly", "exclude", "task", "specific", "templates", "yaml", "debug", "priority", "stack", "trace", "related", "functions", "recent", "changes", "known", "bugs", "exclude", "unrelated", "modules", "documentation", "refactor", "priority", "code", "structure", "dependencies", "tests", "invariants", "exclude", "implementation", "details", "of", "dependencies", "extend", "priority", "patterns", "used", "architecture", "constraints", "related", "features", "exclude", "deprecated", "code", "review", "priority", "changed", "lines", "test", "coverage", "impact", "analysis", "security", "concerns", "exclude", "unchanged", "dependencies", "inputs", "semantic", "graph", "knowledge", "store", "task", "metadata", "outputs", "task", "specific", "context", "artifacts", "hardened", "token", "usage", "reports", "hardened", "context", "compression", "metrics", "downstream", "consumers", "frontier", "llm", "interface", "human", "in", "the", "loop", "workflows", "10", "frontier", "llm", "interface", "layer", "purpose", "use", "frontier", "llms", "only", "where", "they", "add", "leverage", "not", "as", "crutch", "responsibilities", "inject", "synthesized", "context", "frame", "precise", "tasks", "questions", "consume", "minimal", "tokens", "capture", "and", "ground", "responses", "hardened", "model", "abstraction", "open", "ai", "anthropic", "local", "ollama", "hardened", "cost", "tracking", "per", "query", "tokens", "dollars", "hardened", "latency", "slas", "with", "fallback", "strategy", "hardened", "response", "validation", "against", "known", "constraints", "hardened", "prompt", "injection", "prevention", "sandboxed", "prompts", "inputs", "task", "specific", "context", "bundles", "outputs", "generated", "code", "explanations", "recommendations", "always", "traceable", "hardened", "token", "usage", "metrics", "hardened", "validation", "results", "alignment", "with", "known", "facts", "hardened", "cost", "attribution", "per", "query", "downstream", "consumers", "developer", "knowledge", "store", "optional", "feedback", "loop", "10a", "new", "agent", "configuration", "layer", "purpose", "provide", "robust", "configurable", "interface", "to", "external", "llms", "with", "failover", "rate", "limiting", "and", "multi", "provider", "support", "responsibilities", "configuration", "load", "model", "priorities", "and", "settings", "from", "aimodels", "yaml", "or", "knowcode", "yaml", "model", "selection", "iterate", "through", "prioritized", "models", "failover", "automatically", "retry", "with", "the", "next", "model", "on", "429", "resource", "exhausted", "errors", "rate", "limiting", "new", "persistently", "track", "rpm", "requests", "per", "minute", "and", "rpd", "requests", "per", "day", "limit", "usage", "locally", "in", "knowcode", "usage", "stats", "json", "to", "avoid", "api", "bans", "multi", "provider", "support", "google", "gemini", "native", "google", "genai", "client", "open", "ai", "open", "router", "generic", "openai", "client", "support", "mistral", "via", "open", "router", "reasoning", "loop", "re", "act", "dynamic", "capability", "to", "call", "tools", "list", "files", "find", "references", "search", "history", "to", "disambiguate", "queries", "or", "explore", "before", "answering", "temporal", "integration", "query", "temporal", "analyzer", "to", "answer", "why", "and", "when", "questions", "based", "on", "git", "history", "structured", "output", "support", "json", "yaml", "schemas", "for", "automation", "tasks", "task", "aware", "context", "dynamically", "adjust", "context", "prioritization", "debug", "vs", "explain", "based", "on", "user", "intent", "inputs", "aimodels", "yaml", "configuration", "user", "query", "retrieved", "context", "bundle", "outputs", "llm", "answer", "updated", "usage", "statistics", "downstream", "consumers", "knowcode", "ask", "command", "external", "ide", "agents", "via", "mcp", "layer", "10b", "10b", "new", "tool", "exposure", "layer", "mcp", "purpose", "expose", "know", "code", "intelligence", "capabilities", "as", "callable", "tools", "for", "external", "ai", "agents", "ide", "integrated", "agents", "like", "google", "antigravity", "via", "the", "model", "context", "protocol", "mcp", "responsibilities", "mcp", "server", "run", "compliant", "mcp", "server", "discoverable", "by", "ide", "agents", "tool", "registration", "expose", "structured", "tools", "aligned", "with", "layer", "query", "types", "sufficiency", "scoring", "return", "confidence", "metrics", "so", "agents", "can", "decide", "whether", "to", "use", "external", "llms", "structured", "responses", "json", "schemas", "for", "programmatic", "consumption", "hardened", "tool", "versioning", "for", "backward", "compatibility", "hardened", "rate", "limiting", "per", "tool", "for", "resource", "protection", "hardened", "telemetry", "for", "tool", "usage", "analytics", "exposed", "tools", "yaml", "tools", "name", "search", "codebase", "description", "lexical", "search", "for", "code", "entities", "by", "name", "pattern", "parameters", "query", "string", "limit", "int", "returns", "list", "of", "id", "name", "qualified", "name", "kind", "file", "line", "name", "get", "entity", "context", "description", "token", "budgeted", "context", "bundle", "with", "sufficiency", "score", "parameters", "entity", "id", "string", "max", "tokens", "int", "task", "type", "explain", "debug", "extend", "review", "locate", "general", "returns", "entity", "id", "qualified", "name", "context", "text", "total", "tokens", "sufficiency", "score", "task", "type", "name", "trace", "calls", "description", "multi", "hop", "call", "graph", "traversal", "parameters", "entity", "id", "string", "direction", "callers", "callees", "depth", "int", "returns", "list", "of", "entity", "id", "qualified", "name", "kind", "file", "line", "call", "depth", "name", "retrieve", "context", "for", "query", "description", "unified", "query", "retrieval", "context", "bundle", "pipeline", "same", "as", "knowcode", "ask", "with", "evidence", "sufficiency", "score", "parameters", "query", "string", "task", "type", "auto", "explain", "debug", "extend", "review", "locate", "general", "max", "tokens", "int", "limit", "entities", "int", "expand", "deps", "bool", "returns", "context", "text", "total", "tokens", "sufficiency", "score", "retrieval", "mode", "evidence", "selected", "entities", "task", "type", "planned", "not", "yet", "exposed", "via", "mcp", "get", "impact", "available", "via", "knowledge", "store", "rest", "api", "api", "v1", "impact", "entity", "id", "explain", "flow", "step", "by", "step", "execution", "trace", "inputs", "mcp", "tool", "invocation", "from", "external", "agent", "tool", "parameters", "outputs", "structured", "json", "responses", "sufficiency", "scores", "for", "context", "adequacy", "token", "estimates", "for", "budget", "planning", "downstream", "consumers", "external", "ide", "agents", "antigravity", "cursor", "etc", "ci", "cd", "pipelines", "automation", "scripts", "11", "feedback", "validation", "evolution", "layer", "purpose", "continuously", "improve", "accuracy", "and", "completeness", "over", "time", "responsibilities", "capture", "developer", "corrections", "false", "assumptions", "knowledge", "gaps", "validate", "documentation", "vs", "reality", "static", "vs", "runtime", "behavior", "trigger", "re", "analysis", "where", "needed", "hardened", "classify", "feedback", "correction", "enhancement", "gap", "report", "false", "positive", "hardened", "confidence", "decay", "for", "unvalidated", "knowledge", "hardened", "testing", "for", "analysis", "strategies", "hardened", "metrics", "dashboard", "accuracy", "over", "time", "coverage", "gaps", "hardened", "human", "in", "loop", "escalation", "triggers", "inputs", "developer", "feedback", "llm", "outputs", "code", "changes", "outputs", "updated", "semantic", "model", "confidence", "adjustments", "hardened", "trend", "analytics", "12", "cross", "cutting", "concerns", "new", "security", "model", "code", "access", "permissions", "who", "can", "query", "what", "repositories", "modules", "sensitive", "code", "detection", "credentials", "pii", "handlers", "crypto", "keys", "audit", "logging", "for", "all", "queries", "and", "modifications", "sandboxed", "llm", "prompts", "to", "prevent", "injection", "attacks", "data", "residency", "compliance", "eu", "data", "stays", "in", "eu", "infrastructure", "scalability", "architecture", "maximum", "codebase", "size", "specification", "lines", "of", "code", "file", "count", "horizontal", "scaling", "strategy", "for", "large", "monorepos", "10m", "loc", "partial", "analysis", "for", "pr", "scoped", "understanding", "background", "reprocessing", "vs", "on", "demand", "analysis", "trade", "offs", "sharding", "strategy", "for", "distributed", "graph", "storage", "observability", "system", "metrics", "latency", "p50", "p95", "p99", "throughput", "queue", "depth", "analysis", "coverage", "tracking", "per", "repository", "knowledge", "freshness", "monitoring", "and", "alerting", "user", "engagement", "analytics", "queries", "per", "day", "satisfaction", "scores", "error", "rate", "dashboards", "with", "drill", "down", "capability", "configuration", "management", "language", "specific", "parser", "configuration", "analysis", "depth", "toggles", "quick", "scan", "vs", "deep", "analysis", "output", "format", "preferences", "per", "user", "team", "model", "selection", "preferences", "and", "cost", "limits", "feature", "flags", "for", "experimental", "capabilities", "high", "level", "interaction", "flow", "simplified", "source", "artifacts", "parsing", "ir", "semantic", "graph", "behavior", "intent", "runtime", "knowledge", "store", "documentation", "local", "task", "aware", "context", "synthesis", "frontier", "llm", "minimal", "tokens", "enhanced", "layer", "interaction", "diagram", "mermaid", "flowchart", "tb", "subgraph", "ingestion", "l1", "layer", "source", "ingestion", "end", "subgraph", "analysis", "l2", "layer", "structural", "parsing", "l3", "layer", "semantic", "graph", "l4", "layer", "behavioral", "analysis", "l5", "layer", "runtime", "signals", "l6", "layer", "intent", "extraction", "end", "subgraph", "intelligence", "l7", "layer", "doc", "synthesis", "l8", "layer", "knowledge", "store", "l9", "layer", "context", "synthesis", "end", "subgraph", "interface", "l10", "layer", "10", "llm", "interface", "dev", "developer", "end", "subgraph", "evolution", "l11", "layer", "11", "feedback", "loop", "end", "subgraph", "cross", "cutting", "sec", "security", "obs", "observability", "cfg", "configuration", "end", "l1", "l2", "l2", "l3", "l3", "l4", "l3", "l6", "l4", "l8", "l5", "l8", "l6", "l8", "l8", "l7", "l8", "l9", "l9", "l10", "l10", "dev", "dev", "l11", "l11", "l8", "l11", "l3", "sec", "l1", "l8", "l10", "obs", "l1", "l3", "l8", "l10", "cfg", "l2", "l4", "l9", "why", "this", "architecture", "fits", "your", "stated", "priorities", "accuracy", "grounded", "in", "structure", "behavior", "and", "execution", "confidence", "scored", "relevance", "task", "aware", "synthesis", "not", "blind", "retrieval", "token", "budgeted", "completeness", "intent", "runtime", "static", "analysis", "lifecycle", "tracked", "performance", "trade", "offs", "accepted", "deeper", "analysis", "allowed", "tiered", "depth", "production", "ready", "scalability", "security", "observability", "built", "in", "trust", "provenance", "tracking", "human", "in", "loop", "validation", "audit", "logging", "you", "ve", "essentially", "defined", "code", "intelligence", "system", "not", "chatbot", "with", "embeddings", "implementation", "status", "roadmap", "phase", "foundation", "completed", "source", "scanning", "parsing", "layers", "scanner", "with", "gitignore", "support", "parsers", "for", "python", "ast", "js", "ts", "java", "tree", "sitter", "markdown", "yaml", "unified", "semantic", "graph", "layer", "entity", "relationship", "model", "with", "reference", "resolution", "calls", "imports", "contains", "inherits", "local", "knowledge", "store", "layer", "in", "memory", "graph", "with", "json", "persistence", "and", "query", "helpers", "token", "budgeted", "context", "synthesis", "layer", "priority", "ordered", "sections", "with", "truncation", "handling", "service", "layer", "shared", "business", "logic", "for", "cli", "and", "api", "phase", "intelligence", "server", "rag", "completed", "fast", "api", "server", "layer", "10", "health", "stats", "search", "context", "semantic", "query", "reload", "entity", "details", "callers", "callees", "semantic", "search", "indexing", "layer", "4a", "chunker", "module", "header", "imports", "entities", "config", "driven", "embeddings", "open", "ai", "or", "voyage", "ai", "faiss", "vector", "store", "hybrid", "bm25", "vector", "retrieval", "rrf", "reranking", "dependency", "expansion", "indexer", "persistence", "cli", "index", "semantic", "search", "commands", "with", "save", "load", "watch", "mode", "background", "indexer", "filesystem", "monitor", "for", "incremental", "re", "indexing", "10", "cli", "workflows", "analyze", "query", "context", "export", "stats", "server", "history", "ask", "phase", "temporal", "runtime", "signals", "completed", "11", "git", "history", "ingestion", "temporal", "commit", "author", "entities", "authored", "modified", "changed", "by", "relationships", "surfaced", "via", "temporal", "and", "history", "12", "coverage", "signals", "layer", "cobertura", "ingestion", "with", "coverage", "report", "entities", "and", "covers", "executed", "by", "relationships", "phase", "documentation", "synthesis", "partial", "13", "markdown", "export", "mvp", "cli", "export", "produces", "an", "index", "style", "markdown", "doc", "see", "docs", "test", "index", "md", "14", "multi", "level", "doc", "synthesis", "layer", "architecture", "module", "function", "narratives", "change", "summaries", "and", "freshness", "tracking", "phase", "deep", "analysis", "next", "15", "static", "behavioral", "analysis", "layer", "data", "flow", "state", "transitions", "side", "effect", "classification", "16", "intent", "extraction", "layer", "adr", "pr", "commit", "intent", "linking", "beyond", "commit", "metadata", "17", "confidence", "scoring", "layer", "weighted", "edges", "entities", "by", "evidence", "source", "phase", "enterprise", "future", "18", "security", "rbac", "permissioned", "access", "and", "audit", "trails", "19", "scalability", "large", "monorepo", "support", "and", "distributed", "processing", "20", "team", "sharing", "remote", "knowledge", "store", "sync", "and", "collaboration", "phase", "agentic", "capabilities", "completed", "v2", "21", "agent", "architecture", "agent", "class", "with", "configuration", "driven", "model", "selection", "22", "multi", "provider", "support", "google", "gemini", "and", "open", "router", "open", "ai", "integration", "23", "rate", "limiting", "persistent", "rpm", "rpd", "tracking", "and", "enforcement", "24", "query", "classification", "task", "types", "explain", "debug", "extend", "review", "locate", "general", "25", "smart", "answer", "local", "first", "answering", "with", "configurable", "sufficiency", "threshold", "26", "voyage", "ai", "reranking", "cross", "encoder", "reranking", "with", "signal", "based", "fallback", "phase", "ide", "integration", "completed", "v2", "27", "mcp", "server", "layer", "10b", "tool", "exposure", "via", "stdio", "for", "ide", "agents", "28", "core", "tools", "search", "codebase", "get", "entity", "context", "trace", "calls", "retrieve", "context", "for", "query", "29", "sufficiency", "scoring", "context", "confidence", "metrics", "for", "local", "first", "answering", "30", "task", "specific", "templates", "debug", "extend", "review", "explain", "locate", "prioritization", "31", "multi", "hop", "queries", "trace", "calls", "depth", "and", "get", "impact", "analysis", "32", "structured", "responses", "json", "with", "task", "type", "and", "sufficiency", "score", "supporting", "tooling", "qa", "completed", "tests", "unit", "integration", "e2e", "coverage", "for", "parsing", "indexing", "retrieval", "api", "cli", "storage", "and", "analysis", "ci", "cd", "ruff", "linting", "pytest", "coverage", "mk", "docs", "build", "and", "automated", "changelog", "generation", "last", "tag", "range", "optional", "human", "summary", "input", "evaluation", "utilities", "retrieval", "quality", "evaluation", "script", "scripts", "evaluate", "py", "primary", "use", "cases", "use", "case", "developer", "with", "detailed", "answers", "as", "developer", "want", "to", "ask", "questions", "about", "my", "codebase", "in", "plain", "english", "and", "get", "detailed", "step", "by", "step", "answers", "with", "code", "snippets", "workflow", "developer", "asks", "explain", "what", "happens", "when", "knowcode", "ask", "runs", "system", "identifies", "question", "type", "explanation", "agent", "calls", "the", "unified", "retrieval", "kernel", "retrieve", "context", "for", "query", "to", "retrieve", "ranked", "evidence", "context", "bundles", "context", "synthesizer", "builds", "token", "budgeted", "bundles", "task", "aware", "templates", "sufficiency", "scoring", "llm", "generates", "step", "by", "step", "explanation", "with", "code", "snippets", "key", "capabilities", "required", "query", "type", "detection", "layer", "10a", "task", "specific", "templates", "layer", "multi", "hop", "call", "graph", "traversal", "layer", "re", "act", "tool", "use", "for", "complex", "queries", "layer", "10a", "use", "case", "ide", "agent", "integration", "for", "token", "efficiency", "when", "prompting", "an", "ide", "agent", "antigravity", "it", "invokes", "know", "code", "tools", "to", "retrieve", "context", "locally", "minimizing", "expensive", "external", "llm", "token", "usage", "workflow", "user", "prompts", "ide", "agent", "ide", "agent", "invokes", "retrieve", "context", "for", "query", "via", "mcp", "single", "high", "level", "call", "know", "code", "returns", "the", "same", "context", "bundle", "sufficiency", "score", "as", "cli", "consistent", "retrieval", "quality", "if", "score", "agent", "answers", "locally", "zero", "external", "tokens", "if", "score", "agent", "uses", "returned", "context", "with", "external", "llm", "controlled", "tokens", "key", "capabilities", "required", "mcp", "server", "layer", "10b", "sufficiency", "scoring", "layer", "structured", "tool", "responses", "layer", "10b", "token", "budget", "reporting", "layer"], "metadata": {"type": "module_header"}}, {"id": "/home/deeog/Desktop/KnowCode/KnowCode.md::KnowCode::0", "entity_id": "/home/deeog/Desktop/KnowCode/KnowCode.md::KnowCode", "content": "\"\"\"A codebase is deterministic. So, information extraction from it should be 100% local and 100% deterministic. Making it consumable by a human (to help one understand what the code is/ does) or an AI agent (to save the pricey tokens consumption of the frontier LLMs you set it to work with) should therefore be a simple, local-to-your-machine solution at negligible cost.\"\"\"\nKnowCode", "tokens": ["codebase", "is", "deterministic", "so", "information", "extraction", "from", "it", "should", "be", "100", "local", "and", "100", "deterministic", "making", "it", "consumable", "by", "human", "to", "help", "one", "understand", "what", "the", "code", "is", "does", "or", "an", "ai", "agent", "to", "save", "the", "pricey", "tokens", "consumption", "of", "the", "frontier", "llms", "you", "set", "it", "to", "work", "with", "should", "therefore", "be", "simple", "local", "to", "your", "machine", "solution", "at", "negligible", "cost", "know", "code"], "metadata": {"kind": "document", "has_docstring": "true", "last_modified": "1768240645.0455225"}}, {"id": "/home/deeog/Desktop/KnowCode/KnowCode.md::reference-architecture-knowcode::0", "entity_id": "/home/deeog/Desktop/KnowCode/KnowCode.md::reference-architecture-knowcode", "content": "**Reference Architecture: KnowCode**", "tokens": ["reference", "architecture", "know", "code"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768240645.0455225"}}, {"id": "/home/deeog/Desktop/KnowCode/KnowCode.md::0-guiding-principle-sets-the-tone::0", "entity_id": "/home/deeog/Desktop/KnowCode/KnowCode.md::0-guiding-principle-sets-the-tone", "content": "**0\\. Guiding Principle (sets the tone)**", "tokens": ["guiding", "principle", "sets", "the", "tone"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768240645.0455225"}}, {"id": "/home/deeog/Desktop/KnowCode/KnowCode.md::1-source-ingestion-canonicalization-layer::0", "entity_id": "/home/deeog/Desktop/KnowCode/KnowCode.md::1-source-ingestion-canonicalization-layer", "content": "**1\\. Source Ingestion & Canonicalization Layer**", "tokens": ["source", "ingestion", "canonicalization", "layer"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768240645.0455225"}}, {"id": "/home/deeog/Desktop/KnowCode/KnowCode.md::purpose::0", "entity_id": "/home/deeog/Desktop/KnowCode/KnowCode.md::purpose", "content": "**Purpose**", "tokens": ["purpose"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768240645.0455225"}}, {"id": "/home/deeog/Desktop/KnowCode/KnowCode.md::responsibilities::0", "entity_id": "/home/deeog/Desktop/KnowCode/KnowCode.md::responsibilities", "content": "**Responsibilities**", "tokens": ["responsibilities"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768240645.0455225"}}, {"id": "/home/deeog/Desktop/KnowCode/KnowCode.md::inputs::0", "entity_id": "/home/deeog/Desktop/KnowCode/KnowCode.md::inputs", "content": "**Inputs**", "tokens": ["inputs"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768240645.0455225"}}, {"id": "/home/deeog/Desktop/KnowCode/KnowCode.md::outputs::0", "entity_id": "/home/deeog/Desktop/KnowCode/KnowCode.md::outputs", "content": "**Outputs**", "tokens": ["outputs"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768240645.0455225"}}, {"id": "/home/deeog/Desktop/KnowCode/KnowCode.md::downstream-consumers::0", "entity_id": "/home/deeog/Desktop/KnowCode/KnowCode.md::downstream-consumers", "content": "**Downstream Consumers**", "tokens": ["downstream", "consumers"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768240645.0455225"}}, {"id": "/home/deeog/Desktop/KnowCode/KnowCode.md::2-structural-parsing-intermediate-representation-layer::0", "entity_id": "/home/deeog/Desktop/KnowCode/KnowCode.md::2-structural-parsing-intermediate-representation-layer", "content": "**2\\. Structural Parsing & Intermediate Representation Layer**", "tokens": ["structural", "parsing", "intermediate", "representation", "layer"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768240645.0455225"}}, {"id": "/home/deeog/Desktop/KnowCode/KnowCode.md::3-semantic-graph-construction-layer::0", "entity_id": "/home/deeog/Desktop/KnowCode/KnowCode.md::3-semantic-graph-construction-layer", "content": "**3\\. Semantic Graph Construction Layer**", "tokens": ["semantic", "graph", "construction", "layer"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768240645.0455225"}}, {"id": "/home/deeog/Desktop/KnowCode/KnowCode.md::enhanced-entity-model::0", "entity_id": "/home/deeog/Desktop/KnowCode/KnowCode.md::enhanced-entity-model", "content": "**Enhanced Entity Model**", "tokens": ["enhanced", "entity", "model"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768240645.0455225"}}, {"id": "/home/deeog/Desktop/KnowCode/KnowCode.md::4a-new-semantic-search-indexing-layer-v21::0", "entity_id": "/home/deeog/Desktop/KnowCode/KnowCode.md::4a-new-semantic-search-indexing-layer-v21", "content": "**4a. [NEW] Semantic Search & Indexing Layer (v2.1)**", "tokens": ["4a", "new", "semantic", "search", "indexing", "layer", "v2"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768240645.0455225"}}, {"id": "/home/deeog/Desktop/KnowCode/KnowCode.md::4-static-behavioral-analysis-layer::0", "entity_id": "/home/deeog/Desktop/KnowCode/KnowCode.md::4-static-behavioral-analysis-layer", "content": "**4\\. Static Behavioral Analysis Layer**", "tokens": ["static", "behavioral", "analysis", "layer"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768240645.0455225"}}, {"id": "/home/deeog/Desktop/KnowCode/KnowCode.md::5-runtime-execution-signal-layer-optional-but-powerful::0", "entity_id": "/home/deeog/Desktop/KnowCode/KnowCode.md::5-runtime-execution-signal-layer-optional-but-powerful", "content": "**5\\. Runtime & Execution Signal Layer (Optional but Powerful)**", "tokens": ["runtime", "execution", "signal", "layer", "optional", "but", "powerful"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768240645.0455225"}}, {"id": "/home/deeog/Desktop/KnowCode/KnowCode.md::6-intent-rationale-extraction-layer::0", "entity_id": "/home/deeog/Desktop/KnowCode/KnowCode.md::6-intent-rationale-extraction-layer", "content": "**6\\. Intent & Rationale Extraction Layer**", "tokens": ["intent", "rationale", "extraction", "layer"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768240645.0455225"}}, {"id": "/home/deeog/Desktop/KnowCode/KnowCode.md::intent-source-ranking::0", "entity_id": "/home/deeog/Desktop/KnowCode/KnowCode.md::intent-source-ranking", "content": "**Intent Source Ranking**", "tokens": ["intent", "source", "ranking"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768240645.0455225"}}, {"id": "/home/deeog/Desktop/KnowCode/KnowCode.md::7-documentation-synthesis-layer-multi-level::0", "entity_id": "/home/deeog/Desktop/KnowCode/KnowCode.md::7-documentation-synthesis-layer-multi-level", "content": "**7\\. Documentation Synthesis Layer (Multi-Level)**", "tokens": ["documentation", "synthesis", "layer", "multi", "level"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768240645.0455225"}}, {"id": "/home/deeog/Desktop/KnowCode/KnowCode.md::abstraction-levels::0", "entity_id": "/home/deeog/Desktop/KnowCode/KnowCode.md::abstraction-levels", "content": "**Abstraction Levels**", "tokens": ["abstraction", "levels"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768240645.0455225"}}, {"id": "/home/deeog/Desktop/KnowCode/KnowCode.md::8-local-knowledge-store-reasoning-substrate::0", "entity_id": "/home/deeog/Desktop/KnowCode/KnowCode.md::8-local-knowledge-store-reasoning-substrate", "content": "**8\\. Local Knowledge Store & Reasoning Substrate**", "tokens": ["local", "knowledge", "store", "reasoning", "substrate"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768240645.0455225"}}, {"id": "/home/deeog/Desktop/KnowCode/KnowCode.md::supported-query-types::0", "entity_id": "/home/deeog/Desktop/KnowCode/KnowCode.md::supported-query-types", "content": "**Supported Query Types**", "tokens": ["supported", "query", "types"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768240645.0455225"}}, {"id": "/home/deeog/Desktop/KnowCode/KnowCode.md::9-task-aware-context-synthesis-layer::0", "entity_id": "/home/deeog/Desktop/KnowCode/KnowCode.md::9-task-aware-context-synthesis-layer", "content": "**9\\. Task-Aware Context Synthesis Layer**", "tokens": ["task", "aware", "context", "synthesis", "layer"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768240645.0455225"}}, {"id": "/home/deeog/Desktop/KnowCode/KnowCode.md::task-specific-templates::0", "entity_id": "/home/deeog/Desktop/KnowCode/KnowCode.md::task-specific-templates", "content": "**Task-Specific Templates**", "tokens": ["task", "specific", "templates"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768240645.0455225"}}, {"id": "/home/deeog/Desktop/KnowCode/KnowCode.md::10-frontier-llm-interface-layer::0", "entity_id": "/home/deeog/Desktop/KnowCode/KnowCode.md::10-frontier-llm-interface-layer", "content": "**10\\. Frontier LLM Interface Layer**", "tokens": ["10", "frontier", "llm", "interface", "layer"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768240645.0455225"}}, {"id": "/home/deeog/Desktop/KnowCode/KnowCode.md::12-cross-cutting-concerns-new::0", "entity_id": "/home/deeog/Desktop/KnowCode/KnowCode.md::12-cross-cutting-concerns-new", "content": "**12\\. Cross-Cutting Concerns [NEW]**", "tokens": ["12", "cross", "cutting", "concerns", "new"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768240645.0455225"}}, {"id": "/home/deeog/Desktop/KnowCode/KnowCode.md::security-model::0", "entity_id": "/home/deeog/Desktop/KnowCode/KnowCode.md::security-model", "content": "**Security Model**", "tokens": ["security", "model"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768240645.0455225"}}, {"id": "/home/deeog/Desktop/KnowCode/KnowCode.md::scalability-architecture::0", "entity_id": "/home/deeog/Desktop/KnowCode/KnowCode.md::scalability-architecture", "content": "**Scalability Architecture**", "tokens": ["scalability", "architecture"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768240645.0455225"}}, {"id": "/home/deeog/Desktop/KnowCode/KnowCode.md::observability::0", "entity_id": "/home/deeog/Desktop/KnowCode/KnowCode.md::observability", "content": "**Observability**", "tokens": ["observability"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768240645.0455225"}}, {"id": "/home/deeog/Desktop/KnowCode/KnowCode.md::configuration-management::0", "entity_id": "/home/deeog/Desktop/KnowCode/KnowCode.md::configuration-management", "content": "**Configuration Management**", "tokens": ["configuration", "management"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768240645.0455225"}}, {"id": "/home/deeog/Desktop/KnowCode/KnowCode.md::high-level-interaction-flow-simplified::0", "entity_id": "/home/deeog/Desktop/KnowCode/KnowCode.md::high-level-interaction-flow-simplified", "content": "**High-Level Interaction Flow (Simplified)**", "tokens": ["high", "level", "interaction", "flow", "simplified"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768240645.0455225"}}, {"id": "/home/deeog/Desktop/KnowCode/KnowCode.md::enhanced-layer-interaction-diagram::0", "entity_id": "/home/deeog/Desktop/KnowCode/KnowCode.md::enhanced-layer-interaction-diagram", "content": "**Enhanced Layer Interaction Diagram**", "tokens": ["enhanced", "layer", "interaction", "diagram"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768240645.0455225"}}, {"id": "/home/deeog/Desktop/KnowCode/KnowCode.md::why-this-architecture-fits-your-stated-priorities::0", "entity_id": "/home/deeog/Desktop/KnowCode/KnowCode.md::why-this-architecture-fits-your-stated-priorities", "content": "**Why this architecture fits your stated priorities**", "tokens": ["why", "this", "architecture", "fits", "your", "stated", "priorities"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768240645.0455225"}}, {"id": "/home/deeog/Desktop/KnowCode/KnowCode.md::implementation-status-roadmap::0", "entity_id": "/home/deeog/Desktop/KnowCode/KnowCode.md::implementation-status-roadmap", "content": "**Implementation Status & Roadmap**", "tokens": ["implementation", "status", "roadmap"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768240645.0455225"}}, {"id": "/home/deeog/Desktop/KnowCode/KnowCode.md::phase-1-foundation-completed::0", "entity_id": "/home/deeog/Desktop/KnowCode/KnowCode.md::phase-1-foundation-completed", "content": "**Phase 1: Foundation (COMPLETED)**", "tokens": ["phase", "foundation", "completed"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768240645.0455225"}}, {"id": "/home/deeog/Desktop/KnowCode/KnowCode.md::phase-2-intelligence-server-rag-completed::0", "entity_id": "/home/deeog/Desktop/KnowCode/KnowCode.md::phase-2-intelligence-server-rag-completed", "content": "**Phase 2: Intelligence Server & RAG (COMPLETED)**", "tokens": ["phase", "intelligence", "server", "rag", "completed"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768240645.0455225"}}, {"id": "/home/deeog/Desktop/KnowCode/KnowCode.md::phase-3-temporal-runtime-signals-completed::0", "entity_id": "/home/deeog/Desktop/KnowCode/KnowCode.md::phase-3-temporal-runtime-signals-completed", "content": "**Phase 3: Temporal & Runtime Signals (COMPLETED)**", "tokens": ["phase", "temporal", "runtime", "signals", "completed"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768240645.0455225"}}, {"id": "/home/deeog/Desktop/KnowCode/KnowCode.md::phase-4-documentation-synthesis-partial::0", "entity_id": "/home/deeog/Desktop/KnowCode/KnowCode.md::phase-4-documentation-synthesis-partial", "content": "**Phase 4: Documentation Synthesis (PARTIAL)**", "tokens": ["phase", "documentation", "synthesis", "partial"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768240645.0455225"}}, {"id": "/home/deeog/Desktop/KnowCode/KnowCode.md::phase-5-deep-analysis-next::0", "entity_id": "/home/deeog/Desktop/KnowCode/KnowCode.md::phase-5-deep-analysis-next", "content": "**Phase 5: Deep Analysis (NEXT)**", "tokens": ["phase", "deep", "analysis", "next"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768240645.0455225"}}, {"id": "/home/deeog/Desktop/KnowCode/KnowCode.md::phase-6-enterprise-future::0", "entity_id": "/home/deeog/Desktop/KnowCode/KnowCode.md::phase-6-enterprise-future", "content": "**Phase 6: Enterprise (FUTURE)**", "tokens": ["phase", "enterprise", "future"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768240645.0455225"}}, {"id": "/home/deeog/Desktop/KnowCode/KnowCode.md::phase-7-agentic-capabilities-completed-v22::0", "entity_id": "/home/deeog/Desktop/KnowCode/KnowCode.md::phase-7-agentic-capabilities-completed-v22", "content": "**Phase 7: Agentic Capabilities (COMPLETED v2.2)**", "tokens": ["phase", "agentic", "capabilities", "completed", "v2"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768240645.0455225"}}, {"id": "/home/deeog/Desktop/KnowCode/KnowCode.md::phase-8-ide-integration-completed-v22::0", "entity_id": "/home/deeog/Desktop/KnowCode/KnowCode.md::phase-8-ide-integration-completed-v22", "content": "**Phase 8: IDE Integration (COMPLETED v2.2)**", "tokens": ["phase", "ide", "integration", "completed", "v2"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768240645.0455225"}}, {"id": "/home/deeog/Desktop/KnowCode/KnowCode.md::supporting-tooling-qa-completed::0", "entity_id": "/home/deeog/Desktop/KnowCode/KnowCode.md::supporting-tooling-qa-completed", "content": "**Supporting Tooling & QA (COMPLETED)**", "tokens": ["supporting", "tooling", "qa", "completed"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768240645.0455225"}}, {"id": "/home/deeog/Desktop/KnowCode/KnowCode.md::primary-use-cases::0", "entity_id": "/home/deeog/Desktop/KnowCode/KnowCode.md::primary-use-cases", "content": "**Primary Use-Cases**", "tokens": ["primary", "use", "cases"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768240645.0455225"}}, {"id": "/home/deeog/Desktop/KnowCode/KnowCode.md::use-case-1-developer-qa-with-detailed-answers::0", "entity_id": "/home/deeog/Desktop/KnowCode/KnowCode.md::use-case-1-developer-qa-with-detailed-answers", "content": "**Use-Case 1: Developer Q&A with Detailed Answers**", "tokens": ["use", "case", "developer", "with", "detailed", "answers"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768240645.0455225"}}, {"id": "/home/deeog/Desktop/KnowCode/KnowCode.md::use-case-2-ide-agent-integration-for-token-efficiency::0", "entity_id": "/home/deeog/Desktop/KnowCode/KnowCode.md::use-case-2-ide-agent-integration-for-token-efficiency", "content": "**Use-Case 2: IDE Agent Integration for Token Efficiency**", "tokens": ["use", "case", "ide", "agent", "integration", "for", "token", "efficiency"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768240645.0455225"}}, {"id": "/home/deeog/Desktop/KnowCode/README.md::module::0", "entity_id": "/home/deeog/Desktop/KnowCode/README.md::module", "content": "# KnowCode\nKnow a codebase using KnowCode.  Ask questions and get responses in natural language about a codebase to learn more about it. Provide accurate, relevant context to your AI coding agent and make its token usage limits last 10x longer.\n[![codecov](https://codecov.io/gh/deepakdgupta1/KnowCode/graph/badge.svg?token=placeholder)](https://codecov.io/gh/deepakdgupta1/KnowCode) [![CI/CD Pipeline](https://github.com/deepakdgupta1/KnowCode/actions/workflows/ci-cd.yml/badge.svg)](https://github.com/deepakdgupta1/KnowCode/actions/workflows/ci-cd.yml)\n## Overview\nKnowCode analyzes your codebase and builds a semantic graph of entities (functions, classes, modules) and their relationships (calls, imports, dependencies). This structured knowledge enables:\n- **Accurate context synthesis** for AI assistants\n- **Token-efficient** context generation (only what's needed)\n- **Local-first** querying without LLM dependency\n- **Traceability** back to source code\n## Installation\n```bash\n# Create and activate virtual environment\nuv venv\nsource .venv/bin/activate  # On Windows: .venv\\Scripts\\activate\n# Install KnowCode (with dev dependencies)\nuv sync --dev\n# Set API keys (only needed for the features you use; see aimodels.yaml)\nexport VOYAGE_API_KEY_1=\"...\"   # embeddings + reranking (semantic search)\nexport OPENAI_API_KEY=\"...\"     # embeddings (alternative to VoyageAI)\nexport GOOGLE_API_KEY_1=\"...\"   # LLM (Gemini) for `knowcode ask`\n```\n## Quick Start\n```bash\n# 1. Analyze your codebase\nknowcode analyze src/\n# 2. Query the knowledge store\nknowcode query search \"MyClass\"\nknowcode query callers \"my_function\"\nknowcode query callees \"MyClass.method\"\n# 3. Generate context for an entity\nknowcode context \"MyClass.important_method\"\n# 4. Export documentation\nknowcode export -o docs/\n# 5. Build semantic search index\nknowcode index src/\n# 6. Perform semantic search\nknowcode semantic-search \"How does parsing work?\"\n# 7. Start the intelligence server with watch mode\nknowcode server --port 8080 --watch\n# 8. Start MCP server for IDE integration\nknowcode mcp-server --store .\n# 9. View statistics\nknowcode stats\n```\n## Commands\n### `analyze`\nScan and parse a directory to build the knowledge store.\n```bash\nknowcode analyze <directory> [--output <path>] [--ignore <pattern>]\n```\n**Example:**\n```bash\nknowcode analyze src/ --ignore \"tests/*\" --ignore \"*.pyc\"\n```\n### `query`\nQuery the knowledge store for relationships.\n```bash\nknowcode query <type> <target> [--store <path>] [--json]\n```\n**Query types:**\n- `search <pattern>` - Search entities by name\n- `callers <entity>` - Find what calls this entity\n- `callees <entity>` - Find what this entity calls\n- `deps <entity>` - Get all dependencies\n**Example:**\n```bash\nknowcode query search \"Parser\"\nknowcode query callers \"GraphBuilder.build_from_directory\"\nknowcode query deps \"PythonParser\" --json\n```\n### `context`\nGenerate a context bundle for an entity (ready for AI consumption).\n```bash\nknowcode context <entity> [--store <path>] [--max-chars <n>]\n```\n**Example:**\n```bash\nknowcode context \"GraphBuilder.build_from_directory\" --max-chars 4000\n```\n### `export`\nExport the knowledge store as Markdown documentation.\n```bash\nknowcode export [--store <path>] [--output <dir>]\n```\n**Example:**\n```bash\nknowcode export -o docs/\n```\n### `stats`\nShow statistics about the knowledge store.\n```bash\nknowcode stats [--store <path>]\n```\n### `index`\nBuild a semantic search index for your codebase.\n```bash\nknowcode index <directory> [--output <path>] [--config <path>]\n```\n### `semantic-search`\nPerform a natural language search against the semantic index.\n```bash\nknowcode semantic-search <query> [--index <path>] [--store <path>] [--config <path>] [--limit <n>]\n```\n**Example:**\n```bash\nknowcode semantic-search \"Where is the graph built?\"\n```\n### `server`\nStart the FastAPI intelligence server. This is the preferred way for locally hosted AI agents (IDEs) to interact with KnowCode.\n```bash\nknowcode server [--host <host>] [--port <port>] [--store <path>] [--watch]\n```\n**Example:**\n```bash\nknowcode server --port 8080\n```\nOnce running, you can access endpoints like:\n- `GET /api/v1/context?target=MyClass&task_type=debug`\n- `GET /api/v1/search?q=parser` `(lexical search)`\n- `POST /api/v1/context/query` `(semantic search)`\n- `GET /api/v1/trace_calls/{entity_id}?direction=callers&depth=3` `(multi-hop call graph)`\n- `GET /api/v1/impact/{entity_id}` `(deletion impact analysis)`\n- `POST /api/v1/reload` (to refresh data after a new `analyze` run)\n### `history`\nShow git history for the codebase or specific entities. Requires analysis with `--temporal`.\n```bash\nknowcode history [target] [--limit <n>]\n```\n**Example:**\n```bash\n# Show recent project history\nknowcode history --limit 5\n# Show history for a specific class\nknowcode history \"KnowledgeStore\"\n```\n### `ask`\nAsk questions about the codebase using an LLM agent. Requires an API key for at least one configured model in `aimodels.yaml`.\n```bash\nknowcode ask <question> [--config <path>]\n```\n**Configuration:**\nKnowCode looks for a configuration file in the following order:\n1. `--config` argument\n2. `aimodels.yaml` in current directory\n3. `~/.aimodels.yaml`\n**Example `aimodels.yaml`:**\n```yaml\nnatural_language_models:\n  - name: gemini-2.5-flash\n    provider: google\n    api_key_env: GOOGLE_API_KEY_1\n```\n**Example:**\n```bash\nknowcode ask \"How does the graph builder work?\"\n```\n### `mcp-server`\nStart an MCP (Model Context Protocol) server for IDE agent integration.\n```bash\nknowcode mcp-server [--store <path>] [--config <path>]\n```\n**Tools Exposed:**\n- `search_codebase` - Search for code entities by name\n- `get_entity_context` - Get detailed context for an entity\n- `trace_calls` - Trace call graph (callers/callees) with depth\n- `retrieve_context_for_query` - Unified query\u2192retrieval\u2192context bundle (same pipeline as `knowcode ask`)\n**MCP Client Configuration (Claude Desktop, VS Code, etc.):**\n```json\n{\n  \"knowcode\": {\n    \"command\": \"knowcode\",\n    \"args\": [\"mcp-server\", \"--store\", \"/path/to/project\"]\n  }\n}\n```\n**Installation with MCP support:**\n```bash\npip install \"knowcode[mcp]\"\n```\n## IDE Agent Integration\nKnowCode enables token-efficient IDE agent workflows. When your IDE agent needs context, it invokes KnowCode's MCP tools to retrieve relevant code context locally *before* calling expensive external LLMs.\n**How It Works:**\n1. IDE agent receives user query\n2. Agent invokes `retrieve_context_for_query` via MCP\n3. KnowCode returns context + `sufficiency_score` (0.0-1.0)\n4. **Score \u2265 0.8**: Answer locally (zero external tokens)\n5. **Score < 0.8**: Use returned context with external LLM\n**Antigravity Configuration (`.gemini/mcp_servers.json`):**\n```json\n{\n  \"mcpServers\": {\n    \"knowcode\": {\n      \"command\": \"knowcode\",\n      \"args\": [\"mcp-server\", \"--store\", \"/path/to/your/project\"]\n    }\n  }\n}\n```\n**Token Savings:**\n- Simple \"locate\" queries \u2192 **100% savings** (answered locally)\n- Code explanations \u2192 **60-80% savings** (precise context only)\n## Supported Languages (MVP)\n- **Python** (.py) - Full AST parsing (Supports Python 3.9 - 3.12)\n- **JavaScript / TypeScript** (.js, .ts) - Classes, functions, imports (via tree-sitter)\n- **Java** (.java) - Classes, methods, imports, inheritance (via tree-sitter)\n- **Markdown** (.md) - Document structure with heading hierarchy\n- **YAML** (.yaml, .yml) - Configuration keys with nested structure\n## Architecture\nKnowCode follows a layered architecture:\n1. **Scanner** - Discovers files with gitignore support\n2. **Parsers** - Language-specific parsing (Python AST, Tree-sitter for others)\n3. **Graph Builder** - Constructs semantic graph with entities and relationships\n4. **Knowledge Store** - In-memory graph with JSON persistence\n5. **Indexer** - Vector embedding and hybrid retrieval engine (FAISS + BM25)\n6. **Context Synthesizer** - Generates token-efficient context bundles with priority ranking\n7. **CLI** - User interface for all operations\nSee [KnowCode.md](KnowCode.md) for the complete reference architecture.\n## Configuration\n**`aimodels.yaml`** supports:\n```yaml\n# LLM models for 'ask' command\nnatural_language_models:\n  - name: gemini-2.0-flash-lite\n    provider: google\n    api_key_env: GOOGLE_API_KEY_1\n# Embedding models\nembedding_models:\n  - name: voyage-3-lite\n    provider: voyageai\n    api_key_env: VOYAGE_API_KEY_1\n# Reranking models (cross-encoder)\nreranking_models:\n  - name: rerank-2.5\n    provider: voyageai\n    api_key_env: VOYAGE_API_KEY_1\n# Config\nconfig:\n  sufficiency_threshold: 0.8  # For local-first answering\n```\n**Optional dependencies:**\n```bash\npip install \"knowcode[mcp]\"      # MCP server support\npip install \"knowcode[voyageai]\" # VoyageAI embeddings + reranking\n```\n## Example Output\n**Stats:**\n```\nTotal Entities: 98\n  class: 15\n  function: 6\n  method: 66\n  module: 11\nTotal Relationships: 616\n  calls: 478\n  contains: 87\n  imports: 47\n  inherits: 4\n```\n**Context Bundle:**\n```markdown\n# Method: `GraphBuilder.build_from_directory`\n**File**: `/path/to/graph_builder.py`\n**Lines**: 24-45\n## Description\nBuild graph by scanning and parsing a directory.\n## Signature", "tokens": ["know", "code", "know", "codebase", "using", "know", "code", "ask", "questions", "and", "get", "responses", "in", "natural", "language", "about", "codebase", "to", "learn", "more", "about", "it", "provide", "accurate", "relevant", "context", "to", "your", "ai", "coding", "agent", "and", "make", "its", "token", "usage", "limits", "last", "10x", "longer", "codecov", "https", "codecov", "io", "gh", "deepakdgupta1", "know", "code", "graph", "badge", "svg", "token", "placeholder", "https", "codecov", "io", "gh", "deepakdgupta1", "know", "code", "ci", "cd", "pipeline", "https", "github", "com", "deepakdgupta1", "know", "code", "actions", "workflows", "ci", "cd", "yml", "badge", "svg", "https", "github", "com", "deepakdgupta1", "know", "code", "actions", "workflows", "ci", "cd", "yml", "overview", "know", "code", "analyzes", "your", "codebase", "and", "builds", "semantic", "graph", "of", "entities", "functions", "classes", "modules", "and", "their", "relationships", "calls", "imports", "dependencies", "this", "structured", "knowledge", "enables", "accurate", "context", "synthesis", "for", "ai", "assistants", "token", "efficient", "context", "generation", "only", "what", "needed", "local", "first", "querying", "without", "llm", "dependency", "traceability", "back", "to", "source", "code", "installation", "bash", "create", "and", "activate", "virtual", "environment", "uv", "venv", "source", "venv", "bin", "activate", "on", "windows", "venv", "scripts", "activate", "install", "know", "code", "with", "dev", "dependencies", "uv", "sync", "dev", "set", "api", "keys", "only", "needed", "for", "the", "features", "you", "use", "see", "aimodels", "yaml", "export", "voyage", "api", "key", "embeddings", "reranking", "semantic", "search", "export", "openai", "api", "key", "embeddings", "alternative", "to", "voyage", "ai", "export", "google", "api", "key", "llm", "gemini", "for", "knowcode", "ask", "quick", "start", "bash", "analyze", "your", "codebase", "knowcode", "analyze", "src", "query", "the", "knowledge", "store", "knowcode", "query", "search", "my", "class", "knowcode", "query", "callers", "my", "function", "knowcode", "query", "callees", "my", "class", "method", "generate", "context", "for", "an", "entity", "knowcode", "context", "my", "class", "important", "method", "export", "documentation", "knowcode", "export", "docs", "build", "semantic", "search", "index", "knowcode", "index", "src", "perform", "semantic", "search", "knowcode", "semantic", "search", "how", "does", "parsing", "work", "start", "the", "intelligence", "server", "with", "watch", "mode", "knowcode", "server", "port", "8080", "watch", "start", "mcp", "server", "for", "ide", "integration", "knowcode", "mcp", "server", "store", "view", "statistics", "knowcode", "stats", "commands", "analyze", "scan", "and", "parse", "directory", "to", "build", "the", "knowledge", "store", "bash", "knowcode", "analyze", "directory", "output", "path", "ignore", "pattern", "example", "bash", "knowcode", "analyze", "src", "ignore", "tests", "ignore", "pyc", "query", "query", "the", "knowledge", "store", "for", "relationships", "bash", "knowcode", "query", "type", "target", "store", "path", "json", "query", "types", "search", "pattern", "search", "entities", "by", "name", "callers", "entity", "find", "what", "calls", "this", "entity", "callees", "entity", "find", "what", "this", "entity", "calls", "deps", "entity", "get", "all", "dependencies", "example", "bash", "knowcode", "query", "search", "parser", "knowcode", "query", "callers", "graph", "builder", "build", "from", "directory", "knowcode", "query", "deps", "python", "parser", "json", "context", "generate", "context", "bundle", "for", "an", "entity", "ready", "for", "ai", "consumption", "bash", "knowcode", "context", "entity", "store", "path", "max", "chars", "example", "bash", "knowcode", "context", "graph", "builder", "build", "from", "directory", "max", "chars", "4000", "export", "export", "the", "knowledge", "store", "as", "markdown", "documentation", "bash", "knowcode", "export", "store", "path", "output", "dir", "example", "bash", "knowcode", "export", "docs", "stats", "show", "statistics", "about", "the", "knowledge", "store", "bash", "knowcode", "stats", "store", "path", "index", "build", "semantic", "search", "index", "for", "your", "codebase", "bash", "knowcode", "index", "directory", "output", "path", "config", "path", "semantic", "search", "perform", "natural", "language", "search", "against", "the", "semantic", "index", "bash", "knowcode", "semantic", "search", "query", "index", "path", "store", "path", "config", "path", "limit", "example", "bash", "knowcode", "semantic", "search", "where", "is", "the", "graph", "built", "server", "start", "the", "fast", "api", "intelligence", "server", "this", "is", "the", "preferred", "way", "for", "locally", "hosted", "ai", "agents", "ides", "to", "interact", "with", "know", "code", "bash", "knowcode", "server", "host", "host", "port", "port", "store", "path", "watch", "example", "bash", "knowcode", "server", "port", "8080", "once", "running", "you", "can", "access", "endpoints", "like", "get", "api", "v1", "context", "target", "my", "class", "task", "type", "debug", "get", "api", "v1", "search", "parser", "lexical", "search", "post", "api", "v1", "context", "query", "semantic", "search", "get", "api", "v1", "trace", "calls", "entity", "id", "direction", "callers", "depth", "multi", "hop", "call", "graph", "get", "api", "v1", "impact", "entity", "id", "deletion", "impact", "analysis", "post", "api", "v1", "reload", "to", "refresh", "data", "after", "new", "analyze", "run", "history", "show", "git", "history", "for", "the", "codebase", "or", "specific", "entities", "requires", "analysis", "with", "temporal", "bash", "knowcode", "history", "target", "limit", "example", "bash", "show", "recent", "project", "history", "knowcode", "history", "limit", "show", "history", "for", "specific", "class", "knowcode", "history", "knowledge", "store", "ask", "ask", "questions", "about", "the", "codebase", "using", "an", "llm", "agent", "requires", "an", "api", "key", "for", "at", "least", "one", "configured", "model", "in", "aimodels", "yaml", "bash", "knowcode", "ask", "question", "config", "path", "configuration", "know", "code", "looks", "for", "configuration", "file", "in", "the", "following", "order", "config", "argument", "aimodels", "yaml", "in", "current", "directory", "aimodels", "yaml", "example", "aimodels", "yaml", "yaml", "natural", "language", "models", "name", "gemini", "flash", "provider", "google", "api", "key", "env", "google", "api", "key", "example", "bash", "knowcode", "ask", "how", "does", "the", "graph", "builder", "work", "mcp", "server", "start", "an", "mcp", "model", "context", "protocol", "server", "for", "ide", "agent", "integration", "bash", "knowcode", "mcp", "server", "store", "path", "config", "path", "tools", "exposed", "search", "codebase", "search", "for", "code", "entities", "by", "name", "get", "entity", "context", "get", "detailed", "context", "for", "an", "entity", "trace", "calls", "trace", "call", "graph", "callers", "callees", "with", "depth", "retrieve", "context", "for", "query", "unified", "query", "retrieval", "context", "bundle", "same", "pipeline", "as", "knowcode", "ask", "mcp", "client", "configuration", "claude", "desktop", "vs", "code", "etc", "json", "knowcode", "command", "knowcode", "args", "mcp", "server", "store", "path", "to", "project", "installation", "with", "mcp", "support", "bash", "pip", "install", "knowcode", "mcp", "ide", "agent", "integration", "know", "code", "enables", "token", "efficient", "ide", "agent", "workflows", "when", "your", "ide", "agent", "needs", "context", "it", "invokes", "know", "code", "mcp", "tools", "to", "retrieve", "relevant", "code", "context", "locally", "before", "calling", "expensive", "external", "llms", "how", "it", "works", "ide", "agent", "receives", "user", "query", "agent", "invokes", "retrieve", "context", "for", "query", "via", "mcp", "know", "code", "returns", "context", "sufficiency", "score", "score", "answer", "locally", "zero", "external", "tokens", "score", "use", "returned", "context", "with", "external", "llm", "antigravity", "configuration", "gemini", "mcp", "servers", "json", "json", "mcp", "servers", "knowcode", "command", "knowcode", "args", "mcp", "server", "store", "path", "to", "your", "project", "token", "savings", "simple", "locate", "queries", "100", "savings", "answered", "locally", "code", "explanations", "60", "80", "savings", "precise", "context", "only", "supported", "languages", "mvp", "python", "py", "full", "ast", "parsing", "supports", "python", "12", "java", "script", "type", "script", "js", "ts", "classes", "functions", "imports", "via", "tree", "sitter", "java", "java", "classes", "methods", "imports", "inheritance", "via", "tree", "sitter", "markdown", "md", "document", "structure", "with", "heading", "hierarchy", "yaml", "yaml", "yml", "configuration", "keys", "with", "nested", "structure", "architecture", "know", "code", "follows", "layered", "architecture", "scanner", "discovers", "files", "with", "gitignore", "support", "parsers", "language", "specific", "parsing", "python", "ast", "tree", "sitter", "for", "others", "graph", "builder", "constructs", "semantic", "graph", "with", "entities", "and", "relationships", "knowledge", "store", "in", "memory", "graph", "with", "json", "persistence", "indexer", "vector", "embedding", "and", "hybrid", "retrieval", "engine", "faiss", "bm25", "context", "synthesizer", "generates", "token", "efficient", "context", "bundles", "with", "priority", "ranking", "cli", "user", "interface", "for", "all", "operations", "see", "know", "code", "md", "know", "code", "md", "for", "the", "complete", "reference", "architecture", "configuration", "aimodels", "yaml", "supports", "yaml", "llm", "models", "for", "ask", "command", "natural", "language", "models", "name", "gemini", "flash", "lite", "provider", "google", "api", "key", "env", "google", "api", "key", "embedding", "models", "embedding", "models", "name", "voyage", "lite", "provider", "voyageai", "api", "key", "env", "voyage", "api", "key", "reranking", "models", "cross", "encoder", "reranking", "models", "name", "rerank", "provider", "voyageai", "api", "key", "env", "voyage", "api", "key", "config", "config", "sufficiency", "threshold", "for", "local", "first", "answering", "optional", "dependencies", "bash", "pip", "install", "knowcode", "mcp", "mcp", "server", "support", "pip", "install", "knowcode", "voyageai", "voyage", "ai", "embeddings", "reranking", "example", "output", "stats", "total", "entities", "98", "class", "15", "function", "method", "66", "module", "11", "total", "relationships", "616", "calls", "478", "contains", "87", "imports", "47", "inherits", "context", "bundle", "markdown", "method", "graph", "builder", "build", "from", "directory", "file", "path", "to", "graph", "builder", "py", "lines", "24", "45", "description", "build", "graph", "by", "scanning", "and", "parsing", "directory", "signature"], "metadata": {"type": "module_header"}}, {"id": "/home/deeog/Desktop/KnowCode/README.md::README::0", "entity_id": "/home/deeog/Desktop/KnowCode/README.md::README", "content": "\"\"\"Know a codebase using KnowCode.  Ask questions and get responses in natural language about a codebase to learn more about it. Provide accurate, relevant context to your AI coding agent and make its token usage limits last 10x longer.\"\"\"\nREADME", "tokens": ["know", "codebase", "using", "know", "code", "ask", "questions", "and", "get", "responses", "in", "natural", "language", "about", "codebase", "to", "learn", "more", "about", "it", "provide", "accurate", "relevant", "context", "to", "your", "ai", "coding", "agent", "and", "make", "its", "token", "usage", "limits", "last", "10x", "longer", "readme"], "metadata": {"kind": "document", "has_docstring": "true", "last_modified": "1768273149.204458"}}, {"id": "/home/deeog/Desktop/KnowCode/README.md::knowcode::0", "entity_id": "/home/deeog/Desktop/KnowCode/README.md::knowcode", "content": "KnowCode", "tokens": ["know", "code"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768273149.204458"}}, {"id": "/home/deeog/Desktop/KnowCode/README.md::overview::0", "entity_id": "/home/deeog/Desktop/KnowCode/README.md::overview", "content": "Overview", "tokens": ["overview"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768273149.204458"}}, {"id": "/home/deeog/Desktop/KnowCode/README.md::installation::0", "entity_id": "/home/deeog/Desktop/KnowCode/README.md::installation", "content": "Installation", "tokens": ["installation"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768273149.204458"}}, {"id": "/home/deeog/Desktop/KnowCode/README.md::create-and-activate-virtual-environment::0", "entity_id": "/home/deeog/Desktop/KnowCode/README.md::create-and-activate-virtual-environment", "content": "Create and activate virtual environment", "tokens": ["create", "and", "activate", "virtual", "environment"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768273149.204458"}}, {"id": "/home/deeog/Desktop/KnowCode/README.md::install-knowcode-with-dev-dependencies::0", "entity_id": "/home/deeog/Desktop/KnowCode/README.md::install-knowcode-with-dev-dependencies", "content": "Install KnowCode (with dev dependencies)", "tokens": ["install", "know", "code", "with", "dev", "dependencies"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768273149.204458"}}, {"id": "/home/deeog/Desktop/KnowCode/README.md::set-api-keys-only-needed-for-the-features-you-use-see-aimodelsyaml::0", "entity_id": "/home/deeog/Desktop/KnowCode/README.md::set-api-keys-only-needed-for-the-features-you-use-see-aimodelsyaml", "content": "Set API keys (only needed for the features you use; see aimodels.yaml)", "tokens": ["set", "api", "keys", "only", "needed", "for", "the", "features", "you", "use", "see", "aimodels", "yaml"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768273149.204458"}}, {"id": "/home/deeog/Desktop/KnowCode/README.md::quick-start::0", "entity_id": "/home/deeog/Desktop/KnowCode/README.md::quick-start", "content": "Quick Start", "tokens": ["quick", "start"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768273149.204458"}}, {"id": "/home/deeog/Desktop/KnowCode/README.md::1-analyze-your-codebase::0", "entity_id": "/home/deeog/Desktop/KnowCode/README.md::1-analyze-your-codebase", "content": "1. Analyze your codebase", "tokens": ["analyze", "your", "codebase"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768273149.204458"}}, {"id": "/home/deeog/Desktop/KnowCode/README.md::2-query-the-knowledge-store::0", "entity_id": "/home/deeog/Desktop/KnowCode/README.md::2-query-the-knowledge-store", "content": "2. Query the knowledge store", "tokens": ["query", "the", "knowledge", "store"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768273149.204458"}}, {"id": "/home/deeog/Desktop/KnowCode/README.md::3-generate-context-for-an-entity::0", "entity_id": "/home/deeog/Desktop/KnowCode/README.md::3-generate-context-for-an-entity", "content": "3. Generate context for an entity", "tokens": ["generate", "context", "for", "an", "entity"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768273149.204458"}}, {"id": "/home/deeog/Desktop/KnowCode/README.md::4-export-documentation::0", "entity_id": "/home/deeog/Desktop/KnowCode/README.md::4-export-documentation", "content": "4. Export documentation", "tokens": ["export", "documentation"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768273149.204458"}}, {"id": "/home/deeog/Desktop/KnowCode/README.md::5-build-semantic-search-index::0", "entity_id": "/home/deeog/Desktop/KnowCode/README.md::5-build-semantic-search-index", "content": "5. Build semantic search index", "tokens": ["build", "semantic", "search", "index"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768273149.204458"}}, {"id": "/home/deeog/Desktop/KnowCode/README.md::6-perform-semantic-search::0", "entity_id": "/home/deeog/Desktop/KnowCode/README.md::6-perform-semantic-search", "content": "6. Perform semantic search", "tokens": ["perform", "semantic", "search"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768273149.204458"}}, {"id": "/home/deeog/Desktop/KnowCode/README.md::7-start-the-intelligence-server-with-watch-mode::0", "entity_id": "/home/deeog/Desktop/KnowCode/README.md::7-start-the-intelligence-server-with-watch-mode", "content": "7. Start the intelligence server with watch mode", "tokens": ["start", "the", "intelligence", "server", "with", "watch", "mode"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768273149.204458"}}, {"id": "/home/deeog/Desktop/KnowCode/README.md::8-start-mcp-server-for-ide-integration::0", "entity_id": "/home/deeog/Desktop/KnowCode/README.md::8-start-mcp-server-for-ide-integration", "content": "8. Start MCP server for IDE integration", "tokens": ["start", "mcp", "server", "for", "ide", "integration"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768273149.204458"}}, {"id": "/home/deeog/Desktop/KnowCode/README.md::9-view-statistics::0", "entity_id": "/home/deeog/Desktop/KnowCode/README.md::9-view-statistics", "content": "9. View statistics", "tokens": ["view", "statistics"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768273149.204458"}}, {"id": "/home/deeog/Desktop/KnowCode/README.md::commands::0", "entity_id": "/home/deeog/Desktop/KnowCode/README.md::commands", "content": "Commands", "tokens": ["commands"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768273149.204458"}}, {"id": "/home/deeog/Desktop/KnowCode/README.md::analyze::0", "entity_id": "/home/deeog/Desktop/KnowCode/README.md::analyze", "content": "`analyze`", "tokens": ["analyze"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768273149.204458"}}, {"id": "/home/deeog/Desktop/KnowCode/README.md::query::0", "entity_id": "/home/deeog/Desktop/KnowCode/README.md::query", "content": "`query`", "tokens": ["query"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768273149.204458"}}, {"id": "/home/deeog/Desktop/KnowCode/README.md::context::0", "entity_id": "/home/deeog/Desktop/KnowCode/README.md::context", "content": "`context`", "tokens": ["context"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768273149.204458"}}, {"id": "/home/deeog/Desktop/KnowCode/README.md::export::0", "entity_id": "/home/deeog/Desktop/KnowCode/README.md::export", "content": "`export`", "tokens": ["export"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768273149.204458"}}, {"id": "/home/deeog/Desktop/KnowCode/README.md::stats::0", "entity_id": "/home/deeog/Desktop/KnowCode/README.md::stats", "content": "`stats`", "tokens": ["stats"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768273149.204458"}}, {"id": "/home/deeog/Desktop/KnowCode/README.md::index::0", "entity_id": "/home/deeog/Desktop/KnowCode/README.md::index", "content": "`index`", "tokens": ["index"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768273149.204458"}}, {"id": "/home/deeog/Desktop/KnowCode/README.md::semantic-search::0", "entity_id": "/home/deeog/Desktop/KnowCode/README.md::semantic-search", "content": "`semantic-search`", "tokens": ["semantic", "search"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768273149.204458"}}, {"id": "/home/deeog/Desktop/KnowCode/README.md::server::0", "entity_id": "/home/deeog/Desktop/KnowCode/README.md::server", "content": "`server`", "tokens": ["server"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768273149.204458"}}, {"id": "/home/deeog/Desktop/KnowCode/README.md::history::0", "entity_id": "/home/deeog/Desktop/KnowCode/README.md::history", "content": "`history`", "tokens": ["history"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768273149.204458"}}, {"id": "/home/deeog/Desktop/KnowCode/README.md::show-recent-project-history::0", "entity_id": "/home/deeog/Desktop/KnowCode/README.md::show-recent-project-history", "content": "Show recent project history", "tokens": ["show", "recent", "project", "history"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768273149.204458"}}, {"id": "/home/deeog/Desktop/KnowCode/README.md::show-history-for-a-specific-class::0", "entity_id": "/home/deeog/Desktop/KnowCode/README.md::show-history-for-a-specific-class", "content": "Show history for a specific class", "tokens": ["show", "history", "for", "specific", "class"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768273149.204458"}}, {"id": "/home/deeog/Desktop/KnowCode/README.md::ask::0", "entity_id": "/home/deeog/Desktop/KnowCode/README.md::ask", "content": "`ask`", "tokens": ["ask"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768273149.204458"}}, {"id": "/home/deeog/Desktop/KnowCode/README.md::mcp-server::0", "entity_id": "/home/deeog/Desktop/KnowCode/README.md::mcp-server", "content": "`mcp-server`", "tokens": ["mcp", "server"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768273149.204458"}}, {"id": "/home/deeog/Desktop/KnowCode/README.md::ide-agent-integration::0", "entity_id": "/home/deeog/Desktop/KnowCode/README.md::ide-agent-integration", "content": "IDE Agent Integration", "tokens": ["ide", "agent", "integration"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768273149.204458"}}, {"id": "/home/deeog/Desktop/KnowCode/README.md::supported-languages-mvp::0", "entity_id": "/home/deeog/Desktop/KnowCode/README.md::supported-languages-mvp", "content": "Supported Languages (MVP)", "tokens": ["supported", "languages", "mvp"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768273149.204458"}}, {"id": "/home/deeog/Desktop/KnowCode/README.md::architecture::0", "entity_id": "/home/deeog/Desktop/KnowCode/README.md::architecture", "content": "Architecture", "tokens": ["architecture"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768273149.204458"}}, {"id": "/home/deeog/Desktop/KnowCode/README.md::configuration::0", "entity_id": "/home/deeog/Desktop/KnowCode/README.md::configuration", "content": "Configuration", "tokens": ["configuration"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768273149.204458"}}, {"id": "/home/deeog/Desktop/KnowCode/README.md::llm-models-for-ask-command::0", "entity_id": "/home/deeog/Desktop/KnowCode/README.md::llm-models-for-ask-command", "content": "LLM models for 'ask' command", "tokens": ["llm", "models", "for", "ask", "command"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768273149.204458"}}, {"id": "/home/deeog/Desktop/KnowCode/README.md::embedding-models::0", "entity_id": "/home/deeog/Desktop/KnowCode/README.md::embedding-models", "content": "Embedding models", "tokens": ["embedding", "models"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768273149.204458"}}, {"id": "/home/deeog/Desktop/KnowCode/README.md::reranking-models-cross-encoder::0", "entity_id": "/home/deeog/Desktop/KnowCode/README.md::reranking-models-cross-encoder", "content": "Reranking models (cross-encoder)", "tokens": ["reranking", "models", "cross", "encoder"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768273149.204458"}}, {"id": "/home/deeog/Desktop/KnowCode/README.md::config::0", "entity_id": "/home/deeog/Desktop/KnowCode/README.md::config", "content": "Config", "tokens": ["config"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768273149.204458"}}, {"id": "/home/deeog/Desktop/KnowCode/README.md::example-output::0", "entity_id": "/home/deeog/Desktop/KnowCode/README.md::example-output", "content": "Example Output", "tokens": ["example", "output"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768273149.204458"}}, {"id": "/home/deeog/Desktop/KnowCode/README.md::method-graphbuilderbuild-from-directory::0", "entity_id": "/home/deeog/Desktop/KnowCode/README.md::method-graphbuilderbuild-from-directory", "content": "Method: `GraphBuilder.build_from_directory`", "tokens": ["method", "graph", "builder", "build", "from", "directory"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768273149.204458"}}, {"id": "/home/deeog/Desktop/KnowCode/README.md::description::0", "entity_id": "/home/deeog/Desktop/KnowCode/README.md::description", "content": "Description", "tokens": ["description"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768273149.204458"}}, {"id": "/home/deeog/Desktop/KnowCode/README.md::signature::0", "entity_id": "/home/deeog/Desktop/KnowCode/README.md::signature", "content": "Signature", "tokens": ["signature"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768273149.204458"}}, {"id": "/home/deeog/Desktop/KnowCode/README.md::source-code::0", "entity_id": "/home/deeog/Desktop/KnowCode/README.md::source-code", "content": "Source Code", "tokens": ["source", "code"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768273149.204458"}}, {"id": "/home/deeog/Desktop/KnowCode/README.md::called-by::0", "entity_id": "/home/deeog/Desktop/KnowCode/README.md::called-by", "content": "Called By", "tokens": ["called", "by"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768273149.204458"}}, {"id": "/home/deeog/Desktop/KnowCode/README.md::calls::0", "entity_id": "/home/deeog/Desktop/KnowCode/README.md::calls", "content": "Calls", "tokens": ["calls"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768273149.204458"}}, {"id": "/home/deeog/Desktop/KnowCode/README.md::development::0", "entity_id": "/home/deeog/Desktop/KnowCode/README.md::development", "content": "Development", "tokens": ["development"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768273149.204458"}}, {"id": "/home/deeog/Desktop/KnowCode/README.md::run-tests::0", "entity_id": "/home/deeog/Desktop/KnowCode/README.md::run-tests", "content": "Run tests", "tokens": ["run", "tests"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768273149.204458"}}, {"id": "/home/deeog/Desktop/KnowCode/README.md::type-checking::0", "entity_id": "/home/deeog/Desktop/KnowCode/README.md::type-checking", "content": "Type checking", "tokens": ["type", "checking"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768273149.204458"}}, {"id": "/home/deeog/Desktop/KnowCode/README.md::linting::0", "entity_id": "/home/deeog/Desktop/KnowCode/README.md::linting", "content": "Linting", "tokens": ["linting"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768273149.204458"}}, {"id": "/home/deeog/Desktop/KnowCode/README.md::format::0", "entity_id": "/home/deeog/Desktop/KnowCode/README.md::format", "content": "Format", "tokens": ["format"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768273149.204458"}}, {"id": "/home/deeog/Desktop/KnowCode/README.md::roadmap::0", "entity_id": "/home/deeog/Desktop/KnowCode/README.md::roadmap", "content": "Roadmap", "tokens": ["roadmap"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768273149.204458"}}, {"id": "/home/deeog/Desktop/KnowCode/README.md::license::0", "entity_id": "/home/deeog/Desktop/KnowCode/README.md::license", "content": "License", "tokens": ["license"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768273149.204458"}}, {"id": "/home/deeog/Desktop/KnowCode/mkdocs.yml::module::0", "entity_id": "/home/deeog/Desktop/KnowCode/mkdocs.yml::module", "content": "site_name: KnowCode Documentation\nsite_url: https://example.com/knowcode/\nrepo_url: https://github.com/deepakdgupta1/KnowCode\nrepo_name: deepakdgupta1/KnowCode\nedit_uri: edit/main/docs/\ntheme:\n  name: material\n  features:\n    - navigation.sections\n    - navigation.expand\n    - navigation.top\n    - search.suggest\n    - search.highlight\n    - content.code.copy\n  palette:\n    # Light mode\n    - media: \"(prefers-color-scheme: light)\"\n      scheme: default\n      primary: indigo\n      accent: deep purple\n      toggle:\n        icon: material/weather-night\n        name: Switch to dark mode\n    # Dark mode\n    - media: \"(prefers-color-scheme: dark)\"\n      scheme: slate\n      primary: indigo\n      accent: deep purple\n      toggle:\n        icon: material/weather-sunny\n        name: Switch to light mode\nplugins:\n  - search\n  - mkdocstrings:\n      handlers:\n        python:\n          paths: [src]\n          options:\n            show_source: true\n            heading_level: 2\nmarkdown_extensions:\n  - admonition\n  - pymdownx.details\n  - pymdownx.superfences\n  - pymdownx.highlight:\n      anchor_linenums: true\n  - pymdownx.inlinehilite\n  - pymdownx.snippets\n  - tables\n  - attr_list\nnav:\n  - Home: index.md\n  - Evolution: evolution.md\n  - API Reference:\n      - Knowledge Store: api/knowledge_store.md\n      # Add more API docs here", "tokens": ["site", "name", "know", "code", "documentation", "site", "url", "https", "example", "com", "knowcode", "repo", "url", "https", "github", "com", "deepakdgupta1", "know", "code", "repo", "name", "deepakdgupta1", "know", "code", "edit", "uri", "edit", "main", "docs", "theme", "name", "material", "features", "navigation", "sections", "navigation", "expand", "navigation", "top", "search", "suggest", "search", "highlight", "content", "code", "copy", "palette", "light", "mode", "media", "prefers", "color", "scheme", "light", "scheme", "default", "primary", "indigo", "accent", "deep", "purple", "toggle", "icon", "material", "weather", "night", "name", "switch", "to", "dark", "mode", "dark", "mode", "media", "prefers", "color", "scheme", "dark", "scheme", "slate", "primary", "indigo", "accent", "deep", "purple", "toggle", "icon", "material", "weather", "sunny", "name", "switch", "to", "light", "mode", "plugins", "search", "mkdocstrings", "handlers", "python", "paths", "src", "options", "show", "source", "true", "heading", "level", "markdown", "extensions", "admonition", "pymdownx", "details", "pymdownx", "superfences", "pymdownx", "highlight", "anchor", "linenums", "true", "pymdownx", "inlinehilite", "pymdownx", "snippets", "tables", "attr", "list", "nav", "home", "index", "md", "evolution", "evolution", "md", "api", "reference", "knowledge", "store", "api", "knowledge", "store", "md", "add", "more", "api", "docs", "here"], "metadata": {"type": "module_header"}}, {"id": "/home/deeog/Desktop/KnowCode/mkdocs.yml::mkdocs::0", "entity_id": "/home/deeog/Desktop/KnowCode/mkdocs.yml::mkdocs", "content": "mkdocs", "tokens": ["mkdocs"], "metadata": {"kind": "document", "has_docstring": "false", "last_modified": "1765822199.837665"}}, {"id": "/home/deeog/Desktop/KnowCode/mkdocs.yml::site_name::0", "entity_id": "/home/deeog/Desktop/KnowCode/mkdocs.yml::site_name", "content": "site_name", "tokens": ["site", "name"], "metadata": {"kind": "config_key", "has_docstring": "false", "last_modified": "1765822199.837665"}}, {"id": "/home/deeog/Desktop/KnowCode/mkdocs.yml::site_url::0", "entity_id": "/home/deeog/Desktop/KnowCode/mkdocs.yml::site_url", "content": "site_url", "tokens": ["site", "url"], "metadata": {"kind": "config_key", "has_docstring": "false", "last_modified": "1765822199.837665"}}, {"id": "/home/deeog/Desktop/KnowCode/mkdocs.yml::repo_url::0", "entity_id": "/home/deeog/Desktop/KnowCode/mkdocs.yml::repo_url", "content": "repo_url", "tokens": ["repo", "url"], "metadata": {"kind": "config_key", "has_docstring": "false", "last_modified": "1765822199.837665"}}, {"id": "/home/deeog/Desktop/KnowCode/mkdocs.yml::repo_name::0", "entity_id": "/home/deeog/Desktop/KnowCode/mkdocs.yml::repo_name", "content": "repo_name", "tokens": ["repo", "name"], "metadata": {"kind": "config_key", "has_docstring": "false", "last_modified": "1765822199.837665"}}, {"id": "/home/deeog/Desktop/KnowCode/mkdocs.yml::edit_uri::0", "entity_id": "/home/deeog/Desktop/KnowCode/mkdocs.yml::edit_uri", "content": "edit_uri", "tokens": ["edit", "uri"], "metadata": {"kind": "config_key", "has_docstring": "false", "last_modified": "1765822199.837665"}}, {"id": "/home/deeog/Desktop/KnowCode/mkdocs.yml::theme::0", "entity_id": "/home/deeog/Desktop/KnowCode/mkdocs.yml::theme", "content": "theme", "tokens": ["theme"], "metadata": {"kind": "config_key", "has_docstring": "false", "last_modified": "1765822199.837665"}}, {"id": "/home/deeog/Desktop/KnowCode/mkdocs.yml::theme.name::0", "entity_id": "/home/deeog/Desktop/KnowCode/mkdocs.yml::theme.name", "content": "name", "tokens": ["name"], "metadata": {"kind": "config_key", "has_docstring": "false", "last_modified": "1765822199.837665"}}, {"id": "/home/deeog/Desktop/KnowCode/mkdocs.yml::theme.features::0", "entity_id": "/home/deeog/Desktop/KnowCode/mkdocs.yml::theme.features", "content": "features", "tokens": ["features"], "metadata": {"kind": "config_key", "has_docstring": "false", "last_modified": "1765822199.837665"}}, {"id": "/home/deeog/Desktop/KnowCode/mkdocs.yml::theme.palette::0", "entity_id": "/home/deeog/Desktop/KnowCode/mkdocs.yml::theme.palette", "content": "palette", "tokens": ["palette"], "metadata": {"kind": "config_key", "has_docstring": "false", "last_modified": "1765822199.837665"}}, {"id": "/home/deeog/Desktop/KnowCode/mkdocs.yml::plugins::0", "entity_id": "/home/deeog/Desktop/KnowCode/mkdocs.yml::plugins", "content": "plugins", "tokens": ["plugins"], "metadata": {"kind": "config_key", "has_docstring": "false", "last_modified": "1765822199.837665"}}, {"id": "/home/deeog/Desktop/KnowCode/mkdocs.yml::markdown_extensions::0", "entity_id": "/home/deeog/Desktop/KnowCode/mkdocs.yml::markdown_extensions", "content": "markdown_extensions", "tokens": ["markdown", "extensions"], "metadata": {"kind": "config_key", "has_docstring": "false", "last_modified": "1765822199.837665"}}, {"id": "/home/deeog/Desktop/KnowCode/mkdocs.yml::nav::0", "entity_id": "/home/deeog/Desktop/KnowCode/mkdocs.yml::nav", "content": "nav", "tokens": ["nav"], "metadata": {"kind": "config_key", "has_docstring": "false", "last_modified": "1765822199.837665"}}, {"id": "/home/deeog/Desktop/KnowCode/aimodels.yaml::module::0", "entity_id": "/home/deeog/Desktop/KnowCode/aimodels.yaml::module", "content": "natural_language_models:\n  - name: mistralai/devstral-2512\n    provider: mistralai\n    api_key_env: OPENROUTER_API_KEY\n    rpm_free_tier_limit: 99999\n    rpd_free_tier_limit: 99999\n  - name: gemini-3-flash-preview\n    provider: google\n    api_key_env: GOOGLE_API_KEY_1\n    rpm_free_tier_limit: 5\n    rpd_free_tier_limit: 20\nembedding_models:\n  - name: voyage-code-3\n    provider: voyageai\n    api_key_env: VOYAGE_API_KEY_1\n    tokens_free_tier_limit: 200000000\neval_models:\n  - name: voyage-code-3\n    provider: voyageai\n#   api_key_env: VOYAGE_API_KEY_1\n    tokens_free_tier_limit: 200000000\n# Configuration\nconfig:\n  sufficiency_threshold: 0.8  # Configurable threshold for local-first answering", "tokens": ["natural", "language", "models", "name", "mistralai", "devstral", "2512", "provider", "mistralai", "api", "key", "env", "openrouter", "api", "key", "rpm", "free", "tier", "limit", "99999", "rpd", "free", "tier", "limit", "99999", "name", "gemini", "flash", "preview", "provider", "google", "api", "key", "env", "google", "api", "key", "rpm", "free", "tier", "limit", "rpd", "free", "tier", "limit", "20", "embedding", "models", "name", "voyage", "code", "provider", "voyageai", "api", "key", "env", "voyage", "api", "key", "tokens", "free", "tier", "limit", "200000000", "eval", "models", "name", "voyage", "code", "provider", "voyageai", "api", "key", "env", "voyage", "api", "key", "tokens", "free", "tier", "limit", "200000000", "configuration", "config", "sufficiency", "threshold", "configurable", "threshold", "for", "local", "first", "answering"], "metadata": {"type": "module_header"}}, {"id": "/home/deeog/Desktop/KnowCode/aimodels.yaml::aimodels::0", "entity_id": "/home/deeog/Desktop/KnowCode/aimodels.yaml::aimodels", "content": "aimodels", "tokens": ["aimodels"], "metadata": {"kind": "document", "has_docstring": "false", "last_modified": "1768290377.4244857"}}, {"id": "/home/deeog/Desktop/KnowCode/aimodels.yaml::natural_language_models::0", "entity_id": "/home/deeog/Desktop/KnowCode/aimodels.yaml::natural_language_models", "content": "natural_language_models", "tokens": ["natural", "language", "models"], "metadata": {"kind": "config_key", "has_docstring": "false", "last_modified": "1768290377.4244857"}}, {"id": "/home/deeog/Desktop/KnowCode/aimodels.yaml::embedding_models::0", "entity_id": "/home/deeog/Desktop/KnowCode/aimodels.yaml::embedding_models", "content": "embedding_models", "tokens": ["embedding", "models"], "metadata": {"kind": "config_key", "has_docstring": "false", "last_modified": "1768290377.4244857"}}, {"id": "/home/deeog/Desktop/KnowCode/aimodels.yaml::eval_models::0", "entity_id": "/home/deeog/Desktop/KnowCode/aimodels.yaml::eval_models", "content": "eval_models", "tokens": ["eval", "models"], "metadata": {"kind": "config_key", "has_docstring": "false", "last_modified": "1768290377.4244857"}}, {"id": "/home/deeog/Desktop/KnowCode/aimodels.yaml::config::0", "entity_id": "/home/deeog/Desktop/KnowCode/aimodels.yaml::config", "content": "config", "tokens": ["config"], "metadata": {"kind": "config_key", "has_docstring": "false", "last_modified": "1768290377.4244857"}}, {"id": "/home/deeog/Desktop/KnowCode/aimodels.yaml::config.sufficiency_threshold::0", "entity_id": "/home/deeog/Desktop/KnowCode/aimodels.yaml::config.sufficiency_threshold", "content": "sufficiency_threshold", "tokens": ["sufficiency", "threshold"], "metadata": {"kind": "config_key", "has_docstring": "false", "last_modified": "1768290377.4244857"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/test_rate_limiter_manual.py::imports::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/test_rate_limiter_manual.py::module", "content": "from unittest.mock import MagicMock, patch\nfrom knowcode.config import AppConfig, ModelConfig\nfrom knowcode.llm.agent import Agent\nfrom knowcode.llm.rate_limiter import RateLimiter", "tokens": ["from", "unittest", "mock", "import", "magic", "mock", "patch", "from", "knowcode", "config", "import", "app", "config", "model", "config", "from", "knowcode", "llm", "agent", "import", "agent", "from", "knowcode", "llm", "rate", "limiter", "import", "rate", "limiter"], "metadata": {"type": "imports"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/test_rate_limiter_manual.py::test_rate_limiter_integration::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/test_rate_limiter_manual.py::test_rate_limiter_integration", "content": "def test_rate_limiter_integration(tmp_path)\ndef test_rate_limiter_integration(tmp_path):\n    mock_service = MagicMock()\n    mock_service.store_path = tmp_path\n    mock_service.retrieve_context_for_query.return_value = {\n        \"query\": \"query\",\n        \"task_type\": \"general\",\n        \"task_confidence\": 0.0,\n        \"retrieval_mode\": \"none\",\n        \"context_text\": \"\",\n        \"total_tokens\": 0,\n        \"max_tokens\": 6000,\n        \"truncated\": False,\n        \"sufficiency_score\": 0.0,\n        \"selected_entities\": [],\n        \"evidence\": [],\n        \"errors\": [],\n    }\n\n    # Setup RateLimiter with temp file\n    stats_file = tmp_path / \"usage_stats.json\"\n    rate_limiter = RateLimiter(persistence_path=stats_file)\n    \n    # Config: Model A has RPM=1, Model B has RPM=10\n    config = AppConfig(models=[\n        ModelConfig(name=\"low-limit-model\", api_key_env=\"TEST_KEY\", rpm_free_tier_limit=1),\n        ModelConfig(name=\"high-limit-model\", api_key_env=\"TEST_KEY\", rpm_free_tier_limit=10)\n    ]", "tokens": ["def", "test", "rate", "limiter", "integration", "tmp", "path", "def", "test", "rate", "limiter", "integration", "tmp", "path", "mock", "service", "magic", "mock", "mock", "service", "store", "path", "tmp", "path", "mock", "service", "retrieve", "context", "for", "query", "return", "value", "query", "query", "task", "type", "general", "task", "confidence", "retrieval", "mode", "none", "context", "text", "total", "tokens", "max", "tokens", "6000", "truncated", "false", "sufficiency", "score", "selected", "entities", "evidence", "errors", "setup", "rate", "limiter", "with", "temp", "file", "stats", "file", "tmp", "path", "usage", "stats", "json", "rate", "limiter", "rate", "limiter", "persistence", "path", "stats", "file", "config", "model", "has", "rpm", "model", "has", "rpm", "10", "config", "app", "config", "models", "model", "config", "name", "low", "limit", "model", "api", "key", "env", "test", "key", "rpm", "free", "tier", "limit", "model", "config", "name", "high", "limit", "model", "api", "key", "env", "test", "key", "rpm", "free", "tier", "limit", "10"], "metadata": {"kind": "function", "chunk_index": "0", "has_docstring": "false", "last_modified": "1768185812.994584"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/test_rate_limiter_manual.py::test_rate_limiter_integration::1", "entity_id": "/home/deeog/Desktop/KnowCode/tests/test_rate_limiter_manual.py::test_rate_limiter_integration", "content": ",\n        ModelConfig(name=\"high-limit-model\", api_key_env=\"TEST_KEY\", rpm_free_tier_limit=10)\n    ])\n    \n    agent = Agent(mock_service, config)\n    agent.rate_limiter = rate_limiter # Inject test limiter\n    \n    # Mock clients\n    with patch.object(agent, \"_get_client\") as mock_get_client:\n        mock_client = MagicMock()\n        mock_get_client.return_value = mock_client\n        mock_client.models.generate_content.return_value = MagicMock(text=\"Success\")\n        \n        with patch.dict(\"os.environ\", {\"TEST_KEY\": \"fake\"}):\n            # 1st Call: Should use low-limit-model\n            print(\"\\n--- Call 1 ---\")\n            agent.answer(\"query 1\")\n            \n            # 2nd Call: low-limit-model should be skipped (used 1/1), should use high-limit-model\n            print(\"\\n--- Call 2 ---\")\n            agent.answer(\"query 2\")\n            \n    # Verify persistence\n    assert stats_file.exists()\n    with open(stats_file) as f:\n        print(\"\\nStats File Content:\", f.read())", "tokens": ["model", "config", "name", "high", "limit", "model", "api", "key", "env", "test", "key", "rpm", "free", "tier", "limit", "10", "agent", "agent", "mock", "service", "config", "agent", "rate", "limiter", "rate", "limiter", "inject", "test", "limiter", "mock", "clients", "with", "patch", "object", "agent", "get", "client", "as", "mock", "get", "client", "mock", "client", "magic", "mock", "mock", "get", "client", "return", "value", "mock", "client", "mock", "client", "models", "generate", "content", "return", "value", "magic", "mock", "text", "success", "with", "patch", "dict", "os", "environ", "test", "key", "fake", "1st", "call", "should", "use", "low", "limit", "model", "print", "call", "agent", "answer", "query", "2nd", "call", "low", "limit", "model", "should", "be", "skipped", "used", "should", "use", "high", "limit", "model", "print", "call", "agent", "answer", "query", "verify", "persistence", "assert", "stats", "file", "exists", "with", "open", "stats", "file", "as", "print", "stats", "file", "content", "read"], "metadata": {"kind": "function", "chunk_index": "1", "has_docstring": "false", "last_modified": "1768185812.994584"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/__init__.py::module::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/__init__.py::module", "content": "\"\"\"Tests package.\"\"\"", "tokens": ["tests", "package"], "metadata": {"type": "module_header"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/test_failover_manual.py::imports::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/test_failover_manual.py::module", "content": "from unittest.mock import MagicMock, patch\nfrom google.api_core.exceptions import ResourceExhausted\nfrom pathlib import Path\nfrom knowcode.config import AppConfig, ModelConfig\nfrom knowcode.llm.agent import Agent", "tokens": ["from", "unittest", "mock", "import", "magic", "mock", "patch", "from", "google", "api", "core", "exceptions", "import", "resource", "exhausted", "from", "pathlib", "import", "path", "from", "knowcode", "config", "import", "app", "config", "model", "config", "from", "knowcode", "llm", "agent", "import", "agent"], "metadata": {"type": "imports"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/test_failover_manual.py::test_agent_failover_logic::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/test_failover_manual.py::test_agent_failover_logic", "content": "def test_agent_failover_logic()\ndef test_agent_failover_logic():\n    # Setup mock service and config\n    mock_service = MagicMock()\n    mock_service.store_path = Path(\".\")\n    mock_service.retrieve_context_for_query.return_value = {\n        \"query\": \"test query\",\n        \"task_type\": \"general\",\n        \"task_confidence\": 0.0,\n        \"retrieval_mode\": \"none\",\n        \"context_text\": \"\",\n        \"total_tokens\": 0,\n        \"max_tokens\": 6000,\n        \"truncated\": False,\n        \"sufficiency_score\": 0.0,\n        \"selected_entities\": [],\n        \"evidence\": [],\n        \"errors\": [],\n    }\n    \n    config = AppConfig(models=[\n        ModelConfig(name=\"primary-model\", api_key_env=\"TEST_KEY\"),\n        ModelConfig(name=\"backup-model\", api_key_env=\"TEST_KEY\")\n    ])\n    \n    agent = Agent(mock_service, config)\n    \n    # Mock genai.Client\n    with patch.object(agent, \"_get_client\") as mock_get_client:\n        mock_client = MagicMock()\n        mock_get_client.return_value = mock_client\n        \n", "tokens": ["def", "test", "agent", "failover", "logic", "def", "test", "agent", "failover", "logic", "setup", "mock", "service", "and", "config", "mock", "service", "magic", "mock", "mock", "service", "store", "path", "path", "mock", "service", "retrieve", "context", "for", "query", "return", "value", "query", "test", "query", "task", "type", "general", "task", "confidence", "retrieval", "mode", "none", "context", "text", "total", "tokens", "max", "tokens", "6000", "truncated", "false", "sufficiency", "score", "selected", "entities", "evidence", "errors", "config", "app", "config", "models", "model", "config", "name", "primary", "model", "api", "key", "env", "test", "key", "model", "config", "name", "backup", "model", "api", "key", "env", "test", "key", "agent", "agent", "mock", "service", "config", "mock", "genai", "client", "with", "patch", "object", "agent", "get", "client", "as", "mock", "get", "client", "mock", "client", "magic", "mock", "mock", "get", "client", "return", "value", "mock", "client"], "metadata": {"kind": "function", "chunk_index": "0", "has_docstring": "false", "last_modified": "1768185812.994584"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/test_failover_manual.py::test_agent_failover_logic::1", "entity_id": "/home/deeog/Desktop/KnowCode/tests/test_failover_manual.py::test_agent_failover_logic", "content": "ient:\n        mock_client = MagicMock()\n        mock_get_client.return_value = mock_client\n        \n        # Simulate failover: first call raises ResourceExhausted, second succeeds\n        mock_client.models.generate_content.side_effect = [\n            ResourceExhausted(\"Quota exceeded\"),\n            MagicMock(text=\"Success from backup\")\n        ]\n        \n        # Execute\n        with patch.dict(\"os.environ\", {\"TEST_KEY\": \"fake-key\"}):\n            answer = agent.answer(\"test query\")\n            \n        # Verify\n        print(f\"Answer: {answer}\")\n        assert answer == \"Success from backup\"\n        assert mock_client.models.generate_content.call_count == 2", "tokens": ["ient", "mock", "client", "magic", "mock", "mock", "get", "client", "return", "value", "mock", "client", "simulate", "failover", "first", "call", "raises", "resource", "exhausted", "second", "succeeds", "mock", "client", "models", "generate", "content", "side", "effect", "resource", "exhausted", "quota", "exceeded", "magic", "mock", "text", "success", "from", "backup", "execute", "with", "patch", "dict", "os", "environ", "test", "key", "fake", "key", "answer", "agent", "answer", "test", "query", "verify", "print", "answer", "answer", "assert", "answer", "success", "from", "backup", "assert", "mock", "client", "models", "generate", "content", "call", "count"], "metadata": {"kind": "function", "chunk_index": "1", "has_docstring": "false", "last_modified": "1768185812.994584"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/e2e/test_server_refinement.py::module::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/e2e/test_server_refinement.py::module", "content": "\"\"\"API refinement tests using the real service (no sockets/TestClient).\"\"\"", "tokens": ["api", "refinement", "tests", "using", "the", "real", "service", "no", "sockets", "test", "client"], "metadata": {"type": "module_header"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/e2e/test_server_refinement.py::imports::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/e2e/test_server_refinement.py::module", "content": "from __future__ import annotations\nimport pytest\nfrom fastapi import HTTPException\nfrom knowcode.api import api\nfrom knowcode.service import KnowCodeService", "tokens": ["from", "future", "import", "annotations", "import", "pytest", "from", "fastapi", "import", "httpexception", "from", "knowcode", "api", "import", "api", "from", "knowcode", "service", "import", "know", "code", "service"], "metadata": {"type": "imports"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/e2e/test_server_refinement.py::service::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/e2e/test_server_refinement.py::service", "content": "def service() -> KnowCodeService\ndef service() -> KnowCodeService:\n    return KnowCodeService(store_path=\".\")", "tokens": ["def", "service", "know", "code", "service", "def", "service", "know", "code", "service", "return", "know", "code", "service", "store", "path"], "metadata": {"kind": "function", "has_docstring": "false", "last_modified": "1768185812.9945054"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/e2e/test_server_refinement.py::test_reload_endpoint::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/e2e/test_server_refinement.py::test_reload_endpoint", "content": "def test_reload_endpoint(service: KnowCodeService) -> None\ndef test_reload_endpoint(service: KnowCodeService) -> None:\n    resp = api.reload_store(service=service)\n    assert resp[\"status\"] == \"reloaded\"", "tokens": ["def", "test", "reload", "endpoint", "service", "know", "code", "service", "none", "def", "test", "reload", "endpoint", "service", "know", "code", "service", "none", "resp", "api", "reload", "store", "service", "service", "assert", "resp", "status", "reloaded"], "metadata": {"kind": "function", "has_docstring": "false", "last_modified": "1768185812.9945054"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/e2e/test_server_refinement.py::test_get_entity::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/e2e/test_server_refinement.py::test_get_entity", "content": "def test_get_entity(service: KnowCodeService) -> None\ndef test_get_entity(service: KnowCodeService) -> None:\n    results = api.search(q=\"GraphBuilder\", service=service)\n    assert len(results) > 0\n\n    entity_id = results[0][\"id\"]\n    details = api.get_entity(entity_id=entity_id, service=service)\n\n    assert details[\"id\"] == entity_id\n    assert \"source_code\" in details\n    assert \"location\" in details", "tokens": ["def", "test", "get", "entity", "service", "know", "code", "service", "none", "def", "test", "get", "entity", "service", "know", "code", "service", "none", "results", "api", "search", "graph", "builder", "service", "service", "assert", "len", "results", "entity", "id", "results", "id", "details", "api", "get", "entity", "entity", "id", "entity", "id", "service", "service", "assert", "details", "id", "entity", "id", "assert", "source", "code", "in", "details", "assert", "location", "in", "details"], "metadata": {"kind": "function", "has_docstring": "false", "last_modified": "1768185812.9945054"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/e2e/test_server_refinement.py::test_entity_not_found::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/e2e/test_server_refinement.py::test_entity_not_found", "content": "def test_entity_not_found(service: KnowCodeService) -> None\ndef test_entity_not_found(service: KnowCodeService) -> None:\n    with pytest.raises(HTTPException):\n        api.get_entity(entity_id=\"non_existent_id\", service=service)", "tokens": ["def", "test", "entity", "not", "found", "service", "know", "code", "service", "none", "def", "test", "entity", "not", "found", "service", "know", "code", "service", "none", "with", "pytest", "raises", "httpexception", "api", "get", "entity", "entity", "id", "non", "existent", "id", "service", "service"], "metadata": {"kind": "function", "has_docstring": "false", "last_modified": "1768185812.9945054"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/e2e/test_usecase2_ide_integration.py::module::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/e2e/test_usecase2_ide_integration.py::module", "content": "\"\"\"E2E test for Use-Case 2: IDE Agent Integration.\n\nSimulates the full workflow:\n1. IDE agent invokes retrieve_context_for_query via MCP\n2. KnowCode returns context bundle + sufficiency score\n3. High sufficiency \u2192 local answer (zero external tokens)\n4. Low sufficiency \u2192 LLM fallback\n\"\"\"", "tokens": ["e2e", "test", "for", "use", "case", "ide", "agent", "integration", "simulates", "the", "full", "workflow", "ide", "agent", "invokes", "retrieve", "context", "for", "query", "via", "mcp", "know", "code", "returns", "context", "bundle", "sufficiency", "score", "high", "sufficiency", "local", "answer", "zero", "external", "tokens", "low", "sufficiency", "llm", "fallback"], "metadata": {"type": "module_header"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/e2e/test_usecase2_ide_integration.py::imports::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/e2e/test_usecase2_ide_integration.py::module", "content": "from __future__ import annotations\nfrom pathlib import Path\nfrom unittest.mock import MagicMock\nfrom knowcode.config import AppConfig, ModelConfig\nfrom knowcode.data_models import TaskType\nfrom knowcode.llm.agent import Agent\nfrom knowcode.mcp.server import KnowCodeMCPServer\n    import json", "tokens": ["from", "future", "import", "annotations", "from", "pathlib", "import", "path", "from", "unittest", "mock", "import", "magic", "mock", "from", "knowcode", "config", "import", "app", "config", "model", "config", "from", "knowcode", "data", "models", "import", "task", "type", "from", "knowcode", "llm", "agent", "import", "agent", "from", "knowcode", "mcp", "server", "import", "know", "code", "mcpserver", "import", "json"], "metadata": {"type": "imports"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/e2e/test_usecase2_ide_integration.py::MockService::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/e2e/test_usecase2_ide_integration.py::MockService", "content": "\"\"\"Mock service simulating full retrieval pipeline.\"\"\"\nclass MockService:\n    \"\"\"Mock service simulating full retrieval pipeline.\"\"\"\n\n    def __init__(self, store_path: Path, sufficiency: float = 0.9) -> None:\n        self.store_path = store_path\n        self.sufficiency = sufficiency\n        self.retrieve_calls: list[str] = []\n\n    def retrieve_context_for_query(self, query: str, **kwargs):  # noqa: ANN001\n        self.retrieve_calls.append(query)\n        return {\n            \"query\": query,\n            \"task_type\": TaskType.EXPLAIN.value,\n            \"task_confidence\": 0.95,\n            \"retrieval_mode\": \"semantic\",\n            \"context_text\": f\"# Context for: {query}\\n\\ndef example_function():\\n    pass\",\n            \"total_tokens\": 50,\n            \"max_tokens\": kwargs.get(\"max_tokens\", 6000),\n            \"truncated\": False,\n            \"sufficiency_score\": self.sufficiency,\n            \"selected_entities\": [{\"entity_id\": \"e1\", \"sufficiency_score\": self.sufficiency}],\n            \"e", "tokens": ["mock", "service", "simulating", "full", "retrieval", "pipeline", "class", "mock", "service", "mock", "service", "simulating", "full", "retrieval", "pipeline", "def", "init", "self", "store", "path", "path", "sufficiency", "float", "none", "self", "store", "path", "store", "path", "self", "sufficiency", "sufficiency", "self", "retrieve", "calls", "list", "str", "def", "retrieve", "context", "for", "query", "self", "query", "str", "kwargs", "noqa", "ann001", "self", "retrieve", "calls", "append", "query", "return", "query", "query", "task", "type", "task", "type", "explain", "value", "task", "confidence", "95", "retrieval", "mode", "semantic", "context", "text", "context", "for", "query", "ndef", "example", "function", "pass", "total", "tokens", "50", "max", "tokens", "kwargs", "get", "max", "tokens", "6000", "truncated", "false", "sufficiency", "score", "self", "sufficiency", "selected", "entities", "entity", "id", "e1", "sufficiency", "score", "self", "sufficiency"], "metadata": {"kind": "class", "chunk_index": "0", "has_docstring": "true", "last_modified": "1768273179.7577543"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/e2e/test_usecase2_ide_integration.py::MockService::1", "entity_id": "/home/deeog/Desktop/KnowCode/tests/e2e/test_usecase2_ide_integration.py::MockService", "content": "   \"selected_entities\": [{\"entity_id\": \"e1\", \"sufficiency_score\": self.sufficiency}],\n            \"evidence\": [{\"rank\": 1, \"entity_id\": \"e1\", \"score\": 0.9}],\n            \"errors\": [],\n        }", "tokens": ["selected", "entities", "entity", "id", "e1", "sufficiency", "score", "self", "sufficiency", "evidence", "rank", "entity", "id", "e1", "score", "errors"], "metadata": {"kind": "class", "chunk_index": "1", "has_docstring": "true", "last_modified": "1768273179.7577543"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/e2e/test_usecase2_ide_integration.py::MockService.__init__::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/e2e/test_usecase2_ide_integration.py::MockService.__init__", "content": "def __init__(self, store_path: Path, sufficiency: float) -> None\n    def __init__(self, store_path: Path, sufficiency: float = 0.9) -> None:\n        self.store_path = store_path\n        self.sufficiency = sufficiency\n        self.retrieve_calls: list[str] = []", "tokens": ["def", "init", "self", "store", "path", "path", "sufficiency", "float", "none", "def", "init", "self", "store", "path", "path", "sufficiency", "float", "none", "self", "store", "path", "store", "path", "self", "sufficiency", "sufficiency", "self", "retrieve", "calls", "list", "str"], "metadata": {"kind": "method", "has_docstring": "false", "last_modified": "1768273179.7577543"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/e2e/test_usecase2_ide_integration.py::MockService.retrieve_context_for_query::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/e2e/test_usecase2_ide_integration.py::MockService.retrieve_context_for_query", "content": "def retrieve_context_for_query(self, query: str, **kwargs)\n    def retrieve_context_for_query(self, query: str, **kwargs):  # noqa: ANN001\n        self.retrieve_calls.append(query)\n        return {\n            \"query\": query,\n            \"task_type\": TaskType.EXPLAIN.value,\n            \"task_confidence\": 0.95,\n            \"retrieval_mode\": \"semantic\",\n            \"context_text\": f\"# Context for: {query}\\n\\ndef example_function():\\n    pass\",\n            \"total_tokens\": 50,\n            \"max_tokens\": kwargs.get(\"max_tokens\", 6000),\n            \"truncated\": False,\n            \"sufficiency_score\": self.sufficiency,\n            \"selected_entities\": [{\"entity_id\": \"e1\", \"sufficiency_score\": self.sufficiency}],\n            \"evidence\": [{\"rank\": 1, \"entity_id\": \"e1\", \"score\": 0.9}],\n            \"errors\": [],\n        }", "tokens": ["def", "retrieve", "context", "for", "query", "self", "query", "str", "kwargs", "def", "retrieve", "context", "for", "query", "self", "query", "str", "kwargs", "noqa", "ann001", "self", "retrieve", "calls", "append", "query", "return", "query", "query", "task", "type", "task", "type", "explain", "value", "task", "confidence", "95", "retrieval", "mode", "semantic", "context", "text", "context", "for", "query", "ndef", "example", "function", "pass", "total", "tokens", "50", "max", "tokens", "kwargs", "get", "max", "tokens", "6000", "truncated", "false", "sufficiency", "score", "self", "sufficiency", "selected", "entities", "entity", "id", "e1", "sufficiency", "score", "self", "sufficiency", "evidence", "rank", "entity", "id", "e1", "score", "errors"], "metadata": {"kind": "method", "has_docstring": "false", "last_modified": "1768273179.7577543"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/e2e/test_usecase2_ide_integration.py::test_usecase2_high_sufficiency_uses_local_answer::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/e2e/test_usecase2_ide_integration.py::test_usecase2_high_sufficiency_uses_local_answer", "content": "def test_usecase2_high_sufficiency_uses_local_answer(tmp_path: Path) -> None\n\"\"\"UC2 E2E: High sufficiency (>=0.8) should use local answer without LLM.\n\nVerifies that when context sufficiency is high, the agent returns\na local answer and does not call any external LLM.\"\"\"\ndef test_usecase2_high_sufficiency_uses_local_answer(tmp_path: Path) -> None:\n    \"\"\"UC2 E2E: High sufficiency (>=0.8) should use local answer without LLM.\n    \n    Verifies that when context sufficiency is high, the agent returns\n    a local answer and does not call any external LLM.\n    \"\"\"\n    # Setup: Create mock service with high sufficiency\n    mock_service = MockService(tmp_path, sufficiency=0.95)\n    config = AppConfig(\n        models=[ModelConfig(name=\"test-model\", provider=\"google\", api_key_env=\"TEST_KEY\")],\n        sufficiency_threshold=0.8,\n    )\n    \n    agent = Agent(mock_service, config)  # type: ignore[arg-type]\n    agent.rate_limiter = MagicMock()\n    agent.rate_limiter.check_availability.return_value ", "tokens": ["def", "test", "usecase2", "high", "sufficiency", "uses", "local", "answer", "tmp", "path", "path", "none", "uc2", "e2e", "high", "sufficiency", "should", "use", "local", "answer", "without", "llm", "verifies", "that", "when", "context", "sufficiency", "is", "high", "the", "agent", "returns", "local", "answer", "and", "does", "not", "call", "any", "external", "llm", "def", "test", "usecase2", "high", "sufficiency", "uses", "local", "answer", "tmp", "path", "path", "none", "uc2", "e2e", "high", "sufficiency", "should", "use", "local", "answer", "without", "llm", "verifies", "that", "when", "context", "sufficiency", "is", "high", "the", "agent", "returns", "local", "answer", "and", "does", "not", "call", "any", "external", "llm", "setup", "create", "mock", "service", "with", "high", "sufficiency", "mock", "service", "mock", "service", "tmp", "path", "sufficiency", "95", "config", "app", "config", "models", "model", "config", "name", "test", "model", "provider", "google", "api", "key", "env", "test", "key", "sufficiency", "threshold", "agent", "agent", "mock", "service", "config", "type", "ignore", "arg", "type", "agent", "rate", "limiter", "magic", "mock", "agent", "rate", "limiter", "check", "availability", "return", "value"], "metadata": {"kind": "function", "chunk_index": "0", "has_docstring": "true", "last_modified": "1768273179.7577543"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/e2e/test_usecase2_ide_integration.py::test_usecase2_high_sufficiency_uses_local_answer::1", "entity_id": "/home/deeog/Desktop/KnowCode/tests/e2e/test_usecase2_ide_integration.py::test_usecase2_high_sufficiency_uses_local_answer", "content": "g-type]\n    agent.rate_limiter = MagicMock()\n    agent.rate_limiter.check_availability.return_value = True\n    \n    # Track if LLM was called\n    llm_called = False\n    original_get_client = agent._get_client\n    def mock_get_client(cfg):\n        nonlocal llm_called\n        llm_called = True\n        return original_get_client(cfg)\n    agent._get_client = mock_get_client  # type: ignore[method-assign]\n    \n    # Execute: Call smart_answer (the local-first mode)\n    result = agent.smart_answer(\"Explain the Agent class\")\n    \n    # Verify: Should use local answer\n    assert result[\"source\"] == \"local\"\n    assert result[\"sufficiency_score\"] >= 0.8\n    assert not llm_called, \"LLM should NOT be called for high sufficiency\"\n    assert mock_service.retrieve_calls, \"Retrieval should be called\"", "tokens": ["type", "agent", "rate", "limiter", "magic", "mock", "agent", "rate", "limiter", "check", "availability", "return", "value", "true", "track", "if", "llm", "was", "called", "llm", "called", "false", "original", "get", "client", "agent", "get", "client", "def", "mock", "get", "client", "cfg", "nonlocal", "llm", "called", "llm", "called", "true", "return", "original", "get", "client", "cfg", "agent", "get", "client", "mock", "get", "client", "type", "ignore", "method", "assign", "execute", "call", "smart", "answer", "the", "local", "first", "mode", "result", "agent", "smart", "answer", "explain", "the", "agent", "class", "verify", "should", "use", "local", "answer", "assert", "result", "source", "local", "assert", "result", "sufficiency", "score", "assert", "not", "llm", "called", "llm", "should", "not", "be", "called", "for", "high", "sufficiency", "assert", "mock", "service", "retrieve", "calls", "retrieval", "should", "be", "called"], "metadata": {"kind": "function", "chunk_index": "1", "has_docstring": "true", "last_modified": "1768273179.7577543"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/e2e/test_usecase2_ide_integration.py::test_usecase2_low_sufficiency_triggers_llm::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/e2e/test_usecase2_ide_integration.py::test_usecase2_low_sufficiency_triggers_llm", "content": "def test_usecase2_low_sufficiency_triggers_llm(tmp_path: Path) -> None\n\"\"\"UC2 E2E: Low sufficiency (<0.8) should trigger LLM fallback.\n\nVerifies that when context sufficiency is below threshold,\nthe agent calls the external LLM with the retrieved context.\"\"\"\ndef test_usecase2_low_sufficiency_triggers_llm(tmp_path: Path) -> None:\n    \"\"\"UC2 E2E: Low sufficiency (<0.8) should trigger LLM fallback.\n    \n    Verifies that when context sufficiency is below threshold,\n    the agent calls the external LLM with the retrieved context.\n    \"\"\"\n    # Setup: Create mock service with low sufficiency\n    mock_service = MockService(tmp_path, sufficiency=0.5)\n    config = AppConfig(\n        models=[ModelConfig(name=\"test-model\", provider=\"google\", api_key_env=\"TEST_KEY\")],\n        sufficiency_threshold=0.8,\n    )\n    \n    agent = Agent(mock_service, config)  # type: ignore[arg-type]\n    agent.rate_limiter = MagicMock()\n    agent.rate_limiter.check_availability.return_value = True\n    \n    # Mock the a", "tokens": ["def", "test", "usecase2", "low", "sufficiency", "triggers", "llm", "tmp", "path", "path", "none", "uc2", "e2e", "low", "sufficiency", "should", "trigger", "llm", "fallback", "verifies", "that", "when", "context", "sufficiency", "is", "below", "threshold", "the", "agent", "calls", "the", "external", "llm", "with", "the", "retrieved", "context", "def", "test", "usecase2", "low", "sufficiency", "triggers", "llm", "tmp", "path", "path", "none", "uc2", "e2e", "low", "sufficiency", "should", "trigger", "llm", "fallback", "verifies", "that", "when", "context", "sufficiency", "is", "below", "threshold", "the", "agent", "calls", "the", "external", "llm", "with", "the", "retrieved", "context", "setup", "create", "mock", "service", "with", "low", "sufficiency", "mock", "service", "mock", "service", "tmp", "path", "sufficiency", "config", "app", "config", "models", "model", "config", "name", "test", "model", "provider", "google", "api", "key", "env", "test", "key", "sufficiency", "threshold", "agent", "agent", "mock", "service", "config", "type", "ignore", "arg", "type", "agent", "rate", "limiter", "magic", "mock", "agent", "rate", "limiter", "check", "availability", "return", "value", "true", "mock", "the"], "metadata": {"kind": "function", "chunk_index": "0", "has_docstring": "true", "last_modified": "1768273179.7577543"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/e2e/test_usecase2_ide_integration.py::test_usecase2_low_sufficiency_triggers_llm::1", "entity_id": "/home/deeog/Desktop/KnowCode/tests/e2e/test_usecase2_ide_integration.py::test_usecase2_low_sufficiency_triggers_llm", "content": "er = MagicMock()\n    agent.rate_limiter.check_availability.return_value = True\n    \n    # Mock the answer method to track calls\n    agent.answer = MagicMock(return_value=\"LLM generated answer\")  # type: ignore[method-assign]\n    \n    # Execute\n    result = agent.smart_answer(\"Explain complex architecture\")\n    \n    # Verify: Should use LLM\n    assert result[\"source\"] == \"llm\"\n    assert result[\"answer\"] == \"LLM generated answer\"\n    assert agent.answer.called, \"LLM should be called for low sufficiency\"", "tokens": ["er", "magic", "mock", "agent", "rate", "limiter", "check", "availability", "return", "value", "true", "mock", "the", "answer", "method", "to", "track", "calls", "agent", "answer", "magic", "mock", "return", "value", "llm", "generated", "answer", "type", "ignore", "method", "assign", "execute", "result", "agent", "smart", "answer", "explain", "complex", "architecture", "verify", "should", "use", "llm", "assert", "result", "source", "llm", "assert", "result", "answer", "llm", "generated", "answer", "assert", "agent", "answer", "called", "llm", "should", "be", "called", "for", "low", "sufficiency"], "metadata": {"kind": "function", "chunk_index": "1", "has_docstring": "true", "last_modified": "1768273179.7577543"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/e2e/test_usecase2_ide_integration.py::test_usecase2_mcp_tool_returns_sufficiency_score::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/e2e/test_usecase2_ide_integration.py::test_usecase2_mcp_tool_returns_sufficiency_score", "content": "def test_usecase2_mcp_tool_returns_sufficiency_score(tmp_path: Path) -> None\n\"\"\"UC2 E2E: MCP tool should return sufficiency score for IDE agent decisions.\n\nThis is the key contract between KnowCode and IDE agents:\nthe sufficiency_score allows agents to decide local vs LLM.\"\"\"\ndef test_usecase2_mcp_tool_returns_sufficiency_score(tmp_path: Path) -> None:\n    \"\"\"UC2 E2E: MCP tool should return sufficiency score for IDE agent decisions.\n    \n    This is the key contract between KnowCode and IDE agents:\n    the sufficiency_score allows agents to decide local vs LLM.\n    \"\"\"\n    import json\n    \n    # Create dummy store file\n    (tmp_path / \"knowcode_knowledge.json\").write_text(\"{}\")\n    \n    server = KnowCodeMCPServer(store_path=tmp_path)\n    mock_service = MockService(tmp_path, sufficiency=0.85)\n    server._ensure_service = lambda allow_missing_store=False: mock_service  # type: ignore[method-assign]\n    \n    # Simulate IDE agent calling retrieve_context_for_query\n    result = json.loads(\n", "tokens": ["def", "test", "usecase2", "mcp", "tool", "returns", "sufficiency", "score", "tmp", "path", "path", "none", "uc2", "e2e", "mcp", "tool", "should", "return", "sufficiency", "score", "for", "ide", "agent", "decisions", "this", "is", "the", "key", "contract", "between", "know", "code", "and", "ide", "agents", "the", "sufficiency", "score", "allows", "agents", "to", "decide", "local", "vs", "llm", "def", "test", "usecase2", "mcp", "tool", "returns", "sufficiency", "score", "tmp", "path", "path", "none", "uc2", "e2e", "mcp", "tool", "should", "return", "sufficiency", "score", "for", "ide", "agent", "decisions", "this", "is", "the", "key", "contract", "between", "know", "code", "and", "ide", "agents", "the", "sufficiency", "score", "allows", "agents", "to", "decide", "local", "vs", "llm", "import", "json", "create", "dummy", "store", "file", "tmp", "path", "knowcode", "knowledge", "json", "write", "text", "server", "know", "code", "mcpserver", "store", "path", "tmp", "path", "mock", "service", "mock", "service", "tmp", "path", "sufficiency", "85", "server", "ensure", "service", "lambda", "allow", "missing", "store", "false", "mock", "service", "type", "ignore", "method", "assign", "simulate", "ide", "agent", "calling", "retrieve", "context", "for", "query", "result", "json", "loads"], "metadata": {"kind": "function", "chunk_index": "0", "has_docstring": "true", "last_modified": "1768273179.7577543"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/e2e/test_usecase2_ide_integration.py::test_usecase2_mcp_tool_returns_sufficiency_score::1", "entity_id": "/home/deeog/Desktop/KnowCode/tests/e2e/test_usecase2_ide_integration.py::test_usecase2_mcp_tool_returns_sufficiency_score", "content": "d-assign]\n    \n    # Simulate IDE agent calling retrieve_context_for_query\n    result = json.loads(\n        server.handle_tool_call(\n            \"retrieve_context_for_query\",\n            {\"query\": \"How does auth work?\", \"task_type\": \"auto\", \"max_tokens\": 4000},\n        )\n    )\n    \n    # Verify: Response must include sufficiency_score for IDE agent\n    assert \"sufficiency_score\" in result, \"Response MUST include sufficiency_score\"\n    assert 0.0 <= result[\"sufficiency_score\"] <= 1.0\n    assert \"context_text\" in result\n    assert \"task_type\" in result\n    assert result[\"sufficiency_score\"] == 0.85", "tokens": ["assign", "simulate", "ide", "agent", "calling", "retrieve", "context", "for", "query", "result", "json", "loads", "server", "handle", "tool", "call", "retrieve", "context", "for", "query", "query", "how", "does", "auth", "work", "task", "type", "auto", "max", "tokens", "4000", "verify", "response", "must", "include", "sufficiency", "score", "for", "ide", "agent", "assert", "sufficiency", "score", "in", "result", "response", "must", "include", "sufficiency", "score", "assert", "result", "sufficiency", "score", "assert", "context", "text", "in", "result", "assert", "task", "type", "in", "result", "assert", "result", "sufficiency", "score", "85"], "metadata": {"kind": "function", "chunk_index": "1", "has_docstring": "true", "last_modified": "1768273179.7577543"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/e2e/test_usecase2_ide_integration.py::test_usecase2_graceful_degradation_on_empty_context::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/e2e/test_usecase2_ide_integration.py::test_usecase2_graceful_degradation_on_empty_context", "content": "def test_usecase2_graceful_degradation_on_empty_context(tmp_path: Path) -> None\n\"\"\"UC2 E2E: Empty context should result in low sufficiency \u2192 LLM fallback.\n\nEven when no entities are found, the system should gracefully\ndegrade by returning zero sufficiency, prompting LLM usage.\"\"\"\ndef test_usecase2_graceful_degradation_on_empty_context(tmp_path: Path) -> None:\n    \"\"\"UC2 E2E: Empty context should result in low sufficiency \u2192 LLM fallback.\n    \n    Even when no entities are found, the system should gracefully\n    degrade by returning zero sufficiency, prompting LLM usage.\n    \"\"\"\n    # Setup: Mock service with empty context\n    mock_service = MockService(tmp_path, sufficiency=0.0)\n    mock_service.retrieve_context_for_query = lambda q, **kw: {  # type: ignore[method-assign]\n        \"query\": q,\n        \"task_type\": TaskType.GENERAL.value,\n        \"task_confidence\": 0.0,\n        \"retrieval_mode\": \"none\",\n        \"context_text\": \"\",\n        \"total_tokens\": 0,\n        \"max_tokens\": kw.get(\"ma", "tokens": ["def", "test", "usecase2", "graceful", "degradation", "on", "empty", "context", "tmp", "path", "path", "none", "uc2", "e2e", "empty", "context", "should", "result", "in", "low", "sufficiency", "llm", "fallback", "even", "when", "no", "entities", "are", "found", "the", "system", "should", "gracefully", "degrade", "by", "returning", "zero", "sufficiency", "prompting", "llm", "usage", "def", "test", "usecase2", "graceful", "degradation", "on", "empty", "context", "tmp", "path", "path", "none", "uc2", "e2e", "empty", "context", "should", "result", "in", "low", "sufficiency", "llm", "fallback", "even", "when", "no", "entities", "are", "found", "the", "system", "should", "gracefully", "degrade", "by", "returning", "zero", "sufficiency", "prompting", "llm", "usage", "setup", "mock", "service", "with", "empty", "context", "mock", "service", "mock", "service", "tmp", "path", "sufficiency", "mock", "service", "retrieve", "context", "for", "query", "lambda", "kw", "type", "ignore", "method", "assign", "query", "task", "type", "task", "type", "general", "value", "task", "confidence", "retrieval", "mode", "none", "context", "text", "total", "tokens", "max", "tokens", "kw", "get", "ma"], "metadata": {"kind": "function", "chunk_index": "0", "has_docstring": "true", "last_modified": "1768273179.7577543"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/e2e/test_usecase2_ide_integration.py::test_usecase2_graceful_degradation_on_empty_context::1", "entity_id": "/home/deeog/Desktop/KnowCode/tests/e2e/test_usecase2_ide_integration.py::test_usecase2_graceful_degradation_on_empty_context", "content": "de\": \"none\",\n        \"context_text\": \"\",\n        \"total_tokens\": 0,\n        \"max_tokens\": kw.get(\"max_tokens\", 6000),\n        \"truncated\": False,\n        \"sufficiency_score\": 0.0,\n        \"selected_entities\": [],\n        \"evidence\": [],\n        \"errors\": [\"No matching entities found\"],\n    }\n    \n    config = AppConfig(\n        models=[ModelConfig(name=\"test-model\", provider=\"google\", api_key_env=\"TEST_KEY\")],\n        sufficiency_threshold=0.8,\n    )\n    \n    agent = Agent(mock_service, config)  # type: ignore[arg-type]\n    agent.rate_limiter = MagicMock()\n    agent.rate_limiter.check_availability.return_value = True\n    agent.answer = MagicMock(return_value=\"General guidance\")  # type: ignore[method-assign]\n    \n    # Execute\n    result = agent.smart_answer(\"What is foo?\")\n    \n    # Verify: Should fall back to LLM due to zero sufficiency\n    assert result[\"source\"] == \"llm\"\n    assert result[\"sufficiency_score\"] == 0.0", "tokens": ["de", "none", "context", "text", "total", "tokens", "max", "tokens", "kw", "get", "max", "tokens", "6000", "truncated", "false", "sufficiency", "score", "selected", "entities", "evidence", "errors", "no", "matching", "entities", "found", "config", "app", "config", "models", "model", "config", "name", "test", "model", "provider", "google", "api", "key", "env", "test", "key", "sufficiency", "threshold", "agent", "agent", "mock", "service", "config", "type", "ignore", "arg", "type", "agent", "rate", "limiter", "magic", "mock", "agent", "rate", "limiter", "check", "availability", "return", "value", "true", "agent", "answer", "magic", "mock", "return", "value", "general", "guidance", "type", "ignore", "method", "assign", "execute", "result", "agent", "smart", "answer", "what", "is", "foo", "verify", "should", "fall", "back", "to", "llm", "due", "to", "zero", "sufficiency", "assert", "result", "source", "llm", "assert", "result", "sufficiency", "score"], "metadata": {"kind": "function", "chunk_index": "1", "has_docstring": "true", "last_modified": "1768273179.7577543"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/integration/test_v2_1_integration.py::module::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/integration/test_v2_1_integration.py::module", "content": "\"\"\"Integration tests for v2.1 search pipeline.\"\"\"", "tokens": ["integration", "tests", "for", "v2", "search", "pipeline"], "metadata": {"type": "module_header"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/integration/test_v2_1_integration.py::imports::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/integration/test_v2_1_integration.py::module", "content": "from unittest.mock import MagicMock\nfrom knowcode.data_models import EmbeddingConfig\nfrom knowcode.llm.embedding import EmbeddingProvider\nfrom knowcode.indexing.indexer import Indexer\nfrom knowcode.storage.chunk_repository import InMemoryChunkRepository\nfrom knowcode.storage.vector_store import VectorStore\nfrom knowcode.retrieval.hybrid_index import HybridIndex\nfrom knowcode.retrieval.search_engine import SearchEngine\n    from knowcode.models import CodeChunk", "tokens": ["from", "unittest", "mock", "import", "magic", "mock", "from", "knowcode", "data", "models", "import", "embedding", "config", "from", "knowcode", "llm", "embedding", "import", "embedding", "provider", "from", "knowcode", "indexing", "indexer", "import", "indexer", "from", "knowcode", "storage", "chunk", "repository", "import", "in", "memory", "chunk", "repository", "from", "knowcode", "storage", "vector", "store", "import", "vector", "store", "from", "knowcode", "retrieval", "hybrid", "index", "import", "hybrid", "index", "from", "knowcode", "retrieval", "search", "engine", "import", "search", "engine", "from", "knowcode", "models", "import", "code", "chunk"], "metadata": {"type": "imports"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/integration/test_v2_1_integration.py::MockEmbeddingProvider::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/integration/test_v2_1_integration.py::MockEmbeddingProvider", "content": "class MockEmbeddingProvider(EmbeddingProvider):\n    def embed(self, texts: list[str]) -> list[list[float]]:\n        # Return dummy vectors of correct dimension\n        return [[0.1] * self.config.dimension for _ in texts]\n        \n    def embed_single(self, text: str) -> list[float]:\n        return [0.1] * self.config.dimension", "tokens": ["class", "mock", "embedding", "provider", "embedding", "provider", "def", "embed", "self", "texts", "list", "str", "list", "list", "float", "return", "dummy", "vectors", "of", "correct", "dimension", "return", "self", "config", "dimension", "for", "in", "texts", "def", "embed", "single", "self", "text", "str", "list", "float", "return", "self", "config", "dimension"], "metadata": {"kind": "class", "has_docstring": "false", "last_modified": "1768185812.994584"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/integration/test_v2_1_integration.py::MockEmbeddingProvider.embed::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/integration/test_v2_1_integration.py::MockEmbeddingProvider.embed", "content": "def embed(self, texts: list[str]) -> list[list[float]]\n    def embed(self, texts: list[str]) -> list[list[float]]:\n        # Return dummy vectors of correct dimension\n        return [[0.1] * self.config.dimension for _ in texts]", "tokens": ["def", "embed", "self", "texts", "list", "str", "list", "list", "float", "def", "embed", "self", "texts", "list", "str", "list", "list", "float", "return", "dummy", "vectors", "of", "correct", "dimension", "return", "self", "config", "dimension", "for", "in", "texts"], "metadata": {"kind": "method", "has_docstring": "false", "last_modified": "1768185812.994584"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/integration/test_v2_1_integration.py::MockEmbeddingProvider.embed_single::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/integration/test_v2_1_integration.py::MockEmbeddingProvider.embed_single", "content": "def embed_single(self, text: str) -> list[float]\n    def embed_single(self, text: str) -> list[float]:\n        return [0.1] * self.config.dimension", "tokens": ["def", "embed", "single", "self", "text", "str", "list", "float", "def", "embed", "single", "self", "text", "str", "list", "float", "return", "self", "config", "dimension"], "metadata": {"kind": "method", "has_docstring": "false", "last_modified": "1768185812.994584"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/integration/test_v2_1_integration.py::test_indexer_flow::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/integration/test_v2_1_integration.py::test_indexer_flow", "content": "def test_indexer_flow(tmp_path)\ndef test_indexer_flow(tmp_path):\n    config = EmbeddingConfig(dimension=8)\n    provider = MockEmbeddingProvider(config)\n    repo = InMemoryChunkRepository()\n    vs = VectorStore(dimension=8)\n    \n    indexer = Indexer(provider, chunk_repo=repo, vector_store=vs)\n    \n    # Mock a file content or create one\n    test_file = tmp_path / \"test.py\"\n    test_file.write_text(\"def my_func():\\n    pass\")\n    \n    # We need to mock GraphBuilder._parse_file or use real one\n    # For integration test, we use the real one if possible, but it depends on scanner.\n    # Let's mock index_file's internal parsing call if needed, but here we'll just test the orchestration\n    \n    count = indexer.index_file(test_file)\n    assert count > 0\n    assert len(repo._chunks) > 0\n    assert vs.index.ntotal > 0", "tokens": ["def", "test", "indexer", "flow", "tmp", "path", "def", "test", "indexer", "flow", "tmp", "path", "config", "embedding", "config", "dimension", "provider", "mock", "embedding", "provider", "config", "repo", "in", "memory", "chunk", "repository", "vs", "vector", "store", "dimension", "indexer", "indexer", "provider", "chunk", "repo", "repo", "vector", "store", "vs", "mock", "file", "content", "or", "create", "one", "test", "file", "tmp", "path", "test", "py", "test", "file", "write", "text", "def", "my", "func", "pass", "we", "need", "to", "mock", "graph", "builder", "parse", "file", "or", "use", "real", "one", "for", "integration", "test", "we", "use", "the", "real", "one", "if", "possible", "but", "it", "depends", "on", "scanner", "let", "mock", "index", "file", "internal", "parsing", "call", "if", "needed", "but", "here", "we", "ll", "just", "test", "the", "orchestration", "count", "indexer", "index", "file", "test", "file", "assert", "count", "assert", "len", "repo", "chunks", "assert", "vs", "index", "ntotal"], "metadata": {"kind": "function", "has_docstring": "false", "last_modified": "1768185812.994584"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/integration/test_v2_1_integration.py::test_search_engine_orchestration::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/integration/test_v2_1_integration.py::test_search_engine_orchestration", "content": "def test_search_engine_orchestration()\ndef test_search_engine_orchestration():\n    config = EmbeddingConfig(dimension=8)\n    provider = MockEmbeddingProvider(config)\n    repo = InMemoryChunkRepository()\n    vs = VectorStore(dimension=8)\n    \n    # Add a chunk\n    from knowcode.models import CodeChunk\n    chunk = CodeChunk(id=\"c1\", entity_id=\"e1\", content=\"find me\", tokens=[\"find\", \"me\"])\n    repo.add(chunk)\n    vs.add(\"c1\", [0.1]*8)\n    \n    hybrid = HybridIndex(repo, vs)\n    # Generic KnowledgeStore mock\n    ks = MagicMock()\n    ks.get_callees.return_value = []\n    \n    engine = SearchEngine(repo, provider, hybrid, ks)\n    results = engine.search(\"find me\", limit=1, expand_deps=False)\n    \n    assert len(results) == 1\n    assert results[0].id == \"c1\"", "tokens": ["def", "test", "search", "engine", "orchestration", "def", "test", "search", "engine", "orchestration", "config", "embedding", "config", "dimension", "provider", "mock", "embedding", "provider", "config", "repo", "in", "memory", "chunk", "repository", "vs", "vector", "store", "dimension", "add", "chunk", "from", "knowcode", "models", "import", "code", "chunk", "chunk", "code", "chunk", "id", "c1", "entity", "id", "e1", "content", "find", "me", "tokens", "find", "me", "repo", "add", "chunk", "vs", "add", "c1", "hybrid", "hybrid", "index", "repo", "vs", "generic", "knowledge", "store", "mock", "ks", "magic", "mock", "ks", "get", "callees", "return", "value", "engine", "search", "engine", "repo", "provider", "hybrid", "ks", "results", "engine", "search", "find", "me", "limit", "expand", "deps", "false", "assert", "len", "results", "assert", "results", "id", "c1"], "metadata": {"kind": "function", "has_docstring": "false", "last_modified": "1768185812.994584"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/integration/test_full_flow.py::module::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/integration/test_full_flow.py::module", "content": "\"\"\"End-to-End Search Pipeline Test.\"\"\"", "tokens": ["end", "to", "end", "search", "pipeline", "test"], "metadata": {"type": "module_header"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/integration/test_full_flow.py::imports::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/integration/test_full_flow.py::module", "content": "from knowcode.indexing.indexer import Indexer\nfrom knowcode.retrieval.search_engine import SearchEngine\nfrom knowcode.llm.embedding import OpenAIEmbeddingProvider\nfrom knowcode.data_models import EmbeddingConfig\nfrom knowcode.retrieval.hybrid_index import HybridIndex\nfrom knowcode.storage.chunk_repository import InMemoryChunkRepository\nfrom knowcode.storage.vector_store import VectorStore", "tokens": ["from", "knowcode", "indexing", "indexer", "import", "indexer", "from", "knowcode", "retrieval", "search", "engine", "import", "search", "engine", "from", "knowcode", "llm", "embedding", "import", "open", "aiembedding", "provider", "from", "knowcode", "data", "models", "import", "embedding", "config", "from", "knowcode", "retrieval", "hybrid", "index", "import", "hybrid", "index", "from", "knowcode", "storage", "chunk", "repository", "import", "in", "memory", "chunk", "repository", "from", "knowcode", "storage", "vector", "store", "import", "vector", "store"], "metadata": {"type": "imports"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/integration/test_full_flow.py::MockEmbeddingProvider::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/integration/test_full_flow.py::MockEmbeddingProvider", "content": "class MockEmbeddingProvider(OpenAIEmbeddingProvider):\n    def __init__(self):\n        self.config = EmbeddingConfig(dimension=8)\n        \n    def embed(self, texts: list[str]) -> list[list[float]]:\n        # Deterministic dummy embedding\n        return [[0.1] * 8 for _ in texts]\n        \n    def embed_single(self, text: str) -> list[float]:\n        return [0.1] * 8", "tokens": ["class", "mock", "embedding", "provider", "open", "aiembedding", "provider", "def", "init", "self", "self", "config", "embedding", "config", "dimension", "def", "embed", "self", "texts", "list", "str", "list", "list", "float", "deterministic", "dummy", "embedding", "return", "for", "in", "texts", "def", "embed", "single", "self", "text", "str", "list", "float", "return"], "metadata": {"kind": "class", "has_docstring": "false", "last_modified": "1768185812.994584"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/integration/test_full_flow.py::MockEmbeddingProvider.__init__::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/integration/test_full_flow.py::MockEmbeddingProvider.__init__", "content": "def __init__(self)\n    def __init__(self):\n        self.config = EmbeddingConfig(dimension=8)", "tokens": ["def", "init", "self", "def", "init", "self", "self", "config", "embedding", "config", "dimension"], "metadata": {"kind": "method", "has_docstring": "false", "last_modified": "1768185812.994584"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/integration/test_full_flow.py::MockEmbeddingProvider.embed::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/integration/test_full_flow.py::MockEmbeddingProvider.embed", "content": "def embed(self, texts: list[str]) -> list[list[float]]\n    def embed(self, texts: list[str]) -> list[list[float]]:\n        # Deterministic dummy embedding\n        return [[0.1] * 8 for _ in texts]", "tokens": ["def", "embed", "self", "texts", "list", "str", "list", "list", "float", "def", "embed", "self", "texts", "list", "str", "list", "list", "float", "deterministic", "dummy", "embedding", "return", "for", "in", "texts"], "metadata": {"kind": "method", "has_docstring": "false", "last_modified": "1768185812.994584"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/integration/test_full_flow.py::MockEmbeddingProvider.embed_single::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/integration/test_full_flow.py::MockEmbeddingProvider.embed_single", "content": "def embed_single(self, text: str) -> list[float]\n    def embed_single(self, text: str) -> list[float]:\n        return [0.1] * 8", "tokens": ["def", "embed", "single", "self", "text", "str", "list", "float", "def", "embed", "single", "self", "text", "str", "list", "float", "return"], "metadata": {"kind": "method", "has_docstring": "false", "last_modified": "1768185812.994584"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/integration/test_full_flow.py::test_full_search_flow::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/integration/test_full_flow.py::test_full_search_flow", "content": "def test_full_search_flow(tmp_path)\n\"\"\"Test full pipeline: Indexing -> Search -> Results.\"\"\"\ndef test_full_search_flow(tmp_path):\n    \"\"\"Test full pipeline: Indexing -> Search -> Results.\"\"\"\n    # 1. Setup\n    repo = InMemoryChunkRepository()\n    vs = VectorStore(dimension=8)\n    provider = MockEmbeddingProvider()\n    \n    indexer = Indexer(provider, chunk_repo=repo, vector_store=vs)\n    \n    # 2. Create content\n    f1 = tmp_path / \"app.py\"\n    f1.write_text(\"\"\"\ndef calculate_metrics(data):\n    '''Calculate important business metrics.'''\n    return data * 2\n\"\"\")\n    \n    # 3. Index\n    indexer.index_file(f1)\n    \n    # 4. Search\n    hybrid = HybridIndex(repo, vs)\n    # Mock knowledge store for dependency expansion\n    class MockStore:\n        def get_callers(self, _): return []\n        def get_callees(self, _): return []\n\n    engine = SearchEngine(repo, provider, hybrid, MockStore())\n    \n    results = engine.search(\"metrics\", limit=5)\n    \n    # 5. Verify\n    assert len(results) > 0\n ", "tokens": ["def", "test", "full", "search", "flow", "tmp", "path", "test", "full", "pipeline", "indexing", "search", "results", "def", "test", "full", "search", "flow", "tmp", "path", "test", "full", "pipeline", "indexing", "search", "results", "setup", "repo", "in", "memory", "chunk", "repository", "vs", "vector", "store", "dimension", "provider", "mock", "embedding", "provider", "indexer", "indexer", "provider", "chunk", "repo", "repo", "vector", "store", "vs", "create", "content", "f1", "tmp", "path", "app", "py", "f1", "write", "text", "def", "calculate", "metrics", "data", "calculate", "important", "business", "metrics", "return", "data", "index", "indexer", "index", "file", "f1", "search", "hybrid", "hybrid", "index", "repo", "vs", "mock", "knowledge", "store", "for", "dependency", "expansion", "class", "mock", "store", "def", "get", "callers", "self", "return", "def", "get", "callees", "self", "return", "engine", "search", "engine", "repo", "provider", "hybrid", "mock", "store", "results", "engine", "search", "metrics", "limit", "verify", "assert", "len", "results"], "metadata": {"kind": "function", "chunk_index": "0", "has_docstring": "true", "last_modified": "1768185812.994584"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/integration/test_full_flow.py::test_full_search_flow::1", "entity_id": "/home/deeog/Desktop/KnowCode/tests/integration/test_full_flow.py::test_full_search_flow", "content": " \n    results = engine.search(\"metrics\", limit=5)\n    \n    # 5. Verify\n    assert len(results) > 0\n    assert \"calculate_metrics\" in results[0].content", "tokens": ["results", "engine", "search", "metrics", "limit", "verify", "assert", "len", "results", "assert", "calculate", "metrics", "in", "results", "content"], "metadata": {"kind": "function", "chunk_index": "1", "has_docstring": "true", "last_modified": "1768185812.994584"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/retrieval/test_search_engine.py::module::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/retrieval/test_search_engine.py::module", "content": "\"\"\"Unit tests for search engine dependency expansion.\"\"\"", "tokens": ["unit", "tests", "for", "search", "engine", "dependency", "expansion"], "metadata": {"type": "module_header"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/retrieval/test_search_engine.py::imports::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/retrieval/test_search_engine.py::module", "content": "from knowcode.data_models import CodeChunk, Entity, EntityKind, Location, Relationship, RelationshipKind\nfrom knowcode.retrieval.search_engine import SearchEngine\nfrom knowcode.storage.chunk_repository import InMemoryChunkRepository\nfrom knowcode.storage.knowledge_store import KnowledgeStore", "tokens": ["from", "knowcode", "data", "models", "import", "code", "chunk", "entity", "entity", "kind", "location", "relationship", "relationship", "kind", "from", "knowcode", "retrieval", "search", "engine", "import", "search", "engine", "from", "knowcode", "storage", "chunk", "repository", "import", "in", "memory", "chunk", "repository", "from", "knowcode", "storage", "knowledge", "store", "import", "knowledge", "store"], "metadata": {"type": "imports"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/retrieval/test_search_engine.py::DummyEmbeddingProvider::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/retrieval/test_search_engine.py::DummyEmbeddingProvider", "content": "class DummyEmbeddingProvider:\n    def embed_single(self, _text):\n        return [0.0]", "tokens": ["class", "dummy", "embedding", "provider", "def", "embed", "single", "self", "text", "return"], "metadata": {"kind": "class", "has_docstring": "false", "last_modified": "1766236633.3726954"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/retrieval/test_search_engine.py::DummyEmbeddingProvider.embed_single::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/retrieval/test_search_engine.py::DummyEmbeddingProvider.embed_single", "content": "def embed_single(self, _text)\n    def embed_single(self, _text):\n        return [0.0]", "tokens": ["def", "embed", "single", "self", "text", "def", "embed", "single", "self", "text", "return"], "metadata": {"kind": "method", "has_docstring": "false", "last_modified": "1766236633.3726954"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/retrieval/test_search_engine.py::StubHybridIndex::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/retrieval/test_search_engine.py::StubHybridIndex", "content": "class StubHybridIndex:\n    def __init__(self, results):\n        self._results = results\n\n    def search(self, _query, _embedding, limit=10):\n        return self._results[:limit]", "tokens": ["class", "stub", "hybrid", "index", "def", "init", "self", "results", "self", "results", "results", "def", "search", "self", "query", "embedding", "limit", "10", "return", "self", "results", "limit"], "metadata": {"kind": "class", "has_docstring": "false", "last_modified": "1766236633.3726954"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/retrieval/test_search_engine.py::StubHybridIndex.__init__::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/retrieval/test_search_engine.py::StubHybridIndex.__init__", "content": "def __init__(self, results)\n    def __init__(self, results):\n        self._results = results", "tokens": ["def", "init", "self", "results", "def", "init", "self", "results", "self", "results", "results"], "metadata": {"kind": "method", "has_docstring": "false", "last_modified": "1766236633.3726954"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/retrieval/test_search_engine.py::StubHybridIndex.search::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/retrieval/test_search_engine.py::StubHybridIndex.search", "content": "def search(self, _query, _embedding, limit)\n    def search(self, _query, _embedding, limit=10):\n        return self._results[:limit]", "tokens": ["def", "search", "self", "query", "embedding", "limit", "def", "search", "self", "query", "embedding", "limit", "10", "return", "self", "results", "limit"], "metadata": {"kind": "method", "has_docstring": "false", "last_modified": "1766236633.3726954"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/retrieval/test_search_engine.py::test_search_engine_expands_dependencies::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/retrieval/test_search_engine.py::test_search_engine_expands_dependencies", "content": "def test_search_engine_expands_dependencies() -> None\n\"\"\"Search should expand callees into the result set.\"\"\"\ndef test_search_engine_expands_dependencies() -> None:\n    \"\"\"Search should expand callees into the result set.\"\"\"\n    repo = InMemoryChunkRepository()\n    chunk_a = CodeChunk(id=\"c1\", entity_id=\"e1\", content=\"A\", tokens=[\"a\"])\n    chunk_b = CodeChunk(id=\"c2\", entity_id=\"e2\", content=\"B\", tokens=[\"b\"])\n    repo.add(chunk_a)\n    repo.add(chunk_b)\n\n    store = KnowledgeStore()\n    entity_a = Entity(\n        id=\"e1\",\n        kind=EntityKind.FUNCTION,\n        name=\"a\",\n        qualified_name=\"a\",\n        location=Location(\"file.py\", 1, 1),\n    )\n    entity_b = Entity(\n        id=\"e2\",\n        kind=EntityKind.FUNCTION,\n        name=\"b\",\n        qualified_name=\"b\",\n        location=Location(\"file.py\", 2, 2),\n    )\n    store.entities = {entity_a.id: entity_a, entity_b.id: entity_b}\n    store.relationships = [\n        Relationship(\n            source_id=entity_a.id,\n            target_", "tokens": ["def", "test", "search", "engine", "expands", "dependencies", "none", "search", "should", "expand", "callees", "into", "the", "result", "set", "def", "test", "search", "engine", "expands", "dependencies", "none", "search", "should", "expand", "callees", "into", "the", "result", "set", "repo", "in", "memory", "chunk", "repository", "chunk", "code", "chunk", "id", "c1", "entity", "id", "e1", "content", "tokens", "chunk", "code", "chunk", "id", "c2", "entity", "id", "e2", "content", "tokens", "repo", "add", "chunk", "repo", "add", "chunk", "store", "knowledge", "store", "entity", "entity", "id", "e1", "kind", "entity", "kind", "function", "name", "qualified", "name", "location", "location", "file", "py", "entity", "entity", "id", "e2", "kind", "entity", "kind", "function", "name", "qualified", "name", "location", "location", "file", "py", "store", "entities", "entity", "id", "entity", "entity", "id", "entity", "store", "relationships", "relationship", "source", "id", "entity", "id", "target"], "metadata": {"kind": "function", "chunk_index": "0", "has_docstring": "true", "last_modified": "1766236633.3726954"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/retrieval/test_search_engine.py::test_search_engine_expands_dependencies::1", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/retrieval/test_search_engine.py::test_search_engine_expands_dependencies", "content": "store.relationships = [\n        Relationship(\n            source_id=entity_a.id,\n            target_id=entity_b.id,\n            kind=RelationshipKind.CALLS,\n        )\n    ]\n\n    hybrid = StubHybridIndex([(chunk_a, 1.0)])\n    engine = SearchEngine(repo, DummyEmbeddingProvider(), hybrid, store)\n\n    results = engine.search(\"a\", limit=1, expand_deps=True)\n    ids = {c.id for c in results}\n\n    assert {\"c1\", \"c2\"} <= ids", "tokens": ["store", "relationships", "relationship", "source", "id", "entity", "id", "target", "id", "entity", "id", "kind", "relationship", "kind", "calls", "hybrid", "stub", "hybrid", "index", "chunk", "engine", "search", "engine", "repo", "dummy", "embedding", "provider", "hybrid", "store", "results", "engine", "search", "limit", "expand", "deps", "true", "ids", "id", "for", "in", "results", "assert", "c1", "c2", "ids"], "metadata": {"kind": "function", "chunk_index": "1", "has_docstring": "true", "last_modified": "1766236633.3726954"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/retrieval/test_hybrid_index.py::module::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/retrieval/test_hybrid_index.py::module", "content": "\"\"\"Unit tests for hybrid retrieval scoring.\"\"\"", "tokens": ["unit", "tests", "for", "hybrid", "retrieval", "scoring"], "metadata": {"type": "module_header"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/retrieval/test_hybrid_index.py::imports::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/retrieval/test_hybrid_index.py::module", "content": "from knowcode.data_models import CodeChunk\nfrom knowcode.retrieval.hybrid_index import HybridIndex", "tokens": ["from", "knowcode", "data", "models", "import", "code", "chunk", "from", "knowcode", "retrieval", "hybrid", "index", "import", "hybrid", "index"], "metadata": {"type": "imports"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/retrieval/test_hybrid_index.py::StubRepo::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/retrieval/test_hybrid_index.py::StubRepo", "content": "class StubRepo:\n    def __init__(self, chunks):\n        self._chunks = {c.id: c for c in chunks}\n        self._sparse = chunks\n\n    def search_by_tokens(self, _tokens, limit=10):\n        return self._sparse[:limit]\n\n    def get(self, chunk_id):\n        return self._chunks.get(chunk_id)", "tokens": ["class", "stub", "repo", "def", "init", "self", "chunks", "self", "chunks", "id", "for", "in", "chunks", "self", "sparse", "chunks", "def", "search", "by", "tokens", "self", "tokens", "limit", "10", "return", "self", "sparse", "limit", "def", "get", "self", "chunk", "id", "return", "self", "chunks", "get", "chunk", "id"], "metadata": {"kind": "class", "has_docstring": "false", "last_modified": "1766236633.3726954"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/retrieval/test_hybrid_index.py::StubRepo.__init__::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/retrieval/test_hybrid_index.py::StubRepo.__init__", "content": "def __init__(self, chunks)\n    def __init__(self, chunks):\n        self._chunks = {c.id: c for c in chunks}\n        self._sparse = chunks", "tokens": ["def", "init", "self", "chunks", "def", "init", "self", "chunks", "self", "chunks", "id", "for", "in", "chunks", "self", "sparse", "chunks"], "metadata": {"kind": "method", "has_docstring": "false", "last_modified": "1766236633.3726954"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/retrieval/test_hybrid_index.py::StubRepo.search_by_tokens::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/retrieval/test_hybrid_index.py::StubRepo.search_by_tokens", "content": "def search_by_tokens(self, _tokens, limit)\n    def search_by_tokens(self, _tokens, limit=10):\n        return self._sparse[:limit]", "tokens": ["def", "search", "by", "tokens", "self", "tokens", "limit", "def", "search", "by", "tokens", "self", "tokens", "limit", "10", "return", "self", "sparse", "limit"], "metadata": {"kind": "method", "has_docstring": "false", "last_modified": "1766236633.3726954"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/retrieval/test_hybrid_index.py::StubRepo.get::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/retrieval/test_hybrid_index.py::StubRepo.get", "content": "def get(self, chunk_id)\n    def get(self, chunk_id):\n        return self._chunks.get(chunk_id)", "tokens": ["def", "get", "self", "chunk", "id", "def", "get", "self", "chunk", "id", "return", "self", "chunks", "get", "chunk", "id"], "metadata": {"kind": "method", "has_docstring": "false", "last_modified": "1766236633.3726954"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/retrieval/test_hybrid_index.py::StubVectorStore::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/retrieval/test_hybrid_index.py::StubVectorStore", "content": "class StubVectorStore:\n    def __init__(self, results):\n        self._results = results\n\n    def search(self, _embedding, limit=10):\n        return self._results[:limit]", "tokens": ["class", "stub", "vector", "store", "def", "init", "self", "results", "self", "results", "results", "def", "search", "self", "embedding", "limit", "10", "return", "self", "results", "limit"], "metadata": {"kind": "class", "has_docstring": "false", "last_modified": "1766236633.3726954"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/retrieval/test_hybrid_index.py::StubVectorStore.__init__::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/retrieval/test_hybrid_index.py::StubVectorStore.__init__", "content": "def __init__(self, results)\n    def __init__(self, results):\n        self._results = results", "tokens": ["def", "init", "self", "results", "def", "init", "self", "results", "self", "results", "results"], "metadata": {"kind": "method", "has_docstring": "false", "last_modified": "1766236633.3726954"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/retrieval/test_hybrid_index.py::StubVectorStore.search::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/retrieval/test_hybrid_index.py::StubVectorStore.search", "content": "def search(self, _embedding, limit)\n    def search(self, _embedding, limit=10):\n        return self._results[:limit]", "tokens": ["def", "search", "self", "embedding", "limit", "def", "search", "self", "embedding", "limit", "10", "return", "self", "results", "limit"], "metadata": {"kind": "method", "has_docstring": "false", "last_modified": "1766236633.3726954"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/retrieval/test_hybrid_index.py::test_hybrid_index_alpha_zero_prefers_sparse::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/retrieval/test_hybrid_index.py::test_hybrid_index_alpha_zero_prefers_sparse", "content": "def test_hybrid_index_alpha_zero_prefers_sparse() -> None\n\"\"\"Alpha=0 should rank purely by sparse results.\"\"\"\ndef test_hybrid_index_alpha_zero_prefers_sparse() -> None:\n    \"\"\"Alpha=0 should rank purely by sparse results.\"\"\"\n    c1 = CodeChunk(id=\"c1\", entity_id=\"e1\", content=\"a\", tokens=[\"a\"])\n    c2 = CodeChunk(id=\"c2\", entity_id=\"e2\", content=\"b\", tokens=[\"b\"])\n    repo = StubRepo([c1, c2])\n    vector_store = StubVectorStore([(\"c2\", 0.9), (\"c1\", 0.8)])\n\n    index = HybridIndex(repo, vector_store, alpha=0.0)\n    results = index.search(\"a\", [0.0], limit=2)\n\n    assert results[0][0].id == \"c1\"", "tokens": ["def", "test", "hybrid", "index", "alpha", "zero", "prefers", "sparse", "none", "alpha", "should", "rank", "purely", "by", "sparse", "results", "def", "test", "hybrid", "index", "alpha", "zero", "prefers", "sparse", "none", "alpha", "should", "rank", "purely", "by", "sparse", "results", "c1", "code", "chunk", "id", "c1", "entity", "id", "e1", "content", "tokens", "c2", "code", "chunk", "id", "c2", "entity", "id", "e2", "content", "tokens", "repo", "stub", "repo", "c1", "c2", "vector", "store", "stub", "vector", "store", "c2", "c1", "index", "hybrid", "index", "repo", "vector", "store", "alpha", "results", "index", "search", "limit", "assert", "results", "id", "c1"], "metadata": {"kind": "function", "has_docstring": "true", "last_modified": "1766236633.3726954"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/retrieval/test_hybrid_index.py::test_hybrid_index_alpha_one_prefers_dense::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/retrieval/test_hybrid_index.py::test_hybrid_index_alpha_one_prefers_dense", "content": "def test_hybrid_index_alpha_one_prefers_dense() -> None\n\"\"\"Alpha=1 should rank purely by dense results.\"\"\"\ndef test_hybrid_index_alpha_one_prefers_dense() -> None:\n    \"\"\"Alpha=1 should rank purely by dense results.\"\"\"\n    c1 = CodeChunk(id=\"c1\", entity_id=\"e1\", content=\"a\", tokens=[\"a\"])\n    c2 = CodeChunk(id=\"c2\", entity_id=\"e2\", content=\"b\", tokens=[\"b\"])\n    repo = StubRepo([c1, c2])\n    vector_store = StubVectorStore([(\"c2\", 0.9), (\"c1\", 0.8)])\n\n    index = HybridIndex(repo, vector_store, alpha=1.0)\n    results = index.search(\"a\", [0.0], limit=2)\n\n    assert results[0][0].id == \"c2\"", "tokens": ["def", "test", "hybrid", "index", "alpha", "one", "prefers", "dense", "none", "alpha", "should", "rank", "purely", "by", "dense", "results", "def", "test", "hybrid", "index", "alpha", "one", "prefers", "dense", "none", "alpha", "should", "rank", "purely", "by", "dense", "results", "c1", "code", "chunk", "id", "c1", "entity", "id", "e1", "content", "tokens", "c2", "code", "chunk", "id", "c2", "entity", "id", "e2", "content", "tokens", "repo", "stub", "repo", "c1", "c2", "vector", "store", "stub", "vector", "store", "c2", "c1", "index", "hybrid", "index", "repo", "vector", "store", "alpha", "results", "index", "search", "limit", "assert", "results", "id", "c2"], "metadata": {"kind": "function", "has_docstring": "true", "last_modified": "1766236633.3726954"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/retrieval/test_completeness.py::module::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/retrieval/test_completeness.py::module", "content": "\"\"\"Unit tests for dependency expansion.\"\"\"", "tokens": ["unit", "tests", "for", "dependency", "expansion"], "metadata": {"type": "module_header"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/retrieval/test_completeness.py::imports::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/retrieval/test_completeness.py::module", "content": "from knowcode.data_models import CodeChunk, Entity, EntityKind, Location, Relationship, RelationshipKind\nfrom knowcode.retrieval.completeness import expand_dependencies\nfrom knowcode.storage.chunk_repository import InMemoryChunkRepository\nfrom knowcode.storage.knowledge_store import KnowledgeStore", "tokens": ["from", "knowcode", "data", "models", "import", "code", "chunk", "entity", "entity", "kind", "location", "relationship", "relationship", "kind", "from", "knowcode", "retrieval", "completeness", "import", "expand", "dependencies", "from", "knowcode", "storage", "chunk", "repository", "import", "in", "memory", "chunk", "repository", "from", "knowcode", "storage", "knowledge", "store", "import", "knowledge", "store"], "metadata": {"type": "imports"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/retrieval/test_completeness.py::test_expand_dependencies_dedupes::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/retrieval/test_completeness.py::test_expand_dependencies_dedupes", "content": "def test_expand_dependencies_dedupes() -> None\n\"\"\"Dependency expansion should include each chunk once.\"\"\"\ndef test_expand_dependencies_dedupes() -> None:\n    \"\"\"Dependency expansion should include each chunk once.\"\"\"\n    repo = InMemoryChunkRepository()\n    chunk_a = CodeChunk(id=\"c1\", entity_id=\"e1\", content=\"A\", tokens=[\"a\"])\n    chunk_b = CodeChunk(id=\"c2\", entity_id=\"e2\", content=\"B\", tokens=[\"b\"])\n    repo.add(chunk_a)\n    repo.add(chunk_b)\n\n    store = KnowledgeStore()\n    entity_a = Entity(\n        id=\"e1\",\n        kind=EntityKind.FUNCTION,\n        name=\"a\",\n        qualified_name=\"a\",\n        location=Location(\"file.py\", 1, 1),\n    )\n    entity_b = Entity(\n        id=\"e2\",\n        kind=EntityKind.FUNCTION,\n        name=\"b\",\n        qualified_name=\"b\",\n        location=Location(\"file.py\", 2, 2),\n    )\n    store.entities = {entity_a.id: entity_a, entity_b.id: entity_b}\n    store.relationships = [\n        Relationship(\n            source_id=entity_a.id,\n            target_id=entit", "tokens": ["def", "test", "expand", "dependencies", "dedupes", "none", "dependency", "expansion", "should", "include", "each", "chunk", "once", "def", "test", "expand", "dependencies", "dedupes", "none", "dependency", "expansion", "should", "include", "each", "chunk", "once", "repo", "in", "memory", "chunk", "repository", "chunk", "code", "chunk", "id", "c1", "entity", "id", "e1", "content", "tokens", "chunk", "code", "chunk", "id", "c2", "entity", "id", "e2", "content", "tokens", "repo", "add", "chunk", "repo", "add", "chunk", "store", "knowledge", "store", "entity", "entity", "id", "e1", "kind", "entity", "kind", "function", "name", "qualified", "name", "location", "location", "file", "py", "entity", "entity", "id", "e2", "kind", "entity", "kind", "function", "name", "qualified", "name", "location", "location", "file", "py", "store", "entities", "entity", "id", "entity", "entity", "id", "entity", "store", "relationships", "relationship", "source", "id", "entity", "id", "target", "id", "entit"], "metadata": {"kind": "function", "chunk_index": "0", "has_docstring": "true", "last_modified": "1766236633.3726954"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/retrieval/test_completeness.py::test_expand_dependencies_dedupes::1", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/retrieval/test_completeness.py::test_expand_dependencies_dedupes", "content": "lationships = [\n        Relationship(\n            source_id=entity_a.id,\n            target_id=entity_b.id,\n            kind=RelationshipKind.CALLS,\n        )\n    ]\n\n    expanded = expand_dependencies(chunk_a, repo, store, max_depth=1)\n    ids = [c.id for c in expanded]\n\n    assert ids.count(\"c1\") == 1\n    assert ids.count(\"c2\") == 1", "tokens": ["lationships", "relationship", "source", "id", "entity", "id", "target", "id", "entity", "id", "kind", "relationship", "kind", "calls", "expanded", "expand", "dependencies", "chunk", "repo", "store", "max", "depth", "ids", "id", "for", "in", "expanded", "assert", "ids", "count", "c1", "assert", "ids", "count", "c2"], "metadata": {"kind": "function", "chunk_index": "1", "has_docstring": "true", "last_modified": "1766236633.3726954"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/llm/test_embedding_provider.py::module::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/llm/test_embedding_provider.py::module", "content": "\"\"\"Unit tests for embedding providers.\"\"\"", "tokens": ["unit", "tests", "for", "embedding", "providers"], "metadata": {"type": "module_header"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/llm/test_embedding_provider.py::imports::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/llm/test_embedding_provider.py::module", "content": "from knowcode.llm.embedding import OpenAIEmbeddingProvider\nfrom knowcode.data_models import EmbeddingConfig", "tokens": ["from", "knowcode", "llm", "embedding", "import", "open", "aiembedding", "provider", "from", "knowcode", "data", "models", "import", "embedding", "config"], "metadata": {"type": "imports"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/llm/test_embedding_provider.py::test_embedding_provider_empty_batch::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/llm/test_embedding_provider.py::test_embedding_provider_empty_batch", "content": "def test_embedding_provider_empty_batch() -> None\n\"\"\"Embedding provider should return empty list for empty input.\"\"\"\ndef test_embedding_provider_empty_batch() -> None:\n    \"\"\"Embedding provider should return empty list for empty input.\"\"\"\n    provider = OpenAIEmbeddingProvider(EmbeddingConfig())\n    assert provider.embed([]) == []", "tokens": ["def", "test", "embedding", "provider", "empty", "batch", "none", "embedding", "provider", "should", "return", "empty", "list", "for", "empty", "input", "def", "test", "embedding", "provider", "empty", "batch", "none", "embedding", "provider", "should", "return", "empty", "list", "for", "empty", "input", "provider", "open", "aiembedding", "provider", "embedding", "config", "assert", "provider", "embed"], "metadata": {"kind": "function", "has_docstring": "true", "last_modified": "1766236633.3726954"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/llm/test_embedding_provider.py::test_embedding_provider_normalize_zero_vector::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/llm/test_embedding_provider.py::test_embedding_provider_normalize_zero_vector", "content": "def test_embedding_provider_normalize_zero_vector() -> None\n\"\"\"Normalization should handle zero vectors safely.\"\"\"\ndef test_embedding_provider_normalize_zero_vector() -> None:\n    \"\"\"Normalization should handle zero vectors safely.\"\"\"\n    provider = OpenAIEmbeddingProvider(EmbeddingConfig())\n    assert provider._normalize([0.0, 0.0]) == [0.0, 0.0]", "tokens": ["def", "test", "embedding", "provider", "normalize", "zero", "vector", "none", "normalization", "should", "handle", "zero", "vectors", "safely", "def", "test", "embedding", "provider", "normalize", "zero", "vector", "none", "normalization", "should", "handle", "zero", "vectors", "safely", "provider", "open", "aiembedding", "provider", "embedding", "config", "assert", "provider", "normalize"], "metadata": {"kind": "function", "has_docstring": "true", "last_modified": "1766236633.3726954"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/llm/test_agent.py::module::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/llm/test_agent.py::module", "content": "\"\"\"Tests for the KnowCode Agent.\"\"\"", "tokens": ["tests", "for", "the", "know", "code", "agent"], "metadata": {"type": "module_header"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/llm/test_agent.py::imports::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/llm/test_agent.py::module", "content": "from __future__ import annotations\nfrom pathlib import Path\nfrom unittest.mock import MagicMock\nfrom knowcode.config import AppConfig, ModelConfig\nfrom knowcode.data_models import TaskType\nfrom knowcode.llm.agent import Agent", "tokens": ["from", "future", "import", "annotations", "from", "pathlib", "import", "path", "from", "unittest", "mock", "import", "magic", "mock", "from", "knowcode", "config", "import", "app", "config", "model", "config", "from", "knowcode", "data", "models", "import", "task", "type", "from", "knowcode", "llm", "agent", "import", "agent"], "metadata": {"type": "imports"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/llm/test_agent.py::DummyService::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/llm/test_agent.py::DummyService", "content": "class DummyService:\n    def __init__(self, store_path: Path) -> None:\n        self.store_path = store_path\n        self.retrieve_calls: list[str] = []\n        self.retrieval_result: dict | None = None\n\n    def retrieve_context_for_query(self, query: str, **_kwargs):\n        self.retrieve_calls.append(query)\n        if self.retrieval_result is not None:\n            return self.retrieval_result\n        return {\n            \"query\": query,\n            \"task_type\": TaskType.GENERAL.value,\n            \"task_confidence\": 0.0,\n            \"retrieval_mode\": \"none\",\n            \"context_text\": \"CTX\",\n            \"total_tokens\": 1,\n            \"max_tokens\": 6000,\n            \"truncated\": False,\n            \"sufficiency_score\": 0.0,\n            \"selected_entities\": [],\n            \"evidence\": [],\n            \"errors\": [],\n        }", "tokens": ["class", "dummy", "service", "def", "init", "self", "store", "path", "path", "none", "self", "store", "path", "store", "path", "self", "retrieve", "calls", "list", "str", "self", "retrieval", "result", "dict", "none", "none", "def", "retrieve", "context", "for", "query", "self", "query", "str", "kwargs", "self", "retrieve", "calls", "append", "query", "if", "self", "retrieval", "result", "is", "not", "none", "return", "self", "retrieval", "result", "return", "query", "query", "task", "type", "task", "type", "general", "value", "task", "confidence", "retrieval", "mode", "none", "context", "text", "ctx", "total", "tokens", "max", "tokens", "6000", "truncated", "false", "sufficiency", "score", "selected", "entities", "evidence", "errors"], "metadata": {"kind": "class", "has_docstring": "false", "last_modified": "1768185812.995584"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/llm/test_agent.py::DummyService.__init__::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/llm/test_agent.py::DummyService.__init__", "content": "def __init__(self, store_path: Path) -> None\n    def __init__(self, store_path: Path) -> None:\n        self.store_path = store_path\n        self.retrieve_calls: list[str] = []\n        self.retrieval_result: dict | None = None", "tokens": ["def", "init", "self", "store", "path", "path", "none", "def", "init", "self", "store", "path", "path", "none", "self", "store", "path", "store", "path", "self", "retrieve", "calls", "list", "str", "self", "retrieval", "result", "dict", "none", "none"], "metadata": {"kind": "method", "has_docstring": "false", "last_modified": "1768185812.995584"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/llm/test_agent.py::DummyService.retrieve_context_for_query::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/llm/test_agent.py::DummyService.retrieve_context_for_query", "content": "def retrieve_context_for_query(self, query: str, **_kwargs)\n    def retrieve_context_for_query(self, query: str, **_kwargs):\n        self.retrieve_calls.append(query)\n        if self.retrieval_result is not None:\n            return self.retrieval_result\n        return {\n            \"query\": query,\n            \"task_type\": TaskType.GENERAL.value,\n            \"task_confidence\": 0.0,\n            \"retrieval_mode\": \"none\",\n            \"context_text\": \"CTX\",\n            \"total_tokens\": 1,\n            \"max_tokens\": 6000,\n            \"truncated\": False,\n            \"sufficiency_score\": 0.0,\n            \"selected_entities\": [],\n            \"evidence\": [],\n            \"errors\": [],\n        }", "tokens": ["def", "retrieve", "context", "for", "query", "self", "query", "str", "kwargs", "def", "retrieve", "context", "for", "query", "self", "query", "str", "kwargs", "self", "retrieve", "calls", "append", "query", "if", "self", "retrieval", "result", "is", "not", "none", "return", "self", "retrieval", "result", "return", "query", "query", "task", "type", "task", "type", "general", "value", "task", "confidence", "retrieval", "mode", "none", "context", "text", "ctx", "total", "tokens", "max", "tokens", "6000", "truncated", "false", "sufficiency", "score", "selected", "entities", "evidence", "errors"], "metadata": {"kind": "method", "has_docstring": "false", "last_modified": "1768185812.995584"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/llm/test_agent.py::_make_agent::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/llm/test_agent.py::_make_agent", "content": "def _make_agent(service: DummyService) -> Agent\ndef _make_agent(service: DummyService) -> Agent:\n    cfg = AppConfig(\n        models=[ModelConfig(name=\"test-model\", provider=\"google\", api_key_env=\"TEST_KEY\")]\n    )\n    agent = Agent(service, cfg)\n    agent.rate_limiter = MagicMock()\n    agent.rate_limiter.check_availability.return_value = True\n\n    stub_client = MagicMock()\n    stub_client.models.generate_content.return_value = MagicMock(text=\"ANSWER\")\n    agent._get_client = MagicMock(return_value=stub_client)\n    return agent", "tokens": ["def", "make", "agent", "service", "dummy", "service", "agent", "def", "make", "agent", "service", "dummy", "service", "agent", "cfg", "app", "config", "models", "model", "config", "name", "test", "model", "provider", "google", "api", "key", "env", "test", "key", "agent", "agent", "service", "cfg", "agent", "rate", "limiter", "magic", "mock", "agent", "rate", "limiter", "check", "availability", "return", "value", "true", "stub", "client", "magic", "mock", "stub", "client", "models", "generate", "content", "return", "value", "magic", "mock", "text", "answer", "agent", "get", "client", "magic", "mock", "return", "value", "stub", "client", "return", "agent"], "metadata": {"kind": "function", "has_docstring": "false", "last_modified": "1768185812.995584"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/llm/test_agent.py::test_agent_answer_uses_unified_retrieval_kernel::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/llm/test_agent.py::test_agent_answer_uses_unified_retrieval_kernel", "content": "def test_agent_answer_uses_unified_retrieval_kernel(tmp_path: Path) -> None\ndef test_agent_answer_uses_unified_retrieval_kernel(tmp_path: Path) -> None:\n    service = DummyService(store_path=tmp_path)\n    service.retrieval_result = {\n        \"query\": \"Explain e1\",\n        \"task_type\": TaskType.EXPLAIN.value,\n        \"task_confidence\": 1.0,\n        \"retrieval_mode\": \"semantic\",\n        \"context_text\": \"CTX:e1\",\n        \"total_tokens\": 10,\n        \"max_tokens\": 6000,\n        \"truncated\": False,\n        \"sufficiency_score\": 0.9,\n        \"selected_entities\": [{\"entity_id\": \"e1\"}],\n        \"evidence\": [],\n        \"errors\": [],\n    }\n    agent = _make_agent(service)\n\n    answer = agent.answer(\"Explain e1\")\n    assert answer == \"ANSWER\"\n    assert service.retrieve_calls == [\"Explain e1\"]", "tokens": ["def", "test", "agent", "answer", "uses", "unified", "retrieval", "kernel", "tmp", "path", "path", "none", "def", "test", "agent", "answer", "uses", "unified", "retrieval", "kernel", "tmp", "path", "path", "none", "service", "dummy", "service", "store", "path", "tmp", "path", "service", "retrieval", "result", "query", "explain", "e1", "task", "type", "task", "type", "explain", "value", "task", "confidence", "retrieval", "mode", "semantic", "context", "text", "ctx", "e1", "total", "tokens", "10", "max", "tokens", "6000", "truncated", "false", "sufficiency", "score", "selected", "entities", "entity", "id", "e1", "evidence", "errors", "agent", "make", "agent", "service", "answer", "agent", "answer", "explain", "e1", "assert", "answer", "answer", "assert", "service", "retrieve", "calls", "explain", "e1"], "metadata": {"kind": "function", "has_docstring": "false", "last_modified": "1768185812.995584"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/llm/test_agent.py::test_smart_answer_uses_local_when_sufficient::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/llm/test_agent.py::test_smart_answer_uses_local_when_sufficient", "content": "def test_smart_answer_uses_local_when_sufficient(tmp_path: Path) -> None\ndef test_smart_answer_uses_local_when_sufficient(tmp_path: Path) -> None:\n    service = DummyService(store_path=tmp_path)\n    service.retrieval_result = {\n        \"query\": \"Where is Foo defined?\",\n        \"task_type\": TaskType.LOCATE.value,\n        \"task_confidence\": 1.0,\n        \"retrieval_mode\": \"lexical\",\n        \"context_text\": \"CTX:Foo\",\n        \"total_tokens\": 10,\n        \"max_tokens\": 6000,\n        \"truncated\": False,\n        \"sufficiency_score\": 1.0,\n        \"selected_entities\": [{\"entity_id\": \"e1\"}],\n        \"evidence\": [],\n        \"errors\": [],\n    }\n    agent = _make_agent(service)\n\n    result = agent.smart_answer(\"Where is Foo defined?\")\n    assert result[\"source\"] == \"local\"\n    assert result[\"task_type\"] == TaskType.LOCATE.value", "tokens": ["def", "test", "smart", "answer", "uses", "local", "when", "sufficient", "tmp", "path", "path", "none", "def", "test", "smart", "answer", "uses", "local", "when", "sufficient", "tmp", "path", "path", "none", "service", "dummy", "service", "store", "path", "tmp", "path", "service", "retrieval", "result", "query", "where", "is", "foo", "defined", "task", "type", "task", "type", "locate", "value", "task", "confidence", "retrieval", "mode", "lexical", "context", "text", "ctx", "foo", "total", "tokens", "10", "max", "tokens", "6000", "truncated", "false", "sufficiency", "score", "selected", "entities", "entity", "id", "e1", "evidence", "errors", "agent", "make", "agent", "service", "result", "agent", "smart", "answer", "where", "is", "foo", "defined", "assert", "result", "source", "local", "assert", "result", "task", "type", "task", "type", "locate", "value"], "metadata": {"kind": "function", "has_docstring": "false", "last_modified": "1768185812.995584"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/llm/test_agent.py::test_smart_answer_calls_llm_when_insufficient::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/llm/test_agent.py::test_smart_answer_calls_llm_when_insufficient", "content": "def test_smart_answer_calls_llm_when_insufficient(tmp_path: Path) -> None\ndef test_smart_answer_calls_llm_when_insufficient(tmp_path: Path) -> None:\n    service = DummyService(store_path=tmp_path)\n    service.retrieval_result = {\n        \"query\": \"Explain Foo\",\n        \"task_type\": TaskType.EXPLAIN.value,\n        \"task_confidence\": 1.0,\n        \"retrieval_mode\": \"none\",\n        \"context_text\": \"\",\n        \"total_tokens\": 0,\n        \"max_tokens\": 6000,\n        \"truncated\": False,\n        \"sufficiency_score\": 0.0,\n        \"selected_entities\": [],\n        \"evidence\": [],\n        \"errors\": [],\n    }\n    agent = _make_agent(service)\n    agent.answer = MagicMock(return_value=\"LLM\")  # type: ignore[method-assign]\n\n    result = agent.smart_answer(\"Explain Foo\")\n    assert result[\"source\"] == \"llm\"\n    assert result[\"answer\"] == \"LLM\"", "tokens": ["def", "test", "smart", "answer", "calls", "llm", "when", "insufficient", "tmp", "path", "path", "none", "def", "test", "smart", "answer", "calls", "llm", "when", "insufficient", "tmp", "path", "path", "none", "service", "dummy", "service", "store", "path", "tmp", "path", "service", "retrieval", "result", "query", "explain", "foo", "task", "type", "task", "type", "explain", "value", "task", "confidence", "retrieval", "mode", "none", "context", "text", "total", "tokens", "max", "tokens", "6000", "truncated", "false", "sufficiency", "score", "selected", "entities", "evidence", "errors", "agent", "make", "agent", "service", "agent", "answer", "magic", "mock", "return", "value", "llm", "type", "ignore", "method", "assign", "result", "agent", "smart", "answer", "explain", "foo", "assert", "result", "source", "llm", "assert", "result", "answer", "llm"], "metadata": {"kind": "function", "has_docstring": "false", "last_modified": "1768185812.995584"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/storage/test_knowledge_store.py::module::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/storage/test_knowledge_store.py::module", "content": "\"\"\"Unit tests for knowledge store helpers and persistence.\"\"\"", "tokens": ["unit", "tests", "for", "knowledge", "store", "helpers", "and", "persistence"], "metadata": {"type": "module_header"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/storage/test_knowledge_store.py::imports::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/storage/test_knowledge_store.py::module", "content": "from knowcode.data_models import Entity, EntityKind, Location, Relationship, RelationshipKind\nfrom knowcode.storage.knowledge_store import KnowledgeStore", "tokens": ["from", "knowcode", "data", "models", "import", "entity", "entity", "kind", "location", "relationship", "relationship", "kind", "from", "knowcode", "storage", "knowledge", "store", "import", "knowledge", "store"], "metadata": {"type": "imports"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/storage/test_knowledge_store.py::_make_entity::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/storage/test_knowledge_store.py::_make_entity", "content": "def _make_entity(entity_id: str, kind: EntityKind, name: str) -> Entity\ndef _make_entity(entity_id: str, kind: EntityKind, name: str) -> Entity:\n    return Entity(\n        id=entity_id,\n        kind=kind,\n        name=name,\n        qualified_name=name,\n        location=Location(\"file.py\", 1, 1),\n    )", "tokens": ["def", "make", "entity", "entity", "id", "str", "kind", "entity", "kind", "name", "str", "entity", "def", "make", "entity", "entity", "id", "str", "kind", "entity", "kind", "name", "str", "entity", "return", "entity", "id", "entity", "id", "kind", "kind", "name", "name", "qualified", "name", "name", "location", "location", "file", "py"], "metadata": {"kind": "function", "has_docstring": "false", "last_modified": "1768185812.995584"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/storage/test_knowledge_store.py::test_kind_filters_and_relationship_helpers::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/storage/test_knowledge_store.py::test_kind_filters_and_relationship_helpers", "content": "def test_kind_filters_and_relationship_helpers() -> None\n\"\"\"KnowledgeStore should filter by kind and expose relationships.\"\"\"\ndef test_kind_filters_and_relationship_helpers() -> None:\n    \"\"\"KnowledgeStore should filter by kind and expose relationships.\"\"\"\n    store = KnowledgeStore()\n    foo = _make_entity(\"file.py::foo\", EntityKind.FUNCTION, \"foo\")\n    bar = _make_entity(\"file.py::bar\", EntityKind.FUNCTION, \"bar\")\n    store.entities = {foo.id: foo, bar.id: bar}\n\n    rel = Relationship(source_id=foo.id, target_id=bar.id, kind=RelationshipKind.CALLS)\n    store.relationships = [rel]\n\n    assert store.get_entities_by_kind(\"function\") == [foo, bar]\n    assert store.get_outgoing_relationships(foo.id) == [rel]\n    assert store.get_incoming_relationships(bar.id) == [rel]", "tokens": ["def", "test", "kind", "filters", "and", "relationship", "helpers", "none", "knowledge", "store", "should", "filter", "by", "kind", "and", "expose", "relationships", "def", "test", "kind", "filters", "and", "relationship", "helpers", "none", "knowledge", "store", "should", "filter", "by", "kind", "and", "expose", "relationships", "store", "knowledge", "store", "foo", "make", "entity", "file", "py", "foo", "entity", "kind", "function", "foo", "bar", "make", "entity", "file", "py", "bar", "entity", "kind", "function", "bar", "store", "entities", "foo", "id", "foo", "bar", "id", "bar", "rel", "relationship", "source", "id", "foo", "id", "target", "id", "bar", "id", "kind", "relationship", "kind", "calls", "store", "relationships", "rel", "assert", "store", "get", "entities", "by", "kind", "function", "foo", "bar", "assert", "store", "get", "outgoing", "relationships", "foo", "id", "rel", "assert", "store", "get", "incoming", "relationships", "bar", "id", "rel"], "metadata": {"kind": "function", "has_docstring": "true", "last_modified": "1768185812.995584"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/storage/test_knowledge_store.py::test_persistence_round_trip::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/storage/test_knowledge_store.py::test_persistence_round_trip", "content": "def test_persistence_round_trip(tmp_path) -> None\n\"\"\"Save/load should preserve entities, relationships, and metadata.\"\"\"\ndef test_persistence_round_trip(tmp_path) -> None:\n    \"\"\"Save/load should preserve entities, relationships, and metadata.\"\"\"\n    store = KnowledgeStore()\n    store.metadata = {\"stats\": {\"total\": 1}}\n    foo = _make_entity(\"file.py::foo\", EntityKind.FUNCTION, \"foo\")\n    store.entities = {foo.id: foo}\n    store.relationships = [\n        Relationship(\n            source_id=foo.id,\n            target_id=\"external::dep\",\n            kind=RelationshipKind.IMPORTS,\n            metadata={\"kind\": \"test\"},\n        )\n    ]\n\n    save_path = tmp_path / \"knowledge.json\"\n    store.save(save_path)\n\n    loaded = KnowledgeStore.load(save_path)\n    assert loaded.metadata[\"stats\"][\"total\"] == 1\n    assert foo.id in loaded.entities\n    assert loaded.relationships[0].metadata[\"kind\"] == \"test\"", "tokens": ["def", "test", "persistence", "round", "trip", "tmp", "path", "none", "save", "load", "should", "preserve", "entities", "relationships", "and", "metadata", "def", "test", "persistence", "round", "trip", "tmp", "path", "none", "save", "load", "should", "preserve", "entities", "relationships", "and", "metadata", "store", "knowledge", "store", "store", "metadata", "stats", "total", "foo", "make", "entity", "file", "py", "foo", "entity", "kind", "function", "foo", "store", "entities", "foo", "id", "foo", "store", "relationships", "relationship", "source", "id", "foo", "id", "target", "id", "external", "dep", "kind", "relationship", "kind", "imports", "metadata", "kind", "test", "save", "path", "tmp", "path", "knowledge", "json", "store", "save", "save", "path", "loaded", "knowledge", "store", "load", "save", "path", "assert", "loaded", "metadata", "stats", "total", "assert", "foo", "id", "in", "loaded", "entities", "assert", "loaded", "relationships", "metadata", "kind", "test"], "metadata": {"kind": "function", "has_docstring": "true", "last_modified": "1768185812.995584"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/storage/test_chunk_repository.py::module::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/storage/test_chunk_repository.py::module", "content": "\"\"\"Unit tests for chunk repositories.\"\"\"", "tokens": ["unit", "tests", "for", "chunk", "repositories"], "metadata": {"type": "module_header"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/storage/test_chunk_repository.py::imports::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/storage/test_chunk_repository.py::module", "content": "from knowcode.data_models import CodeChunk\nfrom knowcode.storage.chunk_repository import InMemoryChunkRepository", "tokens": ["from", "knowcode", "data", "models", "import", "code", "chunk", "from", "knowcode", "storage", "chunk", "repository", "import", "in", "memory", "chunk", "repository"], "metadata": {"type": "imports"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/storage/test_chunk_repository.py::test_chunk_repository_basic::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/storage/test_chunk_repository.py::test_chunk_repository_basic", "content": "def test_chunk_repository_basic() -> None\n\"\"\"Chunks should be retrievable by ID and entity.\"\"\"\ndef test_chunk_repository_basic() -> None:\n    \"\"\"Chunks should be retrievable by ID and entity.\"\"\"\n    repo = InMemoryChunkRepository()\n    chunk = CodeChunk(id=\"c1\", entity_id=\"e1\", content=\"content 1\", tokens=[\"content\", \"1\"])\n    repo.add(chunk)\n\n    assert repo.get(\"c1\") == chunk\n    assert repo.get_by_entity(\"e1\") == [chunk]", "tokens": ["def", "test", "chunk", "repository", "basic", "none", "chunks", "should", "be", "retrievable", "by", "id", "and", "entity", "def", "test", "chunk", "repository", "basic", "none", "chunks", "should", "be", "retrievable", "by", "id", "and", "entity", "repo", "in", "memory", "chunk", "repository", "chunk", "code", "chunk", "id", "c1", "entity", "id", "e1", "content", "content", "tokens", "content", "repo", "add", "chunk", "assert", "repo", "get", "c1", "chunk", "assert", "repo", "get", "by", "entity", "e1", "chunk"], "metadata": {"kind": "function", "has_docstring": "true", "last_modified": "1766236633.3726954"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/storage/test_chunk_repository.py::test_chunk_repository_token_search_limit::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/storage/test_chunk_repository.py::test_chunk_repository_token_search_limit", "content": "def test_chunk_repository_token_search_limit() -> None\n\"\"\"Token search should respect limit and ordering.\"\"\"\ndef test_chunk_repository_token_search_limit() -> None:\n    \"\"\"Token search should respect limit and ordering.\"\"\"\n    repo = InMemoryChunkRepository()\n    repo.add(CodeChunk(id=\"c1\", entity_id=\"e1\", content=\"alpha beta\", tokens=[\"alpha\", \"beta\"]))\n    repo.add(CodeChunk(id=\"c2\", entity_id=\"e2\", content=\"alpha gamma\", tokens=[\"alpha\", \"gamma\"]))\n\n    results = repo.search_by_tokens([\"alpha\"], limit=1)\n    assert len(results) == 1\n    assert results[0].id in {\"c1\", \"c2\"}", "tokens": ["def", "test", "chunk", "repository", "token", "search", "limit", "none", "token", "search", "should", "respect", "limit", "and", "ordering", "def", "test", "chunk", "repository", "token", "search", "limit", "none", "token", "search", "should", "respect", "limit", "and", "ordering", "repo", "in", "memory", "chunk", "repository", "repo", "add", "code", "chunk", "id", "c1", "entity", "id", "e1", "content", "alpha", "beta", "tokens", "alpha", "beta", "repo", "add", "code", "chunk", "id", "c2", "entity", "id", "e2", "content", "alpha", "gamma", "tokens", "alpha", "gamma", "results", "repo", "search", "by", "tokens", "alpha", "limit", "assert", "len", "results", "assert", "results", "id", "in", "c1", "c2"], "metadata": {"kind": "function", "has_docstring": "true", "last_modified": "1766236633.3726954"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/storage/test_vector_store.py::module::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/storage/test_vector_store.py::module", "content": "\"\"\"Unit tests for vector store persistence.\"\"\"", "tokens": ["unit", "tests", "for", "vector", "store", "persistence"], "metadata": {"type": "module_header"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/storage/test_vector_store.py::imports::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/storage/test_vector_store.py::module", "content": "import pytest\nfrom knowcode.storage import vector_store\nfrom knowcode.storage.vector_store import VectorStore", "tokens": ["import", "pytest", "from", "knowcode", "storage", "import", "vector", "store", "from", "knowcode", "storage", "vector", "store", "import", "vector", "store"], "metadata": {"type": "imports"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/storage/test_vector_store.py::test_vector_store_save_load::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/storage/test_vector_store.py::test_vector_store_save_load", "content": "def test_vector_store_save_load(tmp_path) -> None\n\"\"\"Vector store should persist index and ID map when FAISS is available.\"\"\"\ndef test_vector_store_save_load(tmp_path) -> None:\n    \"\"\"Vector store should persist index and ID map when FAISS is available.\"\"\"\n    if vector_store.faiss is None:\n        pytest.skip(\"faiss not installed\")\n\n    store = VectorStore(dimension=2)\n    store.add(\"c1\", [1.0, 0.0])\n    store.add(\"c2\", [0.0, 1.0])\n\n    path = tmp_path / \"vectors\"\n    store.save(path)\n\n    loaded = VectorStore(dimension=2)\n    loaded.load(path)\n    assert loaded.id_map\n    results = loaded.search([1.0, 0.0], limit=1)\n    assert results[0][0] == \"c1\"", "tokens": ["def", "test", "vector", "store", "save", "load", "tmp", "path", "none", "vector", "store", "should", "persist", "index", "and", "id", "map", "when", "faiss", "is", "available", "def", "test", "vector", "store", "save", "load", "tmp", "path", "none", "vector", "store", "should", "persist", "index", "and", "id", "map", "when", "faiss", "is", "available", "if", "vector", "store", "faiss", "is", "none", "pytest", "skip", "faiss", "not", "installed", "store", "vector", "store", "dimension", "store", "add", "c1", "store", "add", "c2", "path", "tmp", "path", "vectors", "store", "save", "path", "loaded", "vector", "store", "dimension", "loaded", "load", "path", "assert", "loaded", "id", "map", "results", "loaded", "search", "limit", "assert", "results", "c1"], "metadata": {"kind": "function", "has_docstring": "true", "last_modified": "1766233979.937463"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/service/test_retrieve_context_for_query.py::module::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/service/test_retrieve_context_for_query.py::module", "content": "\"\"\"Unit tests for KnowCodeService.retrieve_context_for_query().\"\"\"", "tokens": ["unit", "tests", "for", "know", "code", "service", "retrieve", "context", "for", "query"], "metadata": {"type": "module_header"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/service/test_retrieve_context_for_query.py::imports::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/service/test_retrieve_context_for_query.py::module", "content": "from __future__ import annotations\nfrom pathlib import Path\nfrom knowcode.config import AppConfig\nfrom knowcode.data_models import CodeChunk, TaskType\nfrom knowcode.retrieval.search_engine import ScoredChunk\nfrom knowcode.service import KnowCodeService", "tokens": ["from", "future", "import", "annotations", "from", "pathlib", "import", "path", "from", "knowcode", "config", "import", "app", "config", "from", "knowcode", "data", "models", "import", "code", "chunk", "task", "type", "from", "knowcode", "retrieval", "search", "engine", "import", "scored", "chunk", "from", "knowcode", "service", "import", "know", "code", "service"], "metadata": {"type": "imports"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/service/test_retrieve_context_for_query.py::DummySearchEngine::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/service/test_retrieve_context_for_query.py::DummySearchEngine", "content": "class DummySearchEngine:\n    def __init__(self, scored: list[ScoredChunk] | Exception) -> None:\n        self._scored = scored\n\n    def search_scored(self, _query: str, **_kwargs) -> list[ScoredChunk]:\n        if isinstance(self._scored, Exception):\n            raise self._scored\n        return self._scored", "tokens": ["class", "dummy", "search", "engine", "def", "init", "self", "scored", "list", "scored", "chunk", "exception", "none", "self", "scored", "scored", "def", "search", "scored", "self", "query", "str", "kwargs", "list", "scored", "chunk", "if", "isinstance", "self", "scored", "exception", "raise", "self", "scored", "return", "self", "scored"], "metadata": {"kind": "class", "has_docstring": "false", "last_modified": "1768185812.995584"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/service/test_retrieve_context_for_query.py::DummySearchEngine.__init__::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/service/test_retrieve_context_for_query.py::DummySearchEngine.__init__", "content": "def __init__(self, scored: list[ScoredChunk] | Exception) -> None\n    def __init__(self, scored: list[ScoredChunk] | Exception) -> None:\n        self._scored = scored", "tokens": ["def", "init", "self", "scored", "list", "scored", "chunk", "exception", "none", "def", "init", "self", "scored", "list", "scored", "chunk", "exception", "none", "self", "scored", "scored"], "metadata": {"kind": "method", "has_docstring": "false", "last_modified": "1768185812.995584"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/service/test_retrieve_context_for_query.py::DummySearchEngine.search_scored::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/service/test_retrieve_context_for_query.py::DummySearchEngine.search_scored", "content": "def search_scored(self, _query: str, **_kwargs) -> list[ScoredChunk]\n    def search_scored(self, _query: str, **_kwargs) -> list[ScoredChunk]:\n        if isinstance(self._scored, Exception):\n            raise self._scored\n        return self._scored", "tokens": ["def", "search", "scored", "self", "query", "str", "kwargs", "list", "scored", "chunk", "def", "search", "scored", "self", "query", "str", "kwargs", "list", "scored", "chunk", "if", "isinstance", "self", "scored", "exception", "raise", "self", "scored", "return", "self", "scored"], "metadata": {"kind": "method", "has_docstring": "false", "last_modified": "1768185812.995584"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/service/test_retrieve_context_for_query.py::DummyService::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/service/test_retrieve_context_for_query.py::DummyService", "content": "class DummyService(KnowCodeService):\n    def __init__(self, store_path: Path, engine: DummySearchEngine) -> None:\n        super().__init__(store_path=store_path, app_config=AppConfig.default())\n        self._engine = engine\n        self.context_calls: list[tuple[str, int, TaskType]] = []\n        self.search_calls: list[str] = []\n\n    def get_search_engine(self, _index_path=None):  # type: ignore[override]\n        return self._engine\n\n    def get_context(self, target: str, max_tokens: int = 2000, task_type: TaskType | None = None):  # type: ignore[override]\n        assert task_type is not None\n        self.context_calls.append((target, max_tokens, task_type))\n        return {\n            \"entity_id\": target,\n            \"context_text\": f\"CTX:{target}\",\n            \"total_tokens\": 10,\n            \"truncated\": False,\n            \"included_entities\": [target],\n            \"task_type\": task_type.value,\n            \"sufficiency_score\": 1.0,\n        }\n\n    def search(self, pattern: str):  # t", "tokens": ["class", "dummy", "service", "know", "code", "service", "def", "init", "self", "store", "path", "path", "engine", "dummy", "search", "engine", "none", "super", "init", "store", "path", "store", "path", "app", "config", "app", "config", "default", "self", "engine", "engine", "self", "context", "calls", "list", "tuple", "str", "int", "task", "type", "self", "search", "calls", "list", "str", "def", "get", "search", "engine", "self", "index", "path", "none", "type", "ignore", "override", "return", "self", "engine", "def", "get", "context", "self", "target", "str", "max", "tokens", "int", "2000", "task", "type", "task", "type", "none", "none", "type", "ignore", "override", "assert", "task", "type", "is", "not", "none", "self", "context", "calls", "append", "target", "max", "tokens", "task", "type", "return", "entity", "id", "target", "context", "text", "ctx", "target", "total", "tokens", "10", "truncated", "false", "included", "entities", "target", "task", "type", "task", "type", "value", "sufficiency", "score", "def", "search", "self", "pattern", "str"], "metadata": {"kind": "class", "chunk_index": "0", "has_docstring": "false", "last_modified": "1768185812.995584"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/service/test_retrieve_context_for_query.py::DummyService::1", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/service/test_retrieve_context_for_query.py::DummyService", "content": "ype.value,\n            \"sufficiency_score\": 1.0,\n        }\n\n    def search(self, pattern: str):  # type: ignore[override]\n        self.search_calls.append(pattern)\n        return [{\"id\": \"e1\"}, {\"id\": \"e2\"}]\n\n    def _validate_index_compatibility(self, _index_path: Path) -> None:  # type: ignore[override]\n        return", "tokens": ["ype", "value", "sufficiency", "score", "def", "search", "self", "pattern", "str", "type", "ignore", "override", "self", "search", "calls", "append", "pattern", "return", "id", "e1", "id", "e2", "def", "validate", "index", "compatibility", "self", "index", "path", "path", "none", "type", "ignore", "override", "return"], "metadata": {"kind": "class", "chunk_index": "1", "has_docstring": "false", "last_modified": "1768185812.995584"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/service/test_retrieve_context_for_query.py::DummyService.__init__::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/service/test_retrieve_context_for_query.py::DummyService.__init__", "content": "def __init__(self, store_path: Path, engine: DummySearchEngine) -> None\n    def __init__(self, store_path: Path, engine: DummySearchEngine) -> None:\n        super().__init__(store_path=store_path, app_config=AppConfig.default())\n        self._engine = engine\n        self.context_calls: list[tuple[str, int, TaskType]] = []\n        self.search_calls: list[str] = []", "tokens": ["def", "init", "self", "store", "path", "path", "engine", "dummy", "search", "engine", "none", "def", "init", "self", "store", "path", "path", "engine", "dummy", "search", "engine", "none", "super", "init", "store", "path", "store", "path", "app", "config", "app", "config", "default", "self", "engine", "engine", "self", "context", "calls", "list", "tuple", "str", "int", "task", "type", "self", "search", "calls", "list", "str"], "metadata": {"kind": "method", "has_docstring": "false", "last_modified": "1768185812.995584"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/service/test_retrieve_context_for_query.py::DummyService.get_search_engine::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/service/test_retrieve_context_for_query.py::DummyService.get_search_engine", "content": "def get_search_engine(self, _index_path)\n    def get_search_engine(self, _index_path=None):  # type: ignore[override]\n        return self._engine", "tokens": ["def", "get", "search", "engine", "self", "index", "path", "def", "get", "search", "engine", "self", "index", "path", "none", "type", "ignore", "override", "return", "self", "engine"], "metadata": {"kind": "method", "has_docstring": "false", "last_modified": "1768185812.995584"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/service/test_retrieve_context_for_query.py::DummyService.get_context::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/service/test_retrieve_context_for_query.py::DummyService.get_context", "content": "def get_context(self, target: str, max_tokens: int, task_type: TaskType | None)\n    def get_context(self, target: str, max_tokens: int = 2000, task_type: TaskType | None = None):  # type: ignore[override]\n        assert task_type is not None\n        self.context_calls.append((target, max_tokens, task_type))\n        return {\n            \"entity_id\": target,\n            \"context_text\": f\"CTX:{target}\",\n            \"total_tokens\": 10,\n            \"truncated\": False,\n            \"included_entities\": [target],\n            \"task_type\": task_type.value,\n            \"sufficiency_score\": 1.0,\n        }", "tokens": ["def", "get", "context", "self", "target", "str", "max", "tokens", "int", "task", "type", "task", "type", "none", "def", "get", "context", "self", "target", "str", "max", "tokens", "int", "2000", "task", "type", "task", "type", "none", "none", "type", "ignore", "override", "assert", "task", "type", "is", "not", "none", "self", "context", "calls", "append", "target", "max", "tokens", "task", "type", "return", "entity", "id", "target", "context", "text", "ctx", "target", "total", "tokens", "10", "truncated", "false", "included", "entities", "target", "task", "type", "task", "type", "value", "sufficiency", "score"], "metadata": {"kind": "method", "has_docstring": "false", "last_modified": "1768185812.995584"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/service/test_retrieve_context_for_query.py::DummyService.search::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/service/test_retrieve_context_for_query.py::DummyService.search", "content": "def search(self, pattern: str)\n    def search(self, pattern: str):  # type: ignore[override]\n        self.search_calls.append(pattern)\n        return [{\"id\": \"e1\"}, {\"id\": \"e2\"}]", "tokens": ["def", "search", "self", "pattern", "str", "def", "search", "self", "pattern", "str", "type", "ignore", "override", "self", "search", "calls", "append", "pattern", "return", "id", "e1", "id", "e2"], "metadata": {"kind": "method", "has_docstring": "false", "last_modified": "1768185812.995584"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/service/test_retrieve_context_for_query.py::DummyService._validate_index_compatibility::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/service/test_retrieve_context_for_query.py::DummyService._validate_index_compatibility", "content": "def _validate_index_compatibility(self, _index_path: Path) -> None\n    def _validate_index_compatibility(self, _index_path: Path) -> None:  # type: ignore[override]\n        return", "tokens": ["def", "validate", "index", "compatibility", "self", "index", "path", "path", "none", "def", "validate", "index", "compatibility", "self", "index", "path", "path", "none", "type", "ignore", "override", "return"], "metadata": {"kind": "method", "has_docstring": "false", "last_modified": "1768185812.995584"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/service/test_retrieve_context_for_query.py::test_retrieve_context_uses_semantic_when_index_exists::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/service/test_retrieve_context_for_query.py::test_retrieve_context_uses_semantic_when_index_exists", "content": "def test_retrieve_context_uses_semantic_when_index_exists(tmp_path: Path) -> None\ndef test_retrieve_context_uses_semantic_when_index_exists(tmp_path: Path) -> None:\n    (tmp_path / \"knowcode_index\").mkdir()\n\n    chunk_a = CodeChunk(id=\"c1\", entity_id=\"e1\", content=\"one\", tokens=[\"one\"])\n    chunk_b = CodeChunk(id=\"c2\", entity_id=\"e2\", content=\"two\", tokens=[\"two\"])\n    scored = [\n        ScoredChunk(chunk=chunk_a, score=0.9, source=\"retrieved\"),\n        ScoredChunk(chunk=chunk_a, score=0.8, source=\"retrieved\"),  # dup entity\n        ScoredChunk(chunk=chunk_b, score=0.7, source=\"retrieved\"),\n        ScoredChunk(chunk=chunk_b, score=0.0, source=\"dependency\"),\n    ]\n\n    service = DummyService(tmp_path, engine=DummySearchEngine(scored))\n    result = service.retrieve_context_for_query(\"Explain e1\", limit_entities=2)\n\n    assert result[\"retrieval_mode\"] == \"semantic\"\n    assert [e[\"entity_id\"] for e in result[\"selected_entities\"]] == [\"e1\", \"e2\"]\n    assert [c[0] for c in service.context_ca", "tokens": ["def", "test", "retrieve", "context", "uses", "semantic", "when", "index", "exists", "tmp", "path", "path", "none", "def", "test", "retrieve", "context", "uses", "semantic", "when", "index", "exists", "tmp", "path", "path", "none", "tmp", "path", "knowcode", "index", "mkdir", "chunk", "code", "chunk", "id", "c1", "entity", "id", "e1", "content", "one", "tokens", "one", "chunk", "code", "chunk", "id", "c2", "entity", "id", "e2", "content", "two", "tokens", "two", "scored", "scored", "chunk", "chunk", "chunk", "score", "source", "retrieved", "scored", "chunk", "chunk", "chunk", "score", "source", "retrieved", "dup", "entity", "scored", "chunk", "chunk", "chunk", "score", "source", "retrieved", "scored", "chunk", "chunk", "chunk", "score", "source", "dependency", "service", "dummy", "service", "tmp", "path", "engine", "dummy", "search", "engine", "scored", "result", "service", "retrieve", "context", "for", "query", "explain", "e1", "limit", "entities", "assert", "result", "retrieval", "mode", "semantic", "assert", "entity", "id", "for", "in", "result", "selected", "entities", "e1", "e2", "assert", "for", "in", "service", "context", "ca"], "metadata": {"kind": "function", "chunk_index": "0", "has_docstring": "false", "last_modified": "1768185812.995584"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/service/test_retrieve_context_for_query.py::test_retrieve_context_uses_semantic_when_index_exists::1", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/service/test_retrieve_context_for_query.py::test_retrieve_context_uses_semantic_when_index_exists", "content": "] for e in result[\"selected_entities\"]] == [\"e1\", \"e2\"]\n    assert [c[0] for c in service.context_calls] == [\"e1\", \"e2\"]\n    assert result[\"context_text\"].count(\"CTX:\") == 2", "tokens": ["for", "in", "result", "selected", "entities", "e1", "e2", "assert", "for", "in", "service", "context", "calls", "e1", "e2", "assert", "result", "context", "text", "count", "ctx"], "metadata": {"kind": "function", "chunk_index": "1", "has_docstring": "false", "last_modified": "1768185812.995584"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/service/test_retrieve_context_for_query.py::test_retrieve_context_falls_back_to_lexical_on_semantic_error::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/service/test_retrieve_context_for_query.py::test_retrieve_context_falls_back_to_lexical_on_semantic_error", "content": "def test_retrieve_context_falls_back_to_lexical_on_semantic_error(tmp_path: Path) -> None\ndef test_retrieve_context_falls_back_to_lexical_on_semantic_error(tmp_path: Path) -> None:\n    (tmp_path / \"knowcode_index\").mkdir()\n\n    service = DummyService(\n        tmp_path,\n        engine=DummySearchEngine(RuntimeError(\"embed failed\")),\n    )\n    result = service.retrieve_context_for_query(\"Where is Foo defined?\", limit_entities=1)\n\n    assert result[\"retrieval_mode\"] == \"lexical\"\n    assert service.search_calls\n    assert result[\"selected_entities\"][0][\"entity_id\"] == \"e1\"", "tokens": ["def", "test", "retrieve", "context", "falls", "back", "to", "lexical", "on", "semantic", "error", "tmp", "path", "path", "none", "def", "test", "retrieve", "context", "falls", "back", "to", "lexical", "on", "semantic", "error", "tmp", "path", "path", "none", "tmp", "path", "knowcode", "index", "mkdir", "service", "dummy", "service", "tmp", "path", "engine", "dummy", "search", "engine", "runtime", "error", "embed", "failed", "result", "service", "retrieve", "context", "for", "query", "where", "is", "foo", "defined", "limit", "entities", "assert", "result", "retrieval", "mode", "lexical", "assert", "service", "search", "calls", "assert", "result", "selected", "entities", "entity", "id", "e1"], "metadata": {"kind": "function", "has_docstring": "false", "last_modified": "1768185812.995584"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/parsers/test_java_parser.py::module::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/parsers/test_java_parser.py::module", "content": "\"\"\"Tests for Java parser.\"\"\"", "tokens": ["tests", "for", "java", "parser"], "metadata": {"type": "module_header"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/parsers/test_java_parser.py::imports::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/parsers/test_java_parser.py::module", "content": "from pathlib import Path\nfrom knowcode.data_models import EntityKind, RelationshipKind\nfrom knowcode.parsers.java_parser import JavaParser\n    import java.util.List;", "tokens": ["from", "pathlib", "import", "path", "from", "knowcode", "data", "models", "import", "entity", "kind", "relationship", "kind", "from", "knowcode", "parsers", "java", "parser", "import", "java", "parser", "import", "java", "util", "list"], "metadata": {"type": "imports"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/parsers/test_java_parser.py::test_parse_simple_java::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/parsers/test_java_parser.py::test_parse_simple_java", "content": "def test_parse_simple_java(tmp_path: Path) -> None\n\"\"\"Test parsing a simple Java file.\"\"\"\ndef test_parse_simple_java(tmp_path: Path) -> None:\n    \"\"\"Test parsing a simple Java file.\"\"\"\n    source = \"\"\"\n    package com.example;\n    \n    import java.util.List;\n\n    public class MyClass extends BaseClass {\n        public MyClass() {}\n\n        public void myMethod() {\n            helper();\n        }\n        \n        private void helper() {}\n    }\n    \"\"\"\n    \n    file_path = tmp_path / \"MyClass.java\"\n    file_path.write_text(source, encoding=\"utf-8\")\n    \n    parser = JavaParser()\n    result = parser.parse_file(file_path)\n    \n    assert not result.errors\n    \n    # Check entities\n    entities = {e.qualified_name: e for e in result.entities}\n    assert \"MyClass\" in entities\n    assert entities[\"MyClass\"].kind == EntityKind.CLASS\n    \n    assert \"MyClass.myMethod\" in entities\n    assert entities[\"MyClass.myMethod\"].kind == EntityKind.METHOD\n    \n    # Check relationships\n    rels = result.r", "tokens": ["def", "test", "parse", "simple", "java", "tmp", "path", "path", "none", "test", "parsing", "simple", "java", "file", "def", "test", "parse", "simple", "java", "tmp", "path", "path", "none", "test", "parsing", "simple", "java", "file", "source", "package", "com", "example", "import", "java", "util", "list", "public", "class", "my", "class", "extends", "base", "class", "public", "my", "class", "public", "void", "my", "method", "helper", "private", "void", "helper", "file", "path", "tmp", "path", "my", "class", "java", "file", "path", "write", "text", "source", "encoding", "utf", "parser", "java", "parser", "result", "parser", "parse", "file", "file", "path", "assert", "not", "result", "errors", "check", "entities", "entities", "qualified", "name", "for", "in", "result", "entities", "assert", "my", "class", "in", "entities", "assert", "entities", "my", "class", "kind", "entity", "kind", "class", "assert", "my", "class", "my", "method", "in", "entities", "assert", "entities", "my", "class", "my", "method", "kind", "entity", "kind", "method", "check", "relationships", "rels", "result"], "metadata": {"kind": "function", "chunk_index": "0", "has_docstring": "true", "last_modified": "1766236633.3726954"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/parsers/test_java_parser.py::test_parse_simple_java::1", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/parsers/test_java_parser.py::test_parse_simple_java", "content": "ies[\"MyClass.myMethod\"].kind == EntityKind.METHOD\n    \n    # Check relationships\n    rels = result.relationships\n    \n    # Import\n    imports = [r for r in rels if r.kind == RelationshipKind.IMPORTS]\n    assert len(imports) == 1\n    assert imports[0].target_id == \"external::java.util.List\"\n    \n    # Inheritance\n    inherits = [r for r in rels if r.kind == RelationshipKind.INHERITS]\n    assert len(inherits) == 1\n    assert inherits[0].target_id == \"ref::BaseClass\"\n    \n    # Calls\n    calls = [r for r in rels if r.kind == RelationshipKind.CALLS]\n    targets = {r.target_id for r in calls}\n    assert \"ref::helper\" in targets", "tokens": ["ies", "my", "class", "my", "method", "kind", "entity", "kind", "method", "check", "relationships", "rels", "result", "relationships", "import", "imports", "for", "in", "rels", "if", "kind", "relationship", "kind", "imports", "assert", "len", "imports", "assert", "imports", "target", "id", "external", "java", "util", "list", "inheritance", "inherits", "for", "in", "rels", "if", "kind", "relationship", "kind", "inherits", "assert", "len", "inherits", "assert", "inherits", "target", "id", "ref", "base", "class", "calls", "calls", "for", "in", "rels", "if", "kind", "relationship", "kind", "calls", "targets", "target", "id", "for", "in", "calls", "assert", "ref", "helper", "in", "targets"], "metadata": {"kind": "function", "chunk_index": "1", "has_docstring": "true", "last_modified": "1766236633.3726954"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/parsers/test_javascript_parser.py::module::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/parsers/test_javascript_parser.py::module", "content": "\"\"\"Tests for JavaScript parser.\"\"\"", "tokens": ["tests", "for", "java", "script", "parser"], "metadata": {"type": "module_header"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/parsers/test_javascript_parser.py::imports::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/parsers/test_javascript_parser.py::module", "content": "from pathlib import Path\nfrom knowcode.data_models import EntityKind, RelationshipKind\nfrom knowcode.parsers.javascript_parser import JavaScriptParser\n    import { something } from 'external-module';", "tokens": ["from", "pathlib", "import", "path", "from", "knowcode", "data", "models", "import", "entity", "kind", "relationship", "kind", "from", "knowcode", "parsers", "javascript", "parser", "import", "java", "script", "parser", "import", "something", "from", "external", "module"], "metadata": {"type": "imports"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/parsers/test_javascript_parser.py::test_parse_simple_js::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/parsers/test_javascript_parser.py::test_parse_simple_js", "content": "def test_parse_simple_js(tmp_path: Path) -> None\n\"\"\"Test parsing a simple JavaScript file.\"\"\"\ndef test_parse_simple_js(tmp_path: Path) -> None:\n    \"\"\"Test parsing a simple JavaScript file.\"\"\"\n    source = \"\"\"\n    import { something } from 'external-module';\n\n    class MyClass {\n        constructor() {}\n\n        myMethod() {\n            something();\n        }\n    }\n\n    function globalFunc() {\n        const x = new MyClass();\n    }\n    \"\"\"\n    \n    file_path = tmp_path / \"test.js\"\n    file_path.write_text(source, encoding=\"utf-8\")\n    \n    parser = JavaScriptParser()\n    result = parser.parse_file(file_path)\n    \n    assert not result.errors\n    \n    # Check entities\n    entities = {e.qualified_name: e for e in result.entities}\n    assert \"MyClass\" in entities\n    assert entities[\"MyClass\"].kind == EntityKind.CLASS\n    \n    # Check method (might be MyClass.myMethod or just myMethod dependent on implementation details)\n    # Our implementation uses qualified names\n    assert \"MyClass.my", "tokens": ["def", "test", "parse", "simple", "js", "tmp", "path", "path", "none", "test", "parsing", "simple", "java", "script", "file", "def", "test", "parse", "simple", "js", "tmp", "path", "path", "none", "test", "parsing", "simple", "java", "script", "file", "source", "import", "something", "from", "external", "module", "class", "my", "class", "constructor", "my", "method", "something", "function", "global", "func", "const", "new", "my", "class", "file", "path", "tmp", "path", "test", "js", "file", "path", "write", "text", "source", "encoding", "utf", "parser", "java", "script", "parser", "result", "parser", "parse", "file", "file", "path", "assert", "not", "result", "errors", "check", "entities", "entities", "qualified", "name", "for", "in", "result", "entities", "assert", "my", "class", "in", "entities", "assert", "entities", "my", "class", "kind", "entity", "kind", "class", "check", "method", "might", "be", "my", "class", "my", "method", "or", "just", "my", "method", "dependent", "on", "implementation", "details", "our", "implementation", "uses", "qualified", "names", "assert", "my", "class", "my"], "metadata": {"kind": "function", "chunk_index": "0", "has_docstring": "true", "last_modified": "1766236633.3726954"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/parsers/test_javascript_parser.py::test_parse_simple_js::1", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/parsers/test_javascript_parser.py::test_parse_simple_js", "content": "dent on implementation details)\n    # Our implementation uses qualified names\n    assert \"MyClass.myMethod\" in entities\n    assert entities[\"MyClass.myMethod\"].kind == EntityKind.METHOD\n    \n    assert \"globalFunc\" in entities\n    assert entities[\"globalFunc\"].kind == EntityKind.FUNCTION\n    \n    # Check relationships\n    rels = result.relationships\n    \n    # Import\n    imports = [r for r in rels if r.kind == RelationshipKind.IMPORTS]\n    assert len(imports) == 1\n    assert imports[0].target_id == \"external::external-module\"\n    \n    # Calls\n    calls = [r for r in rels if r.kind == RelationshipKind.CALLS]\n    # something() inside myMethod\n    # new MyClass() inside globalFunc (constructor call)\n    \n    targets = {r.target_id for r in calls}\n    assert \"ref::something\" in targets", "tokens": ["dent", "on", "implementation", "details", "our", "implementation", "uses", "qualified", "names", "assert", "my", "class", "my", "method", "in", "entities", "assert", "entities", "my", "class", "my", "method", "kind", "entity", "kind", "method", "assert", "global", "func", "in", "entities", "assert", "entities", "global", "func", "kind", "entity", "kind", "function", "check", "relationships", "rels", "result", "relationships", "import", "imports", "for", "in", "rels", "if", "kind", "relationship", "kind", "imports", "assert", "len", "imports", "assert", "imports", "target", "id", "external", "external", "module", "calls", "calls", "for", "in", "rels", "if", "kind", "relationship", "kind", "calls", "something", "inside", "my", "method", "new", "my", "class", "inside", "global", "func", "constructor", "call", "targets", "target", "id", "for", "in", "calls", "assert", "ref", "something", "in", "targets"], "metadata": {"kind": "function", "chunk_index": "1", "has_docstring": "true", "last_modified": "1766236633.3726954"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/analysis/test_temporal.py::module::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/analysis/test_temporal.py::module", "content": "\"\"\"Tests for Temporal Integration.\"\"\"", "tokens": ["tests", "for", "temporal", "integration"], "metadata": {"type": "module_header"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/analysis/test_temporal.py::imports::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/analysis/test_temporal.py::module", "content": "import pytest\nfrom git import Repo, Actor\nfrom knowcode.analysis.temporal import TemporalAnalyzer\nfrom knowcode.data_models import EntityKind, RelationshipKind", "tokens": ["import", "pytest", "from", "git", "import", "repo", "actor", "from", "knowcode", "analysis", "temporal", "import", "temporal", "analyzer", "from", "knowcode", "data", "models", "import", "entity", "kind", "relationship", "kind"], "metadata": {"type": "imports"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/analysis/test_temporal.py::git_repo::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/analysis/test_temporal.py::git_repo", "content": "def git_repo(tmp_path)\n\"\"\"Create a temporary git repo with history.\"\"\"\ndef git_repo(tmp_path):\n    \"\"\"Create a temporary git repo with history.\"\"\"\n    repo_dir = tmp_path / \"repo\"\n    repo_dir.mkdir()\n    \n    repo = Repo.init(repo_dir)\n    author = Actor(\"Test User\", \"test@example.com\")\n    committer = Actor(\"Test User\", \"test@example.com\")\n    \n    # Commit 1: Add file\n    file1 = repo_dir / \"file1.py\"\n    file1.write_text(\"print('hello')\", encoding=\"utf-8\")\n    repo.index.add([str(file1)])\n    repo.index.commit(\"Initial commit\", author=author, committer=committer)\n    \n    # Commit 2: Modify file\n    file1.write_text(\"print('hello world')\", encoding=\"utf-8\")\n    repo.index.add([str(file1)])\n    repo.index.commit(\"Update file1\", author=author, committer=committer)\n    \n    return repo_dir", "tokens": ["def", "git", "repo", "tmp", "path", "create", "temporary", "git", "repo", "with", "history", "def", "git", "repo", "tmp", "path", "create", "temporary", "git", "repo", "with", "history", "repo", "dir", "tmp", "path", "repo", "repo", "dir", "mkdir", "repo", "repo", "init", "repo", "dir", "author", "actor", "test", "user", "test", "example", "com", "committer", "actor", "test", "user", "test", "example", "com", "commit", "add", "file", "file1", "repo", "dir", "file1", "py", "file1", "write", "text", "print", "hello", "encoding", "utf", "repo", "index", "add", "str", "file1", "repo", "index", "commit", "initial", "commit", "author", "author", "committer", "committer", "commit", "modify", "file", "file1", "write", "text", "print", "hello", "world", "encoding", "utf", "repo", "index", "add", "str", "file1", "repo", "index", "commit", "update", "file1", "author", "author", "committer", "committer", "return", "repo", "dir"], "metadata": {"kind": "function", "has_docstring": "true", "last_modified": "1766236633.3726954"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/analysis/test_temporal.py::test_temporal_analysis::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/analysis/test_temporal.py::test_temporal_analysis", "content": "def test_temporal_analysis(git_repo)\n\"\"\"Test standard temporal analysis.\"\"\"\ndef test_temporal_analysis(git_repo):\n    \"\"\"Test standard temporal analysis.\"\"\"\n    analyzer = TemporalAnalyzer(git_repo)\n    result = analyzer.analyze_history()\n    \n    assert not result.errors\n    \n    # Valid Commits\n    commits = [e for e in result.entities if e.kind == EntityKind.COMMIT]\n    assert len(commits) == 2\n    \n    # Validate Author\n    authors = {e.id for e in result.entities if e.kind == EntityKind.AUTHOR}\n    assert len(authors) == 1\n    # Check name on one of them\n    author_ent = next(e for e in result.entities if e.kind == EntityKind.AUTHOR)\n    assert author_ent.name == \"Test User\"\n    \n    # Validate Relationships\n    # Author -> Authored -> Commit\n    authored_rels = [r for r in result.relationships if r.kind == RelationshipKind.AUTHORED]\n    assert len(authored_rels) == 2 # 2 commits by same author\n    \n    # Commit -> Modified -> File\n    # We need to check if proper IDs are generate", "tokens": ["def", "test", "temporal", "analysis", "git", "repo", "test", "standard", "temporal", "analysis", "def", "test", "temporal", "analysis", "git", "repo", "test", "standard", "temporal", "analysis", "analyzer", "temporal", "analyzer", "git", "repo", "result", "analyzer", "analyze", "history", "assert", "not", "result", "errors", "valid", "commits", "commits", "for", "in", "result", "entities", "if", "kind", "entity", "kind", "commit", "assert", "len", "commits", "validate", "author", "authors", "id", "for", "in", "result", "entities", "if", "kind", "entity", "kind", "author", "assert", "len", "authors", "check", "name", "on", "one", "of", "them", "author", "ent", "next", "for", "in", "result", "entities", "if", "kind", "entity", "kind", "author", "assert", "author", "ent", "name", "test", "user", "validate", "relationships", "author", "authored", "commit", "authored", "rels", "for", "in", "result", "relationships", "if", "kind", "relationship", "kind", "authored", "assert", "len", "authored", "rels", "commits", "by", "same", "author", "commit", "modified", "file", "we", "need", "to", "check", "if", "proper", "ids", "are", "generate"], "metadata": {"kind": "function", "chunk_index": "0", "has_docstring": "true", "last_modified": "1766236633.3726954"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/analysis/test_temporal.py::test_temporal_analysis::1", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/analysis/test_temporal.py::test_temporal_analysis", "content": " same author\n    \n    # Commit -> Modified -> File\n    # We need to check if proper IDs are generated. \n    # file1.py should be targeted.\n    modified_rels = [r for r in result.relationships if r.kind == RelationshipKind.MODIFIED]\n    assert len(modified_rels) >= 1\n    \n    # Check if target ID looks right (should be absolute path)\n    target_id = modified_rels[-1].target_id # Latest modification\n    assert \"file1.py\" in target_id\n    assert \"::file1\" in target_id\n    \n    # CHANGED_BY (Entity -> Commit)\n    changed_by_rels = [r for r in result.relationships if r.kind == RelationshipKind.CHANGED_BY]\n    assert len(changed_by_rels) >= 1\n    assert changed_by_rels[0].source_id == target_id", "tokens": ["same", "author", "commit", "modified", "file", "we", "need", "to", "check", "if", "proper", "ids", "are", "generated", "file1", "py", "should", "be", "targeted", "modified", "rels", "for", "in", "result", "relationships", "if", "kind", "relationship", "kind", "modified", "assert", "len", "modified", "rels", "check", "if", "target", "id", "looks", "right", "should", "be", "absolute", "path", "target", "id", "modified", "rels", "target", "id", "latest", "modification", "assert", "file1", "py", "in", "target", "id", "assert", "file1", "in", "target", "id", "changed", "by", "entity", "commit", "changed", "by", "rels", "for", "in", "result", "relationships", "if", "kind", "relationship", "kind", "changed", "by", "assert", "len", "changed", "by", "rels", "assert", "changed", "by", "rels", "source", "id", "target", "id"], "metadata": {"kind": "function", "chunk_index": "1", "has_docstring": "true", "last_modified": "1766236633.3726954"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/analysis/test_signals.py::module::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/analysis/test_signals.py::module", "content": "\"\"\"Tests for Signal Ingestion.\"\"\"", "tokens": ["tests", "for", "signal", "ingestion"], "metadata": {"type": "module_header"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/analysis/test_signals.py::imports::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/analysis/test_signals.py::module", "content": "import pytest\nfrom knowcode.analysis.signals import CoverageProcessor\nfrom knowcode.data_models import EntityKind, RelationshipKind", "tokens": ["import", "pytest", "from", "knowcode", "analysis", "signals", "import", "coverage", "processor", "from", "knowcode", "data", "models", "import", "entity", "kind", "relationship", "kind"], "metadata": {"type": "imports"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/analysis/test_signals.py::coverage_xml::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/analysis/test_signals.py::coverage_xml", "content": "def coverage_xml(tmp_path)\n\"\"\"Create a sample coverage.xml.\"\"\"\ndef coverage_xml(tmp_path):\n    \"\"\"Create a sample coverage.xml.\"\"\"\n    content = \"\"\"<?xml version=\"1.0\" ?>\n    <coverage line-rate=\"0.5\" branch-rate=\"0.0\" lines-covered=\"10\" lines-valid=\"20\" timestamp=\"123456789\">\n        <packages>\n            <package name=\"my_package\" line-rate=\"0.5\" branch-rate=\"0.0\" complexity=\"0.0\">\n                <classes>\n                    <class name=\"module_a\" filename=\"module_a.py\" line-rate=\"1.0\" branch-rate=\"0.0\" complexity=\"0.0\" lines-covered=\"5\" lines-valid=\"5\">\n                        <lines>\n                            <line hits=\"1\" number=\"1\"/>\n                            <line hits=\"1\" number=\"2\"/>\n                        </lines>\n                    </class>\n                    <class name=\"module_b\" filename=\"module_b.py\" line-rate=\"0.0\" branch-rate=\"0.0\" complexity=\"0.0\" lines-covered=\"0\" lines-valid=\"5\">\n                         <lines>\n                            <line hits=\"0\" ", "tokens": ["def", "coverage", "xml", "tmp", "path", "create", "sample", "coverage", "xml", "def", "coverage", "xml", "tmp", "path", "create", "sample", "coverage", "xml", "content", "xml", "version", "coverage", "line", "rate", "branch", "rate", "lines", "covered", "10", "lines", "valid", "20", "timestamp", "123456789", "packages", "package", "name", "my", "package", "line", "rate", "branch", "rate", "complexity", "classes", "class", "name", "module", "filename", "module", "py", "line", "rate", "branch", "rate", "complexity", "lines", "covered", "lines", "valid", "lines", "line", "hits", "number", "line", "hits", "number", "lines", "class", "class", "name", "module", "filename", "module", "py", "line", "rate", "branch", "rate", "complexity", "lines", "covered", "lines", "valid", "lines", "line", "hits"], "metadata": {"kind": "function", "chunk_index": "0", "has_docstring": "true", "last_modified": "1766236633.3726954"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/analysis/test_signals.py::coverage_xml::1", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/analysis/test_signals.py::coverage_xml", "content": "ed=\"0\" lines-valid=\"5\">\n                         <lines>\n                            <line hits=\"0\" number=\"1\"/>\n                        </lines>\n                    </class>\n                </classes>\n            </package>\n        </packages>\n    </coverage>\n    \"\"\"\n    path = tmp_path / \"coverage.xml\"\n    path.write_text(content, encoding=\"utf-8\")\n    return path", "tokens": ["ed", "lines", "valid", "lines", "line", "hits", "number", "lines", "class", "classes", "package", "packages", "coverage", "path", "tmp", "path", "coverage", "xml", "path", "write", "text", "content", "encoding", "utf", "return", "path"], "metadata": {"kind": "function", "chunk_index": "1", "has_docstring": "true", "last_modified": "1766236633.3726954"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/analysis/test_signals.py::test_process_cobertura::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/analysis/test_signals.py::test_process_cobertura", "content": "def test_process_cobertura(tmp_path, coverage_xml)\n\"\"\"Test Cobertura XML processing.\"\"\"\ndef test_process_cobertura(tmp_path, coverage_xml):\n    \"\"\"Test Cobertura XML processing.\"\"\"\n    # Create dummy files so they resolve\n    (tmp_path / \"module_a.py\").touch()\n    (tmp_path / \"module_b.py\").touch()\n    \n    processor = CoverageProcessor(tmp_path)\n    result = processor.process_cobertura(coverage_xml)\n    \n    assert not result.errors\n    \n    # Check Report Entity\n    reports = [e for e in result.entities if e.kind == EntityKind.COVERAGE_REPORT]\n    assert len(reports) == 1\n    report = reports[0]\n    assert report.name == \"Coverage Report (coverage.xml)\"\n    assert report.metadata[\"line-rate\"] == \"0.5\"\n    \n    # Check Relationships\n    # Report -> COVERS -> Module A\n    covers_rels = [r for r in result.relationships if r.kind == RelationshipKind.COVERS]\n    assert len(covers_rels) == 2 # module_a and module_b\n    \n    # Verify module IDs are correct (absolute path)\n    targets = {r.t", "tokens": ["def", "test", "process", "cobertura", "tmp", "path", "coverage", "xml", "test", "cobertura", "xml", "processing", "def", "test", "process", "cobertura", "tmp", "path", "coverage", "xml", "test", "cobertura", "xml", "processing", "create", "dummy", "files", "so", "they", "resolve", "tmp", "path", "module", "py", "touch", "tmp", "path", "module", "py", "touch", "processor", "coverage", "processor", "tmp", "path", "result", "processor", "process", "cobertura", "coverage", "xml", "assert", "not", "result", "errors", "check", "report", "entity", "reports", "for", "in", "result", "entities", "if", "kind", "entity", "kind", "coverage", "report", "assert", "len", "reports", "report", "reports", "assert", "report", "name", "coverage", "report", "coverage", "xml", "assert", "report", "metadata", "line", "rate", "check", "relationships", "report", "covers", "module", "covers", "rels", "for", "in", "result", "relationships", "if", "kind", "relationship", "kind", "covers", "assert", "len", "covers", "rels", "module", "and", "module", "verify", "module", "ids", "are", "correct", "absolute", "path", "targets"], "metadata": {"kind": "function", "chunk_index": "0", "has_docstring": "true", "last_modified": "1766236633.3726954"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/analysis/test_signals.py::test_process_cobertura::1", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/analysis/test_signals.py::test_process_cobertura", "content": " # module_a and module_b\n    \n    # Verify module IDs are correct (absolute path)\n    targets = {r.target_id for r in covers_rels}\n    assert any(\"module_a.py\" in t for t in targets)\n    assert any(\"module_b.py\" in t for t in targets)\n    \n    # Check metadata on relationships\n    rel_a = next(r for r in result.relationships if \"module_a.py\" in r.target_id and r.kind == RelationshipKind.COVERS)\n    assert rel_a.metadata[\"line-rate\"] == \"1.0\"\n    assert rel_a.metadata[\"hits\"] == \"5/5\"", "tokens": ["module", "and", "module", "verify", "module", "ids", "are", "correct", "absolute", "path", "targets", "target", "id", "for", "in", "covers", "rels", "assert", "any", "module", "py", "in", "for", "in", "targets", "assert", "any", "module", "py", "in", "for", "in", "targets", "check", "metadata", "on", "relationships", "rel", "next", "for", "in", "result", "relationships", "if", "module", "py", "in", "target", "id", "and", "kind", "relationship", "kind", "covers", "assert", "rel", "metadata", "line", "rate", "assert", "rel", "metadata", "hits"], "metadata": {"kind": "function", "chunk_index": "1", "has_docstring": "true", "last_modified": "1766236633.3726954"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/analysis/test_token_optimization.py::module::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/analysis/test_token_optimization.py::module", "content": "\"\"\"Tests for Token Counter and Context Synthesizer.\"\"\"", "tokens": ["tests", "for", "token", "counter", "and", "context", "synthesizer"], "metadata": {"type": "module_header"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/analysis/test_token_optimization.py::imports::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/analysis/test_token_optimization.py::module", "content": "from unittest.mock import MagicMock\nfrom knowcode.utils.token_counter import TokenCounter\nfrom knowcode.analysis.context_synthesizer import ContextSynthesizer\nfrom knowcode.data_models import Entity, EntityKind, Location", "tokens": ["from", "unittest", "mock", "import", "magic", "mock", "from", "knowcode", "utils", "token", "counter", "import", "token", "counter", "from", "knowcode", "analysis", "context", "synthesizer", "import", "context", "synthesizer", "from", "knowcode", "data", "models", "import", "entity", "entity", "kind", "location"], "metadata": {"type": "imports"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/analysis/test_token_optimization.py::test_token_counter::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/analysis/test_token_optimization.py::test_token_counter", "content": "def test_token_counter()\n\"\"\"Test functionality of TokenCounter.\"\"\"\ndef test_token_counter():\n    \"\"\"Test functionality of TokenCounter.\"\"\"\n    counter = TokenCounter()\n    \n    text = \"Hello world\"\n    tokens = counter.count_tokens(text)\n    assert tokens > 0\n    \n    truncated = counter.truncate(text, max_tokens=1)\n    assert counter.count_tokens(truncated) == 1\n    assert truncated != text", "tokens": ["def", "test", "token", "counter", "test", "functionality", "of", "token", "counter", "def", "test", "token", "counter", "test", "functionality", "of", "token", "counter", "counter", "token", "counter", "text", "hello", "world", "tokens", "counter", "count", "tokens", "text", "assert", "tokens", "truncated", "counter", "truncate", "text", "max", "tokens", "assert", "counter", "count", "tokens", "truncated", "assert", "truncated", "text"], "metadata": {"kind": "function", "has_docstring": "true", "last_modified": "1766236633.3726954"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/analysis/test_token_optimization.py::test_context_synthesizer_budget::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/analysis/test_token_optimization.py::test_context_synthesizer_budget", "content": "def test_context_synthesizer_budget()\n\"\"\"Test standard budgeting logic.\"\"\"\ndef test_context_synthesizer_budget():\n    \"\"\"Test standard budgeting logic.\"\"\"\n    store = MagicMock()\n    \n    # Create a mock entity with huge source code\n    large_code = \"print('hello')\\n\" * 1000\n    entity = Entity(\n        id=\"test::Foo\",\n        kind=EntityKind.CLASS,\n        name=\"Foo\",\n        qualified_name=\"Foo\",\n        location=Location(\"test.py\", 1, 1000),\n        source_code=large_code\n    )\n    store.get_entity.return_value = entity\n    store.get_parent.return_value = None\n    store.get_callers.return_value = []\n    store.get_callees.return_value = []\n    store.get_children.return_value = []\n    \n    # Low budget\n    synthesizer = ContextSynthesizer(store, max_tokens=50)\n    bundle = synthesizer.synthesize(\"test::Foo\")\n    \n    assert bundle is not None\n    assert bundle.total_tokens <= 50\n    assert bundle.truncated is True", "tokens": ["def", "test", "context", "synthesizer", "budget", "test", "standard", "budgeting", "logic", "def", "test", "context", "synthesizer", "budget", "test", "standard", "budgeting", "logic", "store", "magic", "mock", "create", "mock", "entity", "with", "huge", "source", "code", "large", "code", "print", "hello", "1000", "entity", "entity", "id", "test", "foo", "kind", "entity", "kind", "class", "name", "foo", "qualified", "name", "foo", "location", "location", "test", "py", "1000", "source", "code", "large", "code", "store", "get", "entity", "return", "value", "entity", "store", "get", "parent", "return", "value", "none", "store", "get", "callers", "return", "value", "store", "get", "callees", "return", "value", "store", "get", "children", "return", "value", "low", "budget", "synthesizer", "context", "synthesizer", "store", "max", "tokens", "50", "bundle", "synthesizer", "synthesize", "test", "foo", "assert", "bundle", "is", "not", "none", "assert", "bundle", "total", "tokens", "50", "assert", "bundle", "truncated", "is", "true"], "metadata": {"kind": "function", "has_docstring": "true", "last_modified": "1766236633.3726954"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/analysis/test_token_optimization.py::test_context_synthesizer_priority::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/analysis/test_token_optimization.py::test_context_synthesizer_priority", "content": "def test_context_synthesizer_priority()\n\"\"\"Test that header is preserved even if code is truncated.\"\"\"\ndef test_context_synthesizer_priority():\n    \"\"\"Test that header is preserved even if code is truncated.\"\"\"\n    store = MagicMock()\n    \n    entity = Entity(\n        id=\"test::Bar\",\n        kind=EntityKind.FUNCTION,\n        name=\"bar\",\n        qualified_name=\"bar\",\n        location=Location(\"test.py\", 1, 10),\n        source_code=\"def bar():\\n    pass # very long code...\",\n        docstring=\"Checks that header is kept.\"\n    )\n    store.get_entity.return_value = entity\n    store.get_parent.return_value = None\n    store.get_callers.return_value = []\n    store.get_callees.return_value = []\n    store.get_children.return_value = []\n    \n    synthesizer = ContextSynthesizer(store, max_tokens=100)\n    bundle = synthesizer.synthesize(\"test::Bar\")\n    \n    assert bundle is not None\n    # Ensure header info is present\n    assert \"# Function: `bar`\" in bundle.context_text\n    assert \"**File**: `t", "tokens": ["def", "test", "context", "synthesizer", "priority", "test", "that", "header", "is", "preserved", "even", "if", "code", "is", "truncated", "def", "test", "context", "synthesizer", "priority", "test", "that", "header", "is", "preserved", "even", "if", "code", "is", "truncated", "store", "magic", "mock", "entity", "entity", "id", "test", "bar", "kind", "entity", "kind", "function", "name", "bar", "qualified", "name", "bar", "location", "location", "test", "py", "10", "source", "code", "def", "bar", "pass", "very", "long", "code", "docstring", "checks", "that", "header", "is", "kept", "store", "get", "entity", "return", "value", "entity", "store", "get", "parent", "return", "value", "none", "store", "get", "callers", "return", "value", "store", "get", "callees", "return", "value", "store", "get", "children", "return", "value", "synthesizer", "context", "synthesizer", "store", "max", "tokens", "100", "bundle", "synthesizer", "synthesize", "test", "bar", "assert", "bundle", "is", "not", "none", "ensure", "header", "info", "is", "present", "assert", "function", "bar", "in", "bundle", "context", "text", "assert", "file"], "metadata": {"kind": "function", "chunk_index": "0", "has_docstring": "true", "last_modified": "1766236633.3726954"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/analysis/test_token_optimization.py::test_context_synthesizer_priority::1", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/analysis/test_token_optimization.py::test_context_synthesizer_priority", "content": "eader info is present\n    assert \"# Function: `bar`\" in bundle.context_text\n    assert \"**File**: `test.py`\" in bundle.context_text", "tokens": ["eader", "info", "is", "present", "assert", "function", "bar", "in", "bundle", "context", "text", "assert", "file", "test", "py", "in", "bundle", "context", "text"], "metadata": {"kind": "function", "chunk_index": "1", "has_docstring": "true", "last_modified": "1766236633.3726954"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/mcp/test_mcp_server_tools.py::module::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/mcp/test_mcp_server_tools.py::module", "content": "\"\"\"Unit tests for MCP tool routing without requiring the mcp package.\"\"\"", "tokens": ["unit", "tests", "for", "mcp", "tool", "routing", "without", "requiring", "the", "mcp", "package"], "metadata": {"type": "module_header"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/mcp/test_mcp_server_tools.py::imports::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/mcp/test_mcp_server_tools.py::module", "content": "from __future__ import annotations\nimport json\nfrom pathlib import Path\nfrom knowcode.mcp.server import KnowCodeMCPServer\nfrom knowcode.data_models import Entity, EntityKind, Location", "tokens": ["from", "future", "import", "annotations", "import", "json", "from", "pathlib", "import", "path", "from", "knowcode", "mcp", "server", "import", "know", "code", "mcpserver", "from", "knowcode", "data", "models", "import", "entity", "entity", "kind", "location"], "metadata": {"type": "imports"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/mcp/test_mcp_server_tools.py::DummyService::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/mcp/test_mcp_server_tools.py::DummyService", "content": "\"\"\"Dummy service for testing retrieve_context_for_query.\"\"\"\nclass DummyService:\n    \"\"\"Dummy service for testing retrieve_context_for_query.\"\"\"\n\n    def __init__(self) -> None:\n        self.calls: list[tuple[str, dict]] = []\n\n    def retrieve_context_for_query(self, query: str, **kwargs):  # noqa: ANN001\n        self.calls.append((\"retrieve_context_for_query\", {\"query\": query, **kwargs}))\n        return {\n            \"query\": query,\n            \"task_type\": \"explain\",\n            \"task_confidence\": 1.0,\n            \"retrieval_mode\": \"semantic\",\n            \"context_text\": \"CTX\",\n            \"total_tokens\": 10,\n            \"max_tokens\": kwargs.get(\"max_tokens\", 6000),\n            \"truncated\": False,\n            \"sufficiency_score\": 0.9,\n            \"selected_entities\": [{\"entity_id\": \"e1\"}],\n            \"evidence\": [],\n            \"errors\": [],\n        }", "tokens": ["dummy", "service", "for", "testing", "retrieve", "context", "for", "query", "class", "dummy", "service", "dummy", "service", "for", "testing", "retrieve", "context", "for", "query", "def", "init", "self", "none", "self", "calls", "list", "tuple", "str", "dict", "def", "retrieve", "context", "for", "query", "self", "query", "str", "kwargs", "noqa", "ann001", "self", "calls", "append", "retrieve", "context", "for", "query", "query", "query", "kwargs", "return", "query", "query", "task", "type", "explain", "task", "confidence", "retrieval", "mode", "semantic", "context", "text", "ctx", "total", "tokens", "10", "max", "tokens", "kwargs", "get", "max", "tokens", "6000", "truncated", "false", "sufficiency", "score", "selected", "entities", "entity", "id", "e1", "evidence", "errors"], "metadata": {"kind": "class", "has_docstring": "true", "last_modified": "1768273022.303234"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/mcp/test_mcp_server_tools.py::DummyService.__init__::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/mcp/test_mcp_server_tools.py::DummyService.__init__", "content": "def __init__(self) -> None\n    def __init__(self) -> None:\n        self.calls: list[tuple[str, dict]] = []", "tokens": ["def", "init", "self", "none", "def", "init", "self", "none", "self", "calls", "list", "tuple", "str", "dict"], "metadata": {"kind": "method", "has_docstring": "false", "last_modified": "1768273022.303234"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/mcp/test_mcp_server_tools.py::DummyService.retrieve_context_for_query::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/mcp/test_mcp_server_tools.py::DummyService.retrieve_context_for_query", "content": "def retrieve_context_for_query(self, query: str, **kwargs)\n    def retrieve_context_for_query(self, query: str, **kwargs):  # noqa: ANN001\n        self.calls.append((\"retrieve_context_for_query\", {\"query\": query, **kwargs}))\n        return {\n            \"query\": query,\n            \"task_type\": \"explain\",\n            \"task_confidence\": 1.0,\n            \"retrieval_mode\": \"semantic\",\n            \"context_text\": \"CTX\",\n            \"total_tokens\": 10,\n            \"max_tokens\": kwargs.get(\"max_tokens\", 6000),\n            \"truncated\": False,\n            \"sufficiency_score\": 0.9,\n            \"selected_entities\": [{\"entity_id\": \"e1\"}],\n            \"evidence\": [],\n            \"errors\": [],\n        }", "tokens": ["def", "retrieve", "context", "for", "query", "self", "query", "str", "kwargs", "def", "retrieve", "context", "for", "query", "self", "query", "str", "kwargs", "noqa", "ann001", "self", "calls", "append", "retrieve", "context", "for", "query", "query", "query", "kwargs", "return", "query", "query", "task", "type", "explain", "task", "confidence", "retrieval", "mode", "semantic", "context", "text", "ctx", "total", "tokens", "10", "max", "tokens", "kwargs", "get", "max", "tokens", "6000", "truncated", "false", "sufficiency", "score", "selected", "entities", "entity", "id", "e1", "evidence", "errors"], "metadata": {"kind": "method", "has_docstring": "false", "last_modified": "1768273022.303234"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/mcp/test_mcp_server_tools.py::MockStore::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/mcp/test_mcp_server_tools.py::MockStore", "content": "\"\"\"Mock knowledge store for testing.\"\"\"\nclass MockStore:\n    \"\"\"Mock knowledge store for testing.\"\"\"\n\n    def __init__(self) -> None:\n        self._entities = {\n            \"e1\": Entity(\n                id=\"e1\",\n                name=\"Foo\",\n                kind=EntityKind.FUNCTION,\n                qualified_name=\"module.Foo\",\n                location=Location(file_path=\"foo.py\", line_start=1, line_end=10),\n            ),\n            \"e2\": Entity(\n                id=\"e2\",\n                name=\"Bar\",\n                kind=EntityKind.CLASS,\n                qualified_name=\"module.Bar\",\n                location=Location(file_path=\"bar.py\", line_start=5, line_end=50),\n            ),\n        }\n\n    def search(self, query: str) -> list[Entity]:\n        return [e for e in self._entities.values() if query.lower() in e.name.lower()]\n\n    def get_entity(self, entity_id: str) -> Entity | None:\n        return self._entities.get(entity_id)\n\n    def trace_calls(\n        self, entity_id: str, direction: ", "tokens": ["mock", "knowledge", "store", "for", "testing", "class", "mock", "store", "mock", "knowledge", "store", "for", "testing", "def", "init", "self", "none", "self", "entities", "e1", "entity", "id", "e1", "name", "foo", "kind", "entity", "kind", "function", "qualified", "name", "module", "foo", "location", "location", "file", "path", "foo", "py", "line", "start", "line", "end", "10", "e2", "entity", "id", "e2", "name", "bar", "kind", "entity", "kind", "class", "qualified", "name", "module", "bar", "location", "location", "file", "path", "bar", "py", "line", "start", "line", "end", "50", "def", "search", "self", "query", "str", "list", "entity", "return", "for", "in", "self", "entities", "values", "if", "query", "lower", "in", "name", "lower", "def", "get", "entity", "self", "entity", "id", "str", "entity", "none", "return", "self", "entities", "get", "entity", "id", "def", "trace", "calls", "self", "entity", "id", "str", "direction"], "metadata": {"kind": "class", "chunk_index": "0", "has_docstring": "true", "last_modified": "1768273022.303234"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/mcp/test_mcp_server_tools.py::MockStore::1", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/mcp/test_mcp_server_tools.py::MockStore", "content": "return self._entities.get(entity_id)\n\n    def trace_calls(\n        self, entity_id: str, direction: str = \"callees\", depth: int = 1, max_results: int = 50\n    ) -> list[dict]:\n        return [\n            {\n                \"entity_id\": \"callee1\",\n                \"qualified_name\": \"module.callee1\",\n                \"kind\": \"function\",\n                \"file\": \"callee.py\",\n                \"line\": 10,\n                \"call_depth\": 1,\n            }\n        ]", "tokens": ["return", "self", "entities", "get", "entity", "id", "def", "trace", "calls", "self", "entity", "id", "str", "direction", "str", "callees", "depth", "int", "max", "results", "int", "50", "list", "dict", "return", "entity", "id", "callee1", "qualified", "name", "module", "callee1", "kind", "function", "file", "callee", "py", "line", "10", "call", "depth"], "metadata": {"kind": "class", "chunk_index": "1", "has_docstring": "true", "last_modified": "1768273022.303234"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/mcp/test_mcp_server_tools.py::MockStore.__init__::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/mcp/test_mcp_server_tools.py::MockStore.__init__", "content": "def __init__(self) -> None\n    def __init__(self) -> None:\n        self._entities = {\n            \"e1\": Entity(\n                id=\"e1\",\n                name=\"Foo\",\n                kind=EntityKind.FUNCTION,\n                qualified_name=\"module.Foo\",\n                location=Location(file_path=\"foo.py\", line_start=1, line_end=10),\n            ),\n            \"e2\": Entity(\n                id=\"e2\",\n                name=\"Bar\",\n                kind=EntityKind.CLASS,\n                qualified_name=\"module.Bar\",\n                location=Location(file_path=\"bar.py\", line_start=5, line_end=50),\n            ),\n        }", "tokens": ["def", "init", "self", "none", "def", "init", "self", "none", "self", "entities", "e1", "entity", "id", "e1", "name", "foo", "kind", "entity", "kind", "function", "qualified", "name", "module", "foo", "location", "location", "file", "path", "foo", "py", "line", "start", "line", "end", "10", "e2", "entity", "id", "e2", "name", "bar", "kind", "entity", "kind", "class", "qualified", "name", "module", "bar", "location", "location", "file", "path", "bar", "py", "line", "start", "line", "end", "50"], "metadata": {"kind": "method", "has_docstring": "false", "last_modified": "1768273022.303234"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/mcp/test_mcp_server_tools.py::MockStore.search::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/mcp/test_mcp_server_tools.py::MockStore.search", "content": "def search(self, query: str) -> list[Entity]\n    def search(self, query: str) -> list[Entity]:\n        return [e for e in self._entities.values() if query.lower() in e.name.lower()]", "tokens": ["def", "search", "self", "query", "str", "list", "entity", "def", "search", "self", "query", "str", "list", "entity", "return", "for", "in", "self", "entities", "values", "if", "query", "lower", "in", "name", "lower"], "metadata": {"kind": "method", "has_docstring": "false", "last_modified": "1768273022.303234"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/mcp/test_mcp_server_tools.py::MockStore.get_entity::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/mcp/test_mcp_server_tools.py::MockStore.get_entity", "content": "def get_entity(self, entity_id: str) -> Entity | None\n    def get_entity(self, entity_id: str) -> Entity | None:\n        return self._entities.get(entity_id)", "tokens": ["def", "get", "entity", "self", "entity", "id", "str", "entity", "none", "def", "get", "entity", "self", "entity", "id", "str", "entity", "none", "return", "self", "entities", "get", "entity", "id"], "metadata": {"kind": "method", "has_docstring": "false", "last_modified": "1768273022.303234"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/mcp/test_mcp_server_tools.py::MockStore.trace_calls::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/mcp/test_mcp_server_tools.py::MockStore.trace_calls", "content": "def trace_calls(self, entity_id: str, direction: str, depth: int, max_results: int) -> list[dict]\n    def trace_calls(\n        self, entity_id: str, direction: str = \"callees\", depth: int = 1, max_results: int = 50\n    ) -> list[dict]:\n        return [\n            {\n                \"entity_id\": \"callee1\",\n                \"qualified_name\": \"module.callee1\",\n                \"kind\": \"function\",\n                \"file\": \"callee.py\",\n                \"line\": 10,\n                \"call_depth\": 1,\n            }\n        ]", "tokens": ["def", "trace", "calls", "self", "entity", "id", "str", "direction", "str", "depth", "int", "max", "results", "int", "list", "dict", "def", "trace", "calls", "self", "entity", "id", "str", "direction", "str", "callees", "depth", "int", "max", "results", "int", "50", "list", "dict", "return", "entity", "id", "callee1", "qualified", "name", "module", "callee1", "kind", "function", "file", "callee", "py", "line", "10", "call", "depth"], "metadata": {"kind": "method", "has_docstring": "false", "last_modified": "1768273022.303234"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/mcp/test_mcp_server_tools.py::MockServiceWithStore::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/mcp/test_mcp_server_tools.py::MockServiceWithStore", "content": "\"\"\"Mock service with store for testing search_codebase and trace_calls.\"\"\"\nclass MockServiceWithStore:\n    \"\"\"Mock service with store for testing search_codebase and trace_calls.\"\"\"\n\n    def __init__(self, tmp_path: Path) -> None:\n        self.store = MockStore()\n        self.store_path = tmp_path  # Required by _ensure_store_ready\n        self.context_calls: list[tuple] = []\n\n    def get_context(self, target: str, max_tokens: int = 2000, task_type=None):  # noqa: ANN001\n        self.context_calls.append((target, max_tokens, task_type))\n        return {\n            \"entity_id\": target,\n            \"context_text\": f\"def {target}(): pass\",\n            \"total_tokens\": 5,\n            \"truncated\": False,\n            \"task_type\": task_type.value if task_type else \"general\",\n            \"sufficiency_score\": 0.85,\n        }", "tokens": ["mock", "service", "with", "store", "for", "testing", "search", "codebase", "and", "trace", "calls", "class", "mock", "service", "with", "store", "mock", "service", "with", "store", "for", "testing", "search", "codebase", "and", "trace", "calls", "def", "init", "self", "tmp", "path", "path", "none", "self", "store", "mock", "store", "self", "store", "path", "tmp", "path", "required", "by", "ensure", "store", "ready", "self", "context", "calls", "list", "tuple", "def", "get", "context", "self", "target", "str", "max", "tokens", "int", "2000", "task", "type", "none", "noqa", "ann001", "self", "context", "calls", "append", "target", "max", "tokens", "task", "type", "return", "entity", "id", "target", "context", "text", "def", "target", "pass", "total", "tokens", "truncated", "false", "task", "type", "task", "type", "value", "if", "task", "type", "else", "general", "sufficiency", "score", "85"], "metadata": {"kind": "class", "has_docstring": "true", "last_modified": "1768273022.303234"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/mcp/test_mcp_server_tools.py::MockServiceWithStore.__init__::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/mcp/test_mcp_server_tools.py::MockServiceWithStore.__init__", "content": "def __init__(self, tmp_path: Path) -> None\n    def __init__(self, tmp_path: Path) -> None:\n        self.store = MockStore()\n        self.store_path = tmp_path  # Required by _ensure_store_ready\n        self.context_calls: list[tuple] = []", "tokens": ["def", "init", "self", "tmp", "path", "path", "none", "def", "init", "self", "tmp", "path", "path", "none", "self", "store", "mock", "store", "self", "store", "path", "tmp", "path", "required", "by", "ensure", "store", "ready", "self", "context", "calls", "list", "tuple"], "metadata": {"kind": "method", "has_docstring": "false", "last_modified": "1768273022.303234"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/mcp/test_mcp_server_tools.py::MockServiceWithStore.get_context::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/mcp/test_mcp_server_tools.py::MockServiceWithStore.get_context", "content": "def get_context(self, target: str, max_tokens: int, task_type)\n    def get_context(self, target: str, max_tokens: int = 2000, task_type=None):  # noqa: ANN001\n        self.context_calls.append((target, max_tokens, task_type))\n        return {\n            \"entity_id\": target,\n            \"context_text\": f\"def {target}(): pass\",\n            \"total_tokens\": 5,\n            \"truncated\": False,\n            \"task_type\": task_type.value if task_type else \"general\",\n            \"sufficiency_score\": 0.85,\n        }", "tokens": ["def", "get", "context", "self", "target", "str", "max", "tokens", "int", "task", "type", "def", "get", "context", "self", "target", "str", "max", "tokens", "int", "2000", "task", "type", "none", "noqa", "ann001", "self", "context", "calls", "append", "target", "max", "tokens", "task", "type", "return", "entity", "id", "target", "context", "text", "def", "target", "pass", "total", "tokens", "truncated", "false", "task", "type", "task", "type", "value", "if", "task", "type", "else", "general", "sufficiency", "score", "85"], "metadata": {"kind": "method", "has_docstring": "false", "last_modified": "1768273022.303234"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/mcp/test_mcp_server_tools.py::test_handle_tool_call_retrieve_context_for_query::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/mcp/test_mcp_server_tools.py::test_handle_tool_call_retrieve_context_for_query", "content": "def test_handle_tool_call_retrieve_context_for_query(tmp_path: Path) -> None\n\"\"\"Test retrieve_context_for_query tool routing.\"\"\"\ndef test_handle_tool_call_retrieve_context_for_query(tmp_path: Path) -> None:\n    \"\"\"Test retrieve_context_for_query tool routing.\"\"\"\n    server = KnowCodeMCPServer(store_path=tmp_path)\n    dummy = DummyService()\n    server._ensure_service = lambda allow_missing_store=False: dummy  # type: ignore[method-assign]\n\n    payload = json.loads(\n        server.handle_tool_call(\n            \"retrieve_context_for_query\",\n            {\n                \"query\": \"Explain Foo\",\n                \"task_type\": \"auto\",\n                \"max_tokens\": 123,\n                \"limit_entities\": 2,\n                \"expand_deps\": True,\n            },\n        )\n    )\n\n    assert payload[\"query\"] == \"Explain Foo\"\n    assert dummy.calls and dummy.calls[0][0] == \"retrieve_context_for_query\"", "tokens": ["def", "test", "handle", "tool", "call", "retrieve", "context", "for", "query", "tmp", "path", "path", "none", "test", "retrieve", "context", "for", "query", "tool", "routing", "def", "test", "handle", "tool", "call", "retrieve", "context", "for", "query", "tmp", "path", "path", "none", "test", "retrieve", "context", "for", "query", "tool", "routing", "server", "know", "code", "mcpserver", "store", "path", "tmp", "path", "dummy", "dummy", "service", "server", "ensure", "service", "lambda", "allow", "missing", "store", "false", "dummy", "type", "ignore", "method", "assign", "payload", "json", "loads", "server", "handle", "tool", "call", "retrieve", "context", "for", "query", "query", "explain", "foo", "task", "type", "auto", "max", "tokens", "123", "limit", "entities", "expand", "deps", "true", "assert", "payload", "query", "explain", "foo", "assert", "dummy", "calls", "and", "dummy", "calls", "retrieve", "context", "for", "query"], "metadata": {"kind": "function", "has_docstring": "true", "last_modified": "1768273022.303234"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/mcp/test_mcp_server_tools.py::test_handle_tool_call_search_codebase::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/mcp/test_mcp_server_tools.py::test_handle_tool_call_search_codebase", "content": "def test_handle_tool_call_search_codebase(tmp_path: Path) -> None\n\"\"\"Test search_codebase tool routing (UC2-001).\"\"\"\ndef test_handle_tool_call_search_codebase(tmp_path: Path) -> None:\n    \"\"\"Test search_codebase tool routing (UC2-001).\"\"\"\n    # Create the store file to skip _ensure_store_ready analyze call\n    (tmp_path / \"knowcode_knowledge.json\").write_text(\"{}\")\n    \n    server = KnowCodeMCPServer(store_path=tmp_path)\n    mock_service = MockServiceWithStore(tmp_path)\n    server._ensure_service = lambda allow_missing_store=False: mock_service  # type: ignore[method-assign]\n\n    result = json.loads(\n        server.handle_tool_call(\"search_codebase\", {\"query\": \"Foo\", \"limit\": 5})\n    )\n\n    assert isinstance(result, list)\n    assert len(result) == 1\n    assert result[0][\"name\"] == \"Foo\"\n    assert result[0][\"kind\"] == \"function\"\n    assert result[0][\"qualified_name\"] == \"module.Foo\"\n    assert result[0][\"file\"] == \"foo.py\"\n    assert result[0][\"line\"] == 1", "tokens": ["def", "test", "handle", "tool", "call", "search", "codebase", "tmp", "path", "path", "none", "test", "search", "codebase", "tool", "routing", "uc2", "001", "def", "test", "handle", "tool", "call", "search", "codebase", "tmp", "path", "path", "none", "test", "search", "codebase", "tool", "routing", "uc2", "001", "create", "the", "store", "file", "to", "skip", "ensure", "store", "ready", "analyze", "call", "tmp", "path", "knowcode", "knowledge", "json", "write", "text", "server", "know", "code", "mcpserver", "store", "path", "tmp", "path", "mock", "service", "mock", "service", "with", "store", "tmp", "path", "server", "ensure", "service", "lambda", "allow", "missing", "store", "false", "mock", "service", "type", "ignore", "method", "assign", "result", "json", "loads", "server", "handle", "tool", "call", "search", "codebase", "query", "foo", "limit", "assert", "isinstance", "result", "list", "assert", "len", "result", "assert", "result", "name", "foo", "assert", "result", "kind", "function", "assert", "result", "qualified", "name", "module", "foo", "assert", "result", "file", "foo", "py", "assert", "result", "line"], "metadata": {"kind": "function", "has_docstring": "true", "last_modified": "1768273022.303234"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/mcp/test_mcp_server_tools.py::test_handle_tool_call_get_entity_context::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/mcp/test_mcp_server_tools.py::test_handle_tool_call_get_entity_context", "content": "def test_handle_tool_call_get_entity_context(tmp_path: Path) -> None\n\"\"\"Test get_entity_context tool routing (UC2-002).\"\"\"\ndef test_handle_tool_call_get_entity_context(tmp_path: Path) -> None:\n    \"\"\"Test get_entity_context tool routing (UC2-002).\"\"\"\n    # Create the store file to skip _ensure_store_ready analyze call\n    (tmp_path / \"knowcode_knowledge.json\").write_text(\"{}\")\n    \n    server = KnowCodeMCPServer(store_path=tmp_path)\n    mock_service = MockServiceWithStore(tmp_path)\n    server._ensure_service = lambda allow_missing_store=False: mock_service  # type: ignore[method-assign]\n\n    result = json.loads(\n        server.handle_tool_call(\n            \"get_entity_context\",\n            {\"entity_id\": \"e1\", \"task_type\": \"explain\", \"max_tokens\": 1000},\n        )\n    )\n\n    assert result[\"entity_id\"] == \"e1\"\n    assert result[\"sufficiency_score\"] == 0.85\n    assert result[\"task_type\"] == \"explain\"\n    assert result[\"qualified_name\"] == \"module.Foo\"\n    assert mock_service.context_calls", "tokens": ["def", "test", "handle", "tool", "call", "get", "entity", "context", "tmp", "path", "path", "none", "test", "get", "entity", "context", "tool", "routing", "uc2", "002", "def", "test", "handle", "tool", "call", "get", "entity", "context", "tmp", "path", "path", "none", "test", "get", "entity", "context", "tool", "routing", "uc2", "002", "create", "the", "store", "file", "to", "skip", "ensure", "store", "ready", "analyze", "call", "tmp", "path", "knowcode", "knowledge", "json", "write", "text", "server", "know", "code", "mcpserver", "store", "path", "tmp", "path", "mock", "service", "mock", "service", "with", "store", "tmp", "path", "server", "ensure", "service", "lambda", "allow", "missing", "store", "false", "mock", "service", "type", "ignore", "method", "assign", "result", "json", "loads", "server", "handle", "tool", "call", "get", "entity", "context", "entity", "id", "e1", "task", "type", "explain", "max", "tokens", "1000", "assert", "result", "entity", "id", "e1", "assert", "result", "sufficiency", "score", "85", "assert", "result", "task", "type", "explain", "assert", "result", "qualified", "name", "module", "foo", "assert", "mock", "service", "context", "calls"], "metadata": {"kind": "function", "chunk_index": "0", "has_docstring": "true", "last_modified": "1768273022.303234"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/mcp/test_mcp_server_tools.py::test_handle_tool_call_get_entity_context::1", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/mcp/test_mcp_server_tools.py::test_handle_tool_call_get_entity_context", "content": " \"explain\"\n    assert result[\"qualified_name\"] == \"module.Foo\"\n    assert mock_service.context_calls  # Verify service was called", "tokens": ["explain", "assert", "result", "qualified", "name", "module", "foo", "assert", "mock", "service", "context", "calls", "verify", "service", "was", "called"], "metadata": {"kind": "function", "chunk_index": "1", "has_docstring": "true", "last_modified": "1768273022.303234"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/mcp/test_mcp_server_tools.py::test_handle_tool_call_trace_calls::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/mcp/test_mcp_server_tools.py::test_handle_tool_call_trace_calls", "content": "def test_handle_tool_call_trace_calls(tmp_path: Path) -> None\n\"\"\"Test trace_calls tool routing (UC2-003).\"\"\"\ndef test_handle_tool_call_trace_calls(tmp_path: Path) -> None:\n    \"\"\"Test trace_calls tool routing (UC2-003).\"\"\"\n    # Create the store file to skip _ensure_store_ready analyze call\n    (tmp_path / \"knowcode_knowledge.json\").write_text(\"{}\")\n    \n    server = KnowCodeMCPServer(store_path=tmp_path)\n    mock_service = MockServiceWithStore(tmp_path)\n    server._ensure_service = lambda allow_missing_store=False: mock_service  # type: ignore[method-assign]\n\n    result = json.loads(\n        server.handle_tool_call(\n            \"trace_calls\",\n            {\"entity_id\": \"e1\", \"direction\": \"callees\", \"depth\": 2},\n        )\n    )\n\n    assert isinstance(result, list)\n    assert len(result) == 1\n    assert result[0][\"entity_id\"] == \"callee1\"\n    assert result[0][\"call_depth\"] == 1", "tokens": ["def", "test", "handle", "tool", "call", "trace", "calls", "tmp", "path", "path", "none", "test", "trace", "calls", "tool", "routing", "uc2", "003", "def", "test", "handle", "tool", "call", "trace", "calls", "tmp", "path", "path", "none", "test", "trace", "calls", "tool", "routing", "uc2", "003", "create", "the", "store", "file", "to", "skip", "ensure", "store", "ready", "analyze", "call", "tmp", "path", "knowcode", "knowledge", "json", "write", "text", "server", "know", "code", "mcpserver", "store", "path", "tmp", "path", "mock", "service", "mock", "service", "with", "store", "tmp", "path", "server", "ensure", "service", "lambda", "allow", "missing", "store", "false", "mock", "service", "type", "ignore", "method", "assign", "result", "json", "loads", "server", "handle", "tool", "call", "trace", "calls", "entity", "id", "e1", "direction", "callees", "depth", "assert", "isinstance", "result", "list", "assert", "len", "result", "assert", "result", "entity", "id", "callee1", "assert", "result", "call", "depth"], "metadata": {"kind": "function", "has_docstring": "true", "last_modified": "1768273022.303234"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/mcp/test_mcp_server_tools.py::test_handle_tool_call_unknown_tool_returns_error::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/mcp/test_mcp_server_tools.py::test_handle_tool_call_unknown_tool_returns_error", "content": "def test_handle_tool_call_unknown_tool_returns_error(tmp_path: Path) -> None\n\"\"\"Test unknown tool returns error (UC2-004).\"\"\"\ndef test_handle_tool_call_unknown_tool_returns_error(tmp_path: Path) -> None:\n    \"\"\"Test unknown tool returns error (UC2-004).\"\"\"\n    server = KnowCodeMCPServer(store_path=tmp_path)\n\n    result = json.loads(\n        server.handle_tool_call(\"nonexistent_tool\", {\"foo\": \"bar\"})\n    )\n\n    assert \"error\" in result\n    assert \"Unknown tool\" in result[\"error\"]", "tokens": ["def", "test", "handle", "tool", "call", "unknown", "tool", "returns", "error", "tmp", "path", "path", "none", "test", "unknown", "tool", "returns", "error", "uc2", "004", "def", "test", "handle", "tool", "call", "unknown", "tool", "returns", "error", "tmp", "path", "path", "none", "test", "unknown", "tool", "returns", "error", "uc2", "004", "server", "know", "code", "mcpserver", "store", "path", "tmp", "path", "result", "json", "loads", "server", "handle", "tool", "call", "nonexistent", "tool", "foo", "bar", "assert", "error", "in", "result", "assert", "unknown", "tool", "in", "result", "error"], "metadata": {"kind": "function", "has_docstring": "true", "last_modified": "1768273022.303234"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/models/test_models.py::module::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/models/test_models.py::module", "content": "\"\"\"Unit tests for core models.\"\"\"", "tokens": ["unit", "tests", "for", "core", "models"], "metadata": {"type": "module_header"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/models/test_models.py::imports::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/models/test_models.py::module", "content": "from knowcode.data_models import CodeChunk", "tokens": ["from", "knowcode", "data", "models", "import", "code", "chunk"], "metadata": {"type": "imports"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/models/test_models.py::test_code_chunk_defaults::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/models/test_models.py::test_code_chunk_defaults", "content": "def test_code_chunk_defaults() -> None\n\"\"\"CodeChunk defaults should be empty tokens and no embedding.\"\"\"\ndef test_code_chunk_defaults() -> None:\n    \"\"\"CodeChunk defaults should be empty tokens and no embedding.\"\"\"\n    chunk = CodeChunk(\n        id=\"test::chunk::0\",\n        entity_id=\"test::entity\",\n        content=\"def foo(): pass\",\n    )\n\n    assert chunk.id == \"test::chunk::0\"\n    assert chunk.tokens == []\n    assert chunk.embedding is None", "tokens": ["def", "test", "code", "chunk", "defaults", "none", "code", "chunk", "defaults", "should", "be", "empty", "tokens", "and", "no", "embedding", "def", "test", "code", "chunk", "defaults", "none", "code", "chunk", "defaults", "should", "be", "empty", "tokens", "and", "no", "embedding", "chunk", "code", "chunk", "id", "test", "chunk", "entity", "id", "test", "entity", "content", "def", "foo", "pass", "assert", "chunk", "id", "test", "chunk", "assert", "chunk", "tokens", "assert", "chunk", "embedding", "is", "none"], "metadata": {"kind": "function", "has_docstring": "true", "last_modified": "1766236633.3726954"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/utils/test_tokenizer.py::module::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/utils/test_tokenizer.py::module", "content": "\"\"\"Unit tests for code tokenization.\"\"\"", "tokens": ["unit", "tests", "for", "code", "tokenization"], "metadata": {"type": "module_header"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/utils/test_tokenizer.py::imports::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/utils/test_tokenizer.py::module", "content": "from knowcode.utils.tokenizer import tokenize_code", "tokens": ["from", "knowcode", "utils", "tokenizer", "import", "tokenize", "code"], "metadata": {"type": "imports"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/utils/test_tokenizer.py::test_tokenizer_splits_cases::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/utils/test_tokenizer.py::test_tokenizer_splits_cases", "content": "def test_tokenizer_splits_cases() -> None\ndef test_tokenizer_splits_cases() -> None:\n    tokens = tokenize_code(\"myFunctionName_snake_case\")\n    assert \"my\" in tokens\n    assert \"function\" in tokens\n    assert \"name\" in tokens\n    assert \"snake\" in tokens\n    assert \"case\" in tokens", "tokens": ["def", "test", "tokenizer", "splits", "cases", "none", "def", "test", "tokenizer", "splits", "cases", "none", "tokens", "tokenize", "code", "my", "function", "name", "snake", "case", "assert", "my", "in", "tokens", "assert", "function", "in", "tokens", "assert", "name", "in", "tokens", "assert", "snake", "in", "tokens", "assert", "case", "in", "tokens"], "metadata": {"kind": "function", "has_docstring": "false", "last_modified": "1766233147.1778471"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/utils/test_tokenizer.py::test_tokenizer_strips_punctuation::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/utils/test_tokenizer.py::test_tokenizer_strips_punctuation", "content": "def test_tokenizer_strips_punctuation() -> None\ndef test_tokenizer_strips_punctuation() -> None:\n    tokens = tokenize_code(\"foo(bar); baz.qux!\")\n    assert \"foo\" in tokens\n    assert \"bar\" in tokens\n    assert \"baz\" in tokens\n    assert \"qux\" in tokens", "tokens": ["def", "test", "tokenizer", "strips", "punctuation", "none", "def", "test", "tokenizer", "strips", "punctuation", "none", "tokens", "tokenize", "code", "foo", "bar", "baz", "qux", "assert", "foo", "in", "tokens", "assert", "bar", "in", "tokens", "assert", "baz", "in", "tokens", "assert", "qux", "in", "tokens"], "metadata": {"kind": "function", "has_docstring": "false", "last_modified": "1766233147.1778471"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/utils/test_token_counter.py::module::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/utils/test_token_counter.py::module", "content": "\"\"\"Unit tests for token counting.\"\"\"", "tokens": ["unit", "tests", "for", "token", "counting"], "metadata": {"type": "module_header"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/utils/test_token_counter.py::imports::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/utils/test_token_counter.py::module", "content": "from knowcode.utils.token_counter import TokenCounter", "tokens": ["from", "knowcode", "utils", "token", "counter", "import", "token", "counter"], "metadata": {"type": "imports"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/utils/test_token_counter.py::test_token_counter_unknown_model_fallback::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/utils/test_token_counter.py::test_token_counter_unknown_model_fallback", "content": "def test_token_counter_unknown_model_fallback() -> None\n\"\"\"Unknown models should fall back to a default encoding.\"\"\"\ndef test_token_counter_unknown_model_fallback() -> None:\n    \"\"\"Unknown models should fall back to a default encoding.\"\"\"\n    counter = TokenCounter(\"nonexistent-model\")\n    assert counter.count_tokens(\"hello world\") > 0", "tokens": ["def", "test", "token", "counter", "unknown", "model", "fallback", "none", "unknown", "models", "should", "fall", "back", "to", "default", "encoding", "def", "test", "token", "counter", "unknown", "model", "fallback", "none", "unknown", "models", "should", "fall", "back", "to", "default", "encoding", "counter", "token", "counter", "nonexistent", "model", "assert", "counter", "count", "tokens", "hello", "world"], "metadata": {"kind": "function", "has_docstring": "true", "last_modified": "1766233147.1778119"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/cli/test_cli.py::module::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/cli/test_cli.py::module", "content": "\"\"\"Unit tests for CLI commands.\"\"\"", "tokens": ["unit", "tests", "for", "cli", "commands"], "metadata": {"type": "module_header"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/cli/test_cli.py::imports::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/cli/test_cli.py::module", "content": "import json\nfrom click.testing import CliRunner\nfrom knowcode.cli import cli", "tokens": ["import", "json", "from", "click", "testing", "import", "cli", "runner", "from", "knowcode", "cli", "import", "cli"], "metadata": {"type": "imports"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/cli/test_cli.py::test_cli_analyze_query_stats_context::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/cli/test_cli.py::test_cli_analyze_query_stats_context", "content": "def test_cli_analyze_query_stats_context(tmp_path)\n\"\"\"Basic CLI commands should run against a temporary project.\"\"\"\ndef test_cli_analyze_query_stats_context(tmp_path):\n    \"\"\"Basic CLI commands should run against a temporary project.\"\"\"\n    (tmp_path / \"sample.py\").write_text(\"def foo():\\n    return 1\\n\", encoding=\"utf-8\")\n\n    runner = CliRunner()\n    analyze = runner.invoke(cli, [\"analyze\", str(tmp_path), \"--output\", str(tmp_path)])\n    assert analyze.exit_code == 0\n\n    store_path = tmp_path / \"knowcode_knowledge.json\"\n    data = json.loads(store_path.read_text(encoding=\"utf-8\"))\n    entity_id = next(iter(data[\"entities\"].keys()))\n\n    query = runner.invoke(cli, [\"query\", \"search\", \"foo\", \"--store\", str(tmp_path)])\n    assert query.exit_code == 0\n    assert \"foo\" in query.output\n\n    stats = runner.invoke(cli, [\"stats\", \"--store\", str(tmp_path)])\n    assert stats.exit_code == 0\n    assert \"Total Entities\" in stats.output\n\n    context = runner.invoke(cli, [\"context\", entity_id, \"--st", "tokens": ["def", "test", "cli", "analyze", "query", "stats", "context", "tmp", "path", "basic", "cli", "commands", "should", "run", "against", "temporary", "project", "def", "test", "cli", "analyze", "query", "stats", "context", "tmp", "path", "basic", "cli", "commands", "should", "run", "against", "temporary", "project", "tmp", "path", "sample", "py", "write", "text", "def", "foo", "return", "encoding", "utf", "runner", "cli", "runner", "analyze", "runner", "invoke", "cli", "analyze", "str", "tmp", "path", "output", "str", "tmp", "path", "assert", "analyze", "exit", "code", "store", "path", "tmp", "path", "knowcode", "knowledge", "json", "data", "json", "loads", "store", "path", "read", "text", "encoding", "utf", "entity", "id", "next", "iter", "data", "entities", "keys", "query", "runner", "invoke", "cli", "query", "search", "foo", "store", "str", "tmp", "path", "assert", "query", "exit", "code", "assert", "foo", "in", "query", "output", "stats", "runner", "invoke", "cli", "stats", "store", "str", "tmp", "path", "assert", "stats", "exit", "code", "assert", "total", "entities", "in", "stats", "output", "context", "runner", "invoke", "cli", "context", "entity", "id", "st"], "metadata": {"kind": "function", "chunk_index": "0", "has_docstring": "true", "last_modified": "1766233147.1773834"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/cli/test_cli.py::test_cli_analyze_query_stats_context::1", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/cli/test_cli.py::test_cli_analyze_query_stats_context", "content": "sert \"Total Entities\" in stats.output\n\n    context = runner.invoke(cli, [\"context\", entity_id, \"--store\", str(tmp_path), \"--max-tokens\", \"200\"])\n    assert context.exit_code == 0", "tokens": ["sert", "total", "entities", "in", "stats", "output", "context", "runner", "invoke", "cli", "context", "entity", "id", "store", "str", "tmp", "path", "max", "tokens", "200", "assert", "context", "exit", "code"], "metadata": {"kind": "function", "chunk_index": "1", "has_docstring": "true", "last_modified": "1766233147.1773834"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/indexing/test_scanner.py::module::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/indexing/test_scanner.py::module", "content": "\"\"\"Unit tests for the file scanner.\"\"\"", "tokens": ["unit", "tests", "for", "the", "file", "scanner"], "metadata": {"type": "module_header"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/indexing/test_scanner.py::imports::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/indexing/test_scanner.py::module", "content": "from pathlib import Path\nfrom knowcode.indexing.scanner import Scanner", "tokens": ["from", "pathlib", "import", "path", "from", "knowcode", "indexing", "scanner", "import", "scanner"], "metadata": {"type": "imports"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/indexing/test_scanner.py::test_scanner_respects_gitignore_and_extensions::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/indexing/test_scanner.py::test_scanner_respects_gitignore_and_extensions", "content": "def test_scanner_respects_gitignore_and_extensions(tmp_path: Path) -> None\n\"\"\"Scanner should respect ignore rules and extensions.\"\"\"\ndef test_scanner_respects_gitignore_and_extensions(tmp_path: Path) -> None:\n    \"\"\"Scanner should respect ignore rules and extensions.\"\"\"\n    (tmp_path / \".gitignore\").write_text(\"ignored.py\\n\", encoding=\"utf-8\")\n    (tmp_path / \"ignored.py\").write_text(\"print('ignore')\", encoding=\"utf-8\")\n    (tmp_path / \"skip.py\").write_text(\"print('skip')\", encoding=\"utf-8\")\n    (tmp_path / \"keep.py\").write_text(\"print('keep')\", encoding=\"utf-8\")\n    (tmp_path / \"note.txt\").write_text(\"text\", encoding=\"utf-8\")\n\n    scanner = Scanner(tmp_path, additional_ignores=[\"skip.py\"])\n    files = scanner.scan_all()\n    paths = {f.relative_path for f in files}\n\n    assert \"keep.py\" in paths\n    assert \"ignored.py\" not in paths\n    assert \"skip.py\" not in paths\n    assert \"note.txt\" not in paths", "tokens": ["def", "test", "scanner", "respects", "gitignore", "and", "extensions", "tmp", "path", "path", "none", "scanner", "should", "respect", "ignore", "rules", "and", "extensions", "def", "test", "scanner", "respects", "gitignore", "and", "extensions", "tmp", "path", "path", "none", "scanner", "should", "respect", "ignore", "rules", "and", "extensions", "tmp", "path", "gitignore", "write", "text", "ignored", "py", "encoding", "utf", "tmp", "path", "ignored", "py", "write", "text", "print", "ignore", "encoding", "utf", "tmp", "path", "skip", "py", "write", "text", "print", "skip", "encoding", "utf", "tmp", "path", "keep", "py", "write", "text", "print", "keep", "encoding", "utf", "tmp", "path", "note", "txt", "write", "text", "text", "encoding", "utf", "scanner", "scanner", "tmp", "path", "additional", "ignores", "skip", "py", "files", "scanner", "scan", "all", "paths", "relative", "path", "for", "in", "files", "assert", "keep", "py", "in", "paths", "assert", "ignored", "py", "not", "in", "paths", "assert", "skip", "py", "not", "in", "paths", "assert", "note", "txt", "not", "in", "paths"], "metadata": {"kind": "function", "has_docstring": "true", "last_modified": "1766233147.1775234"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/indexing/test_basic.py::module::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/indexing/test_basic.py::module", "content": "\"\"\"Basic smoke tests for KnowCode.\"\"\"", "tokens": ["basic", "smoke", "tests", "for", "know", "code"], "metadata": {"type": "module_header"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/indexing/test_basic.py::imports::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/indexing/test_basic.py::module", "content": "import tempfile\nfrom pathlib import Path\nfrom knowcode.indexing.graph_builder import GraphBuilder\nfrom knowcode.storage.knowledge_store import KnowledgeStore", "tokens": ["import", "tempfile", "from", "pathlib", "import", "path", "from", "knowcode", "indexing", "graph", "builder", "import", "graph", "builder", "from", "knowcode", "storage", "knowledge", "store", "import", "knowledge", "store"], "metadata": {"type": "imports"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/indexing/test_basic.py::test_python_parsing::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/indexing/test_basic.py::test_python_parsing", "content": "def test_python_parsing() -> None\n\"\"\"Test parsing a simple Python file.\"\"\"\ndef test_python_parsing() -> None:\n    \"\"\"Test parsing a simple Python file.\"\"\"\n    with tempfile.TemporaryDirectory() as tmpdir:\n        # Create a test file\n        test_file = Path(tmpdir) / \"test.py\"\n        test_file.write_text(\"\"\"\ndef hello(name: str) -> str:\n    '''Say hello.'''\n    return f\"Hello, {name}!\"\n\nclass Greeter:\n    '''A greeter class.'''\n    \n    def greet(self, name: str) -> str:\n        '''Greet someone.'''\n        return hello(name)\n\"\"\")\n\n        # Build graph\n        builder = GraphBuilder()\n        builder.build_from_directory(tmpdir)\n\n        # Verify entities\n        assert len(builder.entities) > 0\n        \n        # Check for function\n        functions = builder.get_entities_by_kind(\"function\")\n        assert len(functions) == 1\n        assert functions[0].name == \"hello\"\n        \n        # Check for class\n        classes = builder.get_entities_by_kind(\"class\")\n        assert len(clas", "tokens": ["def", "test", "python", "parsing", "none", "test", "parsing", "simple", "python", "file", "def", "test", "python", "parsing", "none", "test", "parsing", "simple", "python", "file", "with", "tempfile", "temporary", "directory", "as", "tmpdir", "create", "test", "file", "test", "file", "path", "tmpdir", "test", "py", "test", "file", "write", "text", "def", "hello", "name", "str", "str", "say", "hello", "return", "hello", "name", "class", "greeter", "greeter", "class", "def", "greet", "self", "name", "str", "str", "greet", "someone", "return", "hello", "name", "build", "graph", "builder", "graph", "builder", "builder", "build", "from", "directory", "tmpdir", "verify", "entities", "assert", "len", "builder", "entities", "check", "for", "function", "functions", "builder", "get", "entities", "by", "kind", "function", "assert", "len", "functions", "assert", "functions", "name", "hello", "check", "for", "class", "classes", "builder", "get", "entities", "by", "kind", "class", "assert", "len", "clas"], "metadata": {"kind": "function", "chunk_index": "0", "has_docstring": "true", "last_modified": "1766233147.1775234"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/indexing/test_basic.py::test_python_parsing::1", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/indexing/test_basic.py::test_python_parsing", "content": "   # Check for class\n        classes = builder.get_entities_by_kind(\"class\")\n        assert len(classes) == 1\n        assert classes[0].name == \"Greeter\"", "tokens": ["check", "for", "class", "classes", "builder", "get", "entities", "by", "kind", "class", "assert", "len", "classes", "assert", "classes", "name", "greeter"], "metadata": {"kind": "function", "chunk_index": "1", "has_docstring": "true", "last_modified": "1766233147.1775234"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/indexing/test_basic.py::test_knowledge_store_persistence::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/indexing/test_basic.py::test_knowledge_store_persistence", "content": "def test_knowledge_store_persistence() -> None\n\"\"\"Test saving and loading knowledge store.\"\"\"\ndef test_knowledge_store_persistence() -> None:\n    \"\"\"Test saving and loading knowledge store.\"\"\"\n    with tempfile.TemporaryDirectory() as tmpdir:\n        # Create a test file\n        test_file = Path(tmpdir) / \"test.py\"\n        test_file.write_text(\"def foo(): pass\")\n\n        # Build and save\n        builder = GraphBuilder()\n        builder.build_from_directory(tmpdir)\n        \n        store = KnowledgeStore.from_graph_builder(builder)\n        save_path = Path(tmpdir) / \"knowledge.json\"\n        store.save(save_path)\n\n        # Load and verify\n        loaded_store = KnowledgeStore.load(save_path)\n        assert len(loaded_store.entities) == len(store.entities)", "tokens": ["def", "test", "knowledge", "store", "persistence", "none", "test", "saving", "and", "loading", "knowledge", "store", "def", "test", "knowledge", "store", "persistence", "none", "test", "saving", "and", "loading", "knowledge", "store", "with", "tempfile", "temporary", "directory", "as", "tmpdir", "create", "test", "file", "test", "file", "path", "tmpdir", "test", "py", "test", "file", "write", "text", "def", "foo", "pass", "build", "and", "save", "builder", "graph", "builder", "builder", "build", "from", "directory", "tmpdir", "store", "knowledge", "store", "from", "graph", "builder", "builder", "save", "path", "path", "tmpdir", "knowledge", "json", "store", "save", "save", "path", "load", "and", "verify", "loaded", "store", "knowledge", "store", "load", "save", "path", "assert", "len", "loaded", "store", "entities", "len", "store", "entities"], "metadata": {"kind": "function", "has_docstring": "true", "last_modified": "1766233147.1775234"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/indexing/test_basic.py::test_query_operations::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/indexing/test_basic.py::test_query_operations", "content": "def test_query_operations() -> None\n\"\"\"Test basic query operations.\"\"\"\ndef test_query_operations() -> None:\n    \"\"\"Test basic query operations.\"\"\"\n    with tempfile.TemporaryDirectory() as tmpdir:\n        # Create test files\n        test_file = Path(tmpdir) / \"test.py\"\n        test_file.write_text(\"\"\"\ndef caller():\n    callee()\n\ndef callee():\n    pass\n\"\"\")\n\n        # Build graph\n        builder = GraphBuilder()\n        builder.build_from_directory(tmpdir)\n        store = KnowledgeStore.from_graph_builder(builder)\n\n        # Search\n        results = store.search(\"caller\")\n        assert len(results) > 0\n        assert any(e.name == \"caller\" for e in results)\n\n        # Get entity\n        caller_entity = next(e for e in results if e.name == \"caller\")\n        \n        # Check callees\n        callees = store.get_callees(caller_entity.id)\n        assert len(callees) > 0", "tokens": ["def", "test", "query", "operations", "none", "test", "basic", "query", "operations", "def", "test", "query", "operations", "none", "test", "basic", "query", "operations", "with", "tempfile", "temporary", "directory", "as", "tmpdir", "create", "test", "files", "test", "file", "path", "tmpdir", "test", "py", "test", "file", "write", "text", "def", "caller", "callee", "def", "callee", "pass", "build", "graph", "builder", "graph", "builder", "builder", "build", "from", "directory", "tmpdir", "store", "knowledge", "store", "from", "graph", "builder", "builder", "search", "results", "store", "search", "caller", "assert", "len", "results", "assert", "any", "name", "caller", "for", "in", "results", "get", "entity", "caller", "entity", "next", "for", "in", "results", "if", "name", "caller", "check", "callees", "callees", "store", "get", "callees", "caller", "entity", "id", "assert", "len", "callees"], "metadata": {"kind": "function", "has_docstring": "true", "last_modified": "1766233147.1775234"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/indexing/test_graph_builder_references.py::module::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/indexing/test_graph_builder_references.py::module", "content": "\"\"\"Unit tests for graph builder reference resolution.\"\"\"", "tokens": ["unit", "tests", "for", "graph", "builder", "reference", "resolution"], "metadata": {"type": "module_header"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/indexing/test_graph_builder_references.py::imports::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/indexing/test_graph_builder_references.py::module", "content": "from knowcode.indexing.graph_builder import GraphBuilder\nfrom knowcode.data_models import Entity, EntityKind, Location, Relationship, RelationshipKind", "tokens": ["from", "knowcode", "indexing", "graph", "builder", "import", "graph", "builder", "from", "knowcode", "data", "models", "import", "entity", "entity", "kind", "location", "relationship", "relationship", "kind"], "metadata": {"type": "imports"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/indexing/test_graph_builder_references.py::test_reference_resolution::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/indexing/test_graph_builder_references.py::test_reference_resolution", "content": "def test_reference_resolution() -> None\n\"\"\"ref:: targets should resolve to known entities when possible.\"\"\"\ndef test_reference_resolution() -> None:\n    \"\"\"ref:: targets should resolve to known entities when possible.\"\"\"\n    builder = GraphBuilder()\n    entity = Entity(\n        id=\"file.py::Foo\",\n        kind=EntityKind.CLASS,\n        name=\"Foo\",\n        qualified_name=\"Foo\",\n        location=Location(\"file.py\", 1, 5),\n    )\n    builder.entities = {entity.id: entity}\n    builder.relationships = [\n        Relationship(\n            source_id=\"file.py::Caller\",\n            target_id=\"ref::Foo\",\n            kind=RelationshipKind.REFERENCES,\n        )\n    ]\n\n    builder._resolve_references()\n\n    assert builder.relationships[0].target_id == entity.id", "tokens": ["def", "test", "reference", "resolution", "none", "ref", "targets", "should", "resolve", "to", "known", "entities", "when", "possible", "def", "test", "reference", "resolution", "none", "ref", "targets", "should", "resolve", "to", "known", "entities", "when", "possible", "builder", "graph", "builder", "entity", "entity", "id", "file", "py", "foo", "kind", "entity", "kind", "class", "name", "foo", "qualified", "name", "foo", "location", "location", "file", "py", "builder", "entities", "entity", "id", "entity", "builder", "relationships", "relationship", "source", "id", "file", "py", "caller", "target", "id", "ref", "foo", "kind", "relationship", "kind", "references", "builder", "resolve", "references", "assert", "builder", "relationships", "target", "id", "entity", "id"], "metadata": {"kind": "function", "has_docstring": "true", "last_modified": "1766236633.3726954"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/indexing/test_background_indexer.py::module::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/indexing/test_background_indexer.py::module", "content": "\"\"\"Unit tests for background indexing.\"\"\"", "tokens": ["unit", "tests", "for", "background", "indexing"], "metadata": {"type": "module_header"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/indexing/test_background_indexer.py::imports::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/indexing/test_background_indexer.py::module", "content": "import time\nfrom pathlib import Path\nfrom knowcode.indexing.background_indexer import BackgroundIndexer", "tokens": ["import", "time", "from", "pathlib", "import", "path", "from", "knowcode", "indexing", "background", "indexer", "import", "background", "indexer"], "metadata": {"type": "imports"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/indexing/test_background_indexer.py::DummyIndexer::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/indexing/test_background_indexer.py::DummyIndexer", "content": "class DummyIndexer:\n    def __init__(self) -> None:\n        self.calls: list[Path] = []\n\n    def index_file(self, path: Path) -> int:\n        self.calls.append(path)\n        return 1", "tokens": ["class", "dummy", "indexer", "def", "init", "self", "none", "self", "calls", "list", "path", "def", "index", "file", "self", "path", "path", "int", "self", "calls", "append", "path", "return"], "metadata": {"kind": "class", "has_docstring": "false", "last_modified": "1766233147.1773834"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/indexing/test_background_indexer.py::DummyIndexer.__init__::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/indexing/test_background_indexer.py::DummyIndexer.__init__", "content": "def __init__(self) -> None\n    def __init__(self) -> None:\n        self.calls: list[Path] = []", "tokens": ["def", "init", "self", "none", "def", "init", "self", "none", "self", "calls", "list", "path"], "metadata": {"kind": "method", "has_docstring": "false", "last_modified": "1766233147.1773834"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/indexing/test_background_indexer.py::DummyIndexer.index_file::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/indexing/test_background_indexer.py::DummyIndexer.index_file", "content": "def index_file(self, path: Path) -> int\n    def index_file(self, path: Path) -> int:\n        self.calls.append(path)\n        return 1", "tokens": ["def", "index", "file", "self", "path", "path", "int", "def", "index", "file", "self", "path", "path", "int", "self", "calls", "append", "path", "return"], "metadata": {"kind": "method", "has_docstring": "false", "last_modified": "1766233147.1773834"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/indexing/test_background_indexer.py::test_background_indexer_processes_queue::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/indexing/test_background_indexer.py::test_background_indexer_processes_queue", "content": "def test_background_indexer_processes_queue(tmp_path: Path) -> None\n\"\"\"Queued files should be processed by the worker thread.\"\"\"\ndef test_background_indexer_processes_queue(tmp_path: Path) -> None:\n    \"\"\"Queued files should be processed by the worker thread.\"\"\"\n    indexer = DummyIndexer()\n    bg = BackgroundIndexer(indexer)\n    bg.start()\n\n    target = tmp_path / \"file.py\"\n    target.write_text(\"print('hi')\", encoding=\"utf-8\")\n    bg.queue_file(target)\n\n    for _ in range(20):\n        if indexer.calls:\n            break\n        time.sleep(0.05)\n\n    bg.stop()\n\n    assert indexer.calls == [target]", "tokens": ["def", "test", "background", "indexer", "processes", "queue", "tmp", "path", "path", "none", "queued", "files", "should", "be", "processed", "by", "the", "worker", "thread", "def", "test", "background", "indexer", "processes", "queue", "tmp", "path", "path", "none", "queued", "files", "should", "be", "processed", "by", "the", "worker", "thread", "indexer", "dummy", "indexer", "bg", "background", "indexer", "indexer", "bg", "start", "target", "tmp", "path", "file", "py", "target", "write", "text", "print", "hi", "encoding", "utf", "bg", "queue", "file", "target", "for", "in", "range", "20", "if", "indexer", "calls", "break", "time", "sleep", "05", "bg", "stop", "assert", "indexer", "calls", "target"], "metadata": {"kind": "function", "has_docstring": "true", "last_modified": "1766233147.1773834"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/indexing/test_index_manifest.py::module::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/indexing/test_index_manifest.py::module", "content": "\"\"\"Unit tests for index manifest persistence.\"\"\"", "tokens": ["unit", "tests", "for", "index", "manifest", "persistence"], "metadata": {"type": "module_header"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/indexing/test_index_manifest.py::imports::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/indexing/test_index_manifest.py::module", "content": "from __future__ import annotations\nimport json\nfrom pathlib import Path\nfrom knowcode.data_models import EmbeddingConfig\nfrom knowcode.indexing.indexer import Indexer\nfrom knowcode.llm.embedding import EmbeddingProvider", "tokens": ["from", "future", "import", "annotations", "import", "json", "from", "pathlib", "import", "path", "from", "knowcode", "data", "models", "import", "embedding", "config", "from", "knowcode", "indexing", "indexer", "import", "indexer", "from", "knowcode", "llm", "embedding", "import", "embedding", "provider"], "metadata": {"type": "imports"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/indexing/test_index_manifest.py::DummyEmbeddingProvider::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/indexing/test_index_manifest.py::DummyEmbeddingProvider", "content": "class DummyEmbeddingProvider(EmbeddingProvider):\n    def embed(self, texts: list[str]) -> list[list[float]]:\n        return [[0.0] * self.config.dimension for _ in texts]\n\n    def embed_single(self, text: str) -> list[float]:\n        return [0.0] * self.config.dimension", "tokens": ["class", "dummy", "embedding", "provider", "embedding", "provider", "def", "embed", "self", "texts", "list", "str", "list", "list", "float", "return", "self", "config", "dimension", "for", "in", "texts", "def", "embed", "single", "self", "text", "str", "list", "float", "return", "self", "config", "dimension"], "metadata": {"kind": "class", "has_docstring": "false", "last_modified": "1768185812.995584"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/indexing/test_index_manifest.py::DummyEmbeddingProvider.embed::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/indexing/test_index_manifest.py::DummyEmbeddingProvider.embed", "content": "def embed(self, texts: list[str]) -> list[list[float]]\n    def embed(self, texts: list[str]) -> list[list[float]]:\n        return [[0.0] * self.config.dimension for _ in texts]", "tokens": ["def", "embed", "self", "texts", "list", "str", "list", "list", "float", "def", "embed", "self", "texts", "list", "str", "list", "list", "float", "return", "self", "config", "dimension", "for", "in", "texts"], "metadata": {"kind": "method", "has_docstring": "false", "last_modified": "1768185812.995584"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/indexing/test_index_manifest.py::DummyEmbeddingProvider.embed_single::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/indexing/test_index_manifest.py::DummyEmbeddingProvider.embed_single", "content": "def embed_single(self, text: str) -> list[float]\n    def embed_single(self, text: str) -> list[float]:\n        return [0.0] * self.config.dimension", "tokens": ["def", "embed", "single", "self", "text", "str", "list", "float", "def", "embed", "single", "self", "text", "str", "list", "float", "return", "self", "config", "dimension"], "metadata": {"kind": "method", "has_docstring": "false", "last_modified": "1768185812.995584"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/indexing/test_index_manifest.py::test_indexer_writes_and_loads_manifest::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/indexing/test_index_manifest.py::test_indexer_writes_and_loads_manifest", "content": "def test_indexer_writes_and_loads_manifest(tmp_path: Path) -> None\ndef test_indexer_writes_and_loads_manifest(tmp_path: Path) -> None:\n    provider = DummyEmbeddingProvider(EmbeddingConfig(provider=\"openai\", model_name=\"x\", dimension=8))\n    indexer = Indexer(provider)\n\n    out_dir = tmp_path / \"idx\"\n    indexer.save(out_dir)\n\n    manifest_file = out_dir / \"index_manifest.json\"\n    assert manifest_file.exists()\n\n    manifest = json.loads(manifest_file.read_text(encoding=\"utf-8\"))\n    assert manifest[\"embedding\"][\"dimension\"] == 8\n    assert manifest[\"chunking\"][\"max_chunk_size\"] > 0\n\n    indexer2 = Indexer(provider)\n    indexer2.load(out_dir)\n    assert indexer2.manifest.get(\"embedding\", {}).get(\"dimension\") == 8", "tokens": ["def", "test", "indexer", "writes", "and", "loads", "manifest", "tmp", "path", "path", "none", "def", "test", "indexer", "writes", "and", "loads", "manifest", "tmp", "path", "path", "none", "provider", "dummy", "embedding", "provider", "embedding", "config", "provider", "openai", "model", "name", "dimension", "indexer", "indexer", "provider", "out", "dir", "tmp", "path", "idx", "indexer", "save", "out", "dir", "manifest", "file", "out", "dir", "index", "manifest", "json", "assert", "manifest", "file", "exists", "manifest", "json", "loads", "manifest", "file", "read", "text", "encoding", "utf", "assert", "manifest", "embedding", "dimension", "assert", "manifest", "chunking", "max", "chunk", "size", "indexer2", "indexer", "provider", "indexer2", "load", "out", "dir", "assert", "indexer2", "manifest", "get", "embedding", "get", "dimension"], "metadata": {"kind": "function", "has_docstring": "false", "last_modified": "1768185812.995584"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/indexing/test_chunker.py::module::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/indexing/test_chunker.py::module", "content": "\"\"\"Unit tests for the chunker.\"\"\"", "tokens": ["unit", "tests", "for", "the", "chunker"], "metadata": {"type": "module_header"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/indexing/test_chunker.py::imports::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/indexing/test_chunker.py::module", "content": "from pathlib import Path\nfrom knowcode.indexing.chunker import Chunker\nfrom knowcode.data_models import ChunkingConfig, Entity, EntityKind, Location, ParseResult", "tokens": ["from", "pathlib", "import", "path", "from", "knowcode", "indexing", "chunker", "import", "chunker", "from", "knowcode", "data", "models", "import", "chunking", "config", "entity", "entity", "kind", "location", "parse", "result"], "metadata": {"type": "imports"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/indexing/test_chunker.py::test_chunker_module_extraction::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/indexing/test_chunker.py::test_chunker_module_extraction", "content": "def test_chunker_module_extraction() -> None\n\"\"\"Module header and imports should be extracted.\"\"\"\ndef test_chunker_module_extraction() -> None:\n    \"\"\"Module header and imports should be extracted.\"\"\"\n    chunker = Chunker()\n    source = '\"\"\"Module docstring.\"\"\"\\nimport os\\n\\ndef foo(): pass'\n\n    header = chunker._extract_module_header(source)\n    assert '\"\"\"Module docstring.\"\"\"' in header\n\n    imports = chunker._extract_imports(source)\n    assert \"import os\" in imports", "tokens": ["def", "test", "chunker", "module", "extraction", "none", "module", "header", "and", "imports", "should", "be", "extracted", "def", "test", "chunker", "module", "extraction", "none", "module", "header", "and", "imports", "should", "be", "extracted", "chunker", "chunker", "source", "module", "docstring", "nimport", "os", "ndef", "foo", "pass", "header", "chunker", "extract", "module", "header", "source", "assert", "module", "docstring", "in", "header", "imports", "chunker", "extract", "imports", "source", "assert", "import", "os", "in", "imports"], "metadata": {"kind": "function", "has_docstring": "true", "last_modified": "1766236633.3726954"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/indexing/test_chunker.py::test_chunker_metadata_has_docstring_and_last_modified::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/indexing/test_chunker.py::test_chunker_metadata_has_docstring_and_last_modified", "content": "def test_chunker_metadata_has_docstring_and_last_modified(tmp_path: Path) -> None\n\"\"\"Chunk metadata should include docstring and timestamp flags.\"\"\"\ndef test_chunker_metadata_has_docstring_and_last_modified(tmp_path: Path) -> None:\n    \"\"\"Chunk metadata should include docstring and timestamp flags.\"\"\"\n    source = '\"\"\"Module docstring.\"\"\"\\n\\ndef foo():\\n    \"\"\"Doc.\"\"\"\\n    return 1\\n'\n    file_path = tmp_path / \"mod.py\"\n    file_path.write_text(source, encoding=\"utf-8\")\n\n    module_entity = Entity(\n        id=f\"{file_path}::mod\",\n        kind=EntityKind.MODULE,\n        name=\"mod\",\n        qualified_name=\"mod\",\n        location=Location(str(file_path), 1, 5),\n        source_code=source,\n    )\n    func_entity = Entity(\n        id=f\"{file_path}::foo\",\n        kind=EntityKind.FUNCTION,\n        name=\"foo\",\n        qualified_name=\"foo\",\n        location=Location(str(file_path), 3, 5),\n        docstring=\"Doc.\",\n        signature=\"def foo()\",\n        source_code=\"def foo():\\n    return 1\\n\",\n ", "tokens": ["def", "test", "chunker", "metadata", "has", "docstring", "and", "last", "modified", "tmp", "path", "path", "none", "chunk", "metadata", "should", "include", "docstring", "and", "timestamp", "flags", "def", "test", "chunker", "metadata", "has", "docstring", "and", "last", "modified", "tmp", "path", "path", "none", "chunk", "metadata", "should", "include", "docstring", "and", "timestamp", "flags", "source", "module", "docstring", "ndef", "foo", "doc", "return", "file", "path", "tmp", "path", "mod", "py", "file", "path", "write", "text", "source", "encoding", "utf", "module", "entity", "entity", "id", "file", "path", "mod", "kind", "entity", "kind", "module", "name", "mod", "qualified", "name", "mod", "location", "location", "str", "file", "path", "source", "code", "source", "func", "entity", "entity", "id", "file", "path", "foo", "kind", "entity", "kind", "function", "name", "foo", "qualified", "name", "foo", "location", "location", "str", "file", "path", "docstring", "doc", "signature", "def", "foo", "source", "code", "def", "foo", "return"], "metadata": {"kind": "function", "chunk_index": "0", "has_docstring": "true", "last_modified": "1766236633.3726954"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/indexing/test_chunker.py::test_chunker_metadata_has_docstring_and_last_modified::1", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/indexing/test_chunker.py::test_chunker_metadata_has_docstring_and_last_modified", "content": "docstring=\"Doc.\",\n        signature=\"def foo()\",\n        source_code=\"def foo():\\n    return 1\\n\",\n    )\n\n    result = ParseResult(\n        file_path=str(file_path),\n        entities=[module_entity, func_entity],\n        relationships=[],\n    )\n    chunker = Chunker()\n    chunks = chunker.process_parse_result(result)\n\n    func_chunks = [c for c in chunks if c.entity_id == func_entity.id]\n    assert func_chunks\n    assert func_chunks[0].metadata[\"has_docstring\"] == \"true\"\n    assert \"last_modified\" in func_chunks[0].metadata", "tokens": ["docstring", "doc", "signature", "def", "foo", "source", "code", "def", "foo", "return", "result", "parse", "result", "file", "path", "str", "file", "path", "entities", "module", "entity", "func", "entity", "relationships", "chunker", "chunker", "chunks", "chunker", "process", "parse", "result", "result", "func", "chunks", "for", "in", "chunks", "if", "entity", "id", "func", "entity", "id", "assert", "func", "chunks", "assert", "func", "chunks", "metadata", "has", "docstring", "true", "assert", "last", "modified", "in", "func", "chunks", "metadata"], "metadata": {"kind": "function", "chunk_index": "1", "has_docstring": "true", "last_modified": "1766236633.3726954"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/indexing/test_chunker.py::test_chunker_overlap_chunking::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/indexing/test_chunker.py::test_chunker_overlap_chunking", "content": "def test_chunker_overlap_chunking() -> None\n\"\"\"Large entities should be split into overlapping chunks.\"\"\"\ndef test_chunker_overlap_chunking() -> None:\n    \"\"\"Large entities should be split into overlapping chunks.\"\"\"\n    content = \"a\" * 120\n    entity = Entity(\n        id=\"file.py::big\",\n        kind=EntityKind.FUNCTION,\n        name=\"big\",\n        qualified_name=\"big\",\n        location=Location(\"file.py\", 1, 10),\n        source_code=content,\n    )\n    result = ParseResult(file_path=\"file.py\", entities=[entity], relationships=[])\n\n    chunker = Chunker(ChunkingConfig(max_chunk_size=50, overlap=10))\n    chunks = chunker.process_parse_result(result)\n\n    assert len(chunks) > 1\n    assert chunks[0].metadata[\"chunk_index\"] == \"0\"", "tokens": ["def", "test", "chunker", "overlap", "chunking", "none", "large", "entities", "should", "be", "split", "into", "overlapping", "chunks", "def", "test", "chunker", "overlap", "chunking", "none", "large", "entities", "should", "be", "split", "into", "overlapping", "chunks", "content", "120", "entity", "entity", "id", "file", "py", "big", "kind", "entity", "kind", "function", "name", "big", "qualified", "name", "big", "location", "location", "file", "py", "10", "source", "code", "content", "result", "parse", "result", "file", "path", "file", "py", "entities", "entity", "relationships", "chunker", "chunker", "chunking", "config", "max", "chunk", "size", "50", "overlap", "10", "chunks", "chunker", "process", "parse", "result", "result", "assert", "len", "chunks", "assert", "chunks", "metadata", "chunk", "index"], "metadata": {"kind": "function", "has_docstring": "true", "last_modified": "1766236633.3726954"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/api/test_api_endpoints.py::module::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/api/test_api_endpoints.py::module", "content": "\"\"\"Unit tests for API endpoint functions (no TestClient / sockets).\"\"\"", "tokens": ["unit", "tests", "for", "api", "endpoint", "functions", "no", "test", "client", "sockets"], "metadata": {"type": "module_header"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/api/test_api_endpoints.py::imports::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/api/test_api_endpoints.py::module", "content": "from __future__ import annotations\nfrom knowcode.api import api\nfrom knowcode.data_models import CodeChunk", "tokens": ["from", "future", "import", "annotations", "from", "knowcode", "api", "import", "api", "from", "knowcode", "data", "models", "import", "code", "chunk"], "metadata": {"type": "imports"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/api/test_api_endpoints.py::DummySearchEngine::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/api/test_api_endpoints.py::DummySearchEngine", "content": "class DummySearchEngine:\n    def search(self, query, limit=5, expand_deps=True, **_kwargs):  # noqa: ANN001\n        return [CodeChunk(id=\"c1\", entity_id=\"e1\", content=\"hi\", tokens=[\"hi\"])]", "tokens": ["class", "dummy", "search", "engine", "def", "search", "self", "query", "limit", "expand", "deps", "true", "kwargs", "noqa", "ann001", "return", "code", "chunk", "id", "c1", "entity", "id", "e1", "content", "hi", "tokens", "hi"], "metadata": {"kind": "class", "has_docstring": "false", "last_modified": "1768185812.994584"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/api/test_api_endpoints.py::DummySearchEngine.search::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/api/test_api_endpoints.py::DummySearchEngine.search", "content": "def search(self, query, limit, expand_deps, **_kwargs)\n    def search(self, query, limit=5, expand_deps=True, **_kwargs):  # noqa: ANN001\n        return [CodeChunk(id=\"c1\", entity_id=\"e1\", content=\"hi\", tokens=[\"hi\"])]", "tokens": ["def", "search", "self", "query", "limit", "expand", "deps", "kwargs", "def", "search", "self", "query", "limit", "expand", "deps", "true", "kwargs", "noqa", "ann001", "return", "code", "chunk", "id", "c1", "entity", "id", "e1", "content", "hi", "tokens", "hi"], "metadata": {"kind": "method", "has_docstring": "false", "last_modified": "1768185812.994584"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/api/test_api_endpoints.py::DummyStore::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/api/test_api_endpoints.py::DummyStore", "content": "class DummyStore:\n    def trace_calls(self, _entity_id, direction=\"callees\", depth=1, max_results=50):  # noqa: ANN001\n        return [\n            {\n                \"entity_id\": \"e2\",\n                \"name\": \"bar\",\n                \"qualified_name\": \"bar\",\n                \"kind\": \"function\",\n                \"file\": \"file.py\",\n                \"line\": 2,\n                \"call_depth\": 1,\n            }\n        ]\n\n    def get_impact(self, entity_id: str, max_depth: int = 3):\n        return {\n            \"entity_id\": entity_id,\n            \"direct_dependents\": [],\n            \"transitive_dependents\": [],\n            \"affected_files\": [],\n            \"risk_score\": 0.0,\n        }", "tokens": ["class", "dummy", "store", "def", "trace", "calls", "self", "entity", "id", "direction", "callees", "depth", "max", "results", "50", "noqa", "ann001", "return", "entity", "id", "e2", "name", "bar", "qualified", "name", "bar", "kind", "function", "file", "file", "py", "line", "call", "depth", "def", "get", "impact", "self", "entity", "id", "str", "max", "depth", "int", "return", "entity", "id", "entity", "id", "direct", "dependents", "transitive", "dependents", "affected", "files", "risk", "score"], "metadata": {"kind": "class", "has_docstring": "false", "last_modified": "1768185812.994584"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/api/test_api_endpoints.py::DummyStore.trace_calls::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/api/test_api_endpoints.py::DummyStore.trace_calls", "content": "def trace_calls(self, _entity_id, direction, depth, max_results)\n    def trace_calls(self, _entity_id, direction=\"callees\", depth=1, max_results=50):  # noqa: ANN001\n        return [\n            {\n                \"entity_id\": \"e2\",\n                \"name\": \"bar\",\n                \"qualified_name\": \"bar\",\n                \"kind\": \"function\",\n                \"file\": \"file.py\",\n                \"line\": 2,\n                \"call_depth\": 1,\n            }\n        ]", "tokens": ["def", "trace", "calls", "self", "entity", "id", "direction", "depth", "max", "results", "def", "trace", "calls", "self", "entity", "id", "direction", "callees", "depth", "max", "results", "50", "noqa", "ann001", "return", "entity", "id", "e2", "name", "bar", "qualified", "name", "bar", "kind", "function", "file", "file", "py", "line", "call", "depth"], "metadata": {"kind": "method", "has_docstring": "false", "last_modified": "1768185812.994584"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/api/test_api_endpoints.py::DummyStore.get_impact::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/api/test_api_endpoints.py::DummyStore.get_impact", "content": "def get_impact(self, entity_id: str, max_depth: int)\n    def get_impact(self, entity_id: str, max_depth: int = 3):\n        return {\n            \"entity_id\": entity_id,\n            \"direct_dependents\": [],\n            \"transitive_dependents\": [],\n            \"affected_files\": [],\n            \"risk_score\": 0.0,\n        }", "tokens": ["def", "get", "impact", "self", "entity", "id", "str", "max", "depth", "int", "def", "get", "impact", "self", "entity", "id", "str", "max", "depth", "int", "return", "entity", "id", "entity", "id", "direct", "dependents", "transitive", "dependents", "affected", "files", "risk", "score"], "metadata": {"kind": "method", "has_docstring": "false", "last_modified": "1768185812.994584"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/api/test_api_endpoints.py::DummyService::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/api/test_api_endpoints.py::DummyService", "content": "class DummyService:\n    def __init__(self) -> None:\n        self.reload_called = False\n        self.store = DummyStore()\n\n    def get_stats(self):\n        return {\"total_entities\": 1}\n\n    def search(self, _pattern):\n        return [\n            {\n                \"id\": \"e1\",\n                \"kind\": \"function\",\n                \"name\": \"foo\",\n                \"qualified_name\": \"foo\",\n                \"file\": \"file.py\",\n                \"line\": 1,\n            }\n        ]\n\n    def get_context(self, _target, max_tokens=2000, task_type=None):  # noqa: ANN001\n        return {\n            \"entity_id\": \"e1\",\n            \"context_text\": \"ctx\",\n            \"total_tokens\": 1,\n            \"truncated\": False,\n            \"included_entities\": [\"e1\"],\n            \"task_type\": (task_type.value if task_type else \"general\"),\n            \"sufficiency_score\": 0.0,\n        }\n\n    def get_entity_details(self, _entity_id):\n        return {\"id\": \"e1\", \"source_code\": \"pass\", \"location\": {\"file_path\": \"file.py\"}}\n\n", "tokens": ["class", "dummy", "service", "def", "init", "self", "none", "self", "reload", "called", "false", "self", "store", "dummy", "store", "def", "get", "stats", "self", "return", "total", "entities", "def", "search", "self", "pattern", "return", "id", "e1", "kind", "function", "name", "foo", "qualified", "name", "foo", "file", "file", "py", "line", "def", "get", "context", "self", "target", "max", "tokens", "2000", "task", "type", "none", "noqa", "ann001", "return", "entity", "id", "e1", "context", "text", "ctx", "total", "tokens", "truncated", "false", "included", "entities", "e1", "task", "type", "task", "type", "value", "if", "task", "type", "else", "general", "sufficiency", "score", "def", "get", "entity", "details", "self", "entity", "id", "return", "id", "e1", "source", "code", "pass", "location", "file", "path", "file", "py"], "metadata": {"kind": "class", "chunk_index": "0", "has_docstring": "false", "last_modified": "1768185812.994584"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/api/test_api_endpoints.py::DummyService::1", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/api/test_api_endpoints.py::DummyService", "content": "tity_id):\n        return {\"id\": \"e1\", \"source_code\": \"pass\", \"location\": {\"file_path\": \"file.py\"}}\n\n    def get_callers(self, _entity_id):\n        return []\n\n    def get_callees(self, _entity_id):\n        return []\n\n    def get_search_engine(self, _index_path=None):\n        return DummySearchEngine()\n\n    def reload(self):\n        self.reload_called = True", "tokens": ["tity", "id", "return", "id", "e1", "source", "code", "pass", "location", "file", "path", "file", "py", "def", "get", "callers", "self", "entity", "id", "return", "def", "get", "callees", "self", "entity", "id", "return", "def", "get", "search", "engine", "self", "index", "path", "none", "return", "dummy", "search", "engine", "def", "reload", "self", "self", "reload", "called", "true"], "metadata": {"kind": "class", "chunk_index": "1", "has_docstring": "false", "last_modified": "1768185812.994584"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/api/test_api_endpoints.py::DummyService.__init__::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/api/test_api_endpoints.py::DummyService.__init__", "content": "def __init__(self) -> None\n    def __init__(self) -> None:\n        self.reload_called = False\n        self.store = DummyStore()", "tokens": ["def", "init", "self", "none", "def", "init", "self", "none", "self", "reload", "called", "false", "self", "store", "dummy", "store"], "metadata": {"kind": "method", "has_docstring": "false", "last_modified": "1768185812.994584"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/api/test_api_endpoints.py::DummyService.get_stats::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/api/test_api_endpoints.py::DummyService.get_stats", "content": "def get_stats(self)\n    def get_stats(self):\n        return {\"total_entities\": 1}", "tokens": ["def", "get", "stats", "self", "def", "get", "stats", "self", "return", "total", "entities"], "metadata": {"kind": "method", "has_docstring": "false", "last_modified": "1768185812.994584"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/api/test_api_endpoints.py::DummyService.search::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/api/test_api_endpoints.py::DummyService.search", "content": "def search(self, _pattern)\n    def search(self, _pattern):\n        return [\n            {\n                \"id\": \"e1\",\n                \"kind\": \"function\",\n                \"name\": \"foo\",\n                \"qualified_name\": \"foo\",\n                \"file\": \"file.py\",\n                \"line\": 1,\n            }\n        ]", "tokens": ["def", "search", "self", "pattern", "def", "search", "self", "pattern", "return", "id", "e1", "kind", "function", "name", "foo", "qualified", "name", "foo", "file", "file", "py", "line"], "metadata": {"kind": "method", "has_docstring": "false", "last_modified": "1768185812.994584"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/api/test_api_endpoints.py::DummyService.get_context::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/api/test_api_endpoints.py::DummyService.get_context", "content": "def get_context(self, _target, max_tokens, task_type)\n    def get_context(self, _target, max_tokens=2000, task_type=None):  # noqa: ANN001\n        return {\n            \"entity_id\": \"e1\",\n            \"context_text\": \"ctx\",\n            \"total_tokens\": 1,\n            \"truncated\": False,\n            \"included_entities\": [\"e1\"],\n            \"task_type\": (task_type.value if task_type else \"general\"),\n            \"sufficiency_score\": 0.0,\n        }", "tokens": ["def", "get", "context", "self", "target", "max", "tokens", "task", "type", "def", "get", "context", "self", "target", "max", "tokens", "2000", "task", "type", "none", "noqa", "ann001", "return", "entity", "id", "e1", "context", "text", "ctx", "total", "tokens", "truncated", "false", "included", "entities", "e1", "task", "type", "task", "type", "value", "if", "task", "type", "else", "general", "sufficiency", "score"], "metadata": {"kind": "method", "has_docstring": "false", "last_modified": "1768185812.994584"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/api/test_api_endpoints.py::DummyService.get_entity_details::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/api/test_api_endpoints.py::DummyService.get_entity_details", "content": "def get_entity_details(self, _entity_id)\n    def get_entity_details(self, _entity_id):\n        return {\"id\": \"e1\", \"source_code\": \"pass\", \"location\": {\"file_path\": \"file.py\"}}", "tokens": ["def", "get", "entity", "details", "self", "entity", "id", "def", "get", "entity", "details", "self", "entity", "id", "return", "id", "e1", "source", "code", "pass", "location", "file", "path", "file", "py"], "metadata": {"kind": "method", "has_docstring": "false", "last_modified": "1768185812.994584"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/api/test_api_endpoints.py::DummyService.get_callers::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/api/test_api_endpoints.py::DummyService.get_callers", "content": "def get_callers(self, _entity_id)\n    def get_callers(self, _entity_id):\n        return []", "tokens": ["def", "get", "callers", "self", "entity", "id", "def", "get", "callers", "self", "entity", "id", "return"], "metadata": {"kind": "method", "has_docstring": "false", "last_modified": "1768185812.994584"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/api/test_api_endpoints.py::DummyService.get_callees::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/api/test_api_endpoints.py::DummyService.get_callees", "content": "def get_callees(self, _entity_id)\n    def get_callees(self, _entity_id):\n        return []", "tokens": ["def", "get", "callees", "self", "entity", "id", "def", "get", "callees", "self", "entity", "id", "return"], "metadata": {"kind": "method", "has_docstring": "false", "last_modified": "1768185812.994584"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/api/test_api_endpoints.py::DummyService.get_search_engine::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/api/test_api_endpoints.py::DummyService.get_search_engine", "content": "def get_search_engine(self, _index_path)\n    def get_search_engine(self, _index_path=None):\n        return DummySearchEngine()", "tokens": ["def", "get", "search", "engine", "self", "index", "path", "def", "get", "search", "engine", "self", "index", "path", "none", "return", "dummy", "search", "engine"], "metadata": {"kind": "method", "has_docstring": "false", "last_modified": "1768185812.994584"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/api/test_api_endpoints.py::DummyService.reload::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/api/test_api_endpoints.py::DummyService.reload", "content": "def reload(self)\n    def reload(self):\n        self.reload_called = True", "tokens": ["def", "reload", "self", "def", "reload", "self", "self", "reload", "called", "true"], "metadata": {"kind": "method", "has_docstring": "false", "last_modified": "1768185812.994584"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/api/test_api_endpoints.py::test_health_and_stats_endpoints::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/api/test_api_endpoints.py::test_health_and_stats_endpoints", "content": "def test_health_and_stats_endpoints() -> None\ndef test_health_and_stats_endpoints() -> None:\n    assert api.health() == {\"status\": \"ok\"}\n\n    service = DummyService()\n    stats = api.get_stats(service=service)\n    assert stats[\"total_entities\"] == 1", "tokens": ["def", "test", "health", "and", "stats", "endpoints", "none", "def", "test", "health", "and", "stats", "endpoints", "none", "assert", "api", "health", "status", "ok", "service", "dummy", "service", "stats", "api", "get", "stats", "service", "service", "assert", "stats", "total", "entities"], "metadata": {"kind": "function", "has_docstring": "false", "last_modified": "1768185812.994584"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/api/test_api_endpoints.py::test_search_and_context_endpoints::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/api/test_api_endpoints.py::test_search_and_context_endpoints", "content": "def test_search_and_context_endpoints() -> None\ndef test_search_and_context_endpoints() -> None:\n    service = DummyService()\n\n    results = api.search(q=\"foo\", service=service)\n    assert results[0][\"id\"] == \"e1\"\n\n    context = api.get_context(\n        target=\"e1\",\n        max_tokens=2000,\n        task_type=api.TaskTypeParam.general,\n        service=service,\n    )\n    assert context[\"context_text\"] == \"ctx\"", "tokens": ["def", "test", "search", "and", "context", "endpoints", "none", "def", "test", "search", "and", "context", "endpoints", "none", "service", "dummy", "service", "results", "api", "search", "foo", "service", "service", "assert", "results", "id", "e1", "context", "api", "get", "context", "target", "e1", "max", "tokens", "2000", "task", "type", "api", "task", "type", "param", "general", "service", "service", "assert", "context", "context", "text", "ctx"], "metadata": {"kind": "function", "has_docstring": "false", "last_modified": "1768185812.994584"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/api/test_api_endpoints.py::test_query_and_entity_endpoints::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/api/test_api_endpoints.py::test_query_and_entity_endpoints", "content": "def test_query_and_entity_endpoints() -> None\ndef test_query_and_entity_endpoints() -> None:\n    service = DummyService()\n\n    resp = api.query_context(api.QueryRequest(query=\"hi\", limit=1), service=service)\n    assert resp.chunks[0].id == \"c1\"\n\n    entity = api.get_entity(entity_id=\"e1\", service=service)\n    assert entity[\"id\"] == \"e1\"", "tokens": ["def", "test", "query", "and", "entity", "endpoints", "none", "def", "test", "query", "and", "entity", "endpoints", "none", "service", "dummy", "service", "resp", "api", "query", "context", "api", "query", "request", "query", "hi", "limit", "service", "service", "assert", "resp", "chunks", "id", "c1", "entity", "api", "get", "entity", "entity", "id", "e1", "service", "service", "assert", "entity", "id", "e1"], "metadata": {"kind": "function", "has_docstring": "false", "last_modified": "1768185812.994584"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/api/test_api_endpoints.py::test_reload_endpoint::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/api/test_api_endpoints.py::test_reload_endpoint", "content": "def test_reload_endpoint() -> None\ndef test_reload_endpoint() -> None:\n    service = DummyService()\n    resp = api.reload_store(service=service)\n    assert resp[\"status\"] == \"reloaded\"\n    assert service.reload_called is True", "tokens": ["def", "test", "reload", "endpoint", "none", "def", "test", "reload", "endpoint", "none", "service", "dummy", "service", "resp", "api", "reload", "store", "service", "service", "assert", "resp", "status", "reloaded", "assert", "service", "reload", "called", "is", "true"], "metadata": {"kind": "function", "has_docstring": "false", "last_modified": "1768185812.994584"}}, {"id": "/home/deeog/Desktop/KnowCode/tests/unit/api/test_api_endpoints.py::test_trace_calls_and_impact_endpoints::0", "entity_id": "/home/deeog/Desktop/KnowCode/tests/unit/api/test_api_endpoints.py::test_trace_calls_and_impact_endpoints", "content": "def test_trace_calls_and_impact_endpoints() -> None\ndef test_trace_calls_and_impact_endpoints() -> None:\n    service = DummyService()\n\n    trace = api.trace_calls(\n        entity_id=\"e1\",\n        direction=api.DirectionParam.callees,\n        depth=1,\n        max_results=50,\n        service=service,\n    )\n    assert trace[0][\"entity_id\"] == \"e2\"\n\n    impact = api.get_impact(entity_id=\"e1\", max_depth=3, service=service)\n    assert impact[\"entity_id\"] == \"e1\"", "tokens": ["def", "test", "trace", "calls", "and", "impact", "endpoints", "none", "def", "test", "trace", "calls", "and", "impact", "endpoints", "none", "service", "dummy", "service", "trace", "api", "trace", "calls", "entity", "id", "e1", "direction", "api", "direction", "param", "callees", "depth", "max", "results", "50", "service", "service", "assert", "trace", "entity", "id", "e2", "impact", "api", "get", "impact", "entity", "id", "e1", "max", "depth", "service", "service", "assert", "impact", "entity", "id", "e1"], "metadata": {"kind": "function", "has_docstring": "false", "last_modified": "1768185812.994584"}}, {"id": "/home/deeog/Desktop/KnowCode/.github/workflows/ci-cd.yml::module::0", "entity_id": "/home/deeog/Desktop/KnowCode/.github/workflows/ci-cd.yml::module", "content": "name: CI/CD Pipeline\non:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n  workflow_dispatch:\n    inputs:\n      changelog_summary:\n        description: \"Plain-English summary for CHANGELOG (optional).\"\n        required: false\n        default: \"\"\npermissions:\n  contents: write\njobs:\n  test:\n    name: Test & Lint (${{ matrix.os }} / py${{ matrix.python-version }})\n    runs-on: ${{ matrix.os }}\n    strategy:\n      fail-fast: false\n      matrix:\n        os: [ubuntu-latest, windows-latest, macos-latest]\n        python-version: [\"3.9\", \"3.10\", \"3.11\", \"3.12\"]\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v4\n        with:\n          fetch-depth: 0 # Fetch all history for changelog/commit analysis if needed\n      - name: Install uv\n        uses: astral-sh/setup-uv@v3\n        with:\n          enable-cache: true\n          cache-dependency-glob: \"uv.lock\"\n      - name: Install dependencies\n        run: uv sync --all-extras --dev\n      - name: Lint with Ruff\n        run: uv run ruff check .\n      - name: Test with pytest (and coverage)\n        run: uv run pytest -v --cov=src --cov-report=xml\n      - name: Upload coverage to Codecov\n        uses: codecov/codecov-action@v4\n        with:\n          token: ${{ secrets.CODECOV_TOKEN }}\n          file: ./coverage.xml\n          fail_ci_if_error: false # Don't fail the build if codecov is just down/unconfigured\n      - name: Prune uv cache\n        run: uv cache prune --ci\n  docs:\n    name: Build Documentation\n    runs-on: ubuntu-latest\n    needs: test # Only build docs if tests pass\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v4\n      - name: Install uv\n        uses: astral-sh/setup-uv@v3\n      - name: Install dependencies\n        run: uv sync --all-extras --dev\n      - name: Build MkDocs\n        run: uv run mkdocs build\n      # Optional: Deploy to GitHub Pages (disabled for this example, but ready to enable)\n      # - name: Deploy to GitHub Pages\n      #   uses: mkdocs/gh-deployer@...\n  changelog:\n    name: Generate Changelog\n    runs-on: ubuntu-latest\n    if: github.event_name == 'push' && github.ref == 'refs/heads/main' || github.event_name == 'workflow_dispatch'\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v4\n        with:\n          fetch-depth: 0 # Fetch all history for the log\n      - name: Set up Python\n        uses: actions/setup-python@v5\n        with:\n          python-version: \"3.10\"\n      - name: Generate Changelog Entry\n        # We run the script directly.\n        # It appends to CHANGELOG.md in the runner.\n        env:\n          CHANGELOG_SUMMARY: ${{ inputs.changelog_summary }}\n        run: |\n          if [ -n \"${CHANGELOG_SUMMARY}\" ]; then\n            python3 scripts/generate_changelog.py --use-last-tag --summary \"${CHANGELOG_SUMMARY}\"\n          else\n            python3 scripts/generate_changelog.py --use-last-tag\n          fi\n      - name: Commit and Push Changelog\n        run: |\n          git config --global user.name \"github-actions[bot]\"\n          git config --global user.email \"github-actions[bot]@users.noreply.github.com\"\n          git add CHANGELOG.md\n          # Only commit if there are changes\n          if git diff --staged --quiet; then\n            echo \"No changes to commit.\"\n          else\n            git commit -m \"docs: update changelog [skip ci]\"\n            git push\n          fi\n      - name: Upload Changelog Artifact\n        uses: actions/upload-artifact@v4\n        with:\n          name: changelog-update\n          path: CHANGELOG.md", "tokens": ["name", "ci", "cd", "pipeline", "on", "push", "branches", "main", "pull", "request", "branches", "main", "workflow", "dispatch", "inputs", "changelog", "summary", "description", "plain", "english", "summary", "for", "changelog", "optional", "required", "false", "default", "permissions", "contents", "write", "jobs", "test", "name", "test", "lint", "matrix", "os", "py", "matrix", "python", "version", "runs", "on", "matrix", "os", "strategy", "fail", "fast", "false", "matrix", "os", "ubuntu", "latest", "windows", "latest", "macos", "latest", "python", "version", "10", "11", "12", "steps", "name", "checkout", "code", "uses", "actions", "checkout", "v4", "with", "fetch", "depth", "fetch", "all", "history", "for", "changelog", "commit", "analysis", "if", "needed", "name", "install", "uv", "uses", "astral", "sh", "setup", "uv", "v3", "with", "enable", "cache", "true", "cache", "dependency", "glob", "uv", "lock", "name", "install", "dependencies", "run", "uv", "sync", "all", "extras", "dev", "name", "lint", "with", "ruff", "run", "uv", "run", "ruff", "check", "name", "test", "with", "pytest", "and", "coverage", "run", "uv", "run", "pytest", "cov", "src", "cov", "report", "xml", "name", "upload", "coverage", "to", "codecov", "uses", "codecov", "codecov", "action", "v4", "with", "token", "secrets", "codecov", "token", "file", "coverage", "xml", "fail", "ci", "if", "error", "false", "don", "fail", "the", "build", "if", "codecov", "is", "just", "down", "unconfigured", "name", "prune", "uv", "cache", "run", "uv", "cache", "prune", "ci", "docs", "name", "build", "documentation", "runs", "on", "ubuntu", "latest", "needs", "test", "only", "build", "docs", "if", "tests", "pass", "steps", "name", "checkout", "code", "uses", "actions", "checkout", "v4", "name", "install", "uv", "uses", "astral", "sh", "setup", "uv", "v3", "name", "install", "dependencies", "run", "uv", "sync", "all", "extras", "dev", "name", "build", "mk", "docs", "run", "uv", "run", "mkdocs", "build", "optional", "deploy", "to", "git", "hub", "pages", "disabled", "for", "this", "example", "but", "ready", "to", "enable", "name", "deploy", "to", "git", "hub", "pages", "uses", "mkdocs", "gh", "deployer", "changelog", "name", "generate", "changelog", "runs", "on", "ubuntu", "latest", "if", "github", "event", "name", "push", "github", "ref", "refs", "heads", "main", "github", "event", "name", "workflow", "dispatch", "steps", "name", "checkout", "code", "uses", "actions", "checkout", "v4", "with", "fetch", "depth", "fetch", "all", "history", "for", "the", "log", "name", "set", "up", "python", "uses", "actions", "setup", "python", "v5", "with", "python", "version", "10", "name", "generate", "changelog", "entry", "we", "run", "the", "script", "directly", "it", "appends", "to", "changelog", "md", "in", "the", "runner", "env", "changelog", "summary", "inputs", "changelog", "summary", "run", "if", "changelog", "summary", "then", "python3", "scripts", "generate", "changelog", "py", "use", "last", "tag", "summary", "changelog", "summary", "else", "python3", "scripts", "generate", "changelog", "py", "use", "last", "tag", "fi", "name", "commit", "and", "push", "changelog", "run", "git", "config", "global", "user", "name", "github", "actions", "bot", "git", "config", "global", "user", "email", "github", "actions", "bot", "users", "noreply", "github", "com", "git", "add", "changelog", "md", "only", "commit", "if", "there", "are", "changes", "if", "git", "diff", "staged", "quiet", "then", "echo", "no", "changes", "to", "commit", "else", "git", "commit", "docs", "update", "changelog", "skip", "ci", "git", "push", "fi", "name", "upload", "changelog", "artifact", "uses", "actions", "upload", "artifact", "v4", "with", "name", "changelog", "update", "path", "changelog", "md"], "metadata": {"type": "module_header"}}, {"id": "/home/deeog/Desktop/KnowCode/.github/workflows/ci-cd.yml::ci-cd::0", "entity_id": "/home/deeog/Desktop/KnowCode/.github/workflows/ci-cd.yml::ci-cd", "content": "ci-cd", "tokens": ["ci", "cd"], "metadata": {"kind": "document", "has_docstring": "false", "last_modified": "1767810449.2959297"}}, {"id": "/home/deeog/Desktop/KnowCode/.github/workflows/ci-cd.yml::name::0", "entity_id": "/home/deeog/Desktop/KnowCode/.github/workflows/ci-cd.yml::name", "content": "name", "tokens": ["name"], "metadata": {"kind": "config_key", "has_docstring": "false", "last_modified": "1767810449.2959297"}}, {"id": "/home/deeog/Desktop/KnowCode/.github/workflows/ci-cd.yml::True::0", "entity_id": "/home/deeog/Desktop/KnowCode/.github/workflows/ci-cd.yml::True", "content": "True", "tokens": ["true"], "metadata": {"kind": "config_key", "has_docstring": "false", "last_modified": "1767810449.2959297"}}, {"id": "/home/deeog/Desktop/KnowCode/.github/workflows/ci-cd.yml::True.push::0", "entity_id": "/home/deeog/Desktop/KnowCode/.github/workflows/ci-cd.yml::True.push", "content": "push", "tokens": ["push"], "metadata": {"kind": "config_key", "has_docstring": "false", "last_modified": "1767810449.2959297"}}, {"id": "/home/deeog/Desktop/KnowCode/.github/workflows/ci-cd.yml::True.push.branches::0", "entity_id": "/home/deeog/Desktop/KnowCode/.github/workflows/ci-cd.yml::True.push.branches", "content": "branches", "tokens": ["branches"], "metadata": {"kind": "config_key", "has_docstring": "false", "last_modified": "1767810449.2959297"}}, {"id": "/home/deeog/Desktop/KnowCode/.github/workflows/ci-cd.yml::True.pull_request::0", "entity_id": "/home/deeog/Desktop/KnowCode/.github/workflows/ci-cd.yml::True.pull_request", "content": "pull_request", "tokens": ["pull", "request"], "metadata": {"kind": "config_key", "has_docstring": "false", "last_modified": "1767810449.2959297"}}, {"id": "/home/deeog/Desktop/KnowCode/.github/workflows/ci-cd.yml::True.pull_request.branches::0", "entity_id": "/home/deeog/Desktop/KnowCode/.github/workflows/ci-cd.yml::True.pull_request.branches", "content": "branches", "tokens": ["branches"], "metadata": {"kind": "config_key", "has_docstring": "false", "last_modified": "1767810449.2959297"}}, {"id": "/home/deeog/Desktop/KnowCode/.github/workflows/ci-cd.yml::True.workflow_dispatch::0", "entity_id": "/home/deeog/Desktop/KnowCode/.github/workflows/ci-cd.yml::True.workflow_dispatch", "content": "workflow_dispatch", "tokens": ["workflow", "dispatch"], "metadata": {"kind": "config_key", "has_docstring": "false", "last_modified": "1767810449.2959297"}}, {"id": "/home/deeog/Desktop/KnowCode/.github/workflows/ci-cd.yml::True.workflow_dispatch.inputs::0", "entity_id": "/home/deeog/Desktop/KnowCode/.github/workflows/ci-cd.yml::True.workflow_dispatch.inputs", "content": "inputs", "tokens": ["inputs"], "metadata": {"kind": "config_key", "has_docstring": "false", "last_modified": "1767810449.2959297"}}, {"id": "/home/deeog/Desktop/KnowCode/.github/workflows/ci-cd.yml::True.workflow_dispatch.inputs.changelog_summary::0", "entity_id": "/home/deeog/Desktop/KnowCode/.github/workflows/ci-cd.yml::True.workflow_dispatch.inputs.changelog_summary", "content": "changelog_summary", "tokens": ["changelog", "summary"], "metadata": {"kind": "config_key", "has_docstring": "false", "last_modified": "1767810449.2959297"}}, {"id": "/home/deeog/Desktop/KnowCode/.github/workflows/ci-cd.yml::True.workflow_dispatch.inputs.changelog_summary.description::0", "entity_id": "/home/deeog/Desktop/KnowCode/.github/workflows/ci-cd.yml::True.workflow_dispatch.inputs.changelog_summary.description", "content": "description", "tokens": ["description"], "metadata": {"kind": "config_key", "has_docstring": "false", "last_modified": "1767810449.2959297"}}, {"id": "/home/deeog/Desktop/KnowCode/.github/workflows/ci-cd.yml::True.workflow_dispatch.inputs.changelog_summary.required::0", "entity_id": "/home/deeog/Desktop/KnowCode/.github/workflows/ci-cd.yml::True.workflow_dispatch.inputs.changelog_summary.required", "content": "required", "tokens": ["required"], "metadata": {"kind": "config_key", "has_docstring": "false", "last_modified": "1767810449.2959297"}}, {"id": "/home/deeog/Desktop/KnowCode/.github/workflows/ci-cd.yml::True.workflow_dispatch.inputs.changelog_summary.default::0", "entity_id": "/home/deeog/Desktop/KnowCode/.github/workflows/ci-cd.yml::True.workflow_dispatch.inputs.changelog_summary.default", "content": "default", "tokens": ["default"], "metadata": {"kind": "config_key", "has_docstring": "false", "last_modified": "1767810449.2959297"}}, {"id": "/home/deeog/Desktop/KnowCode/.github/workflows/ci-cd.yml::permissions::0", "entity_id": "/home/deeog/Desktop/KnowCode/.github/workflows/ci-cd.yml::permissions", "content": "permissions", "tokens": ["permissions"], "metadata": {"kind": "config_key", "has_docstring": "false", "last_modified": "1767810449.2959297"}}, {"id": "/home/deeog/Desktop/KnowCode/.github/workflows/ci-cd.yml::permissions.contents::0", "entity_id": "/home/deeog/Desktop/KnowCode/.github/workflows/ci-cd.yml::permissions.contents", "content": "contents", "tokens": ["contents"], "metadata": {"kind": "config_key", "has_docstring": "false", "last_modified": "1767810449.2959297"}}, {"id": "/home/deeog/Desktop/KnowCode/.github/workflows/ci-cd.yml::jobs::0", "entity_id": "/home/deeog/Desktop/KnowCode/.github/workflows/ci-cd.yml::jobs", "content": "jobs", "tokens": ["jobs"], "metadata": {"kind": "config_key", "has_docstring": "false", "last_modified": "1767810449.2959297"}}, {"id": "/home/deeog/Desktop/KnowCode/.github/workflows/ci-cd.yml::jobs.test::0", "entity_id": "/home/deeog/Desktop/KnowCode/.github/workflows/ci-cd.yml::jobs.test", "content": "test", "tokens": ["test"], "metadata": {"kind": "config_key", "has_docstring": "false", "last_modified": "1767810449.2959297"}}, {"id": "/home/deeog/Desktop/KnowCode/.github/workflows/ci-cd.yml::jobs.test.name::0", "entity_id": "/home/deeog/Desktop/KnowCode/.github/workflows/ci-cd.yml::jobs.test.name", "content": "name", "tokens": ["name"], "metadata": {"kind": "config_key", "has_docstring": "false", "last_modified": "1767810449.2959297"}}, {"id": "/home/deeog/Desktop/KnowCode/.github/workflows/ci-cd.yml::jobs.test.runs-on::0", "entity_id": "/home/deeog/Desktop/KnowCode/.github/workflows/ci-cd.yml::jobs.test.runs-on", "content": "runs-on", "tokens": ["runs", "on"], "metadata": {"kind": "config_key", "has_docstring": "false", "last_modified": "1767810449.2959297"}}, {"id": "/home/deeog/Desktop/KnowCode/.github/workflows/ci-cd.yml::jobs.test.strategy::0", "entity_id": "/home/deeog/Desktop/KnowCode/.github/workflows/ci-cd.yml::jobs.test.strategy", "content": "strategy", "tokens": ["strategy"], "metadata": {"kind": "config_key", "has_docstring": "false", "last_modified": "1767810449.2959297"}}, {"id": "/home/deeog/Desktop/KnowCode/.github/workflows/ci-cd.yml::jobs.test.strategy.fail-fast::0", "entity_id": "/home/deeog/Desktop/KnowCode/.github/workflows/ci-cd.yml::jobs.test.strategy.fail-fast", "content": "fail-fast", "tokens": ["fail", "fast"], "metadata": {"kind": "config_key", "has_docstring": "false", "last_modified": "1767810449.2959297"}}, {"id": "/home/deeog/Desktop/KnowCode/.github/workflows/ci-cd.yml::jobs.test.strategy.matrix::0", "entity_id": "/home/deeog/Desktop/KnowCode/.github/workflows/ci-cd.yml::jobs.test.strategy.matrix", "content": "matrix", "tokens": ["matrix"], "metadata": {"kind": "config_key", "has_docstring": "false", "last_modified": "1767810449.2959297"}}, {"id": "/home/deeog/Desktop/KnowCode/.github/workflows/ci-cd.yml::jobs.test.strategy.matrix.os::0", "entity_id": "/home/deeog/Desktop/KnowCode/.github/workflows/ci-cd.yml::jobs.test.strategy.matrix.os", "content": "os", "tokens": ["os"], "metadata": {"kind": "config_key", "has_docstring": "false", "last_modified": "1767810449.2959297"}}, {"id": "/home/deeog/Desktop/KnowCode/.github/workflows/ci-cd.yml::jobs.test.strategy.matrix.python-version::0", "entity_id": "/home/deeog/Desktop/KnowCode/.github/workflows/ci-cd.yml::jobs.test.strategy.matrix.python-version", "content": "python-version", "tokens": ["python", "version"], "metadata": {"kind": "config_key", "has_docstring": "false", "last_modified": "1767810449.2959297"}}, {"id": "/home/deeog/Desktop/KnowCode/.github/workflows/ci-cd.yml::jobs.test.steps::0", "entity_id": "/home/deeog/Desktop/KnowCode/.github/workflows/ci-cd.yml::jobs.test.steps", "content": "steps", "tokens": ["steps"], "metadata": {"kind": "config_key", "has_docstring": "false", "last_modified": "1767810449.2959297"}}, {"id": "/home/deeog/Desktop/KnowCode/.github/workflows/ci-cd.yml::jobs.docs::0", "entity_id": "/home/deeog/Desktop/KnowCode/.github/workflows/ci-cd.yml::jobs.docs", "content": "docs", "tokens": ["docs"], "metadata": {"kind": "config_key", "has_docstring": "false", "last_modified": "1767810449.2959297"}}, {"id": "/home/deeog/Desktop/KnowCode/.github/workflows/ci-cd.yml::jobs.docs.name::0", "entity_id": "/home/deeog/Desktop/KnowCode/.github/workflows/ci-cd.yml::jobs.docs.name", "content": "name", "tokens": ["name"], "metadata": {"kind": "config_key", "has_docstring": "false", "last_modified": "1767810449.2959297"}}, {"id": "/home/deeog/Desktop/KnowCode/.github/workflows/ci-cd.yml::jobs.docs.runs-on::0", "entity_id": "/home/deeog/Desktop/KnowCode/.github/workflows/ci-cd.yml::jobs.docs.runs-on", "content": "runs-on", "tokens": ["runs", "on"], "metadata": {"kind": "config_key", "has_docstring": "false", "last_modified": "1767810449.2959297"}}, {"id": "/home/deeog/Desktop/KnowCode/.github/workflows/ci-cd.yml::jobs.docs.needs::0", "entity_id": "/home/deeog/Desktop/KnowCode/.github/workflows/ci-cd.yml::jobs.docs.needs", "content": "needs", "tokens": ["needs"], "metadata": {"kind": "config_key", "has_docstring": "false", "last_modified": "1767810449.2959297"}}, {"id": "/home/deeog/Desktop/KnowCode/.github/workflows/ci-cd.yml::jobs.docs.steps::0", "entity_id": "/home/deeog/Desktop/KnowCode/.github/workflows/ci-cd.yml::jobs.docs.steps", "content": "steps", "tokens": ["steps"], "metadata": {"kind": "config_key", "has_docstring": "false", "last_modified": "1767810449.2959297"}}, {"id": "/home/deeog/Desktop/KnowCode/.github/workflows/ci-cd.yml::jobs.changelog::0", "entity_id": "/home/deeog/Desktop/KnowCode/.github/workflows/ci-cd.yml::jobs.changelog", "content": "changelog", "tokens": ["changelog"], "metadata": {"kind": "config_key", "has_docstring": "false", "last_modified": "1767810449.2959297"}}, {"id": "/home/deeog/Desktop/KnowCode/.github/workflows/ci-cd.yml::jobs.changelog.name::0", "entity_id": "/home/deeog/Desktop/KnowCode/.github/workflows/ci-cd.yml::jobs.changelog.name", "content": "name", "tokens": ["name"], "metadata": {"kind": "config_key", "has_docstring": "false", "last_modified": "1767810449.2959297"}}, {"id": "/home/deeog/Desktop/KnowCode/.github/workflows/ci-cd.yml::jobs.changelog.runs-on::0", "entity_id": "/home/deeog/Desktop/KnowCode/.github/workflows/ci-cd.yml::jobs.changelog.runs-on", "content": "runs-on", "tokens": ["runs", "on"], "metadata": {"kind": "config_key", "has_docstring": "false", "last_modified": "1767810449.2959297"}}, {"id": "/home/deeog/Desktop/KnowCode/.github/workflows/ci-cd.yml::jobs.changelog.if::0", "entity_id": "/home/deeog/Desktop/KnowCode/.github/workflows/ci-cd.yml::jobs.changelog.if", "content": "if", "tokens": ["if"], "metadata": {"kind": "config_key", "has_docstring": "false", "last_modified": "1767810449.2959297"}}, {"id": "/home/deeog/Desktop/KnowCode/.github/workflows/ci-cd.yml::jobs.changelog.steps::0", "entity_id": "/home/deeog/Desktop/KnowCode/.github/workflows/ci-cd.yml::jobs.changelog.steps", "content": "steps", "tokens": ["steps"], "metadata": {"kind": "config_key", "has_docstring": "false", "last_modified": "1767810449.2959297"}}, {"id": "/home/deeog/Desktop/KnowCode/scripts/generate_changelog.py::imports::0", "entity_id": "/home/deeog/Desktop/KnowCode/scripts/generate_changelog.py::module", "content": "import argparse\nimport subprocess\nimport sys\nfrom datetime import datetime\nfrom pathlib import Path", "tokens": ["import", "argparse", "import", "subprocess", "import", "sys", "from", "datetime", "import", "datetime", "from", "pathlib", "import", "path"], "metadata": {"type": "imports"}}, {"id": "/home/deeog/Desktop/KnowCode/scripts/generate_changelog.py::get_git_log::0", "entity_id": "/home/deeog/Desktop/KnowCode/scripts/generate_changelog.py::get_git_log", "content": "def get_git_log(range_str)\n\"\"\"Get raw git log for the specified range.\"\"\"\ndef get_git_log(range_str=\"HEAD~1..HEAD\"):\n    \"\"\"Get raw git log for the specified range.\"\"\"\n    # Format: hash|author|date|message matches the \"structured\" requirement loosely\n    # But user wants to follow EVOLUTION.md template.\n    # We will try to parse standard conventional commits if available.\n    try:\n        cmd = [\"git\", \"log\", range_str, \"--pretty=format:%h|%an|%ad|%s%n%b\", \"--date=short\"]\n        result = subprocess.run(cmd, capture_output=True, text=True, check=True)\n        output = result.stdout.strip()\n        if not output:\n            return []\n        # Split by double newline to separate commits\n        return output.split(\"\\n\\n\")\n    except subprocess.CalledProcessError:\n        print(f\"Error reading git log for range {range_str}\")\n        return []", "tokens": ["def", "get", "git", "log", "range", "str", "get", "raw", "git", "log", "for", "the", "specified", "range", "def", "get", "git", "log", "range", "str", "head", "head", "get", "raw", "git", "log", "for", "the", "specified", "range", "format", "hash", "author", "date", "message", "matches", "the", "structured", "requirement", "loosely", "but", "user", "wants", "to", "follow", "evolution", "md", "template", "we", "will", "try", "to", "parse", "standard", "conventional", "commits", "if", "available", "try", "cmd", "git", "log", "range", "str", "pretty", "format", "an", "ad", "date", "short", "result", "subprocess", "run", "cmd", "capture", "output", "true", "text", "true", "check", "true", "output", "result", "stdout", "strip", "if", "not", "output", "return", "split", "by", "double", "newline", "to", "separate", "commits", "return", "output", "split", "except", "subprocess", "called", "process", "error", "print", "error", "reading", "git", "log", "for", "range", "range", "str", "return"], "metadata": {"kind": "function", "has_docstring": "true", "last_modified": "1767810449.2963154"}}, {"id": "/home/deeog/Desktop/KnowCode/scripts/generate_changelog.py::get_latest_tag::0", "entity_id": "/home/deeog/Desktop/KnowCode/scripts/generate_changelog.py::get_latest_tag", "content": "def get_latest_tag()\n\"\"\"Return the most recent git tag reachable from HEAD.\"\"\"\ndef get_latest_tag():\n    \"\"\"Return the most recent git tag reachable from HEAD.\"\"\"\n    try:\n        cmd = [\"git\", \"describe\", \"--tags\", \"--abbrev=0\"]\n        result = subprocess.run(cmd, capture_output=True, text=True, check=True)\n        tag = result.stdout.strip()\n        return tag or None\n    except subprocess.CalledProcessError:\n        return None", "tokens": ["def", "get", "latest", "tag", "return", "the", "most", "recent", "git", "tag", "reachable", "from", "head", "def", "get", "latest", "tag", "return", "the", "most", "recent", "git", "tag", "reachable", "from", "head", "try", "cmd", "git", "describe", "tags", "abbrev", "result", "subprocess", "run", "cmd", "capture", "output", "true", "text", "true", "check", "true", "tag", "result", "stdout", "strip", "return", "tag", "or", "none", "except", "subprocess", "called", "process", "error", "return", "none"], "metadata": {"kind": "function", "has_docstring": "true", "last_modified": "1767810449.2963154"}}, {"id": "/home/deeog/Desktop/KnowCode/scripts/generate_changelog.py::compute_confidence::0", "entity_id": "/home/deeog/Desktop/KnowCode/scripts/generate_changelog.py::compute_confidence", "content": "def compute_confidence(commits, known_types)\n\"\"\"Compute confidence based on conventional commit parsing coverage.\"\"\"\ndef compute_confidence(commits, known_types):\n    \"\"\"Compute confidence based on conventional commit parsing coverage.\"\"\"\n    if not commits:\n        return \"low\"\n    known = sum(1 for c in commits if c[\"type\"].split(\"(\")[0] in known_types)\n    ratio = known / len(commits)\n    if ratio == 1.0:\n        return \"high\"\n    if ratio >= 0.6:\n        return \"medium\"\n    return \"low\"", "tokens": ["def", "compute", "confidence", "commits", "known", "types", "compute", "confidence", "based", "on", "conventional", "commit", "parsing", "coverage", "def", "compute", "confidence", "commits", "known", "types", "compute", "confidence", "based", "on", "conventional", "commit", "parsing", "coverage", "if", "not", "commits", "return", "low", "known", "sum", "for", "in", "commits", "if", "type", "split", "in", "known", "types", "ratio", "known", "len", "commits", "if", "ratio", "return", "high", "if", "ratio", "return", "medium", "return", "low"], "metadata": {"kind": "function", "has_docstring": "true", "last_modified": "1767810449.2963154"}}, {"id": "/home/deeog/Desktop/KnowCode/scripts/generate_changelog.py::parse_commit::0", "entity_id": "/home/deeog/Desktop/KnowCode/scripts/generate_changelog.py::parse_commit", "content": "def parse_commit(commit_text)\n\"\"\"Parse a single commit block.\"\"\"\ndef parse_commit(commit_text):\n    \"\"\"Parse a single commit block.\"\"\"\n    lines = commit_text.strip().split('\\n')\n    header = lines[0].split('|')\n    if len(header) < 4:\n        return None\n    \n    commit_hash = header[0]\n    author = header[1]\n    date = header[2]\n    subject = header[3]\n    body = \"\\n\".join(lines[1:]) if len(lines) > 1 else \"\"\n    \n    # Simple conventional commit parsing\n    type_scope = \"other\"\n    desc = subject\n    if ':' in subject:\n        parts = subject.split(':', 1)\n        type_scope = parts[0].strip()\n        desc = parts[1].strip()\n    \n    return {\n        \"hash\": commit_hash,\n        \"author\": author,\n        \"date\": date,\n        \"subject\": subject,\n        \"body\": body,\n        \"type\": type_scope,\n        \"desc\": desc\n    }", "tokens": ["def", "parse", "commit", "commit", "text", "parse", "single", "commit", "block", "def", "parse", "commit", "commit", "text", "parse", "single", "commit", "block", "lines", "commit", "text", "strip", "split", "header", "lines", "split", "if", "len", "header", "return", "none", "commit", "hash", "header", "author", "header", "date", "header", "subject", "header", "body", "join", "lines", "if", "len", "lines", "else", "simple", "conventional", "commit", "parsing", "type", "scope", "other", "desc", "subject", "if", "in", "subject", "parts", "subject", "split", "type", "scope", "parts", "strip", "desc", "parts", "strip", "return", "hash", "commit", "hash", "author", "author", "date", "date", "subject", "subject", "body", "body", "type", "type", "scope", "desc", "desc"], "metadata": {"kind": "function", "has_docstring": "true", "last_modified": "1767810449.2963154"}}, {"id": "/home/deeog/Desktop/KnowCode/scripts/generate_changelog.py::generate_entry::0", "entity_id": "/home/deeog/Desktop/KnowCode/scripts/generate_changelog.py::generate_entry", "content": "def generate_entry(commits, range_str, origin, summary)\ndef generate_entry(commits, range_str, origin=\"generated\", summary=None):\n    if not commits:\n        return \"\"\n\n    # Group by type\n    groups = {}\n    for c in commits:\n        t = c['type'].lower()\n        if '(' in t: # handle feat(ui)\n            t = t.split('(')[0]\n        if t not in groups:\n            groups[t] = []\n        groups[t].append(c)\n\n    # Markdown Generation strictly following a simplified version of EVOLUTION.md structure\n    # We can't auto-generate \"Temporal Context\" or \"Architectural Impact\" easily without AI.\n    # We will put placeholders.\n    \n    now = datetime.now().strftime(\"%Y-%m-%d\")\n    known_types = {\"feat\", \"fix\", \"refactor\", \"perf\", \"test\", \"docs\", \"chore\"}\n    confidence = compute_confidence(commits, known_types)\n    output = []\n    output.append(f\"## [Unreleased] - {now}\")\n    output.append(\"\")\n    output.append(f\"**Origin:** {origin.title()}\")\n    output.append(f\"**Range:** `{range_str}`\")\n ", "tokens": ["def", "generate", "entry", "commits", "range", "str", "origin", "summary", "def", "generate", "entry", "commits", "range", "str", "origin", "generated", "summary", "none", "if", "not", "commits", "return", "group", "by", "type", "groups", "for", "in", "commits", "type", "lower", "if", "in", "handle", "feat", "ui", "split", "if", "not", "in", "groups", "groups", "groups", "append", "markdown", "generation", "strictly", "following", "simplified", "version", "of", "evolution", "md", "structure", "we", "can", "auto", "generate", "temporal", "context", "or", "architectural", "impact", "easily", "without", "ai", "we", "will", "put", "placeholders", "now", "datetime", "now", "strftime", "known", "types", "feat", "fix", "refactor", "perf", "test", "docs", "chore", "confidence", "compute", "confidence", "commits", "known", "types", "output", "output", "append", "unreleased", "now", "output", "append", "output", "append", "origin", "origin", "title", "output", "append", "range", "range", "str"], "metadata": {"kind": "function", "chunk_index": "0", "has_docstring": "false", "last_modified": "1767810449.2963154"}}, {"id": "/home/deeog/Desktop/KnowCode/scripts/generate_changelog.py::generate_entry::1", "entity_id": "/home/deeog/Desktop/KnowCode/scripts/generate_changelog.py::generate_entry", "content": "\n    output.append(f\"**Origin:** {origin.title()}\")\n    output.append(f\"**Range:** `{range_str}`\")\n    output.append(f\"**Commit Count:** {len(commits)}\")\n    output.append(f\"**Confidence:** {confidence}\")\n    output.append(\"\")\n    # Determine intent from the most common type or the first commit\n    focus = \"Routine Maintenance\"\n    if 'feat' in groups:\n        focus = \"Feature Development\"\n    if 'fix' in groups:\n        focus = \"Bug Fixes\"\n    \n    output.append(f\"**Focus:** {focus}\")\n    output.append(\"\")\n    output.append(\"### \ud83e\udde0 Temporal Context & Intent\")\n    if summary:\n        output.append(f\"> {summary}\")\n    else:\n        output.append(\"> *Auto-generated: Add context about why these changes were made.*\")\n    output.append(\"\")\n    output.append(\"### \ud83c\udfd7\ufe0f Architectural Impact\")\n    output.append(\"> *Auto-generated: Describe high-level architectural shifts.*\")\n    output.append(\"\")\n    output.append(\"### \ud83d\udcdd Delta Changes\")\n    output.append(\"\")\n\n    # Map conventional types to EVOLUT", "tokens": ["output", "append", "origin", "origin", "title", "output", "append", "range", "range", "str", "output", "append", "commit", "count", "len", "commits", "output", "append", "confidence", "confidence", "output", "append", "determine", "intent", "from", "the", "most", "common", "type", "or", "the", "first", "commit", "focus", "routine", "maintenance", "if", "feat", "in", "groups", "focus", "feature", "development", "if", "fix", "in", "groups", "focus", "bug", "fixes", "output", "append", "focus", "focus", "output", "append", "output", "append", "temporal", "context", "intent", "if", "summary", "output", "append", "summary", "else", "output", "append", "auto", "generated", "add", "context", "about", "why", "these", "changes", "were", "made", "output", "append", "output", "append", "architectural", "impact", "output", "append", "auto", "generated", "describe", "high", "level", "architectural", "shifts", "output", "append", "output", "append", "delta", "changes", "output", "append", "map", "conventional", "types", "to", "evolut"], "metadata": {"kind": "function", "chunk_index": "1", "has_docstring": "false", "last_modified": "1767810449.2963154"}}, {"id": "/home/deeog/Desktop/KnowCode/scripts/generate_changelog.py::generate_entry::2", "entity_id": "/home/deeog/Desktop/KnowCode/scripts/generate_changelog.py::generate_entry", "content": "  output.append(\"### \ud83d\udcdd Delta Changes\")\n    output.append(\"\")\n\n    # Map conventional types to EVOLUTION.md sections\n    type_map = {\n        'feat': '\ud83d\ude80 Features',\n        'fix': '\ud83d\udc1b Fixes',\n        'refactor': '\ud83d\udd28 Refactoring',\n        'perf': '\u26a1 Performance',\n        'test': '\u2705 Testing',\n        'docs': '\ud83d\udcda Documentation',\n        'chore': '\ud83d\udd27 Maintenance'\n    }\n\n    # Features\n    for type_key in ['feat', 'fix', 'chore', 'docs', 'refactor', 'perf', 'test']:\n        if type_key in groups:\n            header = type_map.get(type_key, f\"Changes ({type_key})\")\n            output.append(f\"#### {header}\")\n            for c in groups[type_key]:\n                # Attempt to extract scope\n                scope = \"\"\n                s_subj = c['subject']\n                if ':' in s_subj:\n                    pre = s_subj.split(':')[0]\n                    if '(' in pre and ')' in pre:\n                        scope = pre.split('(')[1].split(')')[0]\n                \n                prefix = f\"**{scope}:", "tokens": ["output", "append", "delta", "changes", "output", "append", "map", "conventional", "types", "to", "evolution", "md", "sections", "type", "map", "feat", "features", "fix", "fixes", "refactor", "refactoring", "perf", "performance", "test", "testing", "docs", "documentation", "chore", "maintenance", "features", "for", "type", "key", "in", "feat", "fix", "chore", "docs", "refactor", "perf", "test", "if", "type", "key", "in", "groups", "header", "type", "map", "get", "type", "key", "changes", "type", "key", "output", "append", "header", "for", "in", "groups", "type", "key", "attempt", "to", "extract", "scope", "scope", "subj", "subject", "if", "in", "subj", "pre", "subj", "split", "if", "in", "pre", "and", "in", "pre", "scope", "pre", "split", "split", "prefix", "scope"], "metadata": {"kind": "function", "chunk_index": "2", "has_docstring": "false", "last_modified": "1767810449.2963154"}}, {"id": "/home/deeog/Desktop/KnowCode/scripts/generate_changelog.py::generate_entry::3", "entity_id": "/home/deeog/Desktop/KnowCode/scripts/generate_changelog.py::generate_entry", "content": "      scope = pre.split('(')[1].split(')')[0]\n                \n                prefix = f\"**{scope}:** \" if scope else \"\"\n                output.append(f\"* {prefix}{c['desc']} (`{c['hash']}`)\")\n                if c['body']:\n                    # Indent body as context\n                    for line in c['body'].split('\\n'):\n                        if line.strip():\n                            output.append(f\"    * *Context:* {line.strip()}\")\n            output.append(\"\")\n            \n    # Handle others\n    others = [c for c in commits if c['type'].split('(')[0] not in type_map]\n    if others:\n        output.append(\"#### \ud83d\udce6 Other Changes\")\n        for c in others:\n            output.append(f\"* {c['subject']} (`{c['hash']}`)\")\n        output.append(\"\")\n\n    return \"\\n\".join(output)", "tokens": ["scope", "pre", "split", "split", "prefix", "scope", "if", "scope", "else", "output", "append", "prefix", "desc", "hash", "if", "body", "indent", "body", "as", "context", "for", "line", "in", "body", "split", "if", "line", "strip", "output", "append", "context", "line", "strip", "output", "append", "handle", "others", "others", "for", "in", "commits", "if", "type", "split", "not", "in", "type", "map", "if", "others", "output", "append", "other", "changes", "for", "in", "others", "output", "append", "subject", "hash", "output", "append", "return", "join", "output"], "metadata": {"kind": "function", "chunk_index": "3", "has_docstring": "false", "last_modified": "1767810449.2963154"}}, {"id": "/home/deeog/Desktop/KnowCode/scripts/generate_changelog.py::main::0", "entity_id": "/home/deeog/Desktop/KnowCode/scripts/generate_changelog.py::main", "content": "def main()\ndef main():\n    changelog_path = Path(\"CHANGELOG.md\")\n\n    parser = argparse.ArgumentParser(description=\"Generate a changelog entry from git history.\")\n    parser.add_argument(\n        \"--range\",\n        dest=\"range_str\",\n        default=None,\n        help=\"Git commit range (e.g., v2.1.0..HEAD).\",\n    )\n    parser.add_argument(\n        \"--use-last-tag\",\n        action=\"store_true\",\n        help=\"Use the latest tag as the start of the range (falls back if none).\",\n    )\n    parser.add_argument(\n        \"--origin\",\n        default=\"generated\",\n        help=\"Origin label for the entry (generated or curated).\",\n    )\n    parser.add_argument(\n        \"--summary\",\n        default=None,\n        help=\"Plain-English summary of the changes to include in the entry.\",\n    )\n    parser.add_argument(\n        \"--summary-file\",\n        default=None,\n        help=\"Path to a file containing the plain-English summary.\",\n    )\n    args = parser.parse_args()\n\n    if args.range_str:\n        range", "tokens": ["def", "main", "def", "main", "changelog", "path", "path", "changelog", "md", "parser", "argparse", "argument", "parser", "description", "generate", "changelog", "entry", "from", "git", "history", "parser", "add", "argument", "range", "dest", "range", "str", "default", "none", "help", "git", "commit", "range", "v2", "head", "parser", "add", "argument", "use", "last", "tag", "action", "store", "true", "help", "use", "the", "latest", "tag", "as", "the", "start", "of", "the", "range", "falls", "back", "if", "none", "parser", "add", "argument", "origin", "default", "generated", "help", "origin", "label", "for", "the", "entry", "generated", "or", "curated", "parser", "add", "argument", "summary", "default", "none", "help", "plain", "english", "summary", "of", "the", "changes", "to", "include", "in", "the", "entry", "parser", "add", "argument", "summary", "file", "default", "none", "help", "path", "to", "file", "containing", "the", "plain", "english", "summary", "args", "parser", "parse", "args", "if", "args", "range", "str", "range"], "metadata": {"kind": "function", "chunk_index": "0", "has_docstring": "false", "last_modified": "1767810449.2963154"}}, {"id": "/home/deeog/Desktop/KnowCode/scripts/generate_changelog.py::main::1", "entity_id": "/home/deeog/Desktop/KnowCode/scripts/generate_changelog.py::main", "content": " plain-English summary.\",\n    )\n    args = parser.parse_args()\n\n    if args.range_str:\n        range_str = args.range_str\n    elif args.use_last_tag:\n        tag = get_latest_tag()\n        range_str = f\"{tag}..HEAD\" if tag else \"HEAD~5..HEAD\"\n    else:\n        range_str = \"HEAD~5..HEAD\"\n\n    # In a real CI, we might compare against the last tag.\n    commits_raw = get_git_log(range_str)\n    parsed_commits = [parse_commit(c) for c in commits_raw if c]\n    parsed_commits = [c for c in parsed_commits if c] # filter Nones\n\n    summary = args.summary\n    if args.summary_file:\n        try:\n            summary = Path(args.summary_file).read_text(encoding=\"utf-8\").strip()\n        except OSError as exc:\n            print(f\"Failed to read summary file: {exc}\")\n            sys.exit(1)\n\n    new_entry = generate_entry(parsed_commits, range_str, origin=args.origin, summary=summary)\n    \n    if not new_entry:\n        print(\"No commits found to generate changelog.\")\n        return\n\n    print(\"Generated", "tokens": ["plain", "english", "summary", "args", "parser", "parse", "args", "if", "args", "range", "str", "range", "str", "args", "range", "str", "elif", "args", "use", "last", "tag", "tag", "get", "latest", "tag", "range", "str", "tag", "head", "if", "tag", "else", "head", "head", "else", "range", "str", "head", "head", "in", "real", "ci", "we", "might", "compare", "against", "the", "last", "tag", "commits", "raw", "get", "git", "log", "range", "str", "parsed", "commits", "parse", "commit", "for", "in", "commits", "raw", "if", "parsed", "commits", "for", "in", "parsed", "commits", "if", "filter", "nones", "summary", "args", "summary", "if", "args", "summary", "file", "try", "summary", "path", "args", "summary", "file", "read", "text", "encoding", "utf", "strip", "except", "oserror", "as", "exc", "print", "failed", "to", "read", "summary", "file", "exc", "sys", "exit", "new", "entry", "generate", "entry", "parsed", "commits", "range", "str", "origin", "args", "origin", "summary", "summary", "if", "not", "new", "entry", "print", "no", "commits", "found", "to", "generate", "changelog", "return", "print", "generated"], "metadata": {"kind": "function", "chunk_index": "1", "has_docstring": "false", "last_modified": "1767810449.2963154"}}, {"id": "/home/deeog/Desktop/KnowCode/scripts/generate_changelog.py::main::2", "entity_id": "/home/deeog/Desktop/KnowCode/scripts/generate_changelog.py::main", "content": "entry:\n        print(\"No commits found to generate changelog.\")\n        return\n\n    print(\"Generated Changelog Entry:\")\n    print(new_entry)\n\n    # Append mode (or prepend? Usually changelogs are prepended, but user asked for Append Mode)\n    # \"write them (append mode) to a change log markdown file\"\n    # I will stick to append as requested, although it's unusual for changelogs.\n    \n    mode = 'a' if changelog_path.exists() else 'w'\n    with open(changelog_path, mode, encoding='utf-8') as f:\n        if mode == 'a':\n            f.write(\"\\n\\n---\\n\\n\")\n        f.write(new_entry)\n    \n    print(f\"\\nSuccessfully appended to {changelog_path}\")", "tokens": ["entry", "print", "no", "commits", "found", "to", "generate", "changelog", "return", "print", "generated", "changelog", "entry", "print", "new", "entry", "append", "mode", "or", "prepend", "usually", "changelogs", "are", "prepended", "but", "user", "asked", "for", "append", "mode", "write", "them", "append", "mode", "to", "change", "log", "markdown", "file", "will", "stick", "to", "append", "as", "requested", "although", "it", "unusual", "for", "changelogs", "mode", "if", "changelog", "path", "exists", "else", "with", "open", "changelog", "path", "mode", "encoding", "utf", "as", "if", "mode", "write", "write", "new", "entry", "print", "successfully", "appended", "to", "changelog", "path"], "metadata": {"kind": "function", "chunk_index": "2", "has_docstring": "false", "last_modified": "1767810449.2963154"}}, {"id": "/home/deeog/Desktop/KnowCode/scripts/evaluate.py::module::0", "entity_id": "/home/deeog/Desktop/KnowCode/scripts/evaluate.py::module", "content": "\"\"\"Evaluation script for retrieval quality.\"\"\"", "tokens": ["evaluation", "script", "for", "retrieval", "quality"], "metadata": {"type": "module_header"}}, {"id": "/home/deeog/Desktop/KnowCode/scripts/evaluate.py::imports::0", "entity_id": "/home/deeog/Desktop/KnowCode/scripts/evaluate.py::module", "content": "import json\nimport os\nimport sys\nfrom pathlib import Path\nfrom knowcode.storage.chunk_repository import InMemoryChunkRepository\nfrom knowcode.storage.vector_store import VectorStore\nfrom knowcode.retrieval.hybrid_index import HybridIndex\nfrom knowcode.llm.embedding import OpenAIEmbeddingProvider\nfrom knowcode.data_models import EmbeddingConfig, CodeChunk", "tokens": ["import", "json", "import", "os", "import", "sys", "from", "pathlib", "import", "path", "from", "knowcode", "storage", "chunk", "repository", "import", "in", "memory", "chunk", "repository", "from", "knowcode", "storage", "vector", "store", "import", "vector", "store", "from", "knowcode", "retrieval", "hybrid", "index", "import", "hybrid", "index", "from", "knowcode", "llm", "embedding", "import", "open", "aiembedding", "provider", "from", "knowcode", "data", "models", "import", "embedding", "config", "code", "chunk"], "metadata": {"type": "imports"}}, {"id": "/home/deeog/Desktop/KnowCode/scripts/evaluate.py::evaluate::0", "entity_id": "/home/deeog/Desktop/KnowCode/scripts/evaluate.py::evaluate", "content": "def evaluate(ground_truth_path: Path, index_path: Path) -> dict\n\"\"\"Evaluate retrieval quality against ground truth.\"\"\"\ndef evaluate(ground_truth_path: Path, index_path: Path) -> dict:\n    \"\"\"Evaluate retrieval quality against ground truth.\"\"\"\n    if not ground_truth_path.exists():\n        return {\"error\": \"Ground truth file not found\"}\n        \n    with open(ground_truth_path) as f:\n        ground_truth = json.load(f)\n    \n    # Load index components\n    repo = InMemoryChunkRepository()\n    # Assuming index_path is directory containing chunks.json and vectors used by Indexer.load\n    # Note: Indexer.load logic:\n    # chunks_file = path / \"chunks.json\"\n    # vector_path = path / \"vectors\"\n    \n    chunks_file = index_path / \"chunks.json\"\n    if chunks_file.exists():\n        with open(chunks_file) as f:\n            data = json.load(f)\n            for c_data in data[\"chunks\"]:\n                repo.add(CodeChunk(**c_data))\n                \n    vs = VectorStore(dimension=1536, index_path=in", "tokens": ["def", "evaluate", "ground", "truth", "path", "path", "index", "path", "path", "dict", "evaluate", "retrieval", "quality", "against", "ground", "truth", "def", "evaluate", "ground", "truth", "path", "path", "index", "path", "path", "dict", "evaluate", "retrieval", "quality", "against", "ground", "truth", "if", "not", "ground", "truth", "path", "exists", "return", "error", "ground", "truth", "file", "not", "found", "with", "open", "ground", "truth", "path", "as", "ground", "truth", "json", "load", "load", "index", "components", "repo", "in", "memory", "chunk", "repository", "assuming", "index", "path", "is", "directory", "containing", "chunks", "json", "and", "vectors", "used", "by", "indexer", "load", "note", "indexer", "load", "logic", "chunks", "file", "path", "chunks", "json", "vector", "path", "path", "vectors", "chunks", "file", "index", "path", "chunks", "json", "if", "chunks", "file", "exists", "with", "open", "chunks", "file", "as", "data", "json", "load", "for", "data", "in", "data", "chunks", "repo", "add", "code", "chunk", "data", "vs", "vector", "store", "dimension", "1536", "index", "path", "in"], "metadata": {"kind": "function", "chunk_index": "0", "has_docstring": "true", "last_modified": "1768185812.992396"}}, {"id": "/home/deeog/Desktop/KnowCode/scripts/evaluate.py::evaluate::1", "entity_id": "/home/deeog/Desktop/KnowCode/scripts/evaluate.py::evaluate", "content": "   repo.add(CodeChunk(**c_data))\n                \n    vs = VectorStore(dimension=1536, index_path=index_path / \"vectors\")\n    # Note: We need a real provider for queries, or mock if vectors are precomputed?\n    # For evaluation we assume we have an API key or use the same provider used for indexing.\n    # Here we assume OpenAI.\n    if not os.environ.get(\"OPENAI_API_KEY\"):\n        print(\"Skipping evaluation: OPENAI_API_KEY not set\")\n        return {}\n\n    provider = OpenAIEmbeddingProvider(EmbeddingConfig())\n\n    hybrid = HybridIndex(repo, vs)\n    \n    # Metrics\n    hits_at_5 = 0\n    hits_at_10 = 0\n    mrr_sum = 0.0\n    total_queries = len(ground_truth)\n    \n    for item in ground_truth:\n        query = item.get(\"query\")\n        expected_ids = set(item.get(\"expected_ids\", []))\n        \n        if not query or not expected_ids:\n            continue\n            \n        q_vec = provider.embed_single(query)\n        # Search directly on hybrid index (skipping SearchEngine wrapper for raw re", "tokens": ["repo", "add", "code", "chunk", "data", "vs", "vector", "store", "dimension", "1536", "index", "path", "index", "path", "vectors", "note", "we", "need", "real", "provider", "for", "queries", "or", "mock", "if", "vectors", "are", "precomputed", "for", "evaluation", "we", "assume", "we", "have", "an", "api", "key", "or", "use", "the", "same", "provider", "used", "for", "indexing", "here", "we", "assume", "open", "ai", "if", "not", "os", "environ", "get", "openai", "api", "key", "print", "skipping", "evaluation", "openai", "api", "key", "not", "set", "return", "provider", "open", "aiembedding", "provider", "embedding", "config", "hybrid", "hybrid", "index", "repo", "vs", "metrics", "hits", "at", "hits", "at", "10", "mrr", "sum", "total", "queries", "len", "ground", "truth", "for", "item", "in", "ground", "truth", "query", "item", "get", "query", "expected", "ids", "set", "item", "get", "expected", "ids", "if", "not", "query", "or", "not", "expected", "ids", "continue", "vec", "provider", "embed", "single", "query", "search", "directly", "on", "hybrid", "index", "skipping", "search", "engine", "wrapper", "for", "raw", "re"], "metadata": {"kind": "function", "chunk_index": "1", "has_docstring": "true", "last_modified": "1768185812.992396"}}, {"id": "/home/deeog/Desktop/KnowCode/scripts/evaluate.py::evaluate::2", "entity_id": "/home/deeog/Desktop/KnowCode/scripts/evaluate.py::evaluate", "content": "ed_single(query)\n        # Search directly on hybrid index (skipping SearchEngine wrapper for raw retrieval eval)\n        results = hybrid.search(query, q_vec, limit=10)\n        \n        found_ids = [c.id for c, _ in results]\n        \n        # Recall@k\n        if any(fid in expected_ids for fid in found_ids[:5]):\n            hits_at_5 += 1\n        if any(fid in expected_ids for fid in found_ids[:10]):\n            hits_at_10 += 1\n            \n        # MRR\n        rank = 0\n        for i, fid in enumerate(found_ids):\n            if fid in expected_ids:\n                rank = i + 1\n                break\n        if rank > 0:\n            mrr_sum += 1.0 / rank\n\n    return {\n        \"precision_at_5\": hits_at_5 / total_queries if total_queries else 0,\n        \"recall_at_10\": hits_at_10 / total_queries if total_queries else 0,\n        \"mrr\": mrr_sum / total_queries if total_queries else 0,\n    }", "tokens": ["ed", "single", "query", "search", "directly", "on", "hybrid", "index", "skipping", "search", "engine", "wrapper", "for", "raw", "retrieval", "eval", "results", "hybrid", "search", "query", "vec", "limit", "10", "found", "ids", "id", "for", "in", "results", "recall", "if", "any", "fid", "in", "expected", "ids", "for", "fid", "in", "found", "ids", "hits", "at", "if", "any", "fid", "in", "expected", "ids", "for", "fid", "in", "found", "ids", "10", "hits", "at", "10", "mrr", "rank", "for", "fid", "in", "enumerate", "found", "ids", "if", "fid", "in", "expected", "ids", "rank", "break", "if", "rank", "mrr", "sum", "rank", "return", "precision", "at", "hits", "at", "total", "queries", "if", "total", "queries", "else", "recall", "at", "10", "hits", "at", "10", "total", "queries", "if", "total", "queries", "else", "mrr", "mrr", "sum", "total", "queries", "if", "total", "queries", "else"], "metadata": {"kind": "function", "chunk_index": "2", "has_docstring": "true", "last_modified": "1768185812.992396"}}, {"id": "/home/deeog/Desktop/KnowCode/docs/index.md::module::0", "entity_id": "/home/deeog/Desktop/KnowCode/docs/index.md::module", "content": "# KnowCode\nTransform your codebase into an effective knowledge base that provides accurate, relevant context for AI coding assistants\u2014using minimal tokens.\n[![codecov](https://codecov.io/gh/deepakdgupta1/KnowCode/graph/badge.svg?token=placeholder)](https://codecov.io/gh/deepakdgupta1/KnowCode) [![CI/CD Pipeline](https://github.com/deepakdgupta1/KnowCode/actions/workflows/ci-cd.yml/badge.svg)](https://github.com/deepakdgupta1/KnowCode/actions/workflows/ci-cd.yml)\n## Overview\nKnowCode analyzes your codebase and builds a semantic graph of entities (functions, classes, modules) and their relationships (calls, imports, dependencies). This structured knowledge enables:\n- **Accurate context synthesis** for AI assistants\n- **Token-efficient** context generation (only what's needed)\n- **Local-first** querying without LLM dependency\n- **Traceability** back to source code\n## Installation\n```bash\n# Create and activate virtual environment\nuv venv\nsource .venv/bin/activate  # On Windows: .venv\\Scripts\\activate\n# Install KnowCode (with dev dependencies)\nuv sync --dev\n# Set API keys (only needed for the features you use; see aimodels.yaml)\nexport VOYAGE_API_KEY_1=\"...\"   # embeddings + reranking (semantic search)\nexport OPENAI_API_KEY=\"...\"     # embeddings (alternative to VoyageAI)\nexport GOOGLE_API_KEY_1=\"...\"   # LLM (Gemini) for `knowcode ask`\n```\n## Quick Start\n```bash\n# 1. Analyze your codebase\nknowcode analyze src/\n# 2. Query the knowledge store\nknowcode query search \"MyClass\"\nknowcode query callers \"my_function\"\nknowcode query callees \"MyClass.method\"\n# 3. Generate context for an entity\nknowcode context \"MyClass.important_method\"\n# 4. Export documentation\nknowcode export -o docs/\n# 5. Build semantic search index\nknowcode index src/\n# 6. Perform semantic search\nknowcode semantic-search \"How does parsing work?\"\n# 7. Start the intelligence server with watch mode\nknowcode server --port 8080 --watch\n# 8. View statistics\nknowcode stats\n```\n## Commands\n### `analyze`\nScan and parse a directory to build the knowledge store.\n```bash\nknowcode analyze <directory> [--output <path>] [--ignore <pattern>]\n```\n**Example:**\n```bash\nknowcode analyze src/ --ignore \"tests/*\" --ignore \"*.pyc\"\n```\n### `query`\nQuery the knowledge store for relationships.\n```bash\nknowcode query <type> <target> [--store <path>] [--json]\n```\n**Query types:**\n- `search <pattern>` - Search entities by name\n- `callers <entity>` - Find what calls this entity\n- `callees <entity>` - Find what this entity calls\n- `deps <entity>` - Get all dependencies\n**Example:**\n```bash\nknowcode query search \"Parser\"\nknowcode query callers \"GraphBuilder.build_from_directory\"\nknowcode query deps \"PythonParser\" --json\n```\n### `context`\nGenerate a context bundle for an entity (ready for AI consumption).\n```bash\nknowcode context <entity> [--store <path>] [--max-chars <n>]\n```\n**Example:**\n```bash\nknowcode context \"GraphBuilder.build_from_directory\" --max-chars 4000\n```\n### `export`\nExport the knowledge store as Markdown documentation.\n```bash\nknowcode export [--store <path>] [--output <dir>]\n```\n**Example:**\n```bash\nknowcode export -o docs/\n```\n### `stats`\nShow statistics about the knowledge store.\n```bash\nknowcode stats [--store <path>]\n```\n### `index`\nBuild a semantic search index for your codebase.\n```bash\nknowcode index <directory> [--output <path>] [--config <path>]\n```\n### `semantic-search`\nPerform a natural language search against the semantic index.\n```bash\nknowcode semantic-search <query> [--index <path>] [--store <path>] [--config <path>] [--limit <n>]\n```\n**Example:**\n```bash\nknowcode semantic-search \"Where is the graph built?\"\n```\n### `server`\nStart the FastAPI intelligence server. This is the preferred way for locally hosted AI agents (IDEs) to interact with KnowCode.\n```bash\nknowcode server [--host <host>] [--port <port>] [--store <path>] [--watch]\n```\n**Example:**\n```bash\nknowcode server --port 8080\n```\nOnce running, you can access endpoints like:\n- `GET /api/v1/context?target=MyClass&task_type=debug`\n- `GET /api/v1/search?q=parser` `(lexical search)`\n- `POST /api/v1/context/query` `(semantic search)`\n- `GET /api/v1/trace_calls/{entity_id}?direction=callers&depth=3` `(multi-hop call graph)`\n- `GET /api/v1/impact/{entity_id}` `(deletion impact analysis)`\n- `POST /api/v1/reload` (to refresh data after a new `analyze` run)\n### `history`\nShow git history for the codebase or specific entities. Requires analysis with `--temporal`.\n```bash\nknowcode history [target] [--limit <n>]\n```\n**Example:**\n```bash\n# Show recent project history\nknowcode history --limit 5\n# Show history for a specific class\nknowcode history \"KnowledgeStore\"\n```\n### `ask`\nAsk questions about the codebase using an LLM agent. Requires an API key for at least one configured model in `aimodels.yaml`.\n```bash\nknowcode ask <question> [--config <path>]\n```\n**Configuration:**\nKnowCode looks for a configuration file in the following order:\n1. `--config` argument\n2. `aimodels.yaml` in current directory\n3. `~/.aimodels.yaml`\n**Example `aimodels.yaml`:**\n```yaml\nnatural_language_models:\n  - name: gemini-2.5-flash\n    provider: google\n    api_key_env: GOOGLE_API_KEY_1\n```\n**Example:**\n```bash\nknowcode ask \"How does the graph builder work?\"\n```\n### `mcp-server`\nStart an MCP (Model Context Protocol) server for IDE agent integration.\n```bash\nknowcode mcp-server [--store <path>]\n```\n**Tools Exposed:**\n- `search_codebase` - Search for code entities by name\n- `get_entity_context` - Get detailed context for an entity\n- `trace_calls` - Trace call graph (callers/callees) with depth\n## Supported Languages (MVP)\n- **Python** (.py) - Full AST parsing (Supports Python 3.9 - 3.12)\n- **JavaScript / TypeScript** (.js, .ts) - Classes, functions, imports (via tree-sitter)\n- **Java** (.java) - Classes, methods, imports, inheritance (via tree-sitter)\n- **Markdown** (.md) - Document structure with heading hierarchy\n- **YAML** (.yaml, .yml) - Configuration keys with nested structure\n## Architecture\nKnowCode follows a layered architecture:\n1. **Scanner** - Discovers files with gitignore support\n2. **Parsers** - Language-specific parsing (Python AST, Tree-sitter for others)\n3. **Graph Builder** - Constructs semantic graph with entities and relationships\n4. **Knowledge Store** - In-memory graph with JSON persistence\n5. **Indexer** - Vector embedding and hybrid retrieval engine (FAISS + BM25)\n6. **Context Synthesizer** - Generates token-efficient context bundles with priority ranking\n7. **CLI** - User interface for all operations\nSee [evolution.md](evolution.md) for the complete reference architecture.\n## Example Output\n**Stats:**\n```\nTotal Entities: 98\n  class: 15\n  function: 6\n  method: 66\n  module: 11\nTotal Relationships: 616\n  calls: 478\n  contains: 87\n  imports: 47\n  inherits: 4\n```\n**Context Bundle:**\n```markdown\n# Method: `GraphBuilder.build_from_directory`\n**File**: `/path/to/graph_builder.py`\n**Lines**: 24-45\n## Description\nBuild graph by scanning and parsing a directory.\n## Signature", "tokens": ["know", "code", "transform", "your", "codebase", "into", "an", "effective", "knowledge", "base", "that", "provides", "accurate", "relevant", "context", "for", "ai", "coding", "assistants", "using", "minimal", "tokens", "codecov", "https", "codecov", "io", "gh", "deepakdgupta1", "know", "code", "graph", "badge", "svg", "token", "placeholder", "https", "codecov", "io", "gh", "deepakdgupta1", "know", "code", "ci", "cd", "pipeline", "https", "github", "com", "deepakdgupta1", "know", "code", "actions", "workflows", "ci", "cd", "yml", "badge", "svg", "https", "github", "com", "deepakdgupta1", "know", "code", "actions", "workflows", "ci", "cd", "yml", "overview", "know", "code", "analyzes", "your", "codebase", "and", "builds", "semantic", "graph", "of", "entities", "functions", "classes", "modules", "and", "their", "relationships", "calls", "imports", "dependencies", "this", "structured", "knowledge", "enables", "accurate", "context", "synthesis", "for", "ai", "assistants", "token", "efficient", "context", "generation", "only", "what", "needed", "local", "first", "querying", "without", "llm", "dependency", "traceability", "back", "to", "source", "code", "installation", "bash", "create", "and", "activate", "virtual", "environment", "uv", "venv", "source", "venv", "bin", "activate", "on", "windows", "venv", "scripts", "activate", "install", "know", "code", "with", "dev", "dependencies", "uv", "sync", "dev", "set", "api", "keys", "only", "needed", "for", "the", "features", "you", "use", "see", "aimodels", "yaml", "export", "voyage", "api", "key", "embeddings", "reranking", "semantic", "search", "export", "openai", "api", "key", "embeddings", "alternative", "to", "voyage", "ai", "export", "google", "api", "key", "llm", "gemini", "for", "knowcode", "ask", "quick", "start", "bash", "analyze", "your", "codebase", "knowcode", "analyze", "src", "query", "the", "knowledge", "store", "knowcode", "query", "search", "my", "class", "knowcode", "query", "callers", "my", "function", "knowcode", "query", "callees", "my", "class", "method", "generate", "context", "for", "an", "entity", "knowcode", "context", "my", "class", "important", "method", "export", "documentation", "knowcode", "export", "docs", "build", "semantic", "search", "index", "knowcode", "index", "src", "perform", "semantic", "search", "knowcode", "semantic", "search", "how", "does", "parsing", "work", "start", "the", "intelligence", "server", "with", "watch", "mode", "knowcode", "server", "port", "8080", "watch", "view", "statistics", "knowcode", "stats", "commands", "analyze", "scan", "and", "parse", "directory", "to", "build", "the", "knowledge", "store", "bash", "knowcode", "analyze", "directory", "output", "path", "ignore", "pattern", "example", "bash", "knowcode", "analyze", "src", "ignore", "tests", "ignore", "pyc", "query", "query", "the", "knowledge", "store", "for", "relationships", "bash", "knowcode", "query", "type", "target", "store", "path", "json", "query", "types", "search", "pattern", "search", "entities", "by", "name", "callers", "entity", "find", "what", "calls", "this", "entity", "callees", "entity", "find", "what", "this", "entity", "calls", "deps", "entity", "get", "all", "dependencies", "example", "bash", "knowcode", "query", "search", "parser", "knowcode", "query", "callers", "graph", "builder", "build", "from", "directory", "knowcode", "query", "deps", "python", "parser", "json", "context", "generate", "context", "bundle", "for", "an", "entity", "ready", "for", "ai", "consumption", "bash", "knowcode", "context", "entity", "store", "path", "max", "chars", "example", "bash", "knowcode", "context", "graph", "builder", "build", "from", "directory", "max", "chars", "4000", "export", "export", "the", "knowledge", "store", "as", "markdown", "documentation", "bash", "knowcode", "export", "store", "path", "output", "dir", "example", "bash", "knowcode", "export", "docs", "stats", "show", "statistics", "about", "the", "knowledge", "store", "bash", "knowcode", "stats", "store", "path", "index", "build", "semantic", "search", "index", "for", "your", "codebase", "bash", "knowcode", "index", "directory", "output", "path", "config", "path", "semantic", "search", "perform", "natural", "language", "search", "against", "the", "semantic", "index", "bash", "knowcode", "semantic", "search", "query", "index", "path", "store", "path", "config", "path", "limit", "example", "bash", "knowcode", "semantic", "search", "where", "is", "the", "graph", "built", "server", "start", "the", "fast", "api", "intelligence", "server", "this", "is", "the", "preferred", "way", "for", "locally", "hosted", "ai", "agents", "ides", "to", "interact", "with", "know", "code", "bash", "knowcode", "server", "host", "host", "port", "port", "store", "path", "watch", "example", "bash", "knowcode", "server", "port", "8080", "once", "running", "you", "can", "access", "endpoints", "like", "get", "api", "v1", "context", "target", "my", "class", "task", "type", "debug", "get", "api", "v1", "search", "parser", "lexical", "search", "post", "api", "v1", "context", "query", "semantic", "search", "get", "api", "v1", "trace", "calls", "entity", "id", "direction", "callers", "depth", "multi", "hop", "call", "graph", "get", "api", "v1", "impact", "entity", "id", "deletion", "impact", "analysis", "post", "api", "v1", "reload", "to", "refresh", "data", "after", "new", "analyze", "run", "history", "show", "git", "history", "for", "the", "codebase", "or", "specific", "entities", "requires", "analysis", "with", "temporal", "bash", "knowcode", "history", "target", "limit", "example", "bash", "show", "recent", "project", "history", "knowcode", "history", "limit", "show", "history", "for", "specific", "class", "knowcode", "history", "knowledge", "store", "ask", "ask", "questions", "about", "the", "codebase", "using", "an", "llm", "agent", "requires", "an", "api", "key", "for", "at", "least", "one", "configured", "model", "in", "aimodels", "yaml", "bash", "knowcode", "ask", "question", "config", "path", "configuration", "know", "code", "looks", "for", "configuration", "file", "in", "the", "following", "order", "config", "argument", "aimodels", "yaml", "in", "current", "directory", "aimodels", "yaml", "example", "aimodels", "yaml", "yaml", "natural", "language", "models", "name", "gemini", "flash", "provider", "google", "api", "key", "env", "google", "api", "key", "example", "bash", "knowcode", "ask", "how", "does", "the", "graph", "builder", "work", "mcp", "server", "start", "an", "mcp", "model", "context", "protocol", "server", "for", "ide", "agent", "integration", "bash", "knowcode", "mcp", "server", "store", "path", "tools", "exposed", "search", "codebase", "search", "for", "code", "entities", "by", "name", "get", "entity", "context", "get", "detailed", "context", "for", "an", "entity", "trace", "calls", "trace", "call", "graph", "callers", "callees", "with", "depth", "supported", "languages", "mvp", "python", "py", "full", "ast", "parsing", "supports", "python", "12", "java", "script", "type", "script", "js", "ts", "classes", "functions", "imports", "via", "tree", "sitter", "java", "java", "classes", "methods", "imports", "inheritance", "via", "tree", "sitter", "markdown", "md", "document", "structure", "with", "heading", "hierarchy", "yaml", "yaml", "yml", "configuration", "keys", "with", "nested", "structure", "architecture", "know", "code", "follows", "layered", "architecture", "scanner", "discovers", "files", "with", "gitignore", "support", "parsers", "language", "specific", "parsing", "python", "ast", "tree", "sitter", "for", "others", "graph", "builder", "constructs", "semantic", "graph", "with", "entities", "and", "relationships", "knowledge", "store", "in", "memory", "graph", "with", "json", "persistence", "indexer", "vector", "embedding", "and", "hybrid", "retrieval", "engine", "faiss", "bm25", "context", "synthesizer", "generates", "token", "efficient", "context", "bundles", "with", "priority", "ranking", "cli", "user", "interface", "for", "all", "operations", "see", "evolution", "md", "evolution", "md", "for", "the", "complete", "reference", "architecture", "example", "output", "stats", "total", "entities", "98", "class", "15", "function", "method", "66", "module", "11", "total", "relationships", "616", "calls", "478", "contains", "87", "imports", "47", "inherits", "context", "bundle", "markdown", "method", "graph", "builder", "build", "from", "directory", "file", "path", "to", "graph", "builder", "py", "lines", "24", "45", "description", "build", "graph", "by", "scanning", "and", "parsing", "directory", "signature"], "metadata": {"type": "module_header"}}, {"id": "/home/deeog/Desktop/KnowCode/docs/index.md::index::0", "entity_id": "/home/deeog/Desktop/KnowCode/docs/index.md::index", "content": "`index`", "tokens": ["index"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768185812.9923136"}}, {"id": "/home/deeog/Desktop/KnowCode/docs/index.md::knowcode::0", "entity_id": "/home/deeog/Desktop/KnowCode/docs/index.md::knowcode", "content": "KnowCode", "tokens": ["know", "code"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768185812.9923136"}}, {"id": "/home/deeog/Desktop/KnowCode/docs/index.md::overview::0", "entity_id": "/home/deeog/Desktop/KnowCode/docs/index.md::overview", "content": "Overview", "tokens": ["overview"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768185812.9923136"}}, {"id": "/home/deeog/Desktop/KnowCode/docs/index.md::installation::0", "entity_id": "/home/deeog/Desktop/KnowCode/docs/index.md::installation", "content": "Installation", "tokens": ["installation"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768185812.9923136"}}, {"id": "/home/deeog/Desktop/KnowCode/docs/index.md::create-and-activate-virtual-environment::0", "entity_id": "/home/deeog/Desktop/KnowCode/docs/index.md::create-and-activate-virtual-environment", "content": "Create and activate virtual environment", "tokens": ["create", "and", "activate", "virtual", "environment"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768185812.9923136"}}, {"id": "/home/deeog/Desktop/KnowCode/docs/index.md::install-knowcode-with-dev-dependencies::0", "entity_id": "/home/deeog/Desktop/KnowCode/docs/index.md::install-knowcode-with-dev-dependencies", "content": "Install KnowCode (with dev dependencies)", "tokens": ["install", "know", "code", "with", "dev", "dependencies"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768185812.9923136"}}, {"id": "/home/deeog/Desktop/KnowCode/docs/index.md::set-api-keys-only-needed-for-the-features-you-use-see-aimodelsyaml::0", "entity_id": "/home/deeog/Desktop/KnowCode/docs/index.md::set-api-keys-only-needed-for-the-features-you-use-see-aimodelsyaml", "content": "Set API keys (only needed for the features you use; see aimodels.yaml)", "tokens": ["set", "api", "keys", "only", "needed", "for", "the", "features", "you", "use", "see", "aimodels", "yaml"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768185812.9923136"}}, {"id": "/home/deeog/Desktop/KnowCode/docs/index.md::quick-start::0", "entity_id": "/home/deeog/Desktop/KnowCode/docs/index.md::quick-start", "content": "Quick Start", "tokens": ["quick", "start"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768185812.9923136"}}, {"id": "/home/deeog/Desktop/KnowCode/docs/index.md::1-analyze-your-codebase::0", "entity_id": "/home/deeog/Desktop/KnowCode/docs/index.md::1-analyze-your-codebase", "content": "1. Analyze your codebase", "tokens": ["analyze", "your", "codebase"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768185812.9923136"}}, {"id": "/home/deeog/Desktop/KnowCode/docs/index.md::2-query-the-knowledge-store::0", "entity_id": "/home/deeog/Desktop/KnowCode/docs/index.md::2-query-the-knowledge-store", "content": "2. Query the knowledge store", "tokens": ["query", "the", "knowledge", "store"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768185812.9923136"}}, {"id": "/home/deeog/Desktop/KnowCode/docs/index.md::3-generate-context-for-an-entity::0", "entity_id": "/home/deeog/Desktop/KnowCode/docs/index.md::3-generate-context-for-an-entity", "content": "3. Generate context for an entity", "tokens": ["generate", "context", "for", "an", "entity"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768185812.9923136"}}, {"id": "/home/deeog/Desktop/KnowCode/docs/index.md::4-export-documentation::0", "entity_id": "/home/deeog/Desktop/KnowCode/docs/index.md::4-export-documentation", "content": "4. Export documentation", "tokens": ["export", "documentation"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768185812.9923136"}}, {"id": "/home/deeog/Desktop/KnowCode/docs/index.md::5-build-semantic-search-index::0", "entity_id": "/home/deeog/Desktop/KnowCode/docs/index.md::5-build-semantic-search-index", "content": "5. Build semantic search index", "tokens": ["build", "semantic", "search", "index"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768185812.9923136"}}, {"id": "/home/deeog/Desktop/KnowCode/docs/index.md::6-perform-semantic-search::0", "entity_id": "/home/deeog/Desktop/KnowCode/docs/index.md::6-perform-semantic-search", "content": "6. Perform semantic search", "tokens": ["perform", "semantic", "search"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768185812.9923136"}}, {"id": "/home/deeog/Desktop/KnowCode/docs/index.md::7-start-the-intelligence-server-with-watch-mode::0", "entity_id": "/home/deeog/Desktop/KnowCode/docs/index.md::7-start-the-intelligence-server-with-watch-mode", "content": "7. Start the intelligence server with watch mode", "tokens": ["start", "the", "intelligence", "server", "with", "watch", "mode"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768185812.9923136"}}, {"id": "/home/deeog/Desktop/KnowCode/docs/index.md::8-view-statistics::0", "entity_id": "/home/deeog/Desktop/KnowCode/docs/index.md::8-view-statistics", "content": "8. View statistics", "tokens": ["view", "statistics"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768185812.9923136"}}, {"id": "/home/deeog/Desktop/KnowCode/docs/index.md::commands::0", "entity_id": "/home/deeog/Desktop/KnowCode/docs/index.md::commands", "content": "Commands", "tokens": ["commands"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768185812.9923136"}}, {"id": "/home/deeog/Desktop/KnowCode/docs/index.md::analyze::0", "entity_id": "/home/deeog/Desktop/KnowCode/docs/index.md::analyze", "content": "`analyze`", "tokens": ["analyze"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768185812.9923136"}}, {"id": "/home/deeog/Desktop/KnowCode/docs/index.md::query::0", "entity_id": "/home/deeog/Desktop/KnowCode/docs/index.md::query", "content": "`query`", "tokens": ["query"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768185812.9923136"}}, {"id": "/home/deeog/Desktop/KnowCode/docs/index.md::context::0", "entity_id": "/home/deeog/Desktop/KnowCode/docs/index.md::context", "content": "`context`", "tokens": ["context"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768185812.9923136"}}, {"id": "/home/deeog/Desktop/KnowCode/docs/index.md::export::0", "entity_id": "/home/deeog/Desktop/KnowCode/docs/index.md::export", "content": "`export`", "tokens": ["export"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768185812.9923136"}}, {"id": "/home/deeog/Desktop/KnowCode/docs/index.md::stats::0", "entity_id": "/home/deeog/Desktop/KnowCode/docs/index.md::stats", "content": "`stats`", "tokens": ["stats"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768185812.9923136"}}, {"id": "/home/deeog/Desktop/KnowCode/docs/index.md::semantic-search::0", "entity_id": "/home/deeog/Desktop/KnowCode/docs/index.md::semantic-search", "content": "`semantic-search`", "tokens": ["semantic", "search"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768185812.9923136"}}, {"id": "/home/deeog/Desktop/KnowCode/docs/index.md::server::0", "entity_id": "/home/deeog/Desktop/KnowCode/docs/index.md::server", "content": "`server`", "tokens": ["server"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768185812.9923136"}}, {"id": "/home/deeog/Desktop/KnowCode/docs/index.md::history::0", "entity_id": "/home/deeog/Desktop/KnowCode/docs/index.md::history", "content": "`history`", "tokens": ["history"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768185812.9923136"}}, {"id": "/home/deeog/Desktop/KnowCode/docs/index.md::show-recent-project-history::0", "entity_id": "/home/deeog/Desktop/KnowCode/docs/index.md::show-recent-project-history", "content": "Show recent project history", "tokens": ["show", "recent", "project", "history"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768185812.9923136"}}, {"id": "/home/deeog/Desktop/KnowCode/docs/index.md::show-history-for-a-specific-class::0", "entity_id": "/home/deeog/Desktop/KnowCode/docs/index.md::show-history-for-a-specific-class", "content": "Show history for a specific class", "tokens": ["show", "history", "for", "specific", "class"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768185812.9923136"}}, {"id": "/home/deeog/Desktop/KnowCode/docs/index.md::ask::0", "entity_id": "/home/deeog/Desktop/KnowCode/docs/index.md::ask", "content": "`ask`", "tokens": ["ask"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768185812.9923136"}}, {"id": "/home/deeog/Desktop/KnowCode/docs/index.md::mcp-server::0", "entity_id": "/home/deeog/Desktop/KnowCode/docs/index.md::mcp-server", "content": "`mcp-server`", "tokens": ["mcp", "server"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768185812.9923136"}}, {"id": "/home/deeog/Desktop/KnowCode/docs/index.md::supported-languages-mvp::0", "entity_id": "/home/deeog/Desktop/KnowCode/docs/index.md::supported-languages-mvp", "content": "Supported Languages (MVP)", "tokens": ["supported", "languages", "mvp"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768185812.9923136"}}, {"id": "/home/deeog/Desktop/KnowCode/docs/index.md::architecture::0", "entity_id": "/home/deeog/Desktop/KnowCode/docs/index.md::architecture", "content": "Architecture", "tokens": ["architecture"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768185812.9923136"}}, {"id": "/home/deeog/Desktop/KnowCode/docs/index.md::example-output::0", "entity_id": "/home/deeog/Desktop/KnowCode/docs/index.md::example-output", "content": "Example Output", "tokens": ["example", "output"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768185812.9923136"}}, {"id": "/home/deeog/Desktop/KnowCode/docs/index.md::method-graphbuilderbuild-from-directory::0", "entity_id": "/home/deeog/Desktop/KnowCode/docs/index.md::method-graphbuilderbuild-from-directory", "content": "Method: `GraphBuilder.build_from_directory`", "tokens": ["method", "graph", "builder", "build", "from", "directory"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768185812.9923136"}}, {"id": "/home/deeog/Desktop/KnowCode/docs/index.md::description::0", "entity_id": "/home/deeog/Desktop/KnowCode/docs/index.md::description", "content": "Description", "tokens": ["description"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768185812.9923136"}}, {"id": "/home/deeog/Desktop/KnowCode/docs/index.md::signature::0", "entity_id": "/home/deeog/Desktop/KnowCode/docs/index.md::signature", "content": "Signature", "tokens": ["signature"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768185812.9923136"}}, {"id": "/home/deeog/Desktop/KnowCode/docs/index.md::source-code::0", "entity_id": "/home/deeog/Desktop/KnowCode/docs/index.md::source-code", "content": "Source Code", "tokens": ["source", "code"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768185812.9923136"}}, {"id": "/home/deeog/Desktop/KnowCode/docs/index.md::called-by::0", "entity_id": "/home/deeog/Desktop/KnowCode/docs/index.md::called-by", "content": "Called By", "tokens": ["called", "by"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768185812.9923136"}}, {"id": "/home/deeog/Desktop/KnowCode/docs/index.md::calls::0", "entity_id": "/home/deeog/Desktop/KnowCode/docs/index.md::calls", "content": "Calls", "tokens": ["calls"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768185812.9923136"}}, {"id": "/home/deeog/Desktop/KnowCode/docs/index.md::development::0", "entity_id": "/home/deeog/Desktop/KnowCode/docs/index.md::development", "content": "Development", "tokens": ["development"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768185812.9923136"}}, {"id": "/home/deeog/Desktop/KnowCode/docs/index.md::run-tests::0", "entity_id": "/home/deeog/Desktop/KnowCode/docs/index.md::run-tests", "content": "Run tests", "tokens": ["run", "tests"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768185812.9923136"}}, {"id": "/home/deeog/Desktop/KnowCode/docs/index.md::type-checking::0", "entity_id": "/home/deeog/Desktop/KnowCode/docs/index.md::type-checking", "content": "Type checking", "tokens": ["type", "checking"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768185812.9923136"}}, {"id": "/home/deeog/Desktop/KnowCode/docs/index.md::linting::0", "entity_id": "/home/deeog/Desktop/KnowCode/docs/index.md::linting", "content": "Linting", "tokens": ["linting"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768185812.9923136"}}, {"id": "/home/deeog/Desktop/KnowCode/docs/index.md::format::0", "entity_id": "/home/deeog/Desktop/KnowCode/docs/index.md::format", "content": "Format", "tokens": ["format"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768185812.9923136"}}, {"id": "/home/deeog/Desktop/KnowCode/docs/index.md::roadmap::0", "entity_id": "/home/deeog/Desktop/KnowCode/docs/index.md::roadmap", "content": "Roadmap", "tokens": ["roadmap"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768185812.9923136"}}, {"id": "/home/deeog/Desktop/KnowCode/docs/index.md::license::0", "entity_id": "/home/deeog/Desktop/KnowCode/docs/index.md::license", "content": "License", "tokens": ["license"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768185812.9923136"}}, {"id": "/home/deeog/Desktop/KnowCode/docs/MCP_SETUP.md::module::0", "entity_id": "/home/deeog/Desktop/KnowCode/docs/MCP_SETUP.md::module", "content": "# KnowCode MCP Server Setup Guide\n## Overview\nThis guide documents how to set up and configure the KnowCode MCP (Model Context Protocol) server for integration with Antigravity IDE.\n## What is MCP?\nMCP (Model Context Protocol) allows IDE agents to retrieve context from your codebase **before** hitting external LLMs, reducing token consumption and improving response quality.\n## Architecture\n```\nUser Query\n    \u2193\nAntigravity Agent\n    \u2193\nretrieve_context_for_query (MCP Tool)\n    \u2193\nKnowCode MCP Server\n    \u2193\nKnowledge Store + Semantic Index\n    \u2193\nContext Bundle (with sufficiency_score)\n    \u2193\nAgent Decision:\n    \u2022 If sufficiency_score >= 0.88 \u2192 Answer from context only\n    \u2022 If sufficiency_score < 0.88 \u2192 Use external LLM\n```\n## Prerequisites\n1. **KnowCode installed** in a virtual environment\n2. **Knowledge store generated** (`knowcode_knowledge.json`)\n3. **Semantic index built** (optional, but recommended)\n4. **Antigravity IDE** with MCP support\n## Configuration\n### 1. MCP Server Configuration File\n**Location:** `/home/deeog/.gemini/mcp_servers.json`\n**Content:**\n```json\n{\n  \"mcpServers\": {\n    \"knowcode\": {\n      \"command\": \"/home/deeog/Desktop/KnowCode/.venv/bin/knowcode\",\n      \"args\": [\"mcp-server\", \"--store\", \"/home/deeog/Desktop/KnowCode/\"]\n    }\n  }\n}\n```\n**\u26a0\ufe0f Important Notes:**\n- Use **absolute path** to the `knowcode` binary in your virtual environment\n- Do NOT use just `\"knowcode\"` - it won't be in the system PATH\n- The `--store` argument should point to the directory containing `knowcode_knowledge.json`\n### 2. Agent Rules Configuration\n**Location:** `/home/deeog/Desktop/KnowCode/.agent/context.md`\n**Content:**\n```markdown\nAlways call the tool retrieve_context_for_query before answering.\nUse task_type=auto, max_tokens=3000, limit_entities=3, expand_deps=true.\nIf sufficiency_score >= 0.88 and context_text is non-empty, answer ONLY from context_text.\nDo not call other tools or request more context.\nIf sufficiency_score < 0.88, then proceed with a full LLM answer.\n```\nThis ensures the agent follows the local-first workflow.\n## Setup Steps\n### Step 1: Analyze Codebase (Includes Indexing)\n```bash\ncd /home/deeog/Desktop/KnowCode\nsource .venv/bin/activate\nknowcode analyze . -o .\n```\nThis **automatically**:\n- \u2705 Parses the codebase and builds the knowledge graph\n- \u2705 Creates `knowcode_knowledge.json` with all entities and relationships\n- \u2705 **Builds the semantic index** at `knowcode_index/` with vector embeddings\n- \u2705 Reports statistics including indexed chunk count\n**Note:** You do NOT need to run a separate `knowcode index` command - it's built-in!\n### Step 3: Configure MCP Server\nCreate or update `/home/deeog/.gemini/mcp_servers.json` with the configuration shown above.\n### Step 4: Restart Antigravity IDE\nThe IDE needs to be restarted to:\n1. Read the updated MCP configuration\n2. Establish connection to the MCP server\n3. Make the `retrieve_context_for_query` tool available\n### Step 5: Verify Connection\nRun the verification script:\n```bash\n./verify_mcp_connection.sh\n```\n## Testing the Setup\n### Test 1: Check MCP Server is Running\n```bash\nps aux | grep \"knowcode mcp-server\"\n```\nYou should see a process running with the full path to your venv.\n### Test 2: Ask a Question\nIn Antigravity, ask a question about your codebase:\n```\nHow does search work in KnowCode?\n```\n**Expected behavior:**\n1. Agent calls `retrieve_context_for_query`\n2. Returns context with `sufficiency_score`\n3. If score >= 0.88, answers from context only\n4. If score < 0.88, uses external LLM\n### Test 3: Check Agent Logs\nThe agent should show:\n```\nCalling retrieve_context_for_query...\nSufficiency score: 0.92\nAnswering from local context only.\n```\n## Troubleshooting\n### Issue 1: MCP Server Not Starting\n**Symptoms:**\n- `retrieve_context_for_query` tool not available\n- No MCP server process running\n**Solutions:**\n1. Check the command path in `mcp_servers.json` is absolute\n2. Verify the knowcode binary exists: `ls -la /path/to/.venv/bin/knowcode`\n3. Check file permissions: `chmod +x /path/to/.venv/bin/knowcode`\n4. Restart the IDE\n### Issue 2: Knowledge Store Not Found\n**Symptoms:**\n- MCP server starts but returns empty context\n- Error: \"Knowledge store not found\"\n**Solutions:**\n1. Verify `knowcode_knowledge.json` exists in the store path\n2. Check the `--store` argument in `mcp_servers.json`\n3. Re-run `knowcode analyze`\n### Issue 3: Low Sufficiency Scores\n**Symptoms:**\n- `sufficiency_score` always < 0.88\n- Agent always uses external LLM\n**Solutions:**\n1. Build semantic index: `knowcode index .`\n2. Increase `max_tokens` parameter (default: 3000)\n3. Increase `limit_entities` parameter (default: 3)\n4. Check if the query matches your codebase domain\n### Issue 4: Semantic Search Not Working\n**Symptoms:**\n- Falls back to lexical search\n- Warning: \"Semantic retrieval failed\"\n**Solutions:**\n1. Verify `knowcode_index/` directory exists\n2. Check `knowcode_index/manifest.json` exists\n3. Verify embedding model is configured in `aimodels.yaml`\n4. Check API keys for embedding provider (VoyageAI, OpenAI, etc.)\n## MCP Server Commands\n### Start Manually (for testing)\n```bash\ncd /home/deeog/Desktop/KnowCode\nsource .venv/bin/activate\nknowcode mcp-server --store .\n```\n### Check Status\n```bash\n./check_mcp_server.sh\n```\n### Stop Server\nIf running manually, press `Ctrl+C`.\nIf started by Antigravity, it will be managed automatically.\n## Configuration Files Reference\n### `aimodels.yaml` (Embedding Configuration)\n```yaml\nembedding_models:\n  - name: voyage-code-3\n    provider: voyageai\n    api_key_env: VOYAGE_API_KEY_1\n    dimensions: 1024\nreranking_models:\n  - name: rerank-2.5\n    provider: voyageai\n    api_key_env: VOYAGE_API_KEY_1\n```\n### Environment Variables\nCreate a `.env` file in your project root:\n```bash\nVOYAGE_API_KEY_1=your_api_key_here\nOPENAI_API_KEY=your_openai_key_here\n```\n## Performance Tuning\n### Optimize for Speed\n```markdown\n# In .agent/context.md\nUse task_type=auto, max_tokens=1500, limit_entities=2, expand_deps=false.\n```\n### Optimize for Quality\n```markdown\n# In .agent/context.md\nUse task_type=auto, max_tokens=6000, limit_entities=5, expand_deps=true.\n```\n### Balance (Recommended)\n```markdown\n# In .agent/context.md\nUse task_type=auto, max_tokens=3000, limit_entities=3, expand_deps=true.\n```\n## Monitoring\n### Check Token Savings\nThe MCP server logs show:\n- Queries answered locally (sufficiency >= 0.88)\n- Queries sent to external LLM (sufficiency < 0.88)\n- Token counts for each response\n### Metrics to Track\n1. **Sufficiency Score Distribution**: Aim for >70% of queries with score >= 0.88\n2. **Token Consumption**: Compare before/after MCP integration\n3. **Response Quality**: Verify local answers are accurate\n## Best Practices\n1. **Keep Knowledge Store Updated**: Re-analyze after significant code changes\n2. **Rebuild Index Periodically**: Especially after adding new files\n3. **Monitor Sufficiency Scores**: Low scores indicate missing context\n4. **Use Semantic Search**: Much better than lexical-only\n5. **Configure Appropriate Limits**: Balance speed vs. quality\n## Advanced Configuration\n### Custom Sufficiency Threshold\nYou can adjust the threshold in `.agent/context.md`:\n```markdown\nIf sufficiency_score >= 0.75 and context_text is non-empty, answer ONLY from context_text.\n```\nLower threshold = more local answers, but potentially lower quality.\n### Multi-Hop Dependency Expansion\nFor complex queries, enable deeper dependency traversal:\n```markdown\nUse expand_deps=true, max_depth=2\n```\n### Task-Specific Configuration\n```markdown\nFor code_explanation queries: max_tokens=4000, limit_entities=5\nFor debugging queries: max_tokens=6000, limit_entities=3, expand_deps=true\nFor general queries: max_tokens=2000, limit_entities=2\n```\n## Security Considerations\n1. **API Keys**: Store in `.env`, never commit to git\n2. **MCP Server**: Runs locally, no external data transmission\n3. **Knowledge Store**: Contains your code, keep secure\n4. **Embedding Vectors**: May be sent to external providers (VoyageAI, OpenAI)\n## Support\nFor issues or questions:\n1. Check this documentation\n2. Run `./verify_mcp_connection.sh`\n3. Check `./check_mcp_server.sh`\n4. Review conversation history for similar issues\n## Changelog\n- **2026-01-13**: Initial MCP setup documentation\n- **2026-01-13**: Fixed command path issue (absolute path required)\n- **2026-01-13**: Added verification script\n## References\n- [KnowCode Documentation](../README.md)\n- [MCP Protocol Specification](https://modelcontextprotocol.io/)\n- [Antigravity IDE Documentation](https://antigravity.dev/)", "tokens": ["know", "code", "mcp", "server", "setup", "guide", "overview", "this", "guide", "documents", "how", "to", "set", "up", "and", "configure", "the", "know", "code", "mcp", "model", "context", "protocol", "server", "for", "integration", "with", "antigravity", "ide", "what", "is", "mcp", "mcp", "model", "context", "protocol", "allows", "ide", "agents", "to", "retrieve", "context", "from", "your", "codebase", "before", "hitting", "external", "llms", "reducing", "token", "consumption", "and", "improving", "response", "quality", "architecture", "user", "query", "antigravity", "agent", "retrieve", "context", "for", "query", "mcp", "tool", "know", "code", "mcp", "server", "knowledge", "store", "semantic", "index", "context", "bundle", "with", "sufficiency", "score", "agent", "decision", "if", "sufficiency", "score", "88", "answer", "from", "context", "only", "if", "sufficiency", "score", "88", "use", "external", "llm", "prerequisites", "know", "code", "installed", "in", "virtual", "environment", "knowledge", "store", "generated", "knowcode", "knowledge", "json", "semantic", "index", "built", "optional", "but", "recommended", "antigravity", "ide", "with", "mcp", "support", "configuration", "mcp", "server", "configuration", "file", "location", "home", "deeog", "gemini", "mcp", "servers", "json", "content", "json", "mcp", "servers", "knowcode", "command", "home", "deeog", "desktop", "know", "code", "venv", "bin", "knowcode", "args", "mcp", "server", "store", "home", "deeog", "desktop", "know", "code", "important", "notes", "use", "absolute", "path", "to", "the", "knowcode", "binary", "in", "your", "virtual", "environment", "do", "not", "use", "just", "knowcode", "it", "won", "be", "in", "the", "system", "path", "the", "store", "argument", "should", "point", "to", "the", "directory", "containing", "knowcode", "knowledge", "json", "agent", "rules", "configuration", "location", "home", "deeog", "desktop", "know", "code", "agent", "context", "md", "content", "markdown", "always", "call", "the", "tool", "retrieve", "context", "for", "query", "before", "answering", "use", "task", "type", "auto", "max", "tokens", "3000", "limit", "entities", "expand", "deps", "true", "if", "sufficiency", "score", "88", "and", "context", "text", "is", "non", "empty", "answer", "only", "from", "context", "text", "do", "not", "call", "other", "tools", "or", "request", "more", "context", "if", "sufficiency", "score", "88", "then", "proceed", "with", "full", "llm", "answer", "this", "ensures", "the", "agent", "follows", "the", "local", "first", "workflow", "setup", "steps", "step", "analyze", "codebase", "includes", "indexing", "bash", "cd", "home", "deeog", "desktop", "know", "code", "source", "venv", "bin", "activate", "knowcode", "analyze", "this", "automatically", "parses", "the", "codebase", "and", "builds", "the", "knowledge", "graph", "creates", "knowcode", "knowledge", "json", "with", "all", "entities", "and", "relationships", "builds", "the", "semantic", "index", "at", "knowcode", "index", "with", "vector", "embeddings", "reports", "statistics", "including", "indexed", "chunk", "count", "note", "you", "do", "not", "need", "to", "run", "separate", "knowcode", "index", "command", "it", "built", "in", "step", "configure", "mcp", "server", "create", "or", "update", "home", "deeog", "gemini", "mcp", "servers", "json", "with", "the", "configuration", "shown", "above", "step", "restart", "antigravity", "ide", "the", "ide", "needs", "to", "be", "restarted", "to", "read", "the", "updated", "mcp", "configuration", "establish", "connection", "to", "the", "mcp", "server", "make", "the", "retrieve", "context", "for", "query", "tool", "available", "step", "verify", "connection", "run", "the", "verification", "script", "bash", "verify", "mcp", "connection", "sh", "testing", "the", "setup", "test", "check", "mcp", "server", "is", "running", "bash", "ps", "aux", "grep", "knowcode", "mcp", "server", "you", "should", "see", "process", "running", "with", "the", "full", "path", "to", "your", "venv", "test", "ask", "question", "in", "antigravity", "ask", "question", "about", "your", "codebase", "how", "does", "search", "work", "in", "know", "code", "expected", "behavior", "agent", "calls", "retrieve", "context", "for", "query", "returns", "context", "with", "sufficiency", "score", "if", "score", "88", "answers", "from", "context", "only", "if", "score", "88", "uses", "external", "llm", "test", "check", "agent", "logs", "the", "agent", "should", "show", "calling", "retrieve", "context", "for", "query", "sufficiency", "score", "92", "answering", "from", "local", "context", "only", "troubleshooting", "issue", "mcp", "server", "not", "starting", "symptoms", "retrieve", "context", "for", "query", "tool", "not", "available", "no", "mcp", "server", "process", "running", "solutions", "check", "the", "command", "path", "in", "mcp", "servers", "json", "is", "absolute", "verify", "the", "knowcode", "binary", "exists", "ls", "la", "path", "to", "venv", "bin", "knowcode", "check", "file", "permissions", "chmod", "path", "to", "venv", "bin", "knowcode", "restart", "the", "ide", "issue", "knowledge", "store", "not", "found", "symptoms", "mcp", "server", "starts", "but", "returns", "empty", "context", "error", "knowledge", "store", "not", "found", "solutions", "verify", "knowcode", "knowledge", "json", "exists", "in", "the", "store", "path", "check", "the", "store", "argument", "in", "mcp", "servers", "json", "re", "run", "knowcode", "analyze", "issue", "low", "sufficiency", "scores", "symptoms", "sufficiency", "score", "always", "88", "agent", "always", "uses", "external", "llm", "solutions", "build", "semantic", "index", "knowcode", "index", "increase", "max", "tokens", "parameter", "default", "3000", "increase", "limit", "entities", "parameter", "default", "check", "if", "the", "query", "matches", "your", "codebase", "domain", "issue", "semantic", "search", "not", "working", "symptoms", "falls", "back", "to", "lexical", "search", "warning", "semantic", "retrieval", "failed", "solutions", "verify", "knowcode", "index", "directory", "exists", "check", "knowcode", "index", "manifest", "json", "exists", "verify", "embedding", "model", "is", "configured", "in", "aimodels", "yaml", "check", "api", "keys", "for", "embedding", "provider", "voyage", "ai", "open", "ai", "etc", "mcp", "server", "commands", "start", "manually", "for", "testing", "bash", "cd", "home", "deeog", "desktop", "know", "code", "source", "venv", "bin", "activate", "knowcode", "mcp", "server", "store", "check", "status", "bash", "check", "mcp", "server", "sh", "stop", "server", "if", "running", "manually", "press", "ctrl", "if", "started", "by", "antigravity", "it", "will", "be", "managed", "automatically", "configuration", "files", "reference", "aimodels", "yaml", "embedding", "configuration", "yaml", "embedding", "models", "name", "voyage", "code", "provider", "voyageai", "api", "key", "env", "voyage", "api", "key", "dimensions", "1024", "reranking", "models", "name", "rerank", "provider", "voyageai", "api", "key", "env", "voyage", "api", "key", "environment", "variables", "create", "env", "file", "in", "your", "project", "root", "bash", "voyage", "api", "key", "your", "api", "key", "here", "openai", "api", "key", "your", "openai", "key", "here", "performance", "tuning", "optimize", "for", "speed", "markdown", "in", "agent", "context", "md", "use", "task", "type", "auto", "max", "tokens", "1500", "limit", "entities", "expand", "deps", "false", "optimize", "for", "quality", "markdown", "in", "agent", "context", "md", "use", "task", "type", "auto", "max", "tokens", "6000", "limit", "entities", "expand", "deps", "true", "balance", "recommended", "markdown", "in", "agent", "context", "md", "use", "task", "type", "auto", "max", "tokens", "3000", "limit", "entities", "expand", "deps", "true", "monitoring", "check", "token", "savings", "the", "mcp", "server", "logs", "show", "queries", "answered", "locally", "sufficiency", "88", "queries", "sent", "to", "external", "llm", "sufficiency", "88", "token", "counts", "for", "each", "response", "metrics", "to", "track", "sufficiency", "score", "distribution", "aim", "for", "70", "of", "queries", "with", "score", "88", "token", "consumption", "compare", "before", "after", "mcp", "integration", "response", "quality", "verify", "local", "answers", "are", "accurate", "best", "practices", "keep", "knowledge", "store", "updated", "re", "analyze", "after", "significant", "code", "changes", "rebuild", "index", "periodically", "especially", "after", "adding", "new", "files", "monitor", "sufficiency", "scores", "low", "scores", "indicate", "missing", "context", "use", "semantic", "search", "much", "better", "than", "lexical", "only", "configure", "appropriate", "limits", "balance", "speed", "vs", "quality", "advanced", "configuration", "custom", "sufficiency", "threshold", "you", "can", "adjust", "the", "threshold", "in", "agent", "context", "md", "markdown", "if", "sufficiency", "score", "75", "and", "context", "text", "is", "non", "empty", "answer", "only", "from", "context", "text", "lower", "threshold", "more", "local", "answers", "but", "potentially", "lower", "quality", "multi", "hop", "dependency", "expansion", "for", "complex", "queries", "enable", "deeper", "dependency", "traversal", "markdown", "use", "expand", "deps", "true", "max", "depth", "task", "specific", "configuration", "markdown", "for", "code", "explanation", "queries", "max", "tokens", "4000", "limit", "entities", "for", "debugging", "queries", "max", "tokens", "6000", "limit", "entities", "expand", "deps", "true", "for", "general", "queries", "max", "tokens", "2000", "limit", "entities", "security", "considerations", "api", "keys", "store", "in", "env", "never", "commit", "to", "git", "mcp", "server", "runs", "locally", "no", "external", "data", "transmission", "knowledge", "store", "contains", "your", "code", "keep", "secure", "embedding", "vectors", "may", "be", "sent", "to", "external", "providers", "voyage", "ai", "open", "ai", "support", "for", "issues", "or", "questions", "check", "this", "documentation", "run", "verify", "mcp", "connection", "sh", "check", "check", "mcp", "server", "sh", "review", "conversation", "history", "for", "similar", "issues", "changelog", "2026", "01", "13", "initial", "mcp", "setup", "documentation", "2026", "01", "13", "fixed", "command", "path", "issue", "absolute", "path", "required", "2026", "01", "13", "added", "verification", "script", "references", "know", "code", "documentation", "readme", "md", "mcp", "protocol", "specification", "https", "modelcontextprotocol", "io", "antigravity", "ide", "documentation", "https", "antigravity", "dev"], "metadata": {"type": "module_header"}}, {"id": "/home/deeog/Desktop/KnowCode/docs/MCP_SETUP.md::MCP_SETUP::0", "entity_id": "/home/deeog/Desktop/KnowCode/docs/MCP_SETUP.md::MCP_SETUP", "content": "\"\"\"This guide documents how to set up and configure the KnowCode MCP (Model Context Protocol) server for integration with Antigravity IDE.\"\"\"\nMCP_SETUP", "tokens": ["this", "guide", "documents", "how", "to", "set", "up", "and", "configure", "the", "know", "code", "mcp", "model", "context", "protocol", "server", "for", "integration", "with", "antigravity", "ide", "mcp", "setup"], "metadata": {"kind": "document", "has_docstring": "true", "last_modified": "1768290025.8085005"}}, {"id": "/home/deeog/Desktop/KnowCode/docs/MCP_SETUP.md::knowcode-mcp-server-setup-guide::0", "entity_id": "/home/deeog/Desktop/KnowCode/docs/MCP_SETUP.md::knowcode-mcp-server-setup-guide", "content": "KnowCode MCP Server Setup Guide", "tokens": ["know", "code", "mcp", "server", "setup", "guide"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768290025.8085005"}}, {"id": "/home/deeog/Desktop/KnowCode/docs/MCP_SETUP.md::overview::0", "entity_id": "/home/deeog/Desktop/KnowCode/docs/MCP_SETUP.md::overview", "content": "Overview", "tokens": ["overview"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768290025.8085005"}}, {"id": "/home/deeog/Desktop/KnowCode/docs/MCP_SETUP.md::what-is-mcp::0", "entity_id": "/home/deeog/Desktop/KnowCode/docs/MCP_SETUP.md::what-is-mcp", "content": "What is MCP?", "tokens": ["what", "is", "mcp"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768290025.8085005"}}, {"id": "/home/deeog/Desktop/KnowCode/docs/MCP_SETUP.md::architecture::0", "entity_id": "/home/deeog/Desktop/KnowCode/docs/MCP_SETUP.md::architecture", "content": "Architecture", "tokens": ["architecture"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768290025.8085005"}}, {"id": "/home/deeog/Desktop/KnowCode/docs/MCP_SETUP.md::prerequisites::0", "entity_id": "/home/deeog/Desktop/KnowCode/docs/MCP_SETUP.md::prerequisites", "content": "Prerequisites", "tokens": ["prerequisites"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768290025.8085005"}}, {"id": "/home/deeog/Desktop/KnowCode/docs/MCP_SETUP.md::configuration::0", "entity_id": "/home/deeog/Desktop/KnowCode/docs/MCP_SETUP.md::configuration", "content": "Configuration", "tokens": ["configuration"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768290025.8085005"}}, {"id": "/home/deeog/Desktop/KnowCode/docs/MCP_SETUP.md::1-mcp-server-configuration-file::0", "entity_id": "/home/deeog/Desktop/KnowCode/docs/MCP_SETUP.md::1-mcp-server-configuration-file", "content": "1. MCP Server Configuration File", "tokens": ["mcp", "server", "configuration", "file"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768290025.8085005"}}, {"id": "/home/deeog/Desktop/KnowCode/docs/MCP_SETUP.md::2-agent-rules-configuration::0", "entity_id": "/home/deeog/Desktop/KnowCode/docs/MCP_SETUP.md::2-agent-rules-configuration", "content": "2. Agent Rules Configuration", "tokens": ["agent", "rules", "configuration"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768290025.8085005"}}, {"id": "/home/deeog/Desktop/KnowCode/docs/MCP_SETUP.md::setup-steps::0", "entity_id": "/home/deeog/Desktop/KnowCode/docs/MCP_SETUP.md::setup-steps", "content": "Setup Steps", "tokens": ["setup", "steps"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768290025.8085005"}}, {"id": "/home/deeog/Desktop/KnowCode/docs/MCP_SETUP.md::step-1-analyze-codebase-includes-indexing::0", "entity_id": "/home/deeog/Desktop/KnowCode/docs/MCP_SETUP.md::step-1-analyze-codebase-includes-indexing", "content": "Step 1: Analyze Codebase (Includes Indexing)", "tokens": ["step", "analyze", "codebase", "includes", "indexing"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768290025.8085005"}}, {"id": "/home/deeog/Desktop/KnowCode/docs/MCP_SETUP.md::step-3-configure-mcp-server::0", "entity_id": "/home/deeog/Desktop/KnowCode/docs/MCP_SETUP.md::step-3-configure-mcp-server", "content": "Step 3: Configure MCP Server", "tokens": ["step", "configure", "mcp", "server"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768290025.8085005"}}, {"id": "/home/deeog/Desktop/KnowCode/docs/MCP_SETUP.md::step-4-restart-antigravity-ide::0", "entity_id": "/home/deeog/Desktop/KnowCode/docs/MCP_SETUP.md::step-4-restart-antigravity-ide", "content": "Step 4: Restart Antigravity IDE", "tokens": ["step", "restart", "antigravity", "ide"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768290025.8085005"}}, {"id": "/home/deeog/Desktop/KnowCode/docs/MCP_SETUP.md::step-5-verify-connection::0", "entity_id": "/home/deeog/Desktop/KnowCode/docs/MCP_SETUP.md::step-5-verify-connection", "content": "Step 5: Verify Connection", "tokens": ["step", "verify", "connection"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768290025.8085005"}}, {"id": "/home/deeog/Desktop/KnowCode/docs/MCP_SETUP.md::testing-the-setup::0", "entity_id": "/home/deeog/Desktop/KnowCode/docs/MCP_SETUP.md::testing-the-setup", "content": "Testing the Setup", "tokens": ["testing", "the", "setup"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768290025.8085005"}}, {"id": "/home/deeog/Desktop/KnowCode/docs/MCP_SETUP.md::test-1-check-mcp-server-is-running::0", "entity_id": "/home/deeog/Desktop/KnowCode/docs/MCP_SETUP.md::test-1-check-mcp-server-is-running", "content": "Test 1: Check MCP Server is Running", "tokens": ["test", "check", "mcp", "server", "is", "running"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768290025.8085005"}}, {"id": "/home/deeog/Desktop/KnowCode/docs/MCP_SETUP.md::test-2-ask-a-question::0", "entity_id": "/home/deeog/Desktop/KnowCode/docs/MCP_SETUP.md::test-2-ask-a-question", "content": "Test 2: Ask a Question", "tokens": ["test", "ask", "question"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768290025.8085005"}}, {"id": "/home/deeog/Desktop/KnowCode/docs/MCP_SETUP.md::test-3-check-agent-logs::0", "entity_id": "/home/deeog/Desktop/KnowCode/docs/MCP_SETUP.md::test-3-check-agent-logs", "content": "Test 3: Check Agent Logs", "tokens": ["test", "check", "agent", "logs"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768290025.8085005"}}, {"id": "/home/deeog/Desktop/KnowCode/docs/MCP_SETUP.md::troubleshooting::0", "entity_id": "/home/deeog/Desktop/KnowCode/docs/MCP_SETUP.md::troubleshooting", "content": "Troubleshooting", "tokens": ["troubleshooting"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768290025.8085005"}}, {"id": "/home/deeog/Desktop/KnowCode/docs/MCP_SETUP.md::issue-1-mcp-server-not-starting::0", "entity_id": "/home/deeog/Desktop/KnowCode/docs/MCP_SETUP.md::issue-1-mcp-server-not-starting", "content": "Issue 1: MCP Server Not Starting", "tokens": ["issue", "mcp", "server", "not", "starting"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768290025.8085005"}}, {"id": "/home/deeog/Desktop/KnowCode/docs/MCP_SETUP.md::issue-2-knowledge-store-not-found::0", "entity_id": "/home/deeog/Desktop/KnowCode/docs/MCP_SETUP.md::issue-2-knowledge-store-not-found", "content": "Issue 2: Knowledge Store Not Found", "tokens": ["issue", "knowledge", "store", "not", "found"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768290025.8085005"}}, {"id": "/home/deeog/Desktop/KnowCode/docs/MCP_SETUP.md::issue-3-low-sufficiency-scores::0", "entity_id": "/home/deeog/Desktop/KnowCode/docs/MCP_SETUP.md::issue-3-low-sufficiency-scores", "content": "Issue 3: Low Sufficiency Scores", "tokens": ["issue", "low", "sufficiency", "scores"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768290025.8085005"}}, {"id": "/home/deeog/Desktop/KnowCode/docs/MCP_SETUP.md::issue-4-semantic-search-not-working::0", "entity_id": "/home/deeog/Desktop/KnowCode/docs/MCP_SETUP.md::issue-4-semantic-search-not-working", "content": "Issue 4: Semantic Search Not Working", "tokens": ["issue", "semantic", "search", "not", "working"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768290025.8085005"}}, {"id": "/home/deeog/Desktop/KnowCode/docs/MCP_SETUP.md::mcp-server-commands::0", "entity_id": "/home/deeog/Desktop/KnowCode/docs/MCP_SETUP.md::mcp-server-commands", "content": "MCP Server Commands", "tokens": ["mcp", "server", "commands"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768290025.8085005"}}, {"id": "/home/deeog/Desktop/KnowCode/docs/MCP_SETUP.md::start-manually-for-testing::0", "entity_id": "/home/deeog/Desktop/KnowCode/docs/MCP_SETUP.md::start-manually-for-testing", "content": "Start Manually (for testing)", "tokens": ["start", "manually", "for", "testing"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768290025.8085005"}}, {"id": "/home/deeog/Desktop/KnowCode/docs/MCP_SETUP.md::check-status::0", "entity_id": "/home/deeog/Desktop/KnowCode/docs/MCP_SETUP.md::check-status", "content": "Check Status", "tokens": ["check", "status"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768290025.8085005"}}, {"id": "/home/deeog/Desktop/KnowCode/docs/MCP_SETUP.md::stop-server::0", "entity_id": "/home/deeog/Desktop/KnowCode/docs/MCP_SETUP.md::stop-server", "content": "Stop Server", "tokens": ["stop", "server"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768290025.8085005"}}, {"id": "/home/deeog/Desktop/KnowCode/docs/MCP_SETUP.md::configuration-files-reference::0", "entity_id": "/home/deeog/Desktop/KnowCode/docs/MCP_SETUP.md::configuration-files-reference", "content": "Configuration Files Reference", "tokens": ["configuration", "files", "reference"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768290025.8085005"}}, {"id": "/home/deeog/Desktop/KnowCode/docs/MCP_SETUP.md::aimodelsyaml-embedding-configuration::0", "entity_id": "/home/deeog/Desktop/KnowCode/docs/MCP_SETUP.md::aimodelsyaml-embedding-configuration", "content": "`aimodels.yaml` (Embedding Configuration)", "tokens": ["aimodels", "yaml", "embedding", "configuration"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768290025.8085005"}}, {"id": "/home/deeog/Desktop/KnowCode/docs/MCP_SETUP.md::environment-variables::0", "entity_id": "/home/deeog/Desktop/KnowCode/docs/MCP_SETUP.md::environment-variables", "content": "Environment Variables", "tokens": ["environment", "variables"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768290025.8085005"}}, {"id": "/home/deeog/Desktop/KnowCode/docs/MCP_SETUP.md::performance-tuning::0", "entity_id": "/home/deeog/Desktop/KnowCode/docs/MCP_SETUP.md::performance-tuning", "content": "Performance Tuning", "tokens": ["performance", "tuning"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768290025.8085005"}}, {"id": "/home/deeog/Desktop/KnowCode/docs/MCP_SETUP.md::optimize-for-speed::0", "entity_id": "/home/deeog/Desktop/KnowCode/docs/MCP_SETUP.md::optimize-for-speed", "content": "Optimize for Speed", "tokens": ["optimize", "for", "speed"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768290025.8085005"}}, {"id": "/home/deeog/Desktop/KnowCode/docs/MCP_SETUP.md::in-agentcontextmd::0", "entity_id": "/home/deeog/Desktop/KnowCode/docs/MCP_SETUP.md::in-agentcontextmd", "content": "In .agent/context.md", "tokens": ["in", "agent", "context", "md"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768290025.8085005"}}, {"id": "/home/deeog/Desktop/KnowCode/docs/MCP_SETUP.md::optimize-for-quality::0", "entity_id": "/home/deeog/Desktop/KnowCode/docs/MCP_SETUP.md::optimize-for-quality", "content": "Optimize for Quality", "tokens": ["optimize", "for", "quality"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768290025.8085005"}}, {"id": "/home/deeog/Desktop/KnowCode/docs/MCP_SETUP.md::balance-recommended::0", "entity_id": "/home/deeog/Desktop/KnowCode/docs/MCP_SETUP.md::balance-recommended", "content": "Balance (Recommended)", "tokens": ["balance", "recommended"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768290025.8085005"}}, {"id": "/home/deeog/Desktop/KnowCode/docs/MCP_SETUP.md::monitoring::0", "entity_id": "/home/deeog/Desktop/KnowCode/docs/MCP_SETUP.md::monitoring", "content": "Monitoring", "tokens": ["monitoring"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768290025.8085005"}}, {"id": "/home/deeog/Desktop/KnowCode/docs/MCP_SETUP.md::check-token-savings::0", "entity_id": "/home/deeog/Desktop/KnowCode/docs/MCP_SETUP.md::check-token-savings", "content": "Check Token Savings", "tokens": ["check", "token", "savings"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768290025.8085005"}}, {"id": "/home/deeog/Desktop/KnowCode/docs/MCP_SETUP.md::metrics-to-track::0", "entity_id": "/home/deeog/Desktop/KnowCode/docs/MCP_SETUP.md::metrics-to-track", "content": "Metrics to Track", "tokens": ["metrics", "to", "track"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768290025.8085005"}}, {"id": "/home/deeog/Desktop/KnowCode/docs/MCP_SETUP.md::best-practices::0", "entity_id": "/home/deeog/Desktop/KnowCode/docs/MCP_SETUP.md::best-practices", "content": "Best Practices", "tokens": ["best", "practices"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768290025.8085005"}}, {"id": "/home/deeog/Desktop/KnowCode/docs/MCP_SETUP.md::advanced-configuration::0", "entity_id": "/home/deeog/Desktop/KnowCode/docs/MCP_SETUP.md::advanced-configuration", "content": "Advanced Configuration", "tokens": ["advanced", "configuration"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768290025.8085005"}}, {"id": "/home/deeog/Desktop/KnowCode/docs/MCP_SETUP.md::custom-sufficiency-threshold::0", "entity_id": "/home/deeog/Desktop/KnowCode/docs/MCP_SETUP.md::custom-sufficiency-threshold", "content": "Custom Sufficiency Threshold", "tokens": ["custom", "sufficiency", "threshold"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768290025.8085005"}}, {"id": "/home/deeog/Desktop/KnowCode/docs/MCP_SETUP.md::multi-hop-dependency-expansion::0", "entity_id": "/home/deeog/Desktop/KnowCode/docs/MCP_SETUP.md::multi-hop-dependency-expansion", "content": "Multi-Hop Dependency Expansion", "tokens": ["multi", "hop", "dependency", "expansion"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768290025.8085005"}}, {"id": "/home/deeog/Desktop/KnowCode/docs/MCP_SETUP.md::task-specific-configuration::0", "entity_id": "/home/deeog/Desktop/KnowCode/docs/MCP_SETUP.md::task-specific-configuration", "content": "Task-Specific Configuration", "tokens": ["task", "specific", "configuration"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768290025.8085005"}}, {"id": "/home/deeog/Desktop/KnowCode/docs/MCP_SETUP.md::security-considerations::0", "entity_id": "/home/deeog/Desktop/KnowCode/docs/MCP_SETUP.md::security-considerations", "content": "Security Considerations", "tokens": ["security", "considerations"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768290025.8085005"}}, {"id": "/home/deeog/Desktop/KnowCode/docs/MCP_SETUP.md::support::0", "entity_id": "/home/deeog/Desktop/KnowCode/docs/MCP_SETUP.md::support", "content": "Support", "tokens": ["support"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768290025.8085005"}}, {"id": "/home/deeog/Desktop/KnowCode/docs/MCP_SETUP.md::changelog::0", "entity_id": "/home/deeog/Desktop/KnowCode/docs/MCP_SETUP.md::changelog", "content": "Changelog", "tokens": ["changelog"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768290025.8085005"}}, {"id": "/home/deeog/Desktop/KnowCode/docs/MCP_SETUP.md::references::0", "entity_id": "/home/deeog/Desktop/KnowCode/docs/MCP_SETUP.md::references", "content": "References", "tokens": ["references"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768290025.8085005"}}, {"id": "/home/deeog/Desktop/KnowCode/docs/evolution.md::module::0", "entity_id": "/home/deeog/Desktop/KnowCode/docs/evolution.md::module", "content": "# **Detailed Architecture & Roadmap**\n*Note: This document outlines the conceptual architecture of KnowCode, some of which looks ahead to future phases.*\n---\n## **1. Layered Architecture**\nKnowCode follows a multi-layer design to ensure extensibility, maintainability, and scalability.\n1.  **Ingestion Layer**: Source Code scanning, Parsing (AST/Tree-sitter).\n2.  **Analysis Layer**: Structural building, Semantic graph construction.\n3.  **Storage Layer**: Graph persistence, Vector storage.\n4.  **Retrieval Layer**: Hybrid search (Lexical + Semantic).\n5.  **Intelligence Layer**: Context synthesis, RAG orchestration.\n6.  **Interface Layer**: CLI, REST API (FastAPI).\n---\n## **2. Component Interaction**\n```mermaid\nflowchart TB\n    subgraph Ingestion\n        L1[Layer 1: Source Ingestion]\n    end\n    subgraph Analysis\n        L2[Layer 2: Structural Parsing]\n        L3[Layer 3: Semantic Graph]\n        L4[Layer 4: Behavioral Analysis]\n        L5[Layer 5: Runtime Signals]\n        L6[Layer 6: Intent Extraction]\n    end\n    subgraph Intelligence\n        L7[Layer 7: Doc Synthesis]\n        L8[Layer 8: Knowledge Store]\n        L9[Layer 9: Context Synthesis]\n    end\n    subgraph Interface\n        L10[Layer 10: LLM Interface]\n        DEV[Developer]\n    end\n    subgraph Evolution\n        L11[Layer 11: Feedback Loop]\n    end\n    subgraph Cross-Cutting\n        SEC[Security]\n        OBS[Observability]\n        CFG[Configuration]\n    end\n    L1 --> L2\n    L2 --> L3\n    L3 --> L4\n    L3 --> L6\n    L4 --> L8\n    L5 -.-> L8\n    L6 --> L8\n    L8 --> L7\n    L8 --> L9\n    L9 --> L10\n    L10 --> DEV\n    DEV --> L11\n    L11 --> L8\n    L11 --> L3\n    SEC -.-> L1 & L8 & L10\n    OBS -.-> L1 & L3 & L8 & L10\n    CFG -.-> L2 & L4 & L9\n```\n---\n## **Implementation Status & Roadmap**\n### **Phase 1: Foundation (COMPLETED)**\n1. **[x] Source Scanning + Parsing (Layers 1-2)**: Scanner with gitignore support; parsers for Python (AST), JS/TS + Java (Tree-sitter), Markdown, YAML.\n2. **[x] Unified Semantic Graph (Layer 3)**: Entity/relationship model with reference resolution (calls/imports/contains/inherits).\n3. **[x] Local Knowledge Store (Layer 8)**: In-memory graph with JSON persistence and query helpers.\n4. **[x] Token-Budgeted Context Synthesis (Layer 9)**: Priority-ordered sections with truncation handling.\n5. **[x] Service Layer**: Shared business logic for CLI and API.\n### **Phase 2: Intelligence Server & RAG (COMPLETED)**\n6. **[x] FastAPI Server (Layer 10)**: Health, stats, search, context, semantic query, reload, entity details, callers/callees.\n7. **[x] Semantic Search & Indexing (Layer 4a)**: Chunker (module header/imports/entities), config-driven embeddings (OpenAI or VoyageAI), FAISS vector store, hybrid BM25+vector retrieval (RRF), reranking, dependency expansion.\n8. **[x] Indexer Persistence + CLI**: `index`/`semantic-search` commands with save/load.\n9. **[x] Watch Mode**: Background indexer + filesystem monitor for incremental re-indexing.\n10. **[x] CLI Workflows**: `analyze`, `query`, `context`, `export`, `stats`, `server`, `history`, `ask`.\n### **Phase 3: Temporal & Runtime Signals (COMPLETED)**\n11. **[x] Git History Ingestion (Temporal)**: Commit/author entities, authored/modified/changed_by relationships; surfaced via `--temporal` and `history`.\n12. **[x] Coverage Signals (Layer 5)**: Cobertura ingestion with coverage report entities and covers/executed_by relationships.\n### **Phase 4: Documentation Synthesis (PARTIAL)**\n13. **[x] Markdown Export (MVP)**: CLI `export` produces an index-style Markdown doc.\n14. **[ ] Multi-Level Doc Synthesis (Layer 7)**: Architecture/module/function narratives, change summaries, and freshness tracking.\n### **Phase 5: Deep Analysis (NEXT)**\n15. **[ ] Static Behavioral Analysis (Layer 4)**: Data flow, state transitions, side-effect classification.\n16. **[ ] Intent Extraction (Layer 6)**: ADR/PR/commit intent linking beyond commit metadata.\n17. **[ ] Confidence Scoring (Layer 3)**: Weighted edges/entities by evidence source.\n### **Phase 6: Enterprise (FUTURE)**\n18. **[ ] Security & RBAC**: Permissioned access and audit trails.\n19. **[ ] Scalability**: Large monorepo support and distributed processing.\n20. **[ ] Team Sharing**: Remote knowledge store sync and collaboration.\n### **Phase 7: Agentic Capabilities (COMPLETED v2.2)**\n21. **[x] Agent Architecture**: `Agent` class with configuration-driven model selection.\n22. **[x] Multi-Provider Support**: Google Gemini and OpenRouter/OpenAI integration.\n23. **[x] Rate Limiting**: Persistent RPM/RPD tracking and enforcement.\n24. **[x] Query Classification**: 6 task types (explain, debug, extend, review, locate, general).\n25. **[x] Smart Answer**: Local-first answering with configurable sufficiency threshold.\n26. **[x] VoyageAI Reranking**: Cross-encoder reranking with signal-based fallback.\n### **Phase 8: IDE Integration (COMPLETED v2.2)**\n27. **[x] MCP Server (Layer 10b)**: Tool exposure via STDIO for IDE agents.\n28. **[x] Core Tools**: `search_codebase`, `get_entity_context`, `trace_calls`.\n29. **[x] Sufficiency Scoring**: Context confidence metrics for local-first answering.\n30. **[x] Task-Specific Templates**: Debug/extend/review/explain/locate prioritization.\n31. **[x] Multi-hop Queries**: `trace_calls(depth=N)` and `get_impact()` analysis.\n32. **[x] Structured Responses**: JSON with `task_type` and `sufficiency_score`.", "tokens": ["detailed", "architecture", "roadmap", "note", "this", "document", "outlines", "the", "conceptual", "architecture", "of", "know", "code", "some", "of", "which", "looks", "ahead", "to", "future", "phases", "layered", "architecture", "know", "code", "follows", "multi", "layer", "design", "to", "ensure", "extensibility", "maintainability", "and", "scalability", "ingestion", "layer", "source", "code", "scanning", "parsing", "ast", "tree", "sitter", "analysis", "layer", "structural", "building", "semantic", "graph", "construction", "storage", "layer", "graph", "persistence", "vector", "storage", "retrieval", "layer", "hybrid", "search", "lexical", "semantic", "intelligence", "layer", "context", "synthesis", "rag", "orchestration", "interface", "layer", "cli", "rest", "api", "fast", "api", "component", "interaction", "mermaid", "flowchart", "tb", "subgraph", "ingestion", "l1", "layer", "source", "ingestion", "end", "subgraph", "analysis", "l2", "layer", "structural", "parsing", "l3", "layer", "semantic", "graph", "l4", "layer", "behavioral", "analysis", "l5", "layer", "runtime", "signals", "l6", "layer", "intent", "extraction", "end", "subgraph", "intelligence", "l7", "layer", "doc", "synthesis", "l8", "layer", "knowledge", "store", "l9", "layer", "context", "synthesis", "end", "subgraph", "interface", "l10", "layer", "10", "llm", "interface", "dev", "developer", "end", "subgraph", "evolution", "l11", "layer", "11", "feedback", "loop", "end", "subgraph", "cross", "cutting", "sec", "security", "obs", "observability", "cfg", "configuration", "end", "l1", "l2", "l2", "l3", "l3", "l4", "l3", "l6", "l4", "l8", "l5", "l8", "l6", "l8", "l8", "l7", "l8", "l9", "l9", "l10", "l10", "dev", "dev", "l11", "l11", "l8", "l11", "l3", "sec", "l1", "l8", "l10", "obs", "l1", "l3", "l8", "l10", "cfg", "l2", "l4", "l9", "implementation", "status", "roadmap", "phase", "foundation", "completed", "source", "scanning", "parsing", "layers", "scanner", "with", "gitignore", "support", "parsers", "for", "python", "ast", "js", "ts", "java", "tree", "sitter", "markdown", "yaml", "unified", "semantic", "graph", "layer", "entity", "relationship", "model", "with", "reference", "resolution", "calls", "imports", "contains", "inherits", "local", "knowledge", "store", "layer", "in", "memory", "graph", "with", "json", "persistence", "and", "query", "helpers", "token", "budgeted", "context", "synthesis", "layer", "priority", "ordered", "sections", "with", "truncation", "handling", "service", "layer", "shared", "business", "logic", "for", "cli", "and", "api", "phase", "intelligence", "server", "rag", "completed", "fast", "api", "server", "layer", "10", "health", "stats", "search", "context", "semantic", "query", "reload", "entity", "details", "callers", "callees", "semantic", "search", "indexing", "layer", "4a", "chunker", "module", "header", "imports", "entities", "config", "driven", "embeddings", "open", "ai", "or", "voyage", "ai", "faiss", "vector", "store", "hybrid", "bm25", "vector", "retrieval", "rrf", "reranking", "dependency", "expansion", "indexer", "persistence", "cli", "index", "semantic", "search", "commands", "with", "save", "load", "watch", "mode", "background", "indexer", "filesystem", "monitor", "for", "incremental", "re", "indexing", "10", "cli", "workflows", "analyze", "query", "context", "export", "stats", "server", "history", "ask", "phase", "temporal", "runtime", "signals", "completed", "11", "git", "history", "ingestion", "temporal", "commit", "author", "entities", "authored", "modified", "changed", "by", "relationships", "surfaced", "via", "temporal", "and", "history", "12", "coverage", "signals", "layer", "cobertura", "ingestion", "with", "coverage", "report", "entities", "and", "covers", "executed", "by", "relationships", "phase", "documentation", "synthesis", "partial", "13", "markdown", "export", "mvp", "cli", "export", "produces", "an", "index", "style", "markdown", "doc", "14", "multi", "level", "doc", "synthesis", "layer", "architecture", "module", "function", "narratives", "change", "summaries", "and", "freshness", "tracking", "phase", "deep", "analysis", "next", "15", "static", "behavioral", "analysis", "layer", "data", "flow", "state", "transitions", "side", "effect", "classification", "16", "intent", "extraction", "layer", "adr", "pr", "commit", "intent", "linking", "beyond", "commit", "metadata", "17", "confidence", "scoring", "layer", "weighted", "edges", "entities", "by", "evidence", "source", "phase", "enterprise", "future", "18", "security", "rbac", "permissioned", "access", "and", "audit", "trails", "19", "scalability", "large", "monorepo", "support", "and", "distributed", "processing", "20", "team", "sharing", "remote", "knowledge", "store", "sync", "and", "collaboration", "phase", "agentic", "capabilities", "completed", "v2", "21", "agent", "architecture", "agent", "class", "with", "configuration", "driven", "model", "selection", "22", "multi", "provider", "support", "google", "gemini", "and", "open", "router", "open", "ai", "integration", "23", "rate", "limiting", "persistent", "rpm", "rpd", "tracking", "and", "enforcement", "24", "query", "classification", "task", "types", "explain", "debug", "extend", "review", "locate", "general", "25", "smart", "answer", "local", "first", "answering", "with", "configurable", "sufficiency", "threshold", "26", "voyage", "ai", "reranking", "cross", "encoder", "reranking", "with", "signal", "based", "fallback", "phase", "ide", "integration", "completed", "v2", "27", "mcp", "server", "layer", "10b", "tool", "exposure", "via", "stdio", "for", "ide", "agents", "28", "core", "tools", "search", "codebase", "get", "entity", "context", "trace", "calls", "29", "sufficiency", "scoring", "context", "confidence", "metrics", "for", "local", "first", "answering", "30", "task", "specific", "templates", "debug", "extend", "review", "explain", "locate", "prioritization", "31", "multi", "hop", "queries", "trace", "calls", "depth", "and", "get", "impact", "analysis", "32", "structured", "responses", "json", "with", "task", "type", "and", "sufficiency", "score"], "metadata": {"type": "module_header"}}, {"id": "/home/deeog/Desktop/KnowCode/docs/evolution.md::evolution::0", "entity_id": "/home/deeog/Desktop/KnowCode/docs/evolution.md::evolution", "content": "\"\"\"*Note: This document outlines the conceptual architecture of KnowCode, some of which looks ahead to future phases.*\"\"\"\nevolution", "tokens": ["note", "this", "document", "outlines", "the", "conceptual", "architecture", "of", "know", "code", "some", "of", "which", "looks", "ahead", "to", "future", "phases", "evolution"], "metadata": {"kind": "document", "has_docstring": "true", "last_modified": "1768185812.9922073"}}, {"id": "/home/deeog/Desktop/KnowCode/docs/evolution.md::detailed-architecture-roadmap::0", "entity_id": "/home/deeog/Desktop/KnowCode/docs/evolution.md::detailed-architecture-roadmap", "content": "**Detailed Architecture & Roadmap**", "tokens": ["detailed", "architecture", "roadmap"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768185812.9922073"}}, {"id": "/home/deeog/Desktop/KnowCode/docs/evolution.md::1-layered-architecture::0", "entity_id": "/home/deeog/Desktop/KnowCode/docs/evolution.md::1-layered-architecture", "content": "**1. Layered Architecture**", "tokens": ["layered", "architecture"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768185812.9922073"}}, {"id": "/home/deeog/Desktop/KnowCode/docs/evolution.md::2-component-interaction::0", "entity_id": "/home/deeog/Desktop/KnowCode/docs/evolution.md::2-component-interaction", "content": "**2. Component Interaction**", "tokens": ["component", "interaction"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768185812.9922073"}}, {"id": "/home/deeog/Desktop/KnowCode/docs/evolution.md::implementation-status-roadmap::0", "entity_id": "/home/deeog/Desktop/KnowCode/docs/evolution.md::implementation-status-roadmap", "content": "**Implementation Status & Roadmap**", "tokens": ["implementation", "status", "roadmap"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768185812.9922073"}}, {"id": "/home/deeog/Desktop/KnowCode/docs/evolution.md::phase-1-foundation-completed::0", "entity_id": "/home/deeog/Desktop/KnowCode/docs/evolution.md::phase-1-foundation-completed", "content": "**Phase 1: Foundation (COMPLETED)**", "tokens": ["phase", "foundation", "completed"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768185812.9922073"}}, {"id": "/home/deeog/Desktop/KnowCode/docs/evolution.md::phase-2-intelligence-server-rag-completed::0", "entity_id": "/home/deeog/Desktop/KnowCode/docs/evolution.md::phase-2-intelligence-server-rag-completed", "content": "**Phase 2: Intelligence Server & RAG (COMPLETED)**", "tokens": ["phase", "intelligence", "server", "rag", "completed"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768185812.9922073"}}, {"id": "/home/deeog/Desktop/KnowCode/docs/evolution.md::phase-3-temporal-runtime-signals-completed::0", "entity_id": "/home/deeog/Desktop/KnowCode/docs/evolution.md::phase-3-temporal-runtime-signals-completed", "content": "**Phase 3: Temporal & Runtime Signals (COMPLETED)**", "tokens": ["phase", "temporal", "runtime", "signals", "completed"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768185812.9922073"}}, {"id": "/home/deeog/Desktop/KnowCode/docs/evolution.md::phase-4-documentation-synthesis-partial::0", "entity_id": "/home/deeog/Desktop/KnowCode/docs/evolution.md::phase-4-documentation-synthesis-partial", "content": "**Phase 4: Documentation Synthesis (PARTIAL)**", "tokens": ["phase", "documentation", "synthesis", "partial"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768185812.9922073"}}, {"id": "/home/deeog/Desktop/KnowCode/docs/evolution.md::phase-5-deep-analysis-next::0", "entity_id": "/home/deeog/Desktop/KnowCode/docs/evolution.md::phase-5-deep-analysis-next", "content": "**Phase 5: Deep Analysis (NEXT)**", "tokens": ["phase", "deep", "analysis", "next"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768185812.9922073"}}, {"id": "/home/deeog/Desktop/KnowCode/docs/evolution.md::phase-6-enterprise-future::0", "entity_id": "/home/deeog/Desktop/KnowCode/docs/evolution.md::phase-6-enterprise-future", "content": "**Phase 6: Enterprise (FUTURE)**", "tokens": ["phase", "enterprise", "future"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768185812.9922073"}}, {"id": "/home/deeog/Desktop/KnowCode/docs/evolution.md::phase-7-agentic-capabilities-completed-v22::0", "entity_id": "/home/deeog/Desktop/KnowCode/docs/evolution.md::phase-7-agentic-capabilities-completed-v22", "content": "**Phase 7: Agentic Capabilities (COMPLETED v2.2)**", "tokens": ["phase", "agentic", "capabilities", "completed", "v2"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768185812.9922073"}}, {"id": "/home/deeog/Desktop/KnowCode/docs/evolution.md::phase-8-ide-integration-completed-v22::0", "entity_id": "/home/deeog/Desktop/KnowCode/docs/evolution.md::phase-8-ide-integration-completed-v22", "content": "**Phase 8: IDE Integration (COMPLETED v2.2)**", "tokens": ["phase", "ide", "integration", "completed", "v2"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768185812.9922073"}}, {"id": "/home/deeog/Desktop/KnowCode/docs/api/knowledge_store.md::module::0", "entity_id": "/home/deeog/Desktop/KnowCode/docs/api/knowledge_store.md::module", "content": "# Knowledge Store API\nThe `KnowledgeStore` is the central repository for the semantic graph derived from the codebase. It persists the graph to a JSON file and provides query mechanisms.\n## Class: `KnowledgeStore`\n**Module:** `knowcode.storage.knowledge_store`\n### Initialization\n```python\nstore = KnowledgeStore()\n```\n### Persistence\n#### `save(path: str | Path)`\nSaves the current graph, including entities, relationships, and metadata, to a JSON file (default `knowcode_knowledge.json`).\n#### `load(path: str | Path) -> KnowledgeStore`\nClass method to load a store from a JSON file (or directory containing the file).\n### Core Properties\n- **`entities`**: A dictionary mapping entity IDs to `Entity` objects.\n- **`relationships`**: A list of `Relationship` objects.\n- **`metadata`**: A dictionary containing scan statistics (scan time, file count) and errors.\n### Query Methods\n#### `get_entity(entity_id: str) -> Optional[Entity]`\nRetrieve an entity object by its unique ID.\n#### `search(pattern: str) -> list[Entity]`\nSearch for entities where the name or qualified name matches the substring pattern (case-insensitive).\n#### `get_callers(entity_id: str) -> list[Entity]`\nFind all entities that call the target entity (incoming `CALLS` edges).\n#### `get_callees(entity_id: str) -> list[Entity]`\nFind all entities that are called by the source entity (outgoing `CALLS` edges).\n#### `get_children(entity_id: str) -> list[Entity]`\nFind all entities contained within the source entity (e.g., methods within a class).\n#### `get_parent(entity_id: str) -> Optional[Entity]`\nFind the container of an entity (e.g., the class containing a method).\n#### `get_dependencies(entity_id: str) -> list[Entity]`\nGet all entities that the target entity depends on via calls or imports.\n#### `get_dependents(entity_id: str) -> list[Entity]`\nGet all entities that depend on the target entity via calls or imports.\n#### `get_entities_by_kind(kind: EntityKind | str) -> list[Entity]`\nList all entities of a specific kind (e.g., `EntityKind.CLASS`, \"function\").\n#### `trace_calls(entity_id: str, direction: str = \"callees\", depth: int = 1, max_results: int = 50) -> list[dict[str, Any]]`\nMulti-hop call graph traversal starting from an entity.\n- `direction=\"callees\"`: what the entity calls\n- `direction=\"callers\"`: what calls the entity\nEach result includes `call_depth` (hops from the starting entity) plus basic location metadata.\n#### `get_impact(entity_id: str, max_depth: int = 3) -> dict[str, Any]`\nImpact analysis for modifying/deleting an entity.\nReturns:\n- `direct_dependents`: 1-hop callers/importers\n- `transitive_dependents`: multi-hop dependents up to `max_depth`\n- `affected_files`: files likely requiring review\n- `risk_score`: 0.0\u20131.0 risk estimate\n### Data Models\n#### `Entity`\n- `id`: Unique identifier (path + :: + qualified name)\n- `kind`: `EntityKind` (module, class, function, method, etc.)\n- `name`: Short name\n- `qualified_name`: Full dotted path\n- `location`: File path and line range\n- `source_code`: Raw source code (optional)\n- `docstring`: Extracted docstring (optional)\n#### `Relationship`\n- `source_id`: Origin entity ID\n- `target_id`: Destination entity ID\n- `kind`: `RelationshipKind` (calls, imports, contains, inherits, etc.)", "tokens": ["knowledge", "store", "api", "the", "knowledge", "store", "is", "the", "central", "repository", "for", "the", "semantic", "graph", "derived", "from", "the", "codebase", "it", "persists", "the", "graph", "to", "json", "file", "and", "provides", "query", "mechanisms", "class", "knowledge", "store", "module", "knowcode", "storage", "knowledge", "store", "initialization", "python", "store", "knowledge", "store", "persistence", "save", "path", "str", "path", "saves", "the", "current", "graph", "including", "entities", "relationships", "and", "metadata", "to", "json", "file", "default", "knowcode", "knowledge", "json", "load", "path", "str", "path", "knowledge", "store", "class", "method", "to", "load", "store", "from", "json", "file", "or", "directory", "containing", "the", "file", "core", "properties", "entities", "dictionary", "mapping", "entity", "ids", "to", "entity", "objects", "relationships", "list", "of", "relationship", "objects", "metadata", "dictionary", "containing", "scan", "statistics", "scan", "time", "file", "count", "and", "errors", "query", "methods", "get", "entity", "entity", "id", "str", "optional", "entity", "retrieve", "an", "entity", "object", "by", "its", "unique", "id", "search", "pattern", "str", "list", "entity", "search", "for", "entities", "where", "the", "name", "or", "qualified", "name", "matches", "the", "substring", "pattern", "case", "insensitive", "get", "callers", "entity", "id", "str", "list", "entity", "find", "all", "entities", "that", "call", "the", "target", "entity", "incoming", "calls", "edges", "get", "callees", "entity", "id", "str", "list", "entity", "find", "all", "entities", "that", "are", "called", "by", "the", "source", "entity", "outgoing", "calls", "edges", "get", "children", "entity", "id", "str", "list", "entity", "find", "all", "entities", "contained", "within", "the", "source", "entity", "methods", "within", "class", "get", "parent", "entity", "id", "str", "optional", "entity", "find", "the", "container", "of", "an", "entity", "the", "class", "containing", "method", "get", "dependencies", "entity", "id", "str", "list", "entity", "get", "all", "entities", "that", "the", "target", "entity", "depends", "on", "via", "calls", "or", "imports", "get", "dependents", "entity", "id", "str", "list", "entity", "get", "all", "entities", "that", "depend", "on", "the", "target", "entity", "via", "calls", "or", "imports", "get", "entities", "by", "kind", "kind", "entity", "kind", "str", "list", "entity", "list", "all", "entities", "of", "specific", "kind", "entity", "kind", "class", "function", "trace", "calls", "entity", "id", "str", "direction", "str", "callees", "depth", "int", "max", "results", "int", "50", "list", "dict", "str", "any", "multi", "hop", "call", "graph", "traversal", "starting", "from", "an", "entity", "direction", "callees", "what", "the", "entity", "calls", "direction", "callers", "what", "calls", "the", "entity", "each", "result", "includes", "call", "depth", "hops", "from", "the", "starting", "entity", "plus", "basic", "location", "metadata", "get", "impact", "entity", "id", "str", "max", "depth", "int", "dict", "str", "any", "impact", "analysis", "for", "modifying", "deleting", "an", "entity", "returns", "direct", "dependents", "hop", "callers", "importers", "transitive", "dependents", "multi", "hop", "dependents", "up", "to", "max", "depth", "affected", "files", "files", "likely", "requiring", "review", "risk", "score", "risk", "estimate", "data", "models", "entity", "id", "unique", "identifier", "path", "qualified", "name", "kind", "entity", "kind", "module", "class", "function", "method", "etc", "name", "short", "name", "qualified", "name", "full", "dotted", "path", "location", "file", "path", "and", "line", "range", "source", "code", "raw", "source", "code", "optional", "docstring", "extracted", "docstring", "optional", "relationship", "source", "id", "origin", "entity", "id", "target", "id", "destination", "entity", "id", "kind", "relationship", "kind", "calls", "imports", "contains", "inherits", "etc"], "metadata": {"type": "module_header"}}, {"id": "/home/deeog/Desktop/KnowCode/docs/api/knowledge_store.md::knowledge_store::0", "entity_id": "/home/deeog/Desktop/KnowCode/docs/api/knowledge_store.md::knowledge_store", "content": "\"\"\"The `KnowledgeStore` is the central repository for the semantic graph derived from the codebase. It persists the graph to a JSON file and provides query mechanisms.\"\"\"\nknowledge_store", "tokens": ["the", "knowledge", "store", "is", "the", "central", "repository", "for", "the", "semantic", "graph", "derived", "from", "the", "codebase", "it", "persists", "the", "graph", "to", "json", "file", "and", "provides", "query", "mechanisms", "knowledge", "store"], "metadata": {"kind": "document", "has_docstring": "true", "last_modified": "1768185812.992114"}}, {"id": "/home/deeog/Desktop/KnowCode/docs/api/knowledge_store.md::knowledge-store-api::0", "entity_id": "/home/deeog/Desktop/KnowCode/docs/api/knowledge_store.md::knowledge-store-api", "content": "Knowledge Store API", "tokens": ["knowledge", "store", "api"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768185812.992114"}}, {"id": "/home/deeog/Desktop/KnowCode/docs/api/knowledge_store.md::class-knowledgestore::0", "entity_id": "/home/deeog/Desktop/KnowCode/docs/api/knowledge_store.md::class-knowledgestore", "content": "Class: `KnowledgeStore`", "tokens": ["class", "knowledge", "store"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768185812.992114"}}, {"id": "/home/deeog/Desktop/KnowCode/docs/api/knowledge_store.md::initialization::0", "entity_id": "/home/deeog/Desktop/KnowCode/docs/api/knowledge_store.md::initialization", "content": "Initialization", "tokens": ["initialization"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768185812.992114"}}, {"id": "/home/deeog/Desktop/KnowCode/docs/api/knowledge_store.md::persistence::0", "entity_id": "/home/deeog/Desktop/KnowCode/docs/api/knowledge_store.md::persistence", "content": "Persistence", "tokens": ["persistence"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768185812.992114"}}, {"id": "/home/deeog/Desktop/KnowCode/docs/api/knowledge_store.md::savepath-str-path::0", "entity_id": "/home/deeog/Desktop/KnowCode/docs/api/knowledge_store.md::savepath-str-path", "content": "`save(path: str | Path)`", "tokens": ["save", "path", "str", "path"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768185812.992114"}}, {"id": "/home/deeog/Desktop/KnowCode/docs/api/knowledge_store.md::loadpath-str-path-knowledgestore::0", "entity_id": "/home/deeog/Desktop/KnowCode/docs/api/knowledge_store.md::loadpath-str-path-knowledgestore", "content": "`load(path: str | Path) -> KnowledgeStore`", "tokens": ["load", "path", "str", "path", "knowledge", "store"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768185812.992114"}}, {"id": "/home/deeog/Desktop/KnowCode/docs/api/knowledge_store.md::core-properties::0", "entity_id": "/home/deeog/Desktop/KnowCode/docs/api/knowledge_store.md::core-properties", "content": "Core Properties", "tokens": ["core", "properties"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768185812.992114"}}, {"id": "/home/deeog/Desktop/KnowCode/docs/api/knowledge_store.md::query-methods::0", "entity_id": "/home/deeog/Desktop/KnowCode/docs/api/knowledge_store.md::query-methods", "content": "Query Methods", "tokens": ["query", "methods"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768185812.992114"}}, {"id": "/home/deeog/Desktop/KnowCode/docs/api/knowledge_store.md::get-entityentity-id-str-optionalentity::0", "entity_id": "/home/deeog/Desktop/KnowCode/docs/api/knowledge_store.md::get-entityentity-id-str-optionalentity", "content": "`get_entity(entity_id: str) -> Optional[Entity]`", "tokens": ["get", "entity", "entity", "id", "str", "optional", "entity"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768185812.992114"}}, {"id": "/home/deeog/Desktop/KnowCode/docs/api/knowledge_store.md::searchpattern-str-listentity::0", "entity_id": "/home/deeog/Desktop/KnowCode/docs/api/knowledge_store.md::searchpattern-str-listentity", "content": "`search(pattern: str) -> list[Entity]`", "tokens": ["search", "pattern", "str", "list", "entity"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768185812.992114"}}, {"id": "/home/deeog/Desktop/KnowCode/docs/api/knowledge_store.md::get-callersentity-id-str-listentity::0", "entity_id": "/home/deeog/Desktop/KnowCode/docs/api/knowledge_store.md::get-callersentity-id-str-listentity", "content": "`get_callers(entity_id: str) -> list[Entity]`", "tokens": ["get", "callers", "entity", "id", "str", "list", "entity"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768185812.992114"}}, {"id": "/home/deeog/Desktop/KnowCode/docs/api/knowledge_store.md::get-calleesentity-id-str-listentity::0", "entity_id": "/home/deeog/Desktop/KnowCode/docs/api/knowledge_store.md::get-calleesentity-id-str-listentity", "content": "`get_callees(entity_id: str) -> list[Entity]`", "tokens": ["get", "callees", "entity", "id", "str", "list", "entity"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768185812.992114"}}, {"id": "/home/deeog/Desktop/KnowCode/docs/api/knowledge_store.md::get-childrenentity-id-str-listentity::0", "entity_id": "/home/deeog/Desktop/KnowCode/docs/api/knowledge_store.md::get-childrenentity-id-str-listentity", "content": "`get_children(entity_id: str) -> list[Entity]`", "tokens": ["get", "children", "entity", "id", "str", "list", "entity"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768185812.992114"}}, {"id": "/home/deeog/Desktop/KnowCode/docs/api/knowledge_store.md::get-parententity-id-str-optionalentity::0", "entity_id": "/home/deeog/Desktop/KnowCode/docs/api/knowledge_store.md::get-parententity-id-str-optionalentity", "content": "`get_parent(entity_id: str) -> Optional[Entity]`", "tokens": ["get", "parent", "entity", "id", "str", "optional", "entity"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768185812.992114"}}, {"id": "/home/deeog/Desktop/KnowCode/docs/api/knowledge_store.md::get-dependenciesentity-id-str-listentity::0", "entity_id": "/home/deeog/Desktop/KnowCode/docs/api/knowledge_store.md::get-dependenciesentity-id-str-listentity", "content": "`get_dependencies(entity_id: str) -> list[Entity]`", "tokens": ["get", "dependencies", "entity", "id", "str", "list", "entity"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768185812.992114"}}, {"id": "/home/deeog/Desktop/KnowCode/docs/api/knowledge_store.md::get-dependentsentity-id-str-listentity::0", "entity_id": "/home/deeog/Desktop/KnowCode/docs/api/knowledge_store.md::get-dependentsentity-id-str-listentity", "content": "`get_dependents(entity_id: str) -> list[Entity]`", "tokens": ["get", "dependents", "entity", "id", "str", "list", "entity"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768185812.992114"}}, {"id": "/home/deeog/Desktop/KnowCode/docs/api/knowledge_store.md::get-entities-by-kindkind-entitykind-str-listentity::0", "entity_id": "/home/deeog/Desktop/KnowCode/docs/api/knowledge_store.md::get-entities-by-kindkind-entitykind-str-listentity", "content": "`get_entities_by_kind(kind: EntityKind | str) -> list[Entity]`", "tokens": ["get", "entities", "by", "kind", "kind", "entity", "kind", "str", "list", "entity"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768185812.992114"}}, {"id": "/home/deeog/Desktop/KnowCode/docs/api/knowledge_store.md::trace-callsentity-id-str-direction-str-callees-depth-int-1-max-results-int-50-listdictstr-any::0", "entity_id": "/home/deeog/Desktop/KnowCode/docs/api/knowledge_store.md::trace-callsentity-id-str-direction-str-callees-depth-int-1-max-results-int-50-listdictstr-any", "content": "`trace_calls(entity_id: str, direction: str = \"callees\", depth: int = 1, max_results: int = 50) -> list[dict[str, Any]]`", "tokens": ["trace", "calls", "entity", "id", "str", "direction", "str", "callees", "depth", "int", "max", "results", "int", "50", "list", "dict", "str", "any"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768185812.992114"}}, {"id": "/home/deeog/Desktop/KnowCode/docs/api/knowledge_store.md::get-impactentity-id-str-max-depth-int-3-dictstr-any::0", "entity_id": "/home/deeog/Desktop/KnowCode/docs/api/knowledge_store.md::get-impactentity-id-str-max-depth-int-3-dictstr-any", "content": "`get_impact(entity_id: str, max_depth: int = 3) -> dict[str, Any]`", "tokens": ["get", "impact", "entity", "id", "str", "max", "depth", "int", "dict", "str", "any"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768185812.992114"}}, {"id": "/home/deeog/Desktop/KnowCode/docs/api/knowledge_store.md::data-models::0", "entity_id": "/home/deeog/Desktop/KnowCode/docs/api/knowledge_store.md::data-models", "content": "Data Models", "tokens": ["data", "models"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768185812.992114"}}, {"id": "/home/deeog/Desktop/KnowCode/docs/api/knowledge_store.md::entity::0", "entity_id": "/home/deeog/Desktop/KnowCode/docs/api/knowledge_store.md::entity", "content": "`Entity`", "tokens": ["entity"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768185812.992114"}}, {"id": "/home/deeog/Desktop/KnowCode/docs/api/knowledge_store.md::relationship::0", "entity_id": "/home/deeog/Desktop/KnowCode/docs/api/knowledge_store.md::relationship", "content": "`Relationship`", "tokens": ["relationship"], "metadata": {"kind": "section", "has_docstring": "false", "last_modified": "1768185812.992114"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/data_models.py::module::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/data_models.py::module", "content": "\"\"\"Data models for KnowCode entities and relationships.\"\"\"", "tokens": ["data", "models", "for", "know", "code", "entities", "and", "relationships"], "metadata": {"type": "module_header"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/data_models.py::imports::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/data_models.py::module", "content": "from dataclasses import dataclass, field\nfrom enum import Enum\nfrom typing import Optional", "tokens": ["from", "dataclasses", "import", "dataclass", "field", "from", "enum", "import", "enum", "from", "typing", "import", "optional"], "metadata": {"type": "imports"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/data_models.py::EntityKind::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/data_models.py::EntityKind", "content": "\"\"\"Types of code entities tracked by the system.\n\nThese correspond to semantic nodes in the knowledge graph.\"\"\"\nclass EntityKind(str, Enum):\n    \"\"\"Types of code entities tracked by the system.\n    \n    These correspond to semantic nodes in the knowledge graph.\n    \"\"\"\n\n    MODULE = \"module\"          # Python modules, Java packages\n    CLASS = \"class\"            # Classes, Interfaces, Enums\n    FUNCTION = \"function\"      # Top-level functions\n    METHOD = \"method\"          # Class methods\n    VARIABLE = \"variable\"      # (Future) Top-level variables/constants\n    # Documentation entities\n    DOCUMENT = \"document\"      # Markdown files\n    SECTION = \"section\"        # Headings within documents\n    # Configuration entities\n    CONFIG_KEY = \"config_key\"  # YAML/JSON keys\n    # Temporal entities\n    COMMIT = \"commit\"          # Git commits\n    AUTHOR = \"author\"          # Git authors\n    # Runtime entities\n    TEST_RUN = \"test_run\"      # Test execution result\n    COVERAGE_REPORT = \"covera", "tokens": ["types", "of", "code", "entities", "tracked", "by", "the", "system", "these", "correspond", "to", "semantic", "nodes", "in", "the", "knowledge", "graph", "class", "entity", "kind", "str", "enum", "types", "of", "code", "entities", "tracked", "by", "the", "system", "these", "correspond", "to", "semantic", "nodes", "in", "the", "knowledge", "graph", "module", "module", "python", "modules", "java", "packages", "class", "class", "classes", "interfaces", "enums", "function", "function", "top", "level", "functions", "method", "method", "class", "methods", "variable", "variable", "future", "top", "level", "variables", "constants", "documentation", "entities", "document", "document", "markdown", "files", "section", "section", "headings", "within", "documents", "configuration", "entities", "config", "key", "config", "key", "yaml", "json", "keys", "temporal", "entities", "commit", "commit", "git", "commits", "author", "author", "git", "authors", "runtime", "entities", "test", "run", "test", "run", "test", "execution", "result", "coverage", "report", "covera"], "metadata": {"kind": "class", "chunk_index": "0", "has_docstring": "true", "last_modified": "1768294077.4754992"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/data_models.py::EntityKind::1", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/data_models.py::EntityKind", "content": "untime entities\n    TEST_RUN = \"test_run\"      # Test execution result\n    COVERAGE_REPORT = \"coverage_report\"", "tokens": ["untime", "entities", "test", "run", "test", "run", "test", "execution", "result", "coverage", "report", "coverage", "report"], "metadata": {"kind": "class", "chunk_index": "1", "has_docstring": "true", "last_modified": "1768294077.4754992"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/data_models.py::RelationshipKind::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/data_models.py::RelationshipKind", "content": "\"\"\"Types of relationships (edges) between entities.\"\"\"\nclass RelationshipKind(str, Enum):\n    \"\"\"Types of relationships (edges) between entities.\"\"\"\n\n    CALLS = \"calls\"            # Static function/method call\n    IMPORTS = \"imports\"        # Module import / dependency\n    CONTAINS = \"contains\"      # Structural containment (Class -> Method)\n    INHERITS = \"inherits\"      # Class inheritance / Interface implementation\n    REFERENCES = \"references\"  # General reference (e.g., config usage)\n    # Temporal relationships\n    CHANGED_BY = \"changed_by\"  # Entity -> Commit\n    AUTHORED = \"authored\"      # Author -> Commit\n    MODIFIED = \"modified\"      # Commit -> Entity\n    # Runtime relationships\n    COVERS = \"covers\"           # Report/Test -> Entity\n    EXECUTED_BY = \"executed_by\" # Entity -> Report/Test", "tokens": ["types", "of", "relationships", "edges", "between", "entities", "class", "relationship", "kind", "str", "enum", "types", "of", "relationships", "edges", "between", "entities", "calls", "calls", "static", "function", "method", "call", "imports", "imports", "module", "import", "dependency", "contains", "contains", "structural", "containment", "class", "method", "inherits", "inherits", "class", "inheritance", "interface", "implementation", "references", "references", "general", "reference", "config", "usage", "temporal", "relationships", "changed", "by", "changed", "by", "entity", "commit", "authored", "authored", "author", "commit", "modified", "modified", "commit", "entity", "runtime", "relationships", "covers", "covers", "report", "test", "entity", "executed", "by", "executed", "by", "entity", "report", "test"], "metadata": {"kind": "class", "has_docstring": "true", "last_modified": "1768294077.4754992"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/data_models.py::TaskType::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/data_models.py::TaskType", "content": "\"\"\"Query/task types for context prioritization.\n\nThese correspond to task-specific templates in KnowCode.md (Layer 9).\"\"\"\nclass TaskType(str, Enum):\n    \"\"\"Query/task types for context prioritization.\n    \n    These correspond to task-specific templates in KnowCode.md (Layer 9).\n    \"\"\"\n\n    EXPLAIN = \"explain\"    # \"How does X work?\", \"Explain the flow of Y\"\n    DEBUG = \"debug\"        # \"Why is X failing?\", \"What's causing bug in Y?\"\n    EXTEND = \"extend\"      # \"How do I add X?\", \"Where should I implement Y?\"\n    REVIEW = \"review\"      # \"What changed in X?\", \"Review this code\"\n    LOCATE = \"locate\"      # \"Where is X defined?\", \"Find usages of Y\"\n    GENERAL = \"general\"    # Default fallback for unclassified queries", "tokens": ["query", "task", "types", "for", "context", "prioritization", "these", "correspond", "to", "task", "specific", "templates", "in", "know", "code", "md", "layer", "class", "task", "type", "str", "enum", "query", "task", "types", "for", "context", "prioritization", "these", "correspond", "to", "task", "specific", "templates", "in", "know", "code", "md", "layer", "explain", "explain", "how", "does", "work", "explain", "the", "flow", "of", "debug", "debug", "why", "is", "failing", "what", "causing", "bug", "in", "extend", "extend", "how", "do", "add", "where", "should", "implement", "review", "review", "what", "changed", "in", "review", "this", "code", "locate", "locate", "where", "is", "defined", "find", "usages", "of", "general", "general", "default", "fallback", "for", "unclassified", "queries"], "metadata": {"kind": "class", "has_docstring": "true", "last_modified": "1768294077.4754992"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/data_models.py::Location::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/data_models.py::Location", "content": "\"\"\"Source location of an entity.\"\"\"\nclass Location:\n    \"\"\"Source location of an entity.\"\"\"\n\n    file_path: str\n    line_start: int\n    line_end: int\n    column_start: int = 0\n    column_end: int = 0", "tokens": ["source", "location", "of", "an", "entity", "class", "location", "source", "location", "of", "an", "entity", "file", "path", "str", "line", "start", "int", "line", "end", "int", "column", "start", "int", "column", "end", "int"], "metadata": {"kind": "class", "has_docstring": "true", "last_modified": "1768294077.4754992"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/data_models.py::Entity::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/data_models.py::Entity", "content": "\"\"\"A code entity (function, class, module, etc.).\"\"\"\nclass Entity:\n    \"\"\"A code entity (function, class, module, etc.).\"\"\"\n\n    id: str  # Unique identifier: file_path::qualified_name\n    kind: EntityKind\n    name: str  # Short name (e.g., \"MyClass\")\n    qualified_name: str  # Full name (e.g., \"my_pkg.module.MyClass\")\n    location: Location\n    docstring: Optional[str] = None\n    signature: Optional[str] = None\n    source_code: Optional[str] = None\n    # Flexible metadata storage. Common keys:\n    # - \"language\": \"python\", \"javascript\", etc.\n    # - \"complexity\": Cyclomatic complexity score\n    # - \"is_async\": \"true\" if async function\n    metadata: dict[str, str] = field(default_factory=dict)\n\n    def __hash__(self) -> int:\n        return hash(self.id)\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, Entity):\n            return False\n        return self.id == other.id", "tokens": ["code", "entity", "function", "class", "module", "etc", "class", "entity", "code", "entity", "function", "class", "module", "etc", "id", "str", "unique", "identifier", "file", "path", "qualified", "name", "kind", "entity", "kind", "name", "str", "short", "name", "my", "class", "qualified", "name", "str", "full", "name", "my", "pkg", "module", "my", "class", "location", "location", "docstring", "optional", "str", "none", "signature", "optional", "str", "none", "source", "code", "optional", "str", "none", "flexible", "metadata", "storage", "common", "keys", "language", "python", "javascript", "etc", "complexity", "cyclomatic", "complexity", "score", "is", "async", "true", "if", "async", "function", "metadata", "dict", "str", "str", "field", "default", "factory", "dict", "def", "hash", "self", "int", "return", "hash", "self", "id", "def", "eq", "self", "other", "object", "bool", "if", "not", "isinstance", "other", "entity", "return", "false", "return", "self", "id", "other", "id"], "metadata": {"kind": "class", "has_docstring": "true", "last_modified": "1768294077.4754992"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/data_models.py::Entity.__hash__::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/data_models.py::Entity.__hash__", "content": "def __hash__(self) -> int\n    def __hash__(self) -> int:\n        return hash(self.id)", "tokens": ["def", "hash", "self", "int", "def", "hash", "self", "int", "return", "hash", "self", "id"], "metadata": {"kind": "method", "has_docstring": "false", "last_modified": "1768294077.4754992"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/data_models.py::Entity.__eq__::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/data_models.py::Entity.__eq__", "content": "def __eq__(self, other: object) -> bool\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, Entity):\n            return False\n        return self.id == other.id", "tokens": ["def", "eq", "self", "other", "object", "bool", "def", "eq", "self", "other", "object", "bool", "if", "not", "isinstance", "other", "entity", "return", "false", "return", "self", "id", "other", "id"], "metadata": {"kind": "method", "has_docstring": "false", "last_modified": "1768294077.4754992"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/data_models.py::Relationship::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/data_models.py::Relationship", "content": "\"\"\"A relationship between two entities.\"\"\"\nclass Relationship:\n    \"\"\"A relationship between two entities.\"\"\"\n\n    source_id: str\n    target_id: str\n    kind: RelationshipKind\n    metadata: dict[str, str] = field(default_factory=dict)\n\n    def __hash__(self) -> int:\n        return hash((self.source_id, self.target_id, self.kind))\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, Relationship):\n            return False\n        return (\n            self.source_id == other.source_id\n            and self.target_id == other.target_id\n            and self.kind == other.kind\n        )", "tokens": ["relationship", "between", "two", "entities", "class", "relationship", "relationship", "between", "two", "entities", "source", "id", "str", "target", "id", "str", "kind", "relationship", "kind", "metadata", "dict", "str", "str", "field", "default", "factory", "dict", "def", "hash", "self", "int", "return", "hash", "self", "source", "id", "self", "target", "id", "self", "kind", "def", "eq", "self", "other", "object", "bool", "if", "not", "isinstance", "other", "relationship", "return", "false", "return", "self", "source", "id", "other", "source", "id", "and", "self", "target", "id", "other", "target", "id", "and", "self", "kind", "other", "kind"], "metadata": {"kind": "class", "has_docstring": "true", "last_modified": "1768294077.4754992"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/data_models.py::Relationship.__hash__::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/data_models.py::Relationship.__hash__", "content": "def __hash__(self) -> int\n    def __hash__(self) -> int:\n        return hash((self.source_id, self.target_id, self.kind))", "tokens": ["def", "hash", "self", "int", "def", "hash", "self", "int", "return", "hash", "self", "source", "id", "self", "target", "id", "self", "kind"], "metadata": {"kind": "method", "has_docstring": "false", "last_modified": "1768294077.4754992"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/data_models.py::Relationship.__eq__::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/data_models.py::Relationship.__eq__", "content": "def __eq__(self, other: object) -> bool\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, Relationship):\n            return False\n        return (\n            self.source_id == other.source_id\n            and self.target_id == other.target_id\n            and self.kind == other.kind\n        )", "tokens": ["def", "eq", "self", "other", "object", "bool", "def", "eq", "self", "other", "object", "bool", "if", "not", "isinstance", "other", "relationship", "return", "false", "return", "self", "source", "id", "other", "source", "id", "and", "self", "target", "id", "other", "target", "id", "and", "self", "kind", "other", "kind"], "metadata": {"kind": "method", "has_docstring": "false", "last_modified": "1768294077.4754992"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/data_models.py::ParseResult::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/data_models.py::ParseResult", "content": "\"\"\"Result from parsing a single file.\"\"\"\nclass ParseResult:\n    \"\"\"Result from parsing a single file.\"\"\"\n\n    file_path: str\n    entities: list[Entity]\n    relationships: list[Relationship]\n    errors: list[str] = field(default_factory=list)", "tokens": ["result", "from", "parsing", "single", "file", "class", "parse", "result", "result", "from", "parsing", "single", "file", "file", "path", "str", "entities", "list", "entity", "relationships", "list", "relationship", "errors", "list", "str", "field", "default", "factory", "list"], "metadata": {"kind": "class", "has_docstring": "true", "last_modified": "1768294077.4754992"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/data_models.py::ChunkingConfig::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/data_models.py::ChunkingConfig", "content": "\"\"\"Configuration for code chunking.\"\"\"\nclass ChunkingConfig:\n    \"\"\"Configuration for code chunking.\"\"\"\n\n    max_chunk_size: int = 1000\n    overlap: int = 100\n    include_signatures: bool = True\n    include_docstrings: bool = True", "tokens": ["configuration", "for", "code", "chunking", "class", "chunking", "config", "configuration", "for", "code", "chunking", "max", "chunk", "size", "int", "1000", "overlap", "int", "100", "include", "signatures", "bool", "true", "include", "docstrings", "bool", "true"], "metadata": {"kind": "class", "has_docstring": "true", "last_modified": "1768294077.4754992"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/data_models.py::CodeChunk::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/data_models.py::CodeChunk", "content": "\"\"\"A chunk of code for indexing and retrieval.\"\"\"\nclass CodeChunk:\n    \"\"\"A chunk of code for indexing and retrieval.\"\"\"\n\n    id: str  # Unique chunk ID: entity_id::chunk_index\n    entity_id: str  # Parent entity ID\n    content: str  # Raw text content\n    tokens: list[str] = field(default_factory=list)  # BM25 tokens\n    embedding: Optional[list[float]] = None  # Dense vector\n    metadata: dict[str, str] = field(default_factory=dict)", "tokens": ["chunk", "of", "code", "for", "indexing", "and", "retrieval", "class", "code", "chunk", "chunk", "of", "code", "for", "indexing", "and", "retrieval", "id", "str", "unique", "chunk", "id", "entity", "id", "chunk", "index", "entity", "id", "str", "parent", "entity", "id", "content", "str", "raw", "text", "content", "tokens", "list", "str", "field", "default", "factory", "list", "bm25", "tokens", "embedding", "optional", "list", "float", "none", "dense", "vector", "metadata", "dict", "str", "str", "field", "default", "factory", "dict"], "metadata": {"kind": "class", "has_docstring": "true", "last_modified": "1768294077.4754992"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/data_models.py::EmbeddingConfig::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/data_models.py::EmbeddingConfig", "content": "\"\"\"Configuration for embedding generation.\"\"\"\nclass EmbeddingConfig:\n    \"\"\"Configuration for embedding generation.\"\"\"\n\n    provider: str = \"voyageai\"\n    model_name: str = \"voyage-code-3\"\n    dimension: int = 1024\n    batch_size: int = 100\n    normalize: bool = True  # Normalize vectors for cosine similarity", "tokens": ["configuration", "for", "embedding", "generation", "class", "embedding", "config", "configuration", "for", "embedding", "generation", "provider", "str", "voyageai", "model", "name", "str", "voyage", "code", "dimension", "int", "1024", "batch", "size", "int", "100", "normalize", "bool", "true", "normalize", "vectors", "for", "cosine", "similarity"], "metadata": {"kind": "class", "has_docstring": "true", "last_modified": "1768294077.4754992"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/__init__.py::module::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/__init__.py::module", "content": "\"\"\"KnowCode - Transform your codebase into an effective knowledge base.\"\"\"", "tokens": ["know", "code", "transform", "your", "codebase", "into", "an", "effective", "knowledge", "base"], "metadata": {"type": "module_header"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/__init__.py::imports::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/__init__.py::module", "content": "from knowcode.data_models import CodeChunk as CodeChunk\nfrom knowcode.data_models import EmbeddingConfig as EmbeddingConfig\nfrom knowcode.storage.chunk_repository import ChunkRepository as ChunkRepository\nfrom knowcode.storage.chunk_repository import InMemoryChunkRepository as InMemoryChunkRepository", "tokens": ["from", "knowcode", "data", "models", "import", "code", "chunk", "as", "code", "chunk", "from", "knowcode", "data", "models", "import", "embedding", "config", "as", "embedding", "config", "from", "knowcode", "storage", "chunk", "repository", "import", "chunk", "repository", "as", "chunk", "repository", "from", "knowcode", "storage", "chunk", "repository", "import", "in", "memory", "chunk", "repository", "as", "in", "memory", "chunk", "repository"], "metadata": {"type": "imports"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/config.py::module::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/config.py::module", "content": "\"\"\"Configuration management for KnowCode.\"\"\"", "tokens": ["configuration", "management", "for", "know", "code"], "metadata": {"type": "module_header"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/config.py::imports::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/config.py::module", "content": "from dataclasses import dataclass, field\nfrom pathlib import Path\nfrom typing import Optional\nimport yaml", "tokens": ["from", "dataclasses", "import", "dataclass", "field", "from", "pathlib", "import", "path", "from", "typing", "import", "optional", "import", "yaml"], "metadata": {"type": "imports"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/config.py::ModelConfig::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/config.py::ModelConfig", "content": "\"\"\"Configuration for a single LLM model.\"\"\"\nclass ModelConfig:\n    \"\"\"Configuration for a single LLM model.\"\"\"\n    name: str\n    provider: str = \"google\"\n    api_key_env: str = \"GOOGLE_API_KEY\"\n    rpm_free_tier_limit: int = 10\n    rpd_free_tier_limit: int = 1000\n    tokens_free_tier_limit: int = 0  # For embedding/reranking models", "tokens": ["configuration", "for", "single", "llm", "model", "class", "model", "config", "configuration", "for", "single", "llm", "model", "name", "str", "provider", "str", "google", "api", "key", "env", "str", "google", "api", "key", "rpm", "free", "tier", "limit", "int", "10", "rpd", "free", "tier", "limit", "int", "1000", "tokens", "free", "tier", "limit", "int", "for", "embedding", "reranking", "models"], "metadata": {"kind": "class", "has_docstring": "true", "last_modified": "1768294084.915553"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/config.py::AppConfig::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/config.py::AppConfig", "content": "\"\"\"Global application configuration.\"\"\"\nclass AppConfig:\n    \"\"\"Global application configuration.\"\"\"\n    models: list[ModelConfig] = field(default_factory=list)\n    embedding_models: list[ModelConfig] = field(default_factory=list)\n    reranking_models: list[ModelConfig] = field(default_factory=list)\n    sufficiency_threshold: float = 0.8  # For local-first answering\n\n    @classmethod\n    def load(cls, config_path: Optional[str] = None) -> \"AppConfig\":\n        \"\"\"Load configuration from file or use defaults.\n        \n        Priority:\n        1. Explicit config_path\n        2. ./aimodels.yaml\n        3. ~/.aimodels.yaml\n        4. Defaults\n        \"\"\"\n        if config_path:\n            path = Path(config_path)\n            if path.exists():\n                return cls._load_from_yaml(path)\n        \n        local_config = Path(\"aimodels.yaml\")\n        if local_config.exists():\n            return cls._load_from_yaml(local_config)\n            \n        home_config = Path.home() / \".aimodels.", "tokens": ["global", "application", "configuration", "class", "app", "config", "global", "application", "configuration", "models", "list", "model", "config", "field", "default", "factory", "list", "embedding", "models", "list", "model", "config", "field", "default", "factory", "list", "reranking", "models", "list", "model", "config", "field", "default", "factory", "list", "sufficiency", "threshold", "float", "for", "local", "first", "answering", "classmethod", "def", "load", "cls", "config", "path", "optional", "str", "none", "app", "config", "load", "configuration", "from", "file", "or", "use", "defaults", "priority", "explicit", "config", "path", "aimodels", "yaml", "aimodels", "yaml", "defaults", "if", "config", "path", "path", "path", "config", "path", "if", "path", "exists", "return", "cls", "load", "from", "yaml", "path", "local", "config", "path", "aimodels", "yaml", "if", "local", "config", "exists", "return", "cls", "load", "from", "yaml", "local", "config", "home", "config", "path", "home", "aimodels"], "metadata": {"kind": "class", "chunk_index": "0", "has_docstring": "true", "last_modified": "1768294084.915553"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/config.py::AppConfig::1", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/config.py::AppConfig", "content": "eturn cls._load_from_yaml(local_config)\n            \n        home_config = Path.home() / \".aimodels.yaml\"\n        if home_config.exists():\n            return cls._load_from_yaml(home_config)\n            \n        return cls.default()\n\n    @classmethod\n    def default(cls) -> \"AppConfig\":\n        \"\"\"Return default configuration.\"\"\"\n        return cls(\n            models=[\n                ModelConfig(name=\"gemini-2.0-flash-lite\"),\n                ModelConfig(name=\"gemini-1.5-flash\"),\n                ModelConfig(name=\"gemini-1.5-pro\"),\n            ],\n            embedding_models=[\n                ModelConfig(\n                    name=\"voyage-code-3\",\n                    provider=\"voyageai\",\n                    api_key_env=\"VOYAGE_API_KEY_1\",\n                )\n            ],\n            sufficiency_threshold=0.8,\n        )\n\n    @classmethod\n    def _load_from_yaml(cls, path: Path) -> \"AppConfig\":\n        \"\"\"Parse YAML file into AppConfig.\n        \n        Supports both old format (models: [", "tokens": ["eturn", "cls", "load", "from", "yaml", "local", "config", "home", "config", "path", "home", "aimodels", "yaml", "if", "home", "config", "exists", "return", "cls", "load", "from", "yaml", "home", "config", "return", "cls", "default", "classmethod", "def", "default", "cls", "app", "config", "return", "default", "configuration", "return", "cls", "models", "model", "config", "name", "gemini", "flash", "lite", "model", "config", "name", "gemini", "flash", "model", "config", "name", "gemini", "pro", "embedding", "models", "model", "config", "name", "voyage", "code", "provider", "voyageai", "api", "key", "env", "voyage", "api", "key", "sufficiency", "threshold", "classmethod", "def", "load", "from", "yaml", "cls", "path", "path", "app", "config", "parse", "yaml", "file", "into", "app", "config", "supports", "both", "old", "format", "models"], "metadata": {"kind": "class", "chunk_index": "1", "has_docstring": "true", "last_modified": "1768294084.915553"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/config.py::AppConfig::2", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/config.py::AppConfig", "content": "ig\":\n        \"\"\"Parse YAML file into AppConfig.\n        \n        Supports both old format (models: [...]) and new format \n        (natural_language_models, embedding_models, reranking_models, config).\n        \"\"\"\n        try:\n            with open(path, \"r\", encoding=\"utf-8\") as f:\n                data = yaml.safe_load(f)\n            \n            # Load LLM models (natural language)\n            models = []\n            model_list = data.get(\"natural_language_models\", data.get(\"models\", []))\n            for m in (model_list or []):\n                models.append(ModelConfig(\n                    name=m[\"name\"],\n                    provider=m.get(\"provider\", \"google\"),\n                    api_key_env=m.get(\"api_key_env\", \"GOOGLE_API_KEY\"),\n                    rpm_free_tier_limit=m.get(\"rpm_free_tier_limit\", 10),\n                    rpd_free_tier_limit=m.get(\"rpd_free_tier_limit\", 1000),\n                ))\n            \n            # Load embedding models\n            embedding_models = []\n   ", "tokens": ["ig", "parse", "yaml", "file", "into", "app", "config", "supports", "both", "old", "format", "models", "and", "new", "format", "natural", "language", "models", "embedding", "models", "reranking", "models", "config", "try", "with", "open", "path", "encoding", "utf", "as", "data", "yaml", "safe", "load", "load", "llm", "models", "natural", "language", "models", "model", "list", "data", "get", "natural", "language", "models", "data", "get", "models", "for", "in", "model", "list", "or", "models", "append", "model", "config", "name", "name", "provider", "get", "provider", "google", "api", "key", "env", "get", "api", "key", "env", "google", "api", "key", "rpm", "free", "tier", "limit", "get", "rpm", "free", "tier", "limit", "10", "rpd", "free", "tier", "limit", "get", "rpd", "free", "tier", "limit", "1000", "load", "embedding", "models", "embedding", "models"], "metadata": {"kind": "class", "chunk_index": "2", "has_docstring": "true", "last_modified": "1768294084.915553"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/config.py::AppConfig::3", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/config.py::AppConfig", "content": "           ))\n            \n            # Load embedding models\n            embedding_models = []\n            for m in (data.get(\"embedding_models\") or []):\n                embedding_models.append(ModelConfig(\n                    name=m[\"name\"],\n                    provider=m.get(\"provider\", \"voyageai\"),\n                    api_key_env=m.get(\"api_key_env\", \"VOYAGE_API_KEY_1\"),\n                    tokens_free_tier_limit=m.get(\"tokens_free_tier_limit\", 0),\n                ))\n            \n            # Load reranking models\n            reranking_models = []\n            for m in (data.get(\"reranking_models\") or []):\n                reranking_models.append(ModelConfig(\n                    name=m[\"name\"],\n                    provider=m.get(\"provider\", \"voyageai\"),\n                    api_key_env=m.get(\"api_key_env\", \"VOYAGE_API_KEY_1\"),\n                    tokens_free_tier_limit=m.get(\"tokens_free_tier_limit\", 0),\n                ))\n            \n            # Load config section\n            c", "tokens": ["load", "embedding", "models", "embedding", "models", "for", "in", "data", "get", "embedding", "models", "or", "embedding", "models", "append", "model", "config", "name", "name", "provider", "get", "provider", "voyageai", "api", "key", "env", "get", "api", "key", "env", "voyage", "api", "key", "tokens", "free", "tier", "limit", "get", "tokens", "free", "tier", "limit", "load", "reranking", "models", "reranking", "models", "for", "in", "data", "get", "reranking", "models", "or", "reranking", "models", "append", "model", "config", "name", "name", "provider", "get", "provider", "voyageai", "api", "key", "env", "get", "api", "key", "env", "voyage", "api", "key", "tokens", "free", "tier", "limit", "get", "tokens", "free", "tier", "limit", "load", "config", "section"], "metadata": {"kind": "class", "chunk_index": "3", "has_docstring": "true", "last_modified": "1768294084.915553"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/config.py::AppConfig::4", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/config.py::AppConfig", "content": "ree_tier_limit\", 0),\n                ))\n            \n            # Load config section\n            config_section = data.get(\"config\", {})\n            sufficiency_threshold = config_section.get(\"sufficiency_threshold\", 0.8)\n            \n            if not models:\n                models = cls.default().models\n                \n            return cls(\n                models=models,\n                embedding_models=embedding_models,\n                reranking_models=reranking_models,\n                sufficiency_threshold=sufficiency_threshold,\n            )\n        except Exception as e:\n            print(f\"Warning: Failed to load config from {path}: {e}\")\n            return cls.default()", "tokens": ["ree", "tier", "limit", "load", "config", "section", "config", "section", "data", "get", "config", "sufficiency", "threshold", "config", "section", "get", "sufficiency", "threshold", "if", "not", "models", "models", "cls", "default", "models", "return", "cls", "models", "models", "embedding", "models", "embedding", "models", "reranking", "models", "reranking", "models", "sufficiency", "threshold", "sufficiency", "threshold", "except", "exception", "as", "print", "warning", "failed", "to", "load", "config", "from", "path", "return", "cls", "default"], "metadata": {"kind": "class", "chunk_index": "4", "has_docstring": "true", "last_modified": "1768294084.915553"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/config.py::AppConfig.load::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/config.py::AppConfig.load", "content": "def load(cls, config_path: Optional[str]) -> 'AppConfig'\n\"\"\"Load configuration from file or use defaults.\n\nPriority:\n1. Explicit config_path\n2. ./aimodels.yaml\n3. ~/.aimodels.yaml\n4. Defaults\"\"\"\n    def load(cls, config_path: Optional[str] = None) -> \"AppConfig\":\n        \"\"\"Load configuration from file or use defaults.\n        \n        Priority:\n        1. Explicit config_path\n        2. ./aimodels.yaml\n        3. ~/.aimodels.yaml\n        4. Defaults\n        \"\"\"\n        if config_path:\n            path = Path(config_path)\n            if path.exists():\n                return cls._load_from_yaml(path)\n        \n        local_config = Path(\"aimodels.yaml\")\n        if local_config.exists():\n            return cls._load_from_yaml(local_config)\n            \n        home_config = Path.home() / \".aimodels.yaml\"\n        if home_config.exists():\n            return cls._load_from_yaml(home_config)\n            \n        return cls.default()", "tokens": ["def", "load", "cls", "config", "path", "optional", "str", "app", "config", "load", "configuration", "from", "file", "or", "use", "defaults", "priority", "explicit", "config", "path", "aimodels", "yaml", "aimodels", "yaml", "defaults", "def", "load", "cls", "config", "path", "optional", "str", "none", "app", "config", "load", "configuration", "from", "file", "or", "use", "defaults", "priority", "explicit", "config", "path", "aimodels", "yaml", "aimodels", "yaml", "defaults", "if", "config", "path", "path", "path", "config", "path", "if", "path", "exists", "return", "cls", "load", "from", "yaml", "path", "local", "config", "path", "aimodels", "yaml", "if", "local", "config", "exists", "return", "cls", "load", "from", "yaml", "local", "config", "home", "config", "path", "home", "aimodels", "yaml", "if", "home", "config", "exists", "return", "cls", "load", "from", "yaml", "home", "config", "return", "cls", "default"], "metadata": {"kind": "method", "has_docstring": "true", "last_modified": "1768294084.915553"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/config.py::AppConfig.default::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/config.py::AppConfig.default", "content": "def default(cls) -> 'AppConfig'\n\"\"\"Return default configuration.\"\"\"\n    def default(cls) -> \"AppConfig\":\n        \"\"\"Return default configuration.\"\"\"\n        return cls(\n            models=[\n                ModelConfig(name=\"gemini-2.0-flash-lite\"),\n                ModelConfig(name=\"gemini-1.5-flash\"),\n                ModelConfig(name=\"gemini-1.5-pro\"),\n            ],\n            embedding_models=[\n                ModelConfig(\n                    name=\"voyage-code-3\",\n                    provider=\"voyageai\",\n                    api_key_env=\"VOYAGE_API_KEY_1\",\n                )\n            ],\n            sufficiency_threshold=0.8,\n        )", "tokens": ["def", "default", "cls", "app", "config", "return", "default", "configuration", "def", "default", "cls", "app", "config", "return", "default", "configuration", "return", "cls", "models", "model", "config", "name", "gemini", "flash", "lite", "model", "config", "name", "gemini", "flash", "model", "config", "name", "gemini", "pro", "embedding", "models", "model", "config", "name", "voyage", "code", "provider", "voyageai", "api", "key", "env", "voyage", "api", "key", "sufficiency", "threshold"], "metadata": {"kind": "method", "has_docstring": "true", "last_modified": "1768294084.915553"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/config.py::AppConfig._load_from_yaml::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/config.py::AppConfig._load_from_yaml", "content": "def _load_from_yaml(cls, path: Path) -> 'AppConfig'\n\"\"\"Parse YAML file into AppConfig.\n\nSupports both old format (models: [...]) and new format \n(natural_language_models, embedding_models, reranking_models, config).\"\"\"\n    def _load_from_yaml(cls, path: Path) -> \"AppConfig\":\n        \"\"\"Parse YAML file into AppConfig.\n        \n        Supports both old format (models: [...]) and new format \n        (natural_language_models, embedding_models, reranking_models, config).\n        \"\"\"\n        try:\n            with open(path, \"r\", encoding=\"utf-8\") as f:\n                data = yaml.safe_load(f)\n            \n            # Load LLM models (natural language)\n            models = []\n            model_list = data.get(\"natural_language_models\", data.get(\"models\", []))\n            for m in (model_list or []):\n                models.append(ModelConfig(\n                    name=m[\"name\"],\n                    provider=m.get(\"provider\", \"google\"),\n                    api_key_env=m.get(\"api_key_env\", \"GO", "tokens": ["def", "load", "from", "yaml", "cls", "path", "path", "app", "config", "parse", "yaml", "file", "into", "app", "config", "supports", "both", "old", "format", "models", "and", "new", "format", "natural", "language", "models", "embedding", "models", "reranking", "models", "config", "def", "load", "from", "yaml", "cls", "path", "path", "app", "config", "parse", "yaml", "file", "into", "app", "config", "supports", "both", "old", "format", "models", "and", "new", "format", "natural", "language", "models", "embedding", "models", "reranking", "models", "config", "try", "with", "open", "path", "encoding", "utf", "as", "data", "yaml", "safe", "load", "load", "llm", "models", "natural", "language", "models", "model", "list", "data", "get", "natural", "language", "models", "data", "get", "models", "for", "in", "model", "list", "or", "models", "append", "model", "config", "name", "name", "provider", "get", "provider", "google", "api", "key", "env", "get", "api", "key", "env", "go"], "metadata": {"kind": "method", "chunk_index": "0", "has_docstring": "true", "last_modified": "1768294084.915553"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/config.py::AppConfig._load_from_yaml::1", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/config.py::AppConfig._load_from_yaml", "content": "      provider=m.get(\"provider\", \"google\"),\n                    api_key_env=m.get(\"api_key_env\", \"GOOGLE_API_KEY\"),\n                    rpm_free_tier_limit=m.get(\"rpm_free_tier_limit\", 10),\n                    rpd_free_tier_limit=m.get(\"rpd_free_tier_limit\", 1000),\n                ))\n            \n            # Load embedding models\n            embedding_models = []\n            for m in (data.get(\"embedding_models\") or []):\n                embedding_models.append(ModelConfig(\n                    name=m[\"name\"],\n                    provider=m.get(\"provider\", \"voyageai\"),\n                    api_key_env=m.get(\"api_key_env\", \"VOYAGE_API_KEY_1\"),\n                    tokens_free_tier_limit=m.get(\"tokens_free_tier_limit\", 0),\n                ))\n            \n            # Load reranking models\n            reranking_models = []\n            for m in (data.get(\"reranking_models\") or []):\n                reranking_models.append(ModelConfig(\n                    name=m[\"name\"],\n                    p", "tokens": ["provider", "get", "provider", "google", "api", "key", "env", "get", "api", "key", "env", "google", "api", "key", "rpm", "free", "tier", "limit", "get", "rpm", "free", "tier", "limit", "10", "rpd", "free", "tier", "limit", "get", "rpd", "free", "tier", "limit", "1000", "load", "embedding", "models", "embedding", "models", "for", "in", "data", "get", "embedding", "models", "or", "embedding", "models", "append", "model", "config", "name", "name", "provider", "get", "provider", "voyageai", "api", "key", "env", "get", "api", "key", "env", "voyage", "api", "key", "tokens", "free", "tier", "limit", "get", "tokens", "free", "tier", "limit", "load", "reranking", "models", "reranking", "models", "for", "in", "data", "get", "reranking", "models", "or", "reranking", "models", "append", "model", "config", "name", "name"], "metadata": {"kind": "method", "chunk_index": "1", "has_docstring": "true", "last_modified": "1768294084.915553"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/config.py::AppConfig._load_from_yaml::2", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/config.py::AppConfig._load_from_yaml", "content": "      reranking_models.append(ModelConfig(\n                    name=m[\"name\"],\n                    provider=m.get(\"provider\", \"voyageai\"),\n                    api_key_env=m.get(\"api_key_env\", \"VOYAGE_API_KEY_1\"),\n                    tokens_free_tier_limit=m.get(\"tokens_free_tier_limit\", 0),\n                ))\n            \n            # Load config section\n            config_section = data.get(\"config\", {})\n            sufficiency_threshold = config_section.get(\"sufficiency_threshold\", 0.8)\n            \n            if not models:\n                models = cls.default().models\n                \n            return cls(\n                models=models,\n                embedding_models=embedding_models,\n                reranking_models=reranking_models,\n                sufficiency_threshold=sufficiency_threshold,\n            )\n        except Exception as e:\n            print(f\"Warning: Failed to load config from {path}: {e}\")\n            return cls.default()", "tokens": ["reranking", "models", "append", "model", "config", "name", "name", "provider", "get", "provider", "voyageai", "api", "key", "env", "get", "api", "key", "env", "voyage", "api", "key", "tokens", "free", "tier", "limit", "get", "tokens", "free", "tier", "limit", "load", "config", "section", "config", "section", "data", "get", "config", "sufficiency", "threshold", "config", "section", "get", "sufficiency", "threshold", "if", "not", "models", "models", "cls", "default", "models", "return", "cls", "models", "models", "embedding", "models", "embedding", "models", "reranking", "models", "reranking", "models", "sufficiency", "threshold", "sufficiency", "threshold", "except", "exception", "as", "print", "warning", "failed", "to", "load", "config", "from", "path", "return", "cls", "default"], "metadata": {"kind": "method", "chunk_index": "2", "has_docstring": "true", "last_modified": "1768294084.915553"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/service.py::module::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/service.py::module", "content": "\"\"\"Service layer for KnowCode business logic.\"\"\"", "tokens": ["service", "layer", "for", "know", "code", "business", "logic"], "metadata": {"type": "module_header"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/service.py::imports::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/service.py::module", "content": "from __future__ import annotations\nimport re\nfrom pathlib import Path\nfrom typing import Any, Optional, TYPE_CHECKING\nfrom knowcode.analysis.context_synthesizer import ContextSynthesizer\nfrom knowcode.config import AppConfig\nfrom knowcode.indexing.graph_builder import GraphBuilder\nfrom knowcode.storage.knowledge_store import KnowledgeStore\n    from knowcode.data_models import TaskType\n    from knowcode.indexing.indexer import Indexer\n    from knowcode.retrieval.search_engine import SearchEngine\n            from knowcode.llm.embedding import create_embedding_provider\n            from knowcode.indexing.indexer import Indexer\n            from knowcode.retrieval.hybrid_index import HybridIndex\n            from knowcode.retrieval.search_engine import SearchEngine\n        from knowcode.llm.query_classifier import classify_query\n        from knowcode.llm.embedding import create_embedding_provider\n        from knowcode.indexing.indexer import Indexer\n        from dataclasses import asdict", "tokens": ["from", "future", "import", "annotations", "import", "re", "from", "pathlib", "import", "path", "from", "typing", "import", "any", "optional", "type", "checking", "from", "knowcode", "analysis", "context", "synthesizer", "import", "context", "synthesizer", "from", "knowcode", "config", "import", "app", "config", "from", "knowcode", "indexing", "graph", "builder", "import", "graph", "builder", "from", "knowcode", "storage", "knowledge", "store", "import", "knowledge", "store", "from", "knowcode", "data", "models", "import", "task", "type", "from", "knowcode", "indexing", "indexer", "import", "indexer", "from", "knowcode", "retrieval", "search", "engine", "import", "search", "engine", "from", "knowcode", "llm", "embedding", "import", "create", "embedding", "provider", "from", "knowcode", "indexing", "indexer", "import", "indexer", "from", "knowcode", "retrieval", "hybrid", "index", "import", "hybrid", "index", "from", "knowcode", "retrieval", "search", "engine", "import", "search", "engine", "from", "knowcode", "llm", "query", "classifier", "import", "classify", "query", "from", "knowcode", "llm", "embedding", "import", "create", "embedding", "provider", "from", "knowcode", "indexing", "indexer", "import", "indexer", "from", "dataclasses", "import", "asdict"], "metadata": {"type": "imports"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/service.py::KnowCodeService::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/service.py::KnowCodeService", "content": "\"\"\"Service to handle core KnowCode operations.\"\"\"\nclass KnowCodeService:\n    \"\"\"Service to handle core KnowCode operations.\"\"\"\n\n    def __init__(\n        self,\n        store_path: str | Path = \".\",\n        config_path: Optional[str] = None,\n        app_config: Optional[AppConfig] = None,\n    ) -> None:\n        \"\"\"Initialize service.\n\n        Args:\n            store_path: Path to load the knowledge store from.\n            config_path: Optional config file path (aimodels.yaml).\n            app_config: Optional pre-loaded AppConfig.\n        \"\"\"\n        self.store_path = Path(store_path)\n        self.app_config = app_config or AppConfig.load(config_path)\n        self._store: Optional[KnowledgeStore] = None\n        self._search_engine: Optional[\"SearchEngine\"] = None\n        self._indexer: Optional[\"Indexer\"] = None\n\n    @property\n    def store(self) -> KnowledgeStore:\n        \"\"\"Get or load the knowledge store.\"\"\"\n        if self._store is None:\n            self._store = KnowledgeStore.loa", "tokens": ["service", "to", "handle", "core", "know", "code", "operations", "class", "know", "code", "service", "service", "to", "handle", "core", "know", "code", "operations", "def", "init", "self", "store", "path", "str", "path", "config", "path", "optional", "str", "none", "app", "config", "optional", "app", "config", "none", "none", "initialize", "service", "args", "store", "path", "path", "to", "load", "the", "knowledge", "store", "from", "config", "path", "optional", "config", "file", "path", "aimodels", "yaml", "app", "config", "optional", "pre", "loaded", "app", "config", "self", "store", "path", "path", "store", "path", "self", "app", "config", "app", "config", "or", "app", "config", "load", "config", "path", "self", "store", "optional", "knowledge", "store", "none", "self", "search", "engine", "optional", "search", "engine", "none", "self", "indexer", "optional", "indexer", "none", "property", "def", "store", "self", "knowledge", "store", "get", "or", "load", "the", "knowledge", "store", "if", "self", "store", "is", "none", "self", "store", "knowledge", "store", "loa"], "metadata": {"kind": "class", "chunk_index": "0", "has_docstring": "true", "last_modified": "1768240645.0484078"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/service.py::KnowCodeService::1", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/service.py::KnowCodeService", "content": "the knowledge store.\"\"\"\n        if self._store is None:\n            self._store = KnowledgeStore.load(self.store_path)\n        return self._store\n\n    def get_indexer(self, index_path: Optional[str | Path] = None) -> \"Indexer\":\n        \"\"\"Get or create the indexer.\n\n        Args:\n            index_path: Optional path to load an existing index from.\n\n        Returns:\n            Initialized Indexer instance.\n        \"\"\"\n        if self._indexer is None:\n            from knowcode.llm.embedding import create_embedding_provider\n            from knowcode.indexing.indexer import Indexer\n            \n            provider = create_embedding_provider(app_config=self.app_config)\n            self._indexer = Indexer(provider)\n            \n            if index_path:\n                self._indexer.load(Path(index_path))\n            else:\n                store_root = self.store_path if self.store_path.is_dir() else self.store_path.parent\n                default_index = store_root / \"knowcode_index\"\n  ", "tokens": ["the", "knowledge", "store", "if", "self", "store", "is", "none", "self", "store", "knowledge", "store", "load", "self", "store", "path", "return", "self", "store", "def", "get", "indexer", "self", "index", "path", "optional", "str", "path", "none", "indexer", "get", "or", "create", "the", "indexer", "args", "index", "path", "optional", "path", "to", "load", "an", "existing", "index", "from", "returns", "initialized", "indexer", "instance", "if", "self", "indexer", "is", "none", "from", "knowcode", "llm", "embedding", "import", "create", "embedding", "provider", "from", "knowcode", "indexing", "indexer", "import", "indexer", "provider", "create", "embedding", "provider", "app", "config", "self", "app", "config", "self", "indexer", "indexer", "provider", "if", "index", "path", "self", "indexer", "load", "path", "index", "path", "else", "store", "root", "self", "store", "path", "if", "self", "store", "path", "is", "dir", "else", "self", "store", "path", "parent", "default", "index", "store", "root", "knowcode", "index"], "metadata": {"kind": "class", "chunk_index": "1", "has_docstring": "true", "last_modified": "1768240645.0484078"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/service.py::KnowCodeService::2", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/service.py::KnowCodeService", "content": "s_dir() else self.store_path.parent\n                default_index = store_root / \"knowcode_index\"\n                if default_index.exists():\n                    self._indexer.load(default_index)\n                \n        return self._indexer\n\n    def get_search_engine(self, index_path: Optional[str | Path] = None) -> \"SearchEngine\":\n        \"\"\"Get or create the search engine.\n\n        Args:\n            index_path: Optional path to load an existing index from.\n\n        Returns:\n            SearchEngine wired to the current knowledge store.\n        \"\"\"\n        if self._search_engine is None:\n            from knowcode.retrieval.hybrid_index import HybridIndex\n            from knowcode.retrieval.search_engine import SearchEngine\n            \n            indexer = self.get_indexer(index_path)\n            hybrid_index = HybridIndex(indexer.chunk_repo, indexer.vector_store)\n            \n            self._search_engine = SearchEngine(\n                indexer.chunk_repo, \n                indexer", "tokens": ["dir", "else", "self", "store", "path", "parent", "default", "index", "store", "root", "knowcode", "index", "if", "default", "index", "exists", "self", "indexer", "load", "default", "index", "return", "self", "indexer", "def", "get", "search", "engine", "self", "index", "path", "optional", "str", "path", "none", "search", "engine", "get", "or", "create", "the", "search", "engine", "args", "index", "path", "optional", "path", "to", "load", "an", "existing", "index", "from", "returns", "search", "engine", "wired", "to", "the", "current", "knowledge", "store", "if", "self", "search", "engine", "is", "none", "from", "knowcode", "retrieval", "hybrid", "index", "import", "hybrid", "index", "from", "knowcode", "retrieval", "search", "engine", "import", "search", "engine", "indexer", "self", "get", "indexer", "index", "path", "hybrid", "index", "hybrid", "index", "indexer", "chunk", "repo", "indexer", "vector", "store", "self", "search", "engine", "search", "engine", "indexer", "chunk", "repo", "indexer"], "metadata": {"kind": "class", "chunk_index": "2", "has_docstring": "true", "last_modified": "1768240645.0484078"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/service.py::KnowCodeService::3", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/service.py::KnowCodeService", "content": "    self._search_engine = SearchEngine(\n                indexer.chunk_repo, \n                indexer.embedding_provider, \n                hybrid_index, \n                self.store,\n                config=self.app_config,\n            )\n        return self._search_engine\n\n    def retrieve_context_for_query(\n        self,\n        query: str,\n        max_tokens: int = 6000,\n        task_type: Optional[\"TaskType\"] = None,\n        limit_entities: int = 3,\n        per_entity_max_tokens: Optional[int] = None,\n        expand_deps: bool = True,\n    ) -> dict[str, Any]:\n        \"\"\"Retrieve an evidence-backed context bundle for a natural-language query.\n\n        This is the unified retrieval entrypoint that both CLI Q&A and MCP tools\n        should use to ensure consistent retrieval quality.\n\n        Args:\n            query: Natural-language query.\n            max_tokens: Overall token budget across all returned entity bundles.\n            task_type: Optional task type override; if omitted, query ", "tokens": ["self", "search", "engine", "search", "engine", "indexer", "chunk", "repo", "indexer", "embedding", "provider", "hybrid", "index", "self", "store", "config", "self", "app", "config", "return", "self", "search", "engine", "def", "retrieve", "context", "for", "query", "self", "query", "str", "max", "tokens", "int", "6000", "task", "type", "optional", "task", "type", "none", "limit", "entities", "int", "per", "entity", "max", "tokens", "optional", "int", "none", "expand", "deps", "bool", "true", "dict", "str", "any", "retrieve", "an", "evidence", "backed", "context", "bundle", "for", "natural", "language", "query", "this", "is", "the", "unified", "retrieval", "entrypoint", "that", "both", "cli", "and", "mcp", "tools", "should", "use", "to", "ensure", "consistent", "retrieval", "quality", "args", "query", "natural", "language", "query", "max", "tokens", "overall", "token", "budget", "across", "all", "returned", "entity", "bundles", "task", "type", "optional", "task", "type", "override", "if", "omitted", "query"], "metadata": {"kind": "class", "chunk_index": "3", "has_docstring": "true", "last_modified": "1768240645.0484078"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/service.py::KnowCodeService::4", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/service.py::KnowCodeService", "content": " all returned entity bundles.\n            task_type: Optional task type override; if omitted, query is classified.\n            limit_entities: Maximum number of unique entities to include.\n            per_entity_max_tokens: Optional per-entity token budget; defaults to an even split.\n            expand_deps: Whether to expand dependency context during retrieval.\n\n        Returns:\n            Dictionary with context_text, sufficiency_score, evidence, and metadata.\n        \"\"\"\n        from knowcode.llm.query_classifier import classify_query\n\n        errors: list[str] = []\n        store_root = self.store_path if self.store_path.is_dir() else self.store_path.parent\n        store_file = store_root / KnowledgeStore.DEFAULT_FILENAME\n        index_path = store_root / \"knowcode_index\"\n\n        if not store_file.exists():\n            try:\n                self.analyze(directory=store_root, output=store_root)\n            except Exception as e:\n                return {\n                    \"query\": ", "tokens": ["all", "returned", "entity", "bundles", "task", "type", "optional", "task", "type", "override", "if", "omitted", "query", "is", "classified", "limit", "entities", "maximum", "number", "of", "unique", "entities", "to", "include", "per", "entity", "max", "tokens", "optional", "per", "entity", "token", "budget", "defaults", "to", "an", "even", "split", "expand", "deps", "whether", "to", "expand", "dependency", "context", "during", "retrieval", "returns", "dictionary", "with", "context", "text", "sufficiency", "score", "evidence", "and", "metadata", "from", "knowcode", "llm", "query", "classifier", "import", "classify", "query", "errors", "list", "str", "store", "root", "self", "store", "path", "if", "self", "store", "path", "is", "dir", "else", "self", "store", "path", "parent", "store", "file", "store", "root", "knowledge", "store", "default", "filename", "index", "path", "store", "root", "knowcode", "index", "if", "not", "store", "file", "exists", "try", "self", "analyze", "directory", "store", "root", "output", "store", "root", "except", "exception", "as", "return", "query"], "metadata": {"kind": "class", "chunk_index": "4", "has_docstring": "true", "last_modified": "1768240645.0484078"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/service.py::KnowCodeService::5", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/service.py::KnowCodeService", "content": "tore_root)\n            except Exception as e:\n                return {\n                    \"query\": query,\n                    \"task_type\": task_type.value if task_type else \"general\",\n                    \"task_confidence\": 0.0,\n                    \"retrieval_mode\": \"none\",\n                    \"context_text\": \"\",\n                    \"total_tokens\": 0,\n                    \"max_tokens\": max_tokens,\n                    \"truncated\": False,\n                    \"sufficiency_score\": 0.0,\n                    \"selected_entities\": [],\n                    \"evidence\": [],\n                    \"errors\": [f\"Auto-analyze failed: {e}\"],\n                }\n\n        if not index_path.exists():\n            try:\n                self._build_index(store_root, index_path)\n            except Exception as e:\n                errors.append(f\"Auto-index failed; falling back to lexical: {e}\")\n\n        detected_task_type, confidence = classify_query(query)\n        resolved_task_type = task_type or detected_task_type\n", "tokens": ["tore", "root", "except", "exception", "as", "return", "query", "query", "task", "type", "task", "type", "value", "if", "task", "type", "else", "general", "task", "confidence", "retrieval", "mode", "none", "context", "text", "total", "tokens", "max", "tokens", "max", "tokens", "truncated", "false", "sufficiency", "score", "selected", "entities", "evidence", "errors", "auto", "analyze", "failed", "if", "not", "index", "path", "exists", "try", "self", "build", "index", "store", "root", "index", "path", "except", "exception", "as", "errors", "append", "auto", "index", "failed", "falling", "back", "to", "lexical", "detected", "task", "type", "confidence", "classify", "query", "query", "resolved", "task", "type", "task", "type", "or", "detected", "task", "type"], "metadata": {"kind": "class", "chunk_index": "5", "has_docstring": "true", "last_modified": "1768240645.0484078"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/service.py::KnowCodeService::6", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/service.py::KnowCodeService", "content": "pe, confidence = classify_query(query)\n        resolved_task_type = task_type or detected_task_type\n        task_confidence = 1.0 if task_type is not None else confidence\n\n        if limit_entities <= 0 or max_tokens <= 0:\n            return {\n                \"query\": query,\n                \"task_type\": resolved_task_type.value,\n                \"task_confidence\": task_confidence,\n                \"retrieval_mode\": \"none\",\n                \"context_text\": \"\",\n                \"total_tokens\": 0,\n                \"max_tokens\": max_tokens,\n                \"truncated\": False,\n                \"sufficiency_score\": 0.0,\n                \"selected_entities\": [],\n                \"evidence\": [],\n                \"errors\": [\"Invalid token or entity limits.\"],\n            }\n\n        if per_entity_max_tokens is None:\n            per_entity_max_tokens = max(200, min(2000, max_tokens // limit_entities))\n\n        selected_entity_ids: list[str] = []\n        evidence: list[dict[str, Any]] = []\n        retrieva", "tokens": ["pe", "confidence", "classify", "query", "query", "resolved", "task", "type", "task", "type", "or", "detected", "task", "type", "task", "confidence", "if", "task", "type", "is", "not", "none", "else", "confidence", "if", "limit", "entities", "or", "max", "tokens", "return", "query", "query", "task", "type", "resolved", "task", "type", "value", "task", "confidence", "task", "confidence", "retrieval", "mode", "none", "context", "text", "total", "tokens", "max", "tokens", "max", "tokens", "truncated", "false", "sufficiency", "score", "selected", "entities", "evidence", "errors", "invalid", "token", "or", "entity", "limits", "if", "per", "entity", "max", "tokens", "is", "none", "per", "entity", "max", "tokens", "max", "200", "min", "2000", "max", "tokens", "limit", "entities", "selected", "entity", "ids", "list", "str", "evidence", "list", "dict", "str", "any", "retrieva"], "metadata": {"kind": "class", "chunk_index": "6", "has_docstring": "true", "last_modified": "1768240645.0484078"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/service.py::KnowCodeService::7", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/service.py::KnowCodeService", "content": "    selected_entity_ids: list[str] = []\n        evidence: list[dict[str, Any]] = []\n        retrieval_mode = \"lexical\"\n\n        if index_path.exists():\n            try:\n                engine = self.get_search_engine()\n                self._validate_index_compatibility(index_path)\n                scored = engine.search_scored(\n                    query,\n                    limit=max(10, limit_entities * 5),\n                    expand_deps=expand_deps,\n                )\n                retrieval_mode = \"semantic\"\n\n                primary = [s for s in scored if s.source == \"retrieved\"]\n                seen_entities: set[str] = set()\n                for s in primary:\n                    if s.chunk.entity_id in seen_entities:\n                        continue\n                    seen_entities.add(s.chunk.entity_id)\n                    selected_entity_ids.append(s.chunk.entity_id)\n                    if len(selected_entity_ids) >= limit_entities:\n                        break\n\n             ", "tokens": ["selected", "entity", "ids", "list", "str", "evidence", "list", "dict", "str", "any", "retrieval", "mode", "lexical", "if", "index", "path", "exists", "try", "engine", "self", "get", "search", "engine", "self", "validate", "index", "compatibility", "index", "path", "scored", "engine", "search", "scored", "query", "limit", "max", "10", "limit", "entities", "expand", "deps", "expand", "deps", "retrieval", "mode", "semantic", "primary", "for", "in", "scored", "if", "source", "retrieved", "seen", "entities", "set", "str", "set", "for", "in", "primary", "if", "chunk", "entity", "id", "in", "seen", "entities", "continue", "seen", "entities", "add", "chunk", "entity", "id", "selected", "entity", "ids", "append", "chunk", "entity", "id", "if", "len", "selected", "entity", "ids", "limit", "entities", "break"], "metadata": {"kind": "class", "chunk_index": "7", "has_docstring": "true", "last_modified": "1768240645.0484078"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/service.py::KnowCodeService::8", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/service.py::KnowCodeService", "content": "         if len(selected_entity_ids) >= limit_entities:\n                        break\n\n                for rank, s in enumerate(scored, start=1):\n                    evidence.append(\n                        {\n                            \"rank\": rank,\n                            \"chunk_id\": s.chunk.id,\n                            \"entity_id\": s.chunk.entity_id,\n                            \"score\": s.score,\n                            \"source\": s.source,\n                        }\n                    )\n\n            except Exception as e:\n                errors.append(f\"Semantic retrieval failed; falling back to lexical: {e}\")\n                retrieval_mode = \"lexical\"\n\n        if retrieval_mode == \"lexical\":\n            candidates: list[str] = []\n            seen: set[str] = set()\n\n            def add_entity_ids(items: list[dict[str, Any]]) -> None:\n                for item in items:\n                    entity_id = item.get(\"id\")\n                    if not entity_id or entity_id in seen:\n", "tokens": ["if", "len", "selected", "entity", "ids", "limit", "entities", "break", "for", "rank", "in", "enumerate", "scored", "start", "evidence", "append", "rank", "rank", "chunk", "id", "chunk", "id", "entity", "id", "chunk", "entity", "id", "score", "score", "source", "source", "except", "exception", "as", "errors", "append", "semantic", "retrieval", "failed", "falling", "back", "to", "lexical", "retrieval", "mode", "lexical", "if", "retrieval", "mode", "lexical", "candidates", "list", "str", "seen", "set", "str", "set", "def", "add", "entity", "ids", "items", "list", "dict", "str", "any", "none", "for", "item", "in", "items", "entity", "id", "item", "get", "id", "if", "not", "entity", "id", "or", "entity", "id", "in", "seen"], "metadata": {"kind": "class", "chunk_index": "8", "has_docstring": "true", "last_modified": "1768240645.0484078"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/service.py::KnowCodeService::9", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/service.py::KnowCodeService", "content": "              entity_id = item.get(\"id\")\n                    if not entity_id or entity_id in seen:\n                        continue\n                    seen.add(entity_id)\n                    candidates.append(entity_id)\n\n            add_entity_ids(self.search(query))\n            if len(candidates) < limit_entities:\n                for kw in self._extract_query_keywords(query):\n                    add_entity_ids(self.search(kw))\n                    if len(candidates) >= limit_entities:\n                        break\n\n            selected_entity_ids = candidates[:limit_entities]\n            for rank, entity_id in enumerate(selected_entity_ids, start=1):\n                evidence.append({\"rank\": rank, \"entity_id\": entity_id, \"source\": \"lexical\"})\n\n        selected_entities: list[dict[str, Any]] = []\n        context_parts: list[str] = []\n        sufficiency_scores: list[float] = []\n        total_tokens = 0\n        truncated = False\n\n        for entity_id in selected_entity_ids:\n           ", "tokens": ["entity", "id", "item", "get", "id", "if", "not", "entity", "id", "or", "entity", "id", "in", "seen", "continue", "seen", "add", "entity", "id", "candidates", "append", "entity", "id", "add", "entity", "ids", "self", "search", "query", "if", "len", "candidates", "limit", "entities", "for", "kw", "in", "self", "extract", "query", "keywords", "query", "add", "entity", "ids", "self", "search", "kw", "if", "len", "candidates", "limit", "entities", "break", "selected", "entity", "ids", "candidates", "limit", "entities", "for", "rank", "entity", "id", "in", "enumerate", "selected", "entity", "ids", "start", "evidence", "append", "rank", "rank", "entity", "id", "entity", "id", "source", "lexical", "selected", "entities", "list", "dict", "str", "any", "context", "parts", "list", "str", "sufficiency", "scores", "list", "float", "total", "tokens", "truncated", "false", "for", "entity", "id", "in", "selected", "entity", "ids"], "metadata": {"kind": "class", "chunk_index": "9", "has_docstring": "true", "last_modified": "1768240645.0484078"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/service.py::KnowCodeService::10", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/service.py::KnowCodeService", "content": "otal_tokens = 0\n        truncated = False\n\n        for entity_id in selected_entity_ids:\n            try:\n                bundle = self.get_context(\n                    entity_id,\n                    max_tokens=per_entity_max_tokens,\n                    task_type=resolved_task_type,\n                )\n            except Exception as e:\n                errors.append(f\"Failed to synthesize context for {entity_id}: {e}\")\n                continue\n\n            context_parts.append(bundle.get(\"context_text\", \"\"))\n            total_tokens += int(bundle.get(\"total_tokens\", 0))\n            truncated = truncated or bool(bundle.get(\"truncated\", False))\n\n            s = bundle.get(\"sufficiency_score\")\n            if isinstance(s, (int, float)):\n                sufficiency_scores.append(float(s))\n\n            selected_entities.append(\n                {\n                    \"entity_id\": bundle.get(\"entity_id\", entity_id),\n                    \"task_type\": bundle.get(\"task_type\", resolved_task_type.valu", "tokens": ["otal", "tokens", "truncated", "false", "for", "entity", "id", "in", "selected", "entity", "ids", "try", "bundle", "self", "get", "context", "entity", "id", "max", "tokens", "per", "entity", "max", "tokens", "task", "type", "resolved", "task", "type", "except", "exception", "as", "errors", "append", "failed", "to", "synthesize", "context", "for", "entity", "id", "continue", "context", "parts", "append", "bundle", "get", "context", "text", "total", "tokens", "int", "bundle", "get", "total", "tokens", "truncated", "truncated", "or", "bool", "bundle", "get", "truncated", "false", "bundle", "get", "sufficiency", "score", "if", "isinstance", "int", "float", "sufficiency", "scores", "append", "float", "selected", "entities", "append", "entity", "id", "bundle", "get", "entity", "id", "entity", "id", "task", "type", "bundle", "get", "task", "type", "resolved", "task", "type", "valu"], "metadata": {"kind": "class", "chunk_index": "10", "has_docstring": "true", "last_modified": "1768240645.0484078"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/service.py::KnowCodeService::11", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/service.py::KnowCodeService", "content": "ty_id\", entity_id),\n                    \"task_type\": bundle.get(\"task_type\", resolved_task_type.value),\n                    \"total_tokens\": bundle.get(\"total_tokens\", 0),\n                    \"truncated\": bundle.get(\"truncated\", False),\n                    \"sufficiency_score\": bundle.get(\"sufficiency_score\", 0.0),\n                }\n            )\n\n        context_text = \"\\n\\n---\\n\\n\".join([p for p in context_parts if p])\n        sufficiency = (\n            round(sum(sufficiency_scores) / len(sufficiency_scores), 2)\n            if sufficiency_scores\n            else 0.0\n        )\n\n        return {\n            \"query\": query,\n            \"task_type\": resolved_task_type.value,\n            \"task_confidence\": task_confidence,\n            \"retrieval_mode\": retrieval_mode,\n            \"context_text\": context_text,\n            \"total_tokens\": total_tokens,\n            \"max_tokens\": max_tokens,\n            \"truncated\": truncated,\n            \"sufficiency_score\": sufficiency,\n            \"selected", "tokens": ["ty", "id", "entity", "id", "task", "type", "bundle", "get", "task", "type", "resolved", "task", "type", "value", "total", "tokens", "bundle", "get", "total", "tokens", "truncated", "bundle", "get", "truncated", "false", "sufficiency", "score", "bundle", "get", "sufficiency", "score", "context", "text", "join", "for", "in", "context", "parts", "if", "sufficiency", "round", "sum", "sufficiency", "scores", "len", "sufficiency", "scores", "if", "sufficiency", "scores", "else", "return", "query", "query", "task", "type", "resolved", "task", "type", "value", "task", "confidence", "task", "confidence", "retrieval", "mode", "retrieval", "mode", "context", "text", "context", "text", "total", "tokens", "total", "tokens", "max", "tokens", "max", "tokens", "truncated", "truncated", "sufficiency", "score", "sufficiency", "selected"], "metadata": {"kind": "class", "chunk_index": "11", "has_docstring": "true", "last_modified": "1768240645.0484078"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/service.py::KnowCodeService::12", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/service.py::KnowCodeService", "content": "         \"truncated\": truncated,\n            \"sufficiency_score\": sufficiency,\n            \"selected_entities\": selected_entities,\n            \"evidence\": evidence,\n            \"errors\": errors,\n        }\n\n    def _build_index(self, directory: str | Path, index_path: str | Path) -> int:\n        \"\"\"Build a semantic index for a directory and persist it.\"\"\"\n        from knowcode.llm.embedding import create_embedding_provider\n        from knowcode.indexing.indexer import Indexer\n\n        provider = create_embedding_provider(app_config=self.app_config)\n        indexer = Indexer(provider)\n        count = indexer.index_directory(directory)\n        indexer.save(index_path)\n        self._indexer = indexer\n        return count\n\n    def _extract_query_keywords(self, query: str) -> list[str]:\n        \"\"\"Extract identifier-like keywords from a natural-language query.\"\"\"\n        stopwords = {\n            \"how\",\n            \"what\",\n            \"where\",\n            \"when\",\n            \"why\",\n         ", "tokens": ["truncated", "truncated", "sufficiency", "score", "sufficiency", "selected", "entities", "selected", "entities", "evidence", "evidence", "errors", "errors", "def", "build", "index", "self", "directory", "str", "path", "index", "path", "str", "path", "int", "build", "semantic", "index", "for", "directory", "and", "persist", "it", "from", "knowcode", "llm", "embedding", "import", "create", "embedding", "provider", "from", "knowcode", "indexing", "indexer", "import", "indexer", "provider", "create", "embedding", "provider", "app", "config", "self", "app", "config", "indexer", "indexer", "provider", "count", "indexer", "index", "directory", "directory", "indexer", "save", "index", "path", "self", "indexer", "indexer", "return", "count", "def", "extract", "query", "keywords", "self", "query", "str", "list", "str", "extract", "identifier", "like", "keywords", "from", "natural", "language", "query", "stopwords", "how", "what", "where", "when", "why"], "metadata": {"kind": "class", "chunk_index": "12", "has_docstring": "true", "last_modified": "1768240645.0484078"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/service.py::KnowCodeService::13", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/service.py::KnowCodeService", "content": "    \"how\",\n            \"what\",\n            \"where\",\n            \"when\",\n            \"why\",\n            \"who\",\n            \"does\",\n            \"did\",\n            \"is\",\n            \"are\",\n            \"can\",\n            \"will\",\n            \"the\",\n            \"a\",\n            \"an\",\n            \"in\",\n            \"on\",\n            \"at\",\n            \"for\",\n            \"to\",\n            \"of\",\n            \"and\",\n            \"or\",\n        }\n        tokens = re.findall(r\"\\b[a-zA-Z_][a-zA-Z0-9_.]+\\b\", query)\n        keywords = [\n            t\n            for t in tokens\n            if len(t) > 3 and t.lower() not in stopwords\n        ]\n        return keywords[:10]\n\n    def _validate_index_compatibility(self, index_path: Path) -> None:\n        \"\"\"Validate the loaded index against the current embedding configuration.\n\n        Raises:\n            ValueError: If the index manifest indicates an incompatible embedding model.\n        \"\"\"\n        indexer = self.get_indexer(index_path=index_path)\n\n        ", "tokens": ["how", "what", "where", "when", "why", "who", "does", "did", "is", "are", "can", "will", "the", "an", "in", "on", "at", "for", "to", "of", "and", "or", "tokens", "re", "findall", "z0", "query", "keywords", "for", "in", "tokens", "if", "len", "and", "lower", "not", "in", "stopwords", "return", "keywords", "10", "def", "validate", "index", "compatibility", "self", "index", "path", "path", "none", "validate", "the", "loaded", "index", "against", "the", "current", "embedding", "configuration", "raises", "value", "error", "if", "the", "index", "manifest", "indicates", "an", "incompatible", "embedding", "model", "indexer", "self", "get", "indexer", "index", "path", "index", "path"], "metadata": {"kind": "class", "chunk_index": "13", "has_docstring": "true", "last_modified": "1768240645.0484078"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/service.py::KnowCodeService::14", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/service.py::KnowCodeService", "content": "ble embedding model.\n        \"\"\"\n        indexer = self.get_indexer(index_path=index_path)\n\n        # Always enforce dimension compatibility to prevent runtime FAISS errors.\n        expected_dim = int(getattr(indexer.embedding_provider.config, \"dimension\", 0))\n        actual_dim = int(getattr(indexer.vector_store, \"dimension\", 0))\n        if expected_dim and actual_dim and expected_dim != actual_dim:\n            raise ValueError(\n                \"Embedding dimension mismatch between configured embedding model \"\n                f\"({expected_dim}) and loaded index ({actual_dim}). Rebuild the \"\n                \"semantic index with `knowcode index` using the same embedding model.\"\n            )\n\n        manifest = getattr(indexer, \"manifest\", {}) or {}\n        embedding_meta = manifest.get(\"embedding\")\n        if not isinstance(embedding_meta, dict):\n            return\n\n        mismatches: list[str] = []\n        current = indexer.embedding_provider.config\n\n        for key in (\"provider\", \"", "tokens": ["ble", "embedding", "model", "indexer", "self", "get", "indexer", "index", "path", "index", "path", "always", "enforce", "dimension", "compatibility", "to", "prevent", "runtime", "faiss", "errors", "expected", "dim", "int", "getattr", "indexer", "embedding", "provider", "config", "dimension", "actual", "dim", "int", "getattr", "indexer", "vector", "store", "dimension", "if", "expected", "dim", "and", "actual", "dim", "and", "expected", "dim", "actual", "dim", "raise", "value", "error", "embedding", "dimension", "mismatch", "between", "configured", "embedding", "model", "expected", "dim", "and", "loaded", "index", "actual", "dim", "rebuild", "the", "semantic", "index", "with", "knowcode", "index", "using", "the", "same", "embedding", "model", "manifest", "getattr", "indexer", "manifest", "or", "embedding", "meta", "manifest", "get", "embedding", "if", "not", "isinstance", "embedding", "meta", "dict", "return", "mismatches", "list", "str", "current", "indexer", "embedding", "provider", "config", "for", "key", "in", "provider"], "metadata": {"kind": "class", "chunk_index": "14", "has_docstring": "true", "last_modified": "1768240645.0484078"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/service.py::KnowCodeService::15", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/service.py::KnowCodeService", "content": "ist[str] = []\n        current = indexer.embedding_provider.config\n\n        for key in (\"provider\", \"model_name\", \"dimension\", \"normalize\"):\n            if key not in embedding_meta:\n                continue\n            recorded = embedding_meta.get(key)\n            current_val = getattr(current, key, None)\n            if recorded != current_val:\n                mismatches.append(f\"{key}: index={recorded!r} current={current_val!r}\")\n\n        if mismatches:\n            details = \"; \".join(mismatches)\n            raise ValueError(\n                \"Index embedding configuration mismatch. \"\n                f\"{details}. Rebuild the semantic index with `knowcode index` \"\n                \"using the same embedding model and settings.\"\n            )\n\n    def analyze(\n        self,\n        directory: str | Path,\n        output: str | Path,\n        ignore: list[str] = None,\n        temporal: bool = False,\n        coverage: str | Path = None,\n    ) -> dict[str, Any]:\n        \"\"\"Analyze a codebase a", "tokens": ["ist", "str", "current", "indexer", "embedding", "provider", "config", "for", "key", "in", "provider", "model", "name", "dimension", "normalize", "if", "key", "not", "in", "embedding", "meta", "continue", "recorded", "embedding", "meta", "get", "key", "current", "val", "getattr", "current", "key", "none", "if", "recorded", "current", "val", "mismatches", "append", "key", "index", "recorded", "current", "current", "val", "if", "mismatches", "details", "join", "mismatches", "raise", "value", "error", "index", "embedding", "configuration", "mismatch", "details", "rebuild", "the", "semantic", "index", "with", "knowcode", "index", "using", "the", "same", "embedding", "model", "and", "settings", "def", "analyze", "self", "directory", "str", "path", "output", "str", "path", "ignore", "list", "str", "none", "temporal", "bool", "false", "coverage", "str", "path", "none", "dict", "str", "any", "analyze", "codebase"], "metadata": {"kind": "class", "chunk_index": "15", "has_docstring": "true", "last_modified": "1768240645.0484078"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/service.py::KnowCodeService::16", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/service.py::KnowCodeService", "content": "False,\n        coverage: str | Path = None,\n    ) -> dict[str, Any]:\n        \"\"\"Analyze a codebase and persist the resulting knowledge store.\n\n        Args:\n            directory: Root directory to scan and parse.\n            output: Destination path for the knowledge store JSON.\n            ignore: Additional ignore patterns.\n            temporal: Whether to include git history analysis.\n            coverage: Optional Cobertura coverage report path.\n\n        Returns:\n            Statistics from the graph builder.\n        \"\"\"\n        builder = GraphBuilder()\n        builder.build_from_directory(\n            root_dir=directory,\n            additional_ignores=ignore,\n            analyze_temporal=temporal,\n            coverage_path=Path(coverage) if coverage else None,\n        )\n\n        store = KnowledgeStore.from_graph_builder(builder)\n        output_path = Path(output)\n        store.save(output_path)\n        self._store = store\n\n        store_root = output_path if output_path.is_dir() ", "tokens": ["false", "coverage", "str", "path", "none", "dict", "str", "any", "analyze", "codebase", "and", "persist", "the", "resulting", "knowledge", "store", "args", "directory", "root", "directory", "to", "scan", "and", "parse", "output", "destination", "path", "for", "the", "knowledge", "store", "json", "ignore", "additional", "ignore", "patterns", "temporal", "whether", "to", "include", "git", "history", "analysis", "coverage", "optional", "cobertura", "coverage", "report", "path", "returns", "statistics", "from", "the", "graph", "builder", "builder", "graph", "builder", "builder", "build", "from", "directory", "root", "dir", "directory", "additional", "ignores", "ignore", "analyze", "temporal", "temporal", "coverage", "path", "path", "coverage", "if", "coverage", "else", "none", "store", "knowledge", "store", "from", "graph", "builder", "builder", "output", "path", "path", "output", "store", "save", "output", "path", "self", "store", "store", "store", "root", "output", "path", "if", "output", "path", "is", "dir"], "metadata": {"kind": "class", "chunk_index": "16", "has_docstring": "true", "last_modified": "1768240645.0484078"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/service.py::KnowCodeService::17", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/service.py::KnowCodeService", "content": "(output_path)\n        self._store = store\n\n        store_root = output_path if output_path.is_dir() else output_path.parent\n        index_path = store_root / \"knowcode_index\"\n        index_count = self._build_index(Path(directory), index_path)\n\n        stats = builder.stats()\n        stats[\"indexed_chunks\"] = index_count\n        stats[\"index_path\"] = str(index_path)\n        return stats\n\n    def search(self, pattern: str) -> list[dict[str, Any]]:\n        \"\"\"Search entities by pattern.\n\n        Args:\n            pattern: Substring match over names and qualified names.\n\n        Returns:\n            Lightweight entity metadata for display or API responses.\n        \"\"\"\n        entities = self.store.search(pattern)\n        return [\n            {\n                \"id\": e.id,\n                \"kind\": e.kind.value,\n                \"name\": e.name,\n                \"qualified_name\": e.qualified_name,\n                \"file\": e.location.file_path,\n                \"line\": e.location.line_start,\n      ", "tokens": ["output", "path", "self", "store", "store", "store", "root", "output", "path", "if", "output", "path", "is", "dir", "else", "output", "path", "parent", "index", "path", "store", "root", "knowcode", "index", "index", "count", "self", "build", "index", "path", "directory", "index", "path", "stats", "builder", "stats", "stats", "indexed", "chunks", "index", "count", "stats", "index", "path", "str", "index", "path", "return", "stats", "def", "search", "self", "pattern", "str", "list", "dict", "str", "any", "search", "entities", "by", "pattern", "args", "pattern", "substring", "match", "over", "names", "and", "qualified", "names", "returns", "lightweight", "entity", "metadata", "for", "display", "or", "api", "responses", "entities", "self", "store", "search", "pattern", "return", "id", "id", "kind", "kind", "value", "name", "name", "qualified", "name", "qualified", "name", "file", "location", "file", "path", "line", "location", "line", "start"], "metadata": {"kind": "class", "chunk_index": "17", "has_docstring": "true", "last_modified": "1768240645.0484078"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/service.py::KnowCodeService::18", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/service.py::KnowCodeService", "content": "\n                \"file\": e.location.file_path,\n                \"line\": e.location.line_start,\n            }\n            for e in entities\n        ]\n\n    def get_context(\n        self,\n        target: str,\n        max_tokens: int = 2000,\n        task_type: Optional[\"TaskType\"] = None,\n    ) -> dict[str, Any]:\n        \"\"\"Get a context bundle for an entity.\n\n        Args:\n            target: Entity ID or search pattern.\n            max_tokens: Maximum token budget for the context bundle.\n            task_type: Optional task type for context prioritization.\n\n        Returns:\n            Dictionary containing context text and metadata.\n\n        Raises:\n            ValueError: If no matching entity is found or context synthesis fails.\n        \"\"\"\n        # Try exact match first\n        entity = self.store.get_entity(target)\n        if not entity:\n            # Try search\n            matches = self.store.search(target)\n            if matches:\n                entity = matches[0]\n\n        if no", "tokens": ["file", "location", "file", "path", "line", "location", "line", "start", "for", "in", "entities", "def", "get", "context", "self", "target", "str", "max", "tokens", "int", "2000", "task", "type", "optional", "task", "type", "none", "dict", "str", "any", "get", "context", "bundle", "for", "an", "entity", "args", "target", "entity", "id", "or", "search", "pattern", "max", "tokens", "maximum", "token", "budget", "for", "the", "context", "bundle", "task", "type", "optional", "task", "type", "for", "context", "prioritization", "returns", "dictionary", "containing", "context", "text", "and", "metadata", "raises", "value", "error", "if", "no", "matching", "entity", "is", "found", "or", "context", "synthesis", "fails", "try", "exact", "match", "first", "entity", "self", "store", "get", "entity", "target", "if", "not", "entity", "try", "search", "matches", "self", "store", "search", "target", "if", "matches", "entity", "matches", "if", "no"], "metadata": {"kind": "class", "chunk_index": "18", "has_docstring": "true", "last_modified": "1768240645.0484078"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/service.py::KnowCodeService::19", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/service.py::KnowCodeService", "content": "self.store.search(target)\n            if matches:\n                entity = matches[0]\n\n        if not entity:\n            raise ValueError(f\"Entity not found: {target}\")\n\n        synthesizer = ContextSynthesizer(self.store, max_tokens=max_tokens)\n        \n        # Use task-specific synthesis if task_type provided\n        if task_type is not None:\n            bundle = synthesizer.synthesize_with_task(entity.id, task_type)\n        else:\n            bundle = synthesizer.synthesize(entity.id)\n        \n        if not bundle:\n             raise ValueError(f\"Failed to synthesize context for {entity.id}\")\n\n        result = {\n            \"entity_id\": bundle.target_entity.id,\n            \"context_text\": bundle.context_text,\n            \"total_tokens\": bundle.total_tokens,\n            \"truncated\": bundle.truncated,\n            \"included_entities\": bundle.included_entities,\n        }\n        \n        # Add task-specific fields if using task synthesis\n        if hasattr(bundle, 'task_type') and ha", "tokens": ["self", "store", "search", "target", "if", "matches", "entity", "matches", "if", "not", "entity", "raise", "value", "error", "entity", "not", "found", "target", "synthesizer", "context", "synthesizer", "self", "store", "max", "tokens", "max", "tokens", "use", "task", "specific", "synthesis", "if", "task", "type", "provided", "if", "task", "type", "is", "not", "none", "bundle", "synthesizer", "synthesize", "with", "task", "entity", "id", "task", "type", "else", "bundle", "synthesizer", "synthesize", "entity", "id", "if", "not", "bundle", "raise", "value", "error", "failed", "to", "synthesize", "context", "for", "entity", "id", "result", "entity", "id", "bundle", "target", "entity", "id", "context", "text", "bundle", "context", "text", "total", "tokens", "bundle", "total", "tokens", "truncated", "bundle", "truncated", "included", "entities", "bundle", "included", "entities", "add", "task", "specific", "fields", "if", "using", "task", "synthesis", "if", "hasattr", "bundle", "task", "type", "and", "ha"], "metadata": {"kind": "class", "chunk_index": "19", "has_docstring": "true", "last_modified": "1768240645.0484078"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/service.py::KnowCodeService::20", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/service.py::KnowCodeService", "content": "   # Add task-specific fields if using task synthesis\n        if hasattr(bundle, 'task_type') and hasattr(bundle, 'sufficiency_score'):\n            result[\"task_type\"] = bundle.task_type.value if bundle.task_type else \"general\"\n            result[\"sufficiency_score\"] = bundle.sufficiency_score\n        else:\n            result[\"task_type\"] = \"general\"\n            result[\"sufficiency_score\"] = 0.0\n            \n        return result\n\n    def get_stats(self) -> dict[str, Any]:\n        \"\"\"Get statistics from the current store.\n\n        Returns:\n            Aggregated counts of entities, relationships, and index state.\n        \"\"\"\n        # This is slightly different from builder.stats() as we might not have the builder\n        by_kind: dict[str, int] = {}\n        for entity in self.store.entities.values():\n            kind = entity.kind.value\n            by_kind[kind] = by_kind.get(kind, 0) + 1\n\n        rel_types: dict[str, int] = {}\n        for rel in self.store.relationships:\n            ", "tokens": ["add", "task", "specific", "fields", "if", "using", "task", "synthesis", "if", "hasattr", "bundle", "task", "type", "and", "hasattr", "bundle", "sufficiency", "score", "result", "task", "type", "bundle", "task", "type", "value", "if", "bundle", "task", "type", "else", "general", "result", "sufficiency", "score", "bundle", "sufficiency", "score", "else", "result", "task", "type", "general", "result", "sufficiency", "score", "return", "result", "def", "get", "stats", "self", "dict", "str", "any", "get", "statistics", "from", "the", "current", "store", "returns", "aggregated", "counts", "of", "entities", "relationships", "and", "index", "state", "this", "is", "slightly", "different", "from", "builder", "stats", "as", "we", "might", "not", "have", "the", "builder", "by", "kind", "dict", "str", "int", "for", "entity", "in", "self", "store", "entities", "values", "kind", "entity", "kind", "value", "by", "kind", "kind", "by", "kind", "get", "kind", "rel", "types", "dict", "str", "int", "for", "rel", "in", "self", "store", "relationships"], "metadata": {"kind": "class", "chunk_index": "20", "has_docstring": "true", "last_modified": "1768240645.0484078"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/service.py::KnowCodeService::21", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/service.py::KnowCodeService", "content": " 1\n\n        rel_types: dict[str, int] = {}\n        for rel in self.store.relationships:\n            kind = rel.kind.value\n            rel_types[kind] = rel_types.get(kind, 0) + 1\n\n        stats = {\n            \"total_entities\": len(self.store.entities),\n            \"entities_by_kind\": by_kind,\n            \"total_relationships\": len(self.store.relationships),\n            \"relationships_by_type\": rel_types,\n        }\n        \n        # Add index stats if indexer is loaded\n        if self._indexer:\n            stats[\"total_chunks\"] = len(self._indexer.chunk_repo._chunks)\n            if hasattr(self._indexer.vector_store, \"index\") and self._indexer.vector_store.index:\n                stats[\"vector_index_size\"] = self._indexer.vector_store.index.ntotal\n                \n        return stats\n\n    def get_callers(self, entity_id: str) -> list[dict[str, Any]]:\n        \"\"\"Get callers of an entity.\n\n        Args:\n            entity_id: Entity ID to look up.\n\n        Returns:\n            Caller me", "tokens": ["rel", "types", "dict", "str", "int", "for", "rel", "in", "self", "store", "relationships", "kind", "rel", "kind", "value", "rel", "types", "kind", "rel", "types", "get", "kind", "stats", "total", "entities", "len", "self", "store", "entities", "entities", "by", "kind", "by", "kind", "total", "relationships", "len", "self", "store", "relationships", "relationships", "by", "type", "rel", "types", "add", "index", "stats", "if", "indexer", "is", "loaded", "if", "self", "indexer", "stats", "total", "chunks", "len", "self", "indexer", "chunk", "repo", "chunks", "if", "hasattr", "self", "indexer", "vector", "store", "index", "and", "self", "indexer", "vector", "store", "index", "stats", "vector", "index", "size", "self", "indexer", "vector", "store", "index", "ntotal", "return", "stats", "def", "get", "callers", "self", "entity", "id", "str", "list", "dict", "str", "any", "get", "callers", "of", "an", "entity", "args", "entity", "id", "entity", "id", "to", "look", "up", "returns", "caller", "me"], "metadata": {"kind": "class", "chunk_index": "21", "has_docstring": "true", "last_modified": "1768240645.0484078"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/service.py::KnowCodeService::22", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/service.py::KnowCodeService", "content": "\n\n        Args:\n            entity_id: Entity ID to look up.\n\n        Returns:\n            Caller metadata dictionaries.\n        \"\"\"\n        callers = self.store.get_callers(entity_id)\n        return [{\"id\": c.id, \"name\": c.qualified_name, \"file\": c.location.file_path} for c in callers]\n\n    def reload(self) -> None:\n        \"\"\"Reload the knowledge store from disk.\n        \n        Useful when the underlying JSON file has been updated by a \n        separate process (e.g., a CLI scan).\n        \"\"\"\n        self._store = None\n        try:\n            # Force reload by accessing the property\n            _ = self.store\n        except FileNotFoundError:\n            # If the file is gone, keep _store as None\n            pass\n\n    def get_entity_details(self, entity_id: str) -> Optional[dict[str, Any]]:\n        \"\"\"Get detailed information about an entity as a dictionary.\n        \n        This returns the raw structured data including source code, \n        docstrings, and metadata, which is use", "tokens": ["args", "entity", "id", "entity", "id", "to", "look", "up", "returns", "caller", "metadata", "dictionaries", "callers", "self", "store", "get", "callers", "entity", "id", "return", "id", "id", "name", "qualified", "name", "file", "location", "file", "path", "for", "in", "callers", "def", "reload", "self", "none", "reload", "the", "knowledge", "store", "from", "disk", "useful", "when", "the", "underlying", "json", "file", "has", "been", "updated", "by", "separate", "process", "cli", "scan", "self", "store", "none", "try", "force", "reload", "by", "accessing", "the", "property", "self", "store", "except", "file", "not", "found", "error", "if", "the", "file", "is", "gone", "keep", "store", "as", "none", "pass", "def", "get", "entity", "details", "self", "entity", "id", "str", "optional", "dict", "str", "any", "get", "detailed", "information", "about", "an", "entity", "as", "dictionary", "this", "returns", "the", "raw", "structured", "data", "including", "source", "code", "docstrings", "and", "metadata", "which", "is", "use"], "metadata": {"kind": "class", "chunk_index": "22", "has_docstring": "true", "last_modified": "1768240645.0484078"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/service.py::KnowCodeService::23", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/service.py::KnowCodeService", "content": "turns the raw structured data including source code, \n        docstrings, and metadata, which is useful for tool-calling agents.\n        \"\"\"\n        entity = self.store.get_entity(entity_id)\n        if not entity:\n            return None\n        \n        # Convert to dictionary (using internal helper or creating one)\n        # We can reuse the knowledge store's _entity_to_dict if exposed, \n        # or just construct it manually here to be safe and explicit.\n        from dataclasses import asdict\n\n        return {\n            \"id\": entity.id,\n            \"kind\": entity.kind.value,\n            \"name\": entity.name,\n            \"qualified_name\": entity.qualified_name,\n            \"location\": asdict(entity.location),\n            \"docstring\": entity.docstring,\n            \"signature\": entity.signature,\n            \"source_code\": entity.source_code,\n            \"metadata\": entity.metadata,\n        }\n\n    def get_callees(self, entity_id: str) -> list[dict[str, Any]]:\n        \"\"\"Get callees of", "tokens": ["turns", "the", "raw", "structured", "data", "including", "source", "code", "docstrings", "and", "metadata", "which", "is", "useful", "for", "tool", "calling", "agents", "entity", "self", "store", "get", "entity", "entity", "id", "if", "not", "entity", "return", "none", "convert", "to", "dictionary", "using", "internal", "helper", "or", "creating", "one", "we", "can", "reuse", "the", "knowledge", "store", "entity", "to", "dict", "if", "exposed", "or", "just", "construct", "it", "manually", "here", "to", "be", "safe", "and", "explicit", "from", "dataclasses", "import", "asdict", "return", "id", "entity", "id", "kind", "entity", "kind", "value", "name", "entity", "name", "qualified", "name", "entity", "qualified", "name", "location", "asdict", "entity", "location", "docstring", "entity", "docstring", "signature", "entity", "signature", "source", "code", "entity", "source", "code", "metadata", "entity", "metadata", "def", "get", "callees", "self", "entity", "id", "str", "list", "dict", "str", "any", "get", "callees", "of"], "metadata": {"kind": "class", "chunk_index": "23", "has_docstring": "true", "last_modified": "1768240645.0484078"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/service.py::KnowCodeService::24", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/service.py::KnowCodeService", "content": "     }\n\n    def get_callees(self, entity_id: str) -> list[dict[str, Any]]:\n        \"\"\"Get callees of an entity.\n\n        Args:\n            entity_id: Entity ID to look up.\n\n        Returns:\n            Callee metadata dictionaries.\n        \"\"\"\n        callees = self.store.get_callees(entity_id)\n        return [{\"id\": c.id, \"name\": c.qualified_name} for c in callees]", "tokens": ["def", "get", "callees", "self", "entity", "id", "str", "list", "dict", "str", "any", "get", "callees", "of", "an", "entity", "args", "entity", "id", "entity", "id", "to", "look", "up", "returns", "callee", "metadata", "dictionaries", "callees", "self", "store", "get", "callees", "entity", "id", "return", "id", "id", "name", "qualified", "name", "for", "in", "callees"], "metadata": {"kind": "class", "chunk_index": "24", "has_docstring": "true", "last_modified": "1768240645.0484078"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/service.py::KnowCodeService.__init__::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/service.py::KnowCodeService.__init__", "content": "def __init__(self, store_path: str | Path, config_path: Optional[str], app_config: Optional[AppConfig]) -> None\n\"\"\"Initialize service.\n\nArgs:\n    store_path: Path to load the knowledge store from.\n    config_path: Optional config file path (aimodels.yaml).\n    app_config: Optional pre-loaded AppConfig.\"\"\"\n    def __init__(\n        self,\n        store_path: str | Path = \".\",\n        config_path: Optional[str] = None,\n        app_config: Optional[AppConfig] = None,\n    ) -> None:\n        \"\"\"Initialize service.\n\n        Args:\n            store_path: Path to load the knowledge store from.\n            config_path: Optional config file path (aimodels.yaml).\n            app_config: Optional pre-loaded AppConfig.\n        \"\"\"\n        self.store_path = Path(store_path)\n        self.app_config = app_config or AppConfig.load(config_path)\n        self._store: Optional[KnowledgeStore] = None\n        self._search_engine: Optional[\"SearchEngine\"] = None\n        self._indexer: Optional[\"Indexer\"] = Non", "tokens": ["def", "init", "self", "store", "path", "str", "path", "config", "path", "optional", "str", "app", "config", "optional", "app", "config", "none", "initialize", "service", "args", "store", "path", "path", "to", "load", "the", "knowledge", "store", "from", "config", "path", "optional", "config", "file", "path", "aimodels", "yaml", "app", "config", "optional", "pre", "loaded", "app", "config", "def", "init", "self", "store", "path", "str", "path", "config", "path", "optional", "str", "none", "app", "config", "optional", "app", "config", "none", "none", "initialize", "service", "args", "store", "path", "path", "to", "load", "the", "knowledge", "store", "from", "config", "path", "optional", "config", "file", "path", "aimodels", "yaml", "app", "config", "optional", "pre", "loaded", "app", "config", "self", "store", "path", "path", "store", "path", "self", "app", "config", "app", "config", "or", "app", "config", "load", "config", "path", "self", "store", "optional", "knowledge", "store", "none", "self", "search", "engine", "optional", "search", "engine", "none", "self", "indexer", "optional", "indexer", "non"], "metadata": {"kind": "method", "chunk_index": "0", "has_docstring": "true", "last_modified": "1768240645.0484078"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/service.py::KnowCodeService.__init__::1", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/service.py::KnowCodeService.__init__", "content": "elf._search_engine: Optional[\"SearchEngine\"] = None\n        self._indexer: Optional[\"Indexer\"] = None", "tokens": ["elf", "search", "engine", "optional", "search", "engine", "none", "self", "indexer", "optional", "indexer", "none"], "metadata": {"kind": "method", "chunk_index": "1", "has_docstring": "true", "last_modified": "1768240645.0484078"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/service.py::KnowCodeService.store::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/service.py::KnowCodeService.store", "content": "def store(self) -> KnowledgeStore\n\"\"\"Get or load the knowledge store.\"\"\"\n    def store(self) -> KnowledgeStore:\n        \"\"\"Get or load the knowledge store.\"\"\"\n        if self._store is None:\n            self._store = KnowledgeStore.load(self.store_path)\n        return self._store", "tokens": ["def", "store", "self", "knowledge", "store", "get", "or", "load", "the", "knowledge", "store", "def", "store", "self", "knowledge", "store", "get", "or", "load", "the", "knowledge", "store", "if", "self", "store", "is", "none", "self", "store", "knowledge", "store", "load", "self", "store", "path", "return", "self", "store"], "metadata": {"kind": "method", "has_docstring": "true", "last_modified": "1768240645.0484078"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/service.py::KnowCodeService.get_indexer::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/service.py::KnowCodeService.get_indexer", "content": "def get_indexer(self, index_path: Optional[str | Path]) -> 'Indexer'\n\"\"\"Get or create the indexer.\n\nArgs:\n    index_path: Optional path to load an existing index from.\n\nReturns:\n    Initialized Indexer instance.\"\"\"\n    def get_indexer(self, index_path: Optional[str | Path] = None) -> \"Indexer\":\n        \"\"\"Get or create the indexer.\n\n        Args:\n            index_path: Optional path to load an existing index from.\n\n        Returns:\n            Initialized Indexer instance.\n        \"\"\"\n        if self._indexer is None:\n            from knowcode.llm.embedding import create_embedding_provider\n            from knowcode.indexing.indexer import Indexer\n            \n            provider = create_embedding_provider(app_config=self.app_config)\n            self._indexer = Indexer(provider)\n            \n            if index_path:\n                self._indexer.load(Path(index_path))\n            else:\n                store_root = self.store_path if self.store_path.is_dir() else self.store_path.par", "tokens": ["def", "get", "indexer", "self", "index", "path", "optional", "str", "path", "indexer", "get", "or", "create", "the", "indexer", "args", "index", "path", "optional", "path", "to", "load", "an", "existing", "index", "from", "returns", "initialized", "indexer", "instance", "def", "get", "indexer", "self", "index", "path", "optional", "str", "path", "none", "indexer", "get", "or", "create", "the", "indexer", "args", "index", "path", "optional", "path", "to", "load", "an", "existing", "index", "from", "returns", "initialized", "indexer", "instance", "if", "self", "indexer", "is", "none", "from", "knowcode", "llm", "embedding", "import", "create", "embedding", "provider", "from", "knowcode", "indexing", "indexer", "import", "indexer", "provider", "create", "embedding", "provider", "app", "config", "self", "app", "config", "self", "indexer", "indexer", "provider", "if", "index", "path", "self", "indexer", "load", "path", "index", "path", "else", "store", "root", "self", "store", "path", "if", "self", "store", "path", "is", "dir", "else", "self", "store", "path", "par"], "metadata": {"kind": "method", "chunk_index": "0", "has_docstring": "true", "last_modified": "1768240645.0484078"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/service.py::KnowCodeService.get_indexer::1", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/service.py::KnowCodeService.get_indexer", "content": "e:\n                store_root = self.store_path if self.store_path.is_dir() else self.store_path.parent\n                default_index = store_root / \"knowcode_index\"\n                if default_index.exists():\n                    self._indexer.load(default_index)\n                \n        return self._indexer", "tokens": ["store", "root", "self", "store", "path", "if", "self", "store", "path", "is", "dir", "else", "self", "store", "path", "parent", "default", "index", "store", "root", "knowcode", "index", "if", "default", "index", "exists", "self", "indexer", "load", "default", "index", "return", "self", "indexer"], "metadata": {"kind": "method", "chunk_index": "1", "has_docstring": "true", "last_modified": "1768240645.0484078"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/service.py::KnowCodeService.get_search_engine::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/service.py::KnowCodeService.get_search_engine", "content": "def get_search_engine(self, index_path: Optional[str | Path]) -> 'SearchEngine'\n\"\"\"Get or create the search engine.\n\nArgs:\n    index_path: Optional path to load an existing index from.\n\nReturns:\n    SearchEngine wired to the current knowledge store.\"\"\"\n    def get_search_engine(self, index_path: Optional[str | Path] = None) -> \"SearchEngine\":\n        \"\"\"Get or create the search engine.\n\n        Args:\n            index_path: Optional path to load an existing index from.\n\n        Returns:\n            SearchEngine wired to the current knowledge store.\n        \"\"\"\n        if self._search_engine is None:\n            from knowcode.retrieval.hybrid_index import HybridIndex\n            from knowcode.retrieval.search_engine import SearchEngine\n            \n            indexer = self.get_indexer(index_path)\n            hybrid_index = HybridIndex(indexer.chunk_repo, indexer.vector_store)\n            \n            self._search_engine = SearchEngine(\n                indexer.chunk_repo, \n            ", "tokens": ["def", "get", "search", "engine", "self", "index", "path", "optional", "str", "path", "search", "engine", "get", "or", "create", "the", "search", "engine", "args", "index", "path", "optional", "path", "to", "load", "an", "existing", "index", "from", "returns", "search", "engine", "wired", "to", "the", "current", "knowledge", "store", "def", "get", "search", "engine", "self", "index", "path", "optional", "str", "path", "none", "search", "engine", "get", "or", "create", "the", "search", "engine", "args", "index", "path", "optional", "path", "to", "load", "an", "existing", "index", "from", "returns", "search", "engine", "wired", "to", "the", "current", "knowledge", "store", "if", "self", "search", "engine", "is", "none", "from", "knowcode", "retrieval", "hybrid", "index", "import", "hybrid", "index", "from", "knowcode", "retrieval", "search", "engine", "import", "search", "engine", "indexer", "self", "get", "indexer", "index", "path", "hybrid", "index", "hybrid", "index", "indexer", "chunk", "repo", "indexer", "vector", "store", "self", "search", "engine", "search", "engine", "indexer", "chunk", "repo"], "metadata": {"kind": "method", "chunk_index": "0", "has_docstring": "true", "last_modified": "1768240645.0484078"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/service.py::KnowCodeService.get_search_engine::1", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/service.py::KnowCodeService.get_search_engine", "content": "  \n            self._search_engine = SearchEngine(\n                indexer.chunk_repo, \n                indexer.embedding_provider, \n                hybrid_index, \n                self.store,\n                config=self.app_config,\n            )\n        return self._search_engine", "tokens": ["self", "search", "engine", "search", "engine", "indexer", "chunk", "repo", "indexer", "embedding", "provider", "hybrid", "index", "self", "store", "config", "self", "app", "config", "return", "self", "search", "engine"], "metadata": {"kind": "method", "chunk_index": "1", "has_docstring": "true", "last_modified": "1768240645.0484078"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/service.py::KnowCodeService.retrieve_context_for_query::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/service.py::KnowCodeService.retrieve_context_for_query", "content": "def retrieve_context_for_query(self, query: str, max_tokens: int, task_type: Optional['TaskType'], limit_entities: int, per_entity_max_tokens: Optional[int], expand_deps: bool) -> dict[str, Any]\n\"\"\"Retrieve an evidence-backed context bundle for a natural-language query.\n\nThis is the unified retrieval entrypoint that both CLI Q&A and MCP tools\nshould use to ensure consistent retrieval quality.\n\nArgs:\n    query: Natural-language query.\n    max_tokens: Overall token budget across all returned entity bundles.\n    task_type: Optional task type override; if omitted, query is classified.\n    limit_entities: Maximum number of unique entities to include.\n    per_entity_max_tokens: Optional per-entity token budget; defaults to an even split.\n    expand_deps: Whether to expand dependency context during retrieval.\n\nReturns:\n    Dictionary with context_text, sufficiency_score, evidence, and metadata.\"\"\"\n    def retrieve_context_for_query(\n        self,\n        query: str,\n        max_tokens: int = ", "tokens": ["def", "retrieve", "context", "for", "query", "self", "query", "str", "max", "tokens", "int", "task", "type", "optional", "task", "type", "limit", "entities", "int", "per", "entity", "max", "tokens", "optional", "int", "expand", "deps", "bool", "dict", "str", "any", "retrieve", "an", "evidence", "backed", "context", "bundle", "for", "natural", "language", "query", "this", "is", "the", "unified", "retrieval", "entrypoint", "that", "both", "cli", "and", "mcp", "tools", "should", "use", "to", "ensure", "consistent", "retrieval", "quality", "args", "query", "natural", "language", "query", "max", "tokens", "overall", "token", "budget", "across", "all", "returned", "entity", "bundles", "task", "type", "optional", "task", "type", "override", "if", "omitted", "query", "is", "classified", "limit", "entities", "maximum", "number", "of", "unique", "entities", "to", "include", "per", "entity", "max", "tokens", "optional", "per", "entity", "token", "budget", "defaults", "to", "an", "even", "split", "expand", "deps", "whether", "to", "expand", "dependency", "context", "during", "retrieval", "returns", "dictionary", "with", "context", "text", "sufficiency", "score", "evidence", "and", "metadata", "def", "retrieve", "context", "for", "query", "self", "query", "str", "max", "tokens", "int"], "metadata": {"kind": "method", "chunk_index": "0", "has_docstring": "true", "last_modified": "1768240645.0484078"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/service.py::KnowCodeService.retrieve_context_for_query::1", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/service.py::KnowCodeService.retrieve_context_for_query", "content": "\"\"\"\n    def retrieve_context_for_query(\n        self,\n        query: str,\n        max_tokens: int = 6000,\n        task_type: Optional[\"TaskType\"] = None,\n        limit_entities: int = 3,\n        per_entity_max_tokens: Optional[int] = None,\n        expand_deps: bool = True,\n    ) -> dict[str, Any]:\n        \"\"\"Retrieve an evidence-backed context bundle for a natural-language query.\n\n        This is the unified retrieval entrypoint that both CLI Q&A and MCP tools\n        should use to ensure consistent retrieval quality.\n\n        Args:\n            query: Natural-language query.\n            max_tokens: Overall token budget across all returned entity bundles.\n            task_type: Optional task type override; if omitted, query is classified.\n            limit_entities: Maximum number of unique entities to include.\n            per_entity_max_tokens: Optional per-entity token budget; defaults to an even split.\n            expand_deps: Whether to expand dependency context during retrieval.\n\n ", "tokens": ["def", "retrieve", "context", "for", "query", "self", "query", "str", "max", "tokens", "int", "6000", "task", "type", "optional", "task", "type", "none", "limit", "entities", "int", "per", "entity", "max", "tokens", "optional", "int", "none", "expand", "deps", "bool", "true", "dict", "str", "any", "retrieve", "an", "evidence", "backed", "context", "bundle", "for", "natural", "language", "query", "this", "is", "the", "unified", "retrieval", "entrypoint", "that", "both", "cli", "and", "mcp", "tools", "should", "use", "to", "ensure", "consistent", "retrieval", "quality", "args", "query", "natural", "language", "query", "max", "tokens", "overall", "token", "budget", "across", "all", "returned", "entity", "bundles", "task", "type", "optional", "task", "type", "override", "if", "omitted", "query", "is", "classified", "limit", "entities", "maximum", "number", "of", "unique", "entities", "to", "include", "per", "entity", "max", "tokens", "optional", "per", "entity", "token", "budget", "defaults", "to", "an", "even", "split", "expand", "deps", "whether", "to", "expand", "dependency", "context", "during", "retrieval"], "metadata": {"kind": "method", "chunk_index": "1", "has_docstring": "true", "last_modified": "1768240645.0484078"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/service.py::KnowCodeService.retrieve_context_for_query::2", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/service.py::KnowCodeService.retrieve_context_for_query", "content": "to an even split.\n            expand_deps: Whether to expand dependency context during retrieval.\n\n        Returns:\n            Dictionary with context_text, sufficiency_score, evidence, and metadata.\n        \"\"\"\n        from knowcode.llm.query_classifier import classify_query\n\n        errors: list[str] = []\n        store_root = self.store_path if self.store_path.is_dir() else self.store_path.parent\n        store_file = store_root / KnowledgeStore.DEFAULT_FILENAME\n        index_path = store_root / \"knowcode_index\"\n\n        if not store_file.exists():\n            try:\n                self.analyze(directory=store_root, output=store_root)\n            except Exception as e:\n                return {\n                    \"query\": query,\n                    \"task_type\": task_type.value if task_type else \"general\",\n                    \"task_confidence\": 0.0,\n                    \"retrieval_mode\": \"none\",\n                    \"context_text\": \"\",\n                    \"total_tokens\": 0,\n             ", "tokens": ["to", "an", "even", "split", "expand", "deps", "whether", "to", "expand", "dependency", "context", "during", "retrieval", "returns", "dictionary", "with", "context", "text", "sufficiency", "score", "evidence", "and", "metadata", "from", "knowcode", "llm", "query", "classifier", "import", "classify", "query", "errors", "list", "str", "store", "root", "self", "store", "path", "if", "self", "store", "path", "is", "dir", "else", "self", "store", "path", "parent", "store", "file", "store", "root", "knowledge", "store", "default", "filename", "index", "path", "store", "root", "knowcode", "index", "if", "not", "store", "file", "exists", "try", "self", "analyze", "directory", "store", "root", "output", "store", "root", "except", "exception", "as", "return", "query", "query", "task", "type", "task", "type", "value", "if", "task", "type", "else", "general", "task", "confidence", "retrieval", "mode", "none", "context", "text", "total", "tokens"], "metadata": {"kind": "method", "chunk_index": "2", "has_docstring": "true", "last_modified": "1768240645.0484078"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/service.py::KnowCodeService.retrieve_context_for_query::3", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/service.py::KnowCodeService.retrieve_context_for_query", "content": "\"none\",\n                    \"context_text\": \"\",\n                    \"total_tokens\": 0,\n                    \"max_tokens\": max_tokens,\n                    \"truncated\": False,\n                    \"sufficiency_score\": 0.0,\n                    \"selected_entities\": [],\n                    \"evidence\": [],\n                    \"errors\": [f\"Auto-analyze failed: {e}\"],\n                }\n\n        if not index_path.exists():\n            try:\n                self._build_index(store_root, index_path)\n            except Exception as e:\n                errors.append(f\"Auto-index failed; falling back to lexical: {e}\")\n\n        detected_task_type, confidence = classify_query(query)\n        resolved_task_type = task_type or detected_task_type\n        task_confidence = 1.0 if task_type is not None else confidence\n\n        if limit_entities <= 0 or max_tokens <= 0:\n            return {\n                \"query\": query,\n                \"task_type\": resolved_task_type.value,\n                \"task_confidence\": t", "tokens": ["none", "context", "text", "total", "tokens", "max", "tokens", "max", "tokens", "truncated", "false", "sufficiency", "score", "selected", "entities", "evidence", "errors", "auto", "analyze", "failed", "if", "not", "index", "path", "exists", "try", "self", "build", "index", "store", "root", "index", "path", "except", "exception", "as", "errors", "append", "auto", "index", "failed", "falling", "back", "to", "lexical", "detected", "task", "type", "confidence", "classify", "query", "query", "resolved", "task", "type", "task", "type", "or", "detected", "task", "type", "task", "confidence", "if", "task", "type", "is", "not", "none", "else", "confidence", "if", "limit", "entities", "or", "max", "tokens", "return", "query", "query", "task", "type", "resolved", "task", "type", "value", "task", "confidence"], "metadata": {"kind": "method", "chunk_index": "3", "has_docstring": "true", "last_modified": "1768240645.0484078"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/service.py::KnowCodeService.retrieve_context_for_query::4", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/service.py::KnowCodeService.retrieve_context_for_query", "content": ": query,\n                \"task_type\": resolved_task_type.value,\n                \"task_confidence\": task_confidence,\n                \"retrieval_mode\": \"none\",\n                \"context_text\": \"\",\n                \"total_tokens\": 0,\n                \"max_tokens\": max_tokens,\n                \"truncated\": False,\n                \"sufficiency_score\": 0.0,\n                \"selected_entities\": [],\n                \"evidence\": [],\n                \"errors\": [\"Invalid token or entity limits.\"],\n            }\n\n        if per_entity_max_tokens is None:\n            per_entity_max_tokens = max(200, min(2000, max_tokens // limit_entities))\n\n        selected_entity_ids: list[str] = []\n        evidence: list[dict[str, Any]] = []\n        retrieval_mode = \"lexical\"\n\n        if index_path.exists():\n            try:\n                engine = self.get_search_engine()\n                self._validate_index_compatibility(index_path)\n                scored = engine.search_scored(\n                    query,\n           ", "tokens": ["query", "task", "type", "resolved", "task", "type", "value", "task", "confidence", "task", "confidence", "retrieval", "mode", "none", "context", "text", "total", "tokens", "max", "tokens", "max", "tokens", "truncated", "false", "sufficiency", "score", "selected", "entities", "evidence", "errors", "invalid", "token", "or", "entity", "limits", "if", "per", "entity", "max", "tokens", "is", "none", "per", "entity", "max", "tokens", "max", "200", "min", "2000", "max", "tokens", "limit", "entities", "selected", "entity", "ids", "list", "str", "evidence", "list", "dict", "str", "any", "retrieval", "mode", "lexical", "if", "index", "path", "exists", "try", "engine", "self", "get", "search", "engine", "self", "validate", "index", "compatibility", "index", "path", "scored", "engine", "search", "scored", "query"], "metadata": {"kind": "method", "chunk_index": "4", "has_docstring": "true", "last_modified": "1768240645.0484078"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/service.py::KnowCodeService.retrieve_context_for_query::5", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/service.py::KnowCodeService.retrieve_context_for_query", "content": "ty(index_path)\n                scored = engine.search_scored(\n                    query,\n                    limit=max(10, limit_entities * 5),\n                    expand_deps=expand_deps,\n                )\n                retrieval_mode = \"semantic\"\n\n                primary = [s for s in scored if s.source == \"retrieved\"]\n                seen_entities: set[str] = set()\n                for s in primary:\n                    if s.chunk.entity_id in seen_entities:\n                        continue\n                    seen_entities.add(s.chunk.entity_id)\n                    selected_entity_ids.append(s.chunk.entity_id)\n                    if len(selected_entity_ids) >= limit_entities:\n                        break\n\n                for rank, s in enumerate(scored, start=1):\n                    evidence.append(\n                        {\n                            \"rank\": rank,\n                            \"chunk_id\": s.chunk.id,\n                            \"entity_id\": s.chunk.entity_id,\n    ", "tokens": ["ty", "index", "path", "scored", "engine", "search", "scored", "query", "limit", "max", "10", "limit", "entities", "expand", "deps", "expand", "deps", "retrieval", "mode", "semantic", "primary", "for", "in", "scored", "if", "source", "retrieved", "seen", "entities", "set", "str", "set", "for", "in", "primary", "if", "chunk", "entity", "id", "in", "seen", "entities", "continue", "seen", "entities", "add", "chunk", "entity", "id", "selected", "entity", "ids", "append", "chunk", "entity", "id", "if", "len", "selected", "entity", "ids", "limit", "entities", "break", "for", "rank", "in", "enumerate", "scored", "start", "evidence", "append", "rank", "rank", "chunk", "id", "chunk", "id", "entity", "id", "chunk", "entity", "id"], "metadata": {"kind": "method", "chunk_index": "5", "has_docstring": "true", "last_modified": "1768240645.0484078"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/service.py::KnowCodeService.retrieve_context_for_query::6", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/service.py::KnowCodeService.retrieve_context_for_query", "content": "            \"chunk_id\": s.chunk.id,\n                            \"entity_id\": s.chunk.entity_id,\n                            \"score\": s.score,\n                            \"source\": s.source,\n                        }\n                    )\n\n            except Exception as e:\n                errors.append(f\"Semantic retrieval failed; falling back to lexical: {e}\")\n                retrieval_mode = \"lexical\"\n\n        if retrieval_mode == \"lexical\":\n            candidates: list[str] = []\n            seen: set[str] = set()\n\n            def add_entity_ids(items: list[dict[str, Any]]) -> None:\n                for item in items:\n                    entity_id = item.get(\"id\")\n                    if not entity_id or entity_id in seen:\n                        continue\n                    seen.add(entity_id)\n                    candidates.append(entity_id)\n\n            add_entity_ids(self.search(query))\n            if len(candidates) < limit_entities:\n                for kw in self._extract_query_ke", "tokens": ["chunk", "id", "chunk", "id", "entity", "id", "chunk", "entity", "id", "score", "score", "source", "source", "except", "exception", "as", "errors", "append", "semantic", "retrieval", "failed", "falling", "back", "to", "lexical", "retrieval", "mode", "lexical", "if", "retrieval", "mode", "lexical", "candidates", "list", "str", "seen", "set", "str", "set", "def", "add", "entity", "ids", "items", "list", "dict", "str", "any", "none", "for", "item", "in", "items", "entity", "id", "item", "get", "id", "if", "not", "entity", "id", "or", "entity", "id", "in", "seen", "continue", "seen", "add", "entity", "id", "candidates", "append", "entity", "id", "add", "entity", "ids", "self", "search", "query", "if", "len", "candidates", "limit", "entities", "for", "kw", "in", "self", "extract", "query", "ke"], "metadata": {"kind": "method", "chunk_index": "6", "has_docstring": "true", "last_modified": "1768240645.0484078"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/service.py::KnowCodeService.retrieve_context_for_query::7", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/service.py::KnowCodeService.retrieve_context_for_query", "content": "))\n            if len(candidates) < limit_entities:\n                for kw in self._extract_query_keywords(query):\n                    add_entity_ids(self.search(kw))\n                    if len(candidates) >= limit_entities:\n                        break\n\n            selected_entity_ids = candidates[:limit_entities]\n            for rank, entity_id in enumerate(selected_entity_ids, start=1):\n                evidence.append({\"rank\": rank, \"entity_id\": entity_id, \"source\": \"lexical\"})\n\n        selected_entities: list[dict[str, Any]] = []\n        context_parts: list[str] = []\n        sufficiency_scores: list[float] = []\n        total_tokens = 0\n        truncated = False\n\n        for entity_id in selected_entity_ids:\n            try:\n                bundle = self.get_context(\n                    entity_id,\n                    max_tokens=per_entity_max_tokens,\n                    task_type=resolved_task_type,\n                )\n            except Exception as e:\n                errors.append(", "tokens": ["if", "len", "candidates", "limit", "entities", "for", "kw", "in", "self", "extract", "query", "keywords", "query", "add", "entity", "ids", "self", "search", "kw", "if", "len", "candidates", "limit", "entities", "break", "selected", "entity", "ids", "candidates", "limit", "entities", "for", "rank", "entity", "id", "in", "enumerate", "selected", "entity", "ids", "start", "evidence", "append", "rank", "rank", "entity", "id", "entity", "id", "source", "lexical", "selected", "entities", "list", "dict", "str", "any", "context", "parts", "list", "str", "sufficiency", "scores", "list", "float", "total", "tokens", "truncated", "false", "for", "entity", "id", "in", "selected", "entity", "ids", "try", "bundle", "self", "get", "context", "entity", "id", "max", "tokens", "per", "entity", "max", "tokens", "task", "type", "resolved", "task", "type", "except", "exception", "as", "errors", "append"], "metadata": {"kind": "method", "chunk_index": "7", "has_docstring": "true", "last_modified": "1768240645.0484078"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/service.py::KnowCodeService.retrieve_context_for_query::8", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/service.py::KnowCodeService.retrieve_context_for_query", "content": "olved_task_type,\n                )\n            except Exception as e:\n                errors.append(f\"Failed to synthesize context for {entity_id}: {e}\")\n                continue\n\n            context_parts.append(bundle.get(\"context_text\", \"\"))\n            total_tokens += int(bundle.get(\"total_tokens\", 0))\n            truncated = truncated or bool(bundle.get(\"truncated\", False))\n\n            s = bundle.get(\"sufficiency_score\")\n            if isinstance(s, (int, float)):\n                sufficiency_scores.append(float(s))\n\n            selected_entities.append(\n                {\n                    \"entity_id\": bundle.get(\"entity_id\", entity_id),\n                    \"task_type\": bundle.get(\"task_type\", resolved_task_type.value),\n                    \"total_tokens\": bundle.get(\"total_tokens\", 0),\n                    \"truncated\": bundle.get(\"truncated\", False),\n                    \"sufficiency_score\": bundle.get(\"sufficiency_score\", 0.0),\n                }\n            )\n\n        context_tex", "tokens": ["olved", "task", "type", "except", "exception", "as", "errors", "append", "failed", "to", "synthesize", "context", "for", "entity", "id", "continue", "context", "parts", "append", "bundle", "get", "context", "text", "total", "tokens", "int", "bundle", "get", "total", "tokens", "truncated", "truncated", "or", "bool", "bundle", "get", "truncated", "false", "bundle", "get", "sufficiency", "score", "if", "isinstance", "int", "float", "sufficiency", "scores", "append", "float", "selected", "entities", "append", "entity", "id", "bundle", "get", "entity", "id", "entity", "id", "task", "type", "bundle", "get", "task", "type", "resolved", "task", "type", "value", "total", "tokens", "bundle", "get", "total", "tokens", "truncated", "bundle", "get", "truncated", "false", "sufficiency", "score", "bundle", "get", "sufficiency", "score", "context", "tex"], "metadata": {"kind": "method", "chunk_index": "8", "has_docstring": "true", "last_modified": "1768240645.0484078"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/service.py::KnowCodeService.retrieve_context_for_query::9", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/service.py::KnowCodeService.retrieve_context_for_query", "content": "y_score\": bundle.get(\"sufficiency_score\", 0.0),\n                }\n            )\n\n        context_text = \"\\n\\n---\\n\\n\".join([p for p in context_parts if p])\n        sufficiency = (\n            round(sum(sufficiency_scores) / len(sufficiency_scores), 2)\n            if sufficiency_scores\n            else 0.0\n        )\n\n        return {\n            \"query\": query,\n            \"task_type\": resolved_task_type.value,\n            \"task_confidence\": task_confidence,\n            \"retrieval_mode\": retrieval_mode,\n            \"context_text\": context_text,\n            \"total_tokens\": total_tokens,\n            \"max_tokens\": max_tokens,\n            \"truncated\": truncated,\n            \"sufficiency_score\": sufficiency,\n            \"selected_entities\": selected_entities,\n            \"evidence\": evidence,\n            \"errors\": errors,\n        }", "tokens": ["score", "bundle", "get", "sufficiency", "score", "context", "text", "join", "for", "in", "context", "parts", "if", "sufficiency", "round", "sum", "sufficiency", "scores", "len", "sufficiency", "scores", "if", "sufficiency", "scores", "else", "return", "query", "query", "task", "type", "resolved", "task", "type", "value", "task", "confidence", "task", "confidence", "retrieval", "mode", "retrieval", "mode", "context", "text", "context", "text", "total", "tokens", "total", "tokens", "max", "tokens", "max", "tokens", "truncated", "truncated", "sufficiency", "score", "sufficiency", "selected", "entities", "selected", "entities", "evidence", "evidence", "errors", "errors"], "metadata": {"kind": "method", "chunk_index": "9", "has_docstring": "true", "last_modified": "1768240645.0484078"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/service.py::KnowCodeService._build_index::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/service.py::KnowCodeService._build_index", "content": "def _build_index(self, directory: str | Path, index_path: str | Path) -> int\n\"\"\"Build a semantic index for a directory and persist it.\"\"\"\n    def _build_index(self, directory: str | Path, index_path: str | Path) -> int:\n        \"\"\"Build a semantic index for a directory and persist it.\"\"\"\n        from knowcode.llm.embedding import create_embedding_provider\n        from knowcode.indexing.indexer import Indexer\n\n        provider = create_embedding_provider(app_config=self.app_config)\n        indexer = Indexer(provider)\n        count = indexer.index_directory(directory)\n        indexer.save(index_path)\n        self._indexer = indexer\n        return count", "tokens": ["def", "build", "index", "self", "directory", "str", "path", "index", "path", "str", "path", "int", "build", "semantic", "index", "for", "directory", "and", "persist", "it", "def", "build", "index", "self", "directory", "str", "path", "index", "path", "str", "path", "int", "build", "semantic", "index", "for", "directory", "and", "persist", "it", "from", "knowcode", "llm", "embedding", "import", "create", "embedding", "provider", "from", "knowcode", "indexing", "indexer", "import", "indexer", "provider", "create", "embedding", "provider", "app", "config", "self", "app", "config", "indexer", "indexer", "provider", "count", "indexer", "index", "directory", "directory", "indexer", "save", "index", "path", "self", "indexer", "indexer", "return", "count"], "metadata": {"kind": "method", "has_docstring": "true", "last_modified": "1768240645.0484078"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/service.py::KnowCodeService._extract_query_keywords::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/service.py::KnowCodeService._extract_query_keywords", "content": "def _extract_query_keywords(self, query: str) -> list[str]\n\"\"\"Extract identifier-like keywords from a natural-language query.\"\"\"\n    def _extract_query_keywords(self, query: str) -> list[str]:\n        \"\"\"Extract identifier-like keywords from a natural-language query.\"\"\"\n        stopwords = {\n            \"how\",\n            \"what\",\n            \"where\",\n            \"when\",\n            \"why\",\n            \"who\",\n            \"does\",\n            \"did\",\n            \"is\",\n            \"are\",\n            \"can\",\n            \"will\",\n            \"the\",\n            \"a\",\n            \"an\",\n            \"in\",\n            \"on\",\n            \"at\",\n            \"for\",\n            \"to\",\n            \"of\",\n            \"and\",\n            \"or\",\n        }\n        tokens = re.findall(r\"\\b[a-zA-Z_][a-zA-Z0-9_.]+\\b\", query)\n        keywords = [\n            t\n            for t in tokens\n            if len(t) > 3 and t.lower() not in stopwords\n        ]\n        return keywords[:10]", "tokens": ["def", "extract", "query", "keywords", "self", "query", "str", "list", "str", "extract", "identifier", "like", "keywords", "from", "natural", "language", "query", "def", "extract", "query", "keywords", "self", "query", "str", "list", "str", "extract", "identifier", "like", "keywords", "from", "natural", "language", "query", "stopwords", "how", "what", "where", "when", "why", "who", "does", "did", "is", "are", "can", "will", "the", "an", "in", "on", "at", "for", "to", "of", "and", "or", "tokens", "re", "findall", "z0", "query", "keywords", "for", "in", "tokens", "if", "len", "and", "lower", "not", "in", "stopwords", "return", "keywords", "10"], "metadata": {"kind": "method", "has_docstring": "true", "last_modified": "1768240645.0484078"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/service.py::KnowCodeService._validate_index_compatibility::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/service.py::KnowCodeService._validate_index_compatibility", "content": "def _validate_index_compatibility(self, index_path: Path) -> None\n\"\"\"Validate the loaded index against the current embedding configuration.\n\nRaises:\n    ValueError: If the index manifest indicates an incompatible embedding model.\"\"\"\n    def _validate_index_compatibility(self, index_path: Path) -> None:\n        \"\"\"Validate the loaded index against the current embedding configuration.\n\n        Raises:\n            ValueError: If the index manifest indicates an incompatible embedding model.\n        \"\"\"\n        indexer = self.get_indexer(index_path=index_path)\n\n        # Always enforce dimension compatibility to prevent runtime FAISS errors.\n        expected_dim = int(getattr(indexer.embedding_provider.config, \"dimension\", 0))\n        actual_dim = int(getattr(indexer.vector_store, \"dimension\", 0))\n        if expected_dim and actual_dim and expected_dim != actual_dim:\n            raise ValueError(\n                \"Embedding dimension mismatch between configured embedding model \"\n            ", "tokens": ["def", "validate", "index", "compatibility", "self", "index", "path", "path", "none", "validate", "the", "loaded", "index", "against", "the", "current", "embedding", "configuration", "raises", "value", "error", "if", "the", "index", "manifest", "indicates", "an", "incompatible", "embedding", "model", "def", "validate", "index", "compatibility", "self", "index", "path", "path", "none", "validate", "the", "loaded", "index", "against", "the", "current", "embedding", "configuration", "raises", "value", "error", "if", "the", "index", "manifest", "indicates", "an", "incompatible", "embedding", "model", "indexer", "self", "get", "indexer", "index", "path", "index", "path", "always", "enforce", "dimension", "compatibility", "to", "prevent", "runtime", "faiss", "errors", "expected", "dim", "int", "getattr", "indexer", "embedding", "provider", "config", "dimension", "actual", "dim", "int", "getattr", "indexer", "vector", "store", "dimension", "if", "expected", "dim", "and", "actual", "dim", "and", "expected", "dim", "actual", "dim", "raise", "value", "error", "embedding", "dimension", "mismatch", "between", "configured", "embedding", "model"], "metadata": {"kind": "method", "chunk_index": "0", "has_docstring": "true", "last_modified": "1768240645.0484078"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/service.py::KnowCodeService._validate_index_compatibility::1", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/service.py::KnowCodeService._validate_index_compatibility", "content": "ror(\n                \"Embedding dimension mismatch between configured embedding model \"\n                f\"({expected_dim}) and loaded index ({actual_dim}). Rebuild the \"\n                \"semantic index with `knowcode index` using the same embedding model.\"\n            )\n\n        manifest = getattr(indexer, \"manifest\", {}) or {}\n        embedding_meta = manifest.get(\"embedding\")\n        if not isinstance(embedding_meta, dict):\n            return\n\n        mismatches: list[str] = []\n        current = indexer.embedding_provider.config\n\n        for key in (\"provider\", \"model_name\", \"dimension\", \"normalize\"):\n            if key not in embedding_meta:\n                continue\n            recorded = embedding_meta.get(key)\n            current_val = getattr(current, key, None)\n            if recorded != current_val:\n                mismatches.append(f\"{key}: index={recorded!r} current={current_val!r}\")\n\n        if mismatches:\n            details = \"; \".join(mismatches)\n            raise ValueEr", "tokens": ["ror", "embedding", "dimension", "mismatch", "between", "configured", "embedding", "model", "expected", "dim", "and", "loaded", "index", "actual", "dim", "rebuild", "the", "semantic", "index", "with", "knowcode", "index", "using", "the", "same", "embedding", "model", "manifest", "getattr", "indexer", "manifest", "or", "embedding", "meta", "manifest", "get", "embedding", "if", "not", "isinstance", "embedding", "meta", "dict", "return", "mismatches", "list", "str", "current", "indexer", "embedding", "provider", "config", "for", "key", "in", "provider", "model", "name", "dimension", "normalize", "if", "key", "not", "in", "embedding", "meta", "continue", "recorded", "embedding", "meta", "get", "key", "current", "val", "getattr", "current", "key", "none", "if", "recorded", "current", "val", "mismatches", "append", "key", "index", "recorded", "current", "current", "val", "if", "mismatches", "details", "join", "mismatches", "raise", "value", "er"], "metadata": {"kind": "method", "chunk_index": "1", "has_docstring": "true", "last_modified": "1768240645.0484078"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/service.py::KnowCodeService._validate_index_compatibility::2", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/service.py::KnowCodeService._validate_index_compatibility", "content": "l!r}\")\n\n        if mismatches:\n            details = \"; \".join(mismatches)\n            raise ValueError(\n                \"Index embedding configuration mismatch. \"\n                f\"{details}. Rebuild the semantic index with `knowcode index` \"\n                \"using the same embedding model and settings.\"\n            )", "tokens": ["if", "mismatches", "details", "join", "mismatches", "raise", "value", "error", "index", "embedding", "configuration", "mismatch", "details", "rebuild", "the", "semantic", "index", "with", "knowcode", "index", "using", "the", "same", "embedding", "model", "and", "settings"], "metadata": {"kind": "method", "chunk_index": "2", "has_docstring": "true", "last_modified": "1768240645.0484078"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/service.py::KnowCodeService.analyze::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/service.py::KnowCodeService.analyze", "content": "def analyze(self, directory: str | Path, output: str | Path, ignore: list[str], temporal: bool, coverage: str | Path) -> dict[str, Any]\n\"\"\"Analyze a codebase and persist the resulting knowledge store.\n\nArgs:\n    directory: Root directory to scan and parse.\n    output: Destination path for the knowledge store JSON.\n    ignore: Additional ignore patterns.\n    temporal: Whether to include git history analysis.\n    coverage: Optional Cobertura coverage report path.\n\nReturns:\n    Statistics from the graph builder.\"\"\"\n    def analyze(\n        self,\n        directory: str | Path,\n        output: str | Path,\n        ignore: list[str] = None,\n        temporal: bool = False,\n        coverage: str | Path = None,\n    ) -> dict[str, Any]:\n        \"\"\"Analyze a codebase and persist the resulting knowledge store.\n\n        Args:\n            directory: Root directory to scan and parse.\n            output: Destination path for the knowledge store JSON.\n            ignore: Additional ignore patterns.\n    ", "tokens": ["def", "analyze", "self", "directory", "str", "path", "output", "str", "path", "ignore", "list", "str", "temporal", "bool", "coverage", "str", "path", "dict", "str", "any", "analyze", "codebase", "and", "persist", "the", "resulting", "knowledge", "store", "args", "directory", "root", "directory", "to", "scan", "and", "parse", "output", "destination", "path", "for", "the", "knowledge", "store", "json", "ignore", "additional", "ignore", "patterns", "temporal", "whether", "to", "include", "git", "history", "analysis", "coverage", "optional", "cobertura", "coverage", "report", "path", "returns", "statistics", "from", "the", "graph", "builder", "def", "analyze", "self", "directory", "str", "path", "output", "str", "path", "ignore", "list", "str", "none", "temporal", "bool", "false", "coverage", "str", "path", "none", "dict", "str", "any", "analyze", "codebase", "and", "persist", "the", "resulting", "knowledge", "store", "args", "directory", "root", "directory", "to", "scan", "and", "parse", "output", "destination", "path", "for", "the", "knowledge", "store", "json", "ignore", "additional", "ignore", "patterns"], "metadata": {"kind": "method", "chunk_index": "0", "has_docstring": "true", "last_modified": "1768240645.0484078"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/service.py::KnowCodeService.analyze::1", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/service.py::KnowCodeService.analyze", "content": " Destination path for the knowledge store JSON.\n            ignore: Additional ignore patterns.\n            temporal: Whether to include git history analysis.\n            coverage: Optional Cobertura coverage report path.\n\n        Returns:\n            Statistics from the graph builder.\n        \"\"\"\n        builder = GraphBuilder()\n        builder.build_from_directory(\n            root_dir=directory,\n            additional_ignores=ignore,\n            analyze_temporal=temporal,\n            coverage_path=Path(coverage) if coverage else None,\n        )\n\n        store = KnowledgeStore.from_graph_builder(builder)\n        output_path = Path(output)\n        store.save(output_path)\n        self._store = store\n\n        store_root = output_path if output_path.is_dir() else output_path.parent\n        index_path = store_root / \"knowcode_index\"\n        index_count = self._build_index(Path(directory), index_path)\n\n        stats = builder.stats()\n        stats[\"indexed_chunks\"] = index_count\n        st", "tokens": ["destination", "path", "for", "the", "knowledge", "store", "json", "ignore", "additional", "ignore", "patterns", "temporal", "whether", "to", "include", "git", "history", "analysis", "coverage", "optional", "cobertura", "coverage", "report", "path", "returns", "statistics", "from", "the", "graph", "builder", "builder", "graph", "builder", "builder", "build", "from", "directory", "root", "dir", "directory", "additional", "ignores", "ignore", "analyze", "temporal", "temporal", "coverage", "path", "path", "coverage", "if", "coverage", "else", "none", "store", "knowledge", "store", "from", "graph", "builder", "builder", "output", "path", "path", "output", "store", "save", "output", "path", "self", "store", "store", "store", "root", "output", "path", "if", "output", "path", "is", "dir", "else", "output", "path", "parent", "index", "path", "store", "root", "knowcode", "index", "index", "count", "self", "build", "index", "path", "directory", "index", "path", "stats", "builder", "stats", "stats", "indexed", "chunks", "index", "count", "st"], "metadata": {"kind": "method", "chunk_index": "1", "has_docstring": "true", "last_modified": "1768240645.0484078"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/service.py::KnowCodeService.analyze::2", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/service.py::KnowCodeService.analyze", "content": "ndex_path)\n\n        stats = builder.stats()\n        stats[\"indexed_chunks\"] = index_count\n        stats[\"index_path\"] = str(index_path)\n        return stats", "tokens": ["ndex", "path", "stats", "builder", "stats", "stats", "indexed", "chunks", "index", "count", "stats", "index", "path", "str", "index", "path", "return", "stats"], "metadata": {"kind": "method", "chunk_index": "2", "has_docstring": "true", "last_modified": "1768240645.0484078"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/service.py::KnowCodeService.search::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/service.py::KnowCodeService.search", "content": "def search(self, pattern: str) -> list[dict[str, Any]]\n\"\"\"Search entities by pattern.\n\nArgs:\n    pattern: Substring match over names and qualified names.\n\nReturns:\n    Lightweight entity metadata for display or API responses.\"\"\"\n    def search(self, pattern: str) -> list[dict[str, Any]]:\n        \"\"\"Search entities by pattern.\n\n        Args:\n            pattern: Substring match over names and qualified names.\n\n        Returns:\n            Lightweight entity metadata for display or API responses.\n        \"\"\"\n        entities = self.store.search(pattern)\n        return [\n            {\n                \"id\": e.id,\n                \"kind\": e.kind.value,\n                \"name\": e.name,\n                \"qualified_name\": e.qualified_name,\n                \"file\": e.location.file_path,\n                \"line\": e.location.line_start,\n            }\n            for e in entities\n        ]", "tokens": ["def", "search", "self", "pattern", "str", "list", "dict", "str", "any", "search", "entities", "by", "pattern", "args", "pattern", "substring", "match", "over", "names", "and", "qualified", "names", "returns", "lightweight", "entity", "metadata", "for", "display", "or", "api", "responses", "def", "search", "self", "pattern", "str", "list", "dict", "str", "any", "search", "entities", "by", "pattern", "args", "pattern", "substring", "match", "over", "names", "and", "qualified", "names", "returns", "lightweight", "entity", "metadata", "for", "display", "or", "api", "responses", "entities", "self", "store", "search", "pattern", "return", "id", "id", "kind", "kind", "value", "name", "name", "qualified", "name", "qualified", "name", "file", "location", "file", "path", "line", "location", "line", "start", "for", "in", "entities"], "metadata": {"kind": "method", "has_docstring": "true", "last_modified": "1768240645.0484078"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/service.py::KnowCodeService.get_context::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/service.py::KnowCodeService.get_context", "content": "def get_context(self, target: str, max_tokens: int, task_type: Optional['TaskType']) -> dict[str, Any]\n\"\"\"Get a context bundle for an entity.\n\nArgs:\n    target: Entity ID or search pattern.\n    max_tokens: Maximum token budget for the context bundle.\n    task_type: Optional task type for context prioritization.\n\nReturns:\n    Dictionary containing context text and metadata.\n\nRaises:\n    ValueError: If no matching entity is found or context synthesis fails.\"\"\"\n    def get_context(\n        self,\n        target: str,\n        max_tokens: int = 2000,\n        task_type: Optional[\"TaskType\"] = None,\n    ) -> dict[str, Any]:\n        \"\"\"Get a context bundle for an entity.\n\n        Args:\n            target: Entity ID or search pattern.\n            max_tokens: Maximum token budget for the context bundle.\n            task_type: Optional task type for context prioritization.\n\n        Returns:\n            Dictionary containing context text and metadata.\n\n        Raises:\n            ValueError: If no ", "tokens": ["def", "get", "context", "self", "target", "str", "max", "tokens", "int", "task", "type", "optional", "task", "type", "dict", "str", "any", "get", "context", "bundle", "for", "an", "entity", "args", "target", "entity", "id", "or", "search", "pattern", "max", "tokens", "maximum", "token", "budget", "for", "the", "context", "bundle", "task", "type", "optional", "task", "type", "for", "context", "prioritization", "returns", "dictionary", "containing", "context", "text", "and", "metadata", "raises", "value", "error", "if", "no", "matching", "entity", "is", "found", "or", "context", "synthesis", "fails", "def", "get", "context", "self", "target", "str", "max", "tokens", "int", "2000", "task", "type", "optional", "task", "type", "none", "dict", "str", "any", "get", "context", "bundle", "for", "an", "entity", "args", "target", "entity", "id", "or", "search", "pattern", "max", "tokens", "maximum", "token", "budget", "for", "the", "context", "bundle", "task", "type", "optional", "task", "type", "for", "context", "prioritization", "returns", "dictionary", "containing", "context", "text", "and", "metadata", "raises", "value", "error", "if", "no"], "metadata": {"kind": "method", "chunk_index": "0", "has_docstring": "true", "last_modified": "1768240645.0484078"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/service.py::KnowCodeService.get_context::1", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/service.py::KnowCodeService.get_context", "content": "    Dictionary containing context text and metadata.\n\n        Raises:\n            ValueError: If no matching entity is found or context synthesis fails.\n        \"\"\"\n        # Try exact match first\n        entity = self.store.get_entity(target)\n        if not entity:\n            # Try search\n            matches = self.store.search(target)\n            if matches:\n                entity = matches[0]\n\n        if not entity:\n            raise ValueError(f\"Entity not found: {target}\")\n\n        synthesizer = ContextSynthesizer(self.store, max_tokens=max_tokens)\n        \n        # Use task-specific synthesis if task_type provided\n        if task_type is not None:\n            bundle = synthesizer.synthesize_with_task(entity.id, task_type)\n        else:\n            bundle = synthesizer.synthesize(entity.id)\n        \n        if not bundle:\n             raise ValueError(f\"Failed to synthesize context for {entity.id}\")\n\n        result = {\n            \"entity_id\": bundle.target_entity.id,\n          ", "tokens": ["dictionary", "containing", "context", "text", "and", "metadata", "raises", "value", "error", "if", "no", "matching", "entity", "is", "found", "or", "context", "synthesis", "fails", "try", "exact", "match", "first", "entity", "self", "store", "get", "entity", "target", "if", "not", "entity", "try", "search", "matches", "self", "store", "search", "target", "if", "matches", "entity", "matches", "if", "not", "entity", "raise", "value", "error", "entity", "not", "found", "target", "synthesizer", "context", "synthesizer", "self", "store", "max", "tokens", "max", "tokens", "use", "task", "specific", "synthesis", "if", "task", "type", "provided", "if", "task", "type", "is", "not", "none", "bundle", "synthesizer", "synthesize", "with", "task", "entity", "id", "task", "type", "else", "bundle", "synthesizer", "synthesize", "entity", "id", "if", "not", "bundle", "raise", "value", "error", "failed", "to", "synthesize", "context", "for", "entity", "id", "result", "entity", "id", "bundle", "target", "entity", "id"], "metadata": {"kind": "method", "chunk_index": "1", "has_docstring": "true", "last_modified": "1768240645.0484078"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/service.py::KnowCodeService.get_context::2", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/service.py::KnowCodeService.get_context", "content": "t for {entity.id}\")\n\n        result = {\n            \"entity_id\": bundle.target_entity.id,\n            \"context_text\": bundle.context_text,\n            \"total_tokens\": bundle.total_tokens,\n            \"truncated\": bundle.truncated,\n            \"included_entities\": bundle.included_entities,\n        }\n        \n        # Add task-specific fields if using task synthesis\n        if hasattr(bundle, 'task_type') and hasattr(bundle, 'sufficiency_score'):\n            result[\"task_type\"] = bundle.task_type.value if bundle.task_type else \"general\"\n            result[\"sufficiency_score\"] = bundle.sufficiency_score\n        else:\n            result[\"task_type\"] = \"general\"\n            result[\"sufficiency_score\"] = 0.0\n            \n        return result", "tokens": ["for", "entity", "id", "result", "entity", "id", "bundle", "target", "entity", "id", "context", "text", "bundle", "context", "text", "total", "tokens", "bundle", "total", "tokens", "truncated", "bundle", "truncated", "included", "entities", "bundle", "included", "entities", "add", "task", "specific", "fields", "if", "using", "task", "synthesis", "if", "hasattr", "bundle", "task", "type", "and", "hasattr", "bundle", "sufficiency", "score", "result", "task", "type", "bundle", "task", "type", "value", "if", "bundle", "task", "type", "else", "general", "result", "sufficiency", "score", "bundle", "sufficiency", "score", "else", "result", "task", "type", "general", "result", "sufficiency", "score", "return", "result"], "metadata": {"kind": "method", "chunk_index": "2", "has_docstring": "true", "last_modified": "1768240645.0484078"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/service.py::KnowCodeService.get_stats::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/service.py::KnowCodeService.get_stats", "content": "def get_stats(self) -> dict[str, Any]\n\"\"\"Get statistics from the current store.\n\nReturns:\n    Aggregated counts of entities, relationships, and index state.\"\"\"\n    def get_stats(self) -> dict[str, Any]:\n        \"\"\"Get statistics from the current store.\n\n        Returns:\n            Aggregated counts of entities, relationships, and index state.\n        \"\"\"\n        # This is slightly different from builder.stats() as we might not have the builder\n        by_kind: dict[str, int] = {}\n        for entity in self.store.entities.values():\n            kind = entity.kind.value\n            by_kind[kind] = by_kind.get(kind, 0) + 1\n\n        rel_types: dict[str, int] = {}\n        for rel in self.store.relationships:\n            kind = rel.kind.value\n            rel_types[kind] = rel_types.get(kind, 0) + 1\n\n        stats = {\n            \"total_entities\": len(self.store.entities),\n            \"entities_by_kind\": by_kind,\n            \"total_relationships\": len(self.store.relationships),\n            \"r", "tokens": ["def", "get", "stats", "self", "dict", "str", "any", "get", "statistics", "from", "the", "current", "store", "returns", "aggregated", "counts", "of", "entities", "relationships", "and", "index", "state", "def", "get", "stats", "self", "dict", "str", "any", "get", "statistics", "from", "the", "current", "store", "returns", "aggregated", "counts", "of", "entities", "relationships", "and", "index", "state", "this", "is", "slightly", "different", "from", "builder", "stats", "as", "we", "might", "not", "have", "the", "builder", "by", "kind", "dict", "str", "int", "for", "entity", "in", "self", "store", "entities", "values", "kind", "entity", "kind", "value", "by", "kind", "kind", "by", "kind", "get", "kind", "rel", "types", "dict", "str", "int", "for", "rel", "in", "self", "store", "relationships", "kind", "rel", "kind", "value", "rel", "types", "kind", "rel", "types", "get", "kind", "stats", "total", "entities", "len", "self", "store", "entities", "entities", "by", "kind", "by", "kind", "total", "relationships", "len", "self", "store", "relationships"], "metadata": {"kind": "method", "chunk_index": "0", "has_docstring": "true", "last_modified": "1768240645.0484078"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/service.py::KnowCodeService.get_stats::1", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/service.py::KnowCodeService.get_stats", "content": "_by_kind\": by_kind,\n            \"total_relationships\": len(self.store.relationships),\n            \"relationships_by_type\": rel_types,\n        }\n        \n        # Add index stats if indexer is loaded\n        if self._indexer:\n            stats[\"total_chunks\"] = len(self._indexer.chunk_repo._chunks)\n            if hasattr(self._indexer.vector_store, \"index\") and self._indexer.vector_store.index:\n                stats[\"vector_index_size\"] = self._indexer.vector_store.index.ntotal\n                \n        return stats", "tokens": ["by", "kind", "by", "kind", "total", "relationships", "len", "self", "store", "relationships", "relationships", "by", "type", "rel", "types", "add", "index", "stats", "if", "indexer", "is", "loaded", "if", "self", "indexer", "stats", "total", "chunks", "len", "self", "indexer", "chunk", "repo", "chunks", "if", "hasattr", "self", "indexer", "vector", "store", "index", "and", "self", "indexer", "vector", "store", "index", "stats", "vector", "index", "size", "self", "indexer", "vector", "store", "index", "ntotal", "return", "stats"], "metadata": {"kind": "method", "chunk_index": "1", "has_docstring": "true", "last_modified": "1768240645.0484078"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/service.py::KnowCodeService.get_callers::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/service.py::KnowCodeService.get_callers", "content": "def get_callers(self, entity_id: str) -> list[dict[str, Any]]\n\"\"\"Get callers of an entity.\n\nArgs:\n    entity_id: Entity ID to look up.\n\nReturns:\n    Caller metadata dictionaries.\"\"\"\n    def get_callers(self, entity_id: str) -> list[dict[str, Any]]:\n        \"\"\"Get callers of an entity.\n\n        Args:\n            entity_id: Entity ID to look up.\n\n        Returns:\n            Caller metadata dictionaries.\n        \"\"\"\n        callers = self.store.get_callers(entity_id)\n        return [{\"id\": c.id, \"name\": c.qualified_name, \"file\": c.location.file_path} for c in callers]", "tokens": ["def", "get", "callers", "self", "entity", "id", "str", "list", "dict", "str", "any", "get", "callers", "of", "an", "entity", "args", "entity", "id", "entity", "id", "to", "look", "up", "returns", "caller", "metadata", "dictionaries", "def", "get", "callers", "self", "entity", "id", "str", "list", "dict", "str", "any", "get", "callers", "of", "an", "entity", "args", "entity", "id", "entity", "id", "to", "look", "up", "returns", "caller", "metadata", "dictionaries", "callers", "self", "store", "get", "callers", "entity", "id", "return", "id", "id", "name", "qualified", "name", "file", "location", "file", "path", "for", "in", "callers"], "metadata": {"kind": "method", "has_docstring": "true", "last_modified": "1768240645.0484078"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/service.py::KnowCodeService.reload::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/service.py::KnowCodeService.reload", "content": "def reload(self) -> None\n\"\"\"Reload the knowledge store from disk.\n\nUseful when the underlying JSON file has been updated by a \nseparate process (e.g., a CLI scan).\"\"\"\n    def reload(self) -> None:\n        \"\"\"Reload the knowledge store from disk.\n        \n        Useful when the underlying JSON file has been updated by a \n        separate process (e.g., a CLI scan).\n        \"\"\"\n        self._store = None\n        try:\n            # Force reload by accessing the property\n            _ = self.store\n        except FileNotFoundError:\n            # If the file is gone, keep _store as None\n            pass", "tokens": ["def", "reload", "self", "none", "reload", "the", "knowledge", "store", "from", "disk", "useful", "when", "the", "underlying", "json", "file", "has", "been", "updated", "by", "separate", "process", "cli", "scan", "def", "reload", "self", "none", "reload", "the", "knowledge", "store", "from", "disk", "useful", "when", "the", "underlying", "json", "file", "has", "been", "updated", "by", "separate", "process", "cli", "scan", "self", "store", "none", "try", "force", "reload", "by", "accessing", "the", "property", "self", "store", "except", "file", "not", "found", "error", "if", "the", "file", "is", "gone", "keep", "store", "as", "none", "pass"], "metadata": {"kind": "method", "has_docstring": "true", "last_modified": "1768240645.0484078"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/service.py::KnowCodeService.get_entity_details::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/service.py::KnowCodeService.get_entity_details", "content": "def get_entity_details(self, entity_id: str) -> Optional[dict[str, Any]]\n\"\"\"Get detailed information about an entity as a dictionary.\n\nThis returns the raw structured data including source code, \ndocstrings, and metadata, which is useful for tool-calling agents.\"\"\"\n    def get_entity_details(self, entity_id: str) -> Optional[dict[str, Any]]:\n        \"\"\"Get detailed information about an entity as a dictionary.\n        \n        This returns the raw structured data including source code, \n        docstrings, and metadata, which is useful for tool-calling agents.\n        \"\"\"\n        entity = self.store.get_entity(entity_id)\n        if not entity:\n            return None\n        \n        # Convert to dictionary (using internal helper or creating one)\n        # We can reuse the knowledge store's _entity_to_dict if exposed, \n        # or just construct it manually here to be safe and explicit.\n        from dataclasses import asdict\n\n        return {\n            \"id\": entity.id,\n            \"k", "tokens": ["def", "get", "entity", "details", "self", "entity", "id", "str", "optional", "dict", "str", "any", "get", "detailed", "information", "about", "an", "entity", "as", "dictionary", "this", "returns", "the", "raw", "structured", "data", "including", "source", "code", "docstrings", "and", "metadata", "which", "is", "useful", "for", "tool", "calling", "agents", "def", "get", "entity", "details", "self", "entity", "id", "str", "optional", "dict", "str", "any", "get", "detailed", "information", "about", "an", "entity", "as", "dictionary", "this", "returns", "the", "raw", "structured", "data", "including", "source", "code", "docstrings", "and", "metadata", "which", "is", "useful", "for", "tool", "calling", "agents", "entity", "self", "store", "get", "entity", "entity", "id", "if", "not", "entity", "return", "none", "convert", "to", "dictionary", "using", "internal", "helper", "or", "creating", "one", "we", "can", "reuse", "the", "knowledge", "store", "entity", "to", "dict", "if", "exposed", "or", "just", "construct", "it", "manually", "here", "to", "be", "safe", "and", "explicit", "from", "dataclasses", "import", "asdict", "return", "id", "entity", "id"], "metadata": {"kind": "method", "chunk_index": "0", "has_docstring": "true", "last_modified": "1768240645.0484078"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/service.py::KnowCodeService.get_entity_details::1", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/service.py::KnowCodeService.get_entity_details", "content": "        from dataclasses import asdict\n\n        return {\n            \"id\": entity.id,\n            \"kind\": entity.kind.value,\n            \"name\": entity.name,\n            \"qualified_name\": entity.qualified_name,\n            \"location\": asdict(entity.location),\n            \"docstring\": entity.docstring,\n            \"signature\": entity.signature,\n            \"source_code\": entity.source_code,\n            \"metadata\": entity.metadata,\n        }", "tokens": ["from", "dataclasses", "import", "asdict", "return", "id", "entity", "id", "kind", "entity", "kind", "value", "name", "entity", "name", "qualified", "name", "entity", "qualified", "name", "location", "asdict", "entity", "location", "docstring", "entity", "docstring", "signature", "entity", "signature", "source", "code", "entity", "source", "code", "metadata", "entity", "metadata"], "metadata": {"kind": "method", "chunk_index": "1", "has_docstring": "true", "last_modified": "1768240645.0484078"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/service.py::KnowCodeService.get_callees::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/service.py::KnowCodeService.get_callees", "content": "def get_callees(self, entity_id: str) -> list[dict[str, Any]]\n\"\"\"Get callees of an entity.\n\nArgs:\n    entity_id: Entity ID to look up.\n\nReturns:\n    Callee metadata dictionaries.\"\"\"\n    def get_callees(self, entity_id: str) -> list[dict[str, Any]]:\n        \"\"\"Get callees of an entity.\n\n        Args:\n            entity_id: Entity ID to look up.\n\n        Returns:\n            Callee metadata dictionaries.\n        \"\"\"\n        callees = self.store.get_callees(entity_id)\n        return [{\"id\": c.id, \"name\": c.qualified_name} for c in callees]", "tokens": ["def", "get", "callees", "self", "entity", "id", "str", "list", "dict", "str", "any", "get", "callees", "of", "an", "entity", "args", "entity", "id", "entity", "id", "to", "look", "up", "returns", "callee", "metadata", "dictionaries", "def", "get", "callees", "self", "entity", "id", "str", "list", "dict", "str", "any", "get", "callees", "of", "an", "entity", "args", "entity", "id", "entity", "id", "to", "look", "up", "returns", "callee", "metadata", "dictionaries", "callees", "self", "store", "get", "callees", "entity", "id", "return", "id", "id", "name", "qualified", "name", "for", "in", "callees"], "metadata": {"kind": "method", "has_docstring": "true", "last_modified": "1768240645.0484078"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/models.py::module::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/models.py::module", "content": "\"\"\"Compatibility module for legacy imports.\n\nRe-exports data model symbols from knowcode.data_models.\n\"\"\"", "tokens": ["compatibility", "module", "for", "legacy", "imports", "re", "exports", "data", "model", "symbols", "from", "knowcode", "data", "models"], "metadata": {"type": "module_header"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/models.py::imports::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/models.py::module", "content": "from knowcode.data_models import (  # noqa: F401", "tokens": ["from", "knowcode", "data", "models", "import", "noqa", "f401"], "metadata": {"type": "imports"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/retrieval/search_engine.py::module::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/retrieval/search_engine.py::module", "content": "\"\"\"Search engine orchestrating the retrieval pipeline.\"\"\"", "tokens": ["search", "engine", "orchestrating", "the", "retrieval", "pipeline"], "metadata": {"type": "module_header"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/retrieval/search_engine.py::imports::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/retrieval/search_engine.py::module", "content": "from __future__ import annotations\nfrom dataclasses import dataclass\nfrom typing import Optional\nfrom knowcode.storage.chunk_repository import ChunkRepository\nfrom knowcode.retrieval.completeness import expand_dependencies\nfrom knowcode.llm.embedding import EmbeddingProvider\nfrom knowcode.retrieval.hybrid_index import HybridIndex\nfrom knowcode.storage.knowledge_store import KnowledgeStore\nfrom knowcode.data_models import CodeChunk\nfrom knowcode.retrieval.reranker import Reranker\nfrom knowcode.config import AppConfig", "tokens": ["from", "future", "import", "annotations", "from", "dataclasses", "import", "dataclass", "from", "typing", "import", "optional", "from", "knowcode", "storage", "chunk", "repository", "import", "chunk", "repository", "from", "knowcode", "retrieval", "completeness", "import", "expand", "dependencies", "from", "knowcode", "llm", "embedding", "import", "embedding", "provider", "from", "knowcode", "retrieval", "hybrid", "index", "import", "hybrid", "index", "from", "knowcode", "storage", "knowledge", "store", "import", "knowledge", "store", "from", "knowcode", "data", "models", "import", "code", "chunk", "from", "knowcode", "retrieval", "reranker", "import", "reranker", "from", "knowcode", "config", "import", "app", "config"], "metadata": {"type": "imports"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/retrieval/search_engine.py::ScoredChunk::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/retrieval/search_engine.py::ScoredChunk", "content": "\"\"\"A retrieved chunk with an attached score and provenance.\"\"\"\nclass ScoredChunk:\n    \"\"\"A retrieved chunk with an attached score and provenance.\"\"\"\n\n    chunk: CodeChunk\n    score: float\n    source: str  # \"retrieved\" | \"dependency\"", "tokens": ["retrieved", "chunk", "with", "an", "attached", "score", "and", "provenance", "class", "scored", "chunk", "retrieved", "chunk", "with", "an", "attached", "score", "and", "provenance", "chunk", "code", "chunk", "score", "float", "source", "str", "retrieved", "dependency"], "metadata": {"kind": "class", "has_docstring": "true", "last_modified": "1768185812.9936173"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/retrieval/search_engine.py::SearchEngine::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/retrieval/search_engine.py::SearchEngine", "content": "\"\"\"Orchestrates: embed query -> hybrid search -> rerank -> completeness.\"\"\"\nclass SearchEngine:\n    \"\"\"Orchestrates: embed query -> hybrid search -> rerank -> completeness.\"\"\"\n\n    def __init__(\n        self,\n        chunk_repo: ChunkRepository,\n        embedding_provider: EmbeddingProvider,\n        hybrid_index: HybridIndex,\n        knowledge_store: KnowledgeStore,\n        config: Optional[AppConfig] = None,\n        use_voyageai_reranking: bool = True,\n    ) -> None:\n        \"\"\"Initialize the search engine pipeline.\n\n        Args:\n            chunk_repo: Chunk repository backing BM25 search.\n            embedding_provider: Provider for generating query embeddings.\n            hybrid_index: Combined sparse+dense index used for retrieval.\n            knowledge_store: Graph store used to expand dependency context.\n            config: AppConfig with reranking model settings.\n            use_voyageai_reranking: Whether to try VoyageAI for reranking.\n        \"\"\"\n        self.chunk_repo = ch", "tokens": ["orchestrates", "embed", "query", "hybrid", "search", "rerank", "completeness", "class", "search", "engine", "orchestrates", "embed", "query", "hybrid", "search", "rerank", "completeness", "def", "init", "self", "chunk", "repo", "chunk", "repository", "embedding", "provider", "embedding", "provider", "hybrid", "index", "hybrid", "index", "knowledge", "store", "knowledge", "store", "config", "optional", "app", "config", "none", "use", "voyageai", "reranking", "bool", "true", "none", "initialize", "the", "search", "engine", "pipeline", "args", "chunk", "repo", "chunk", "repository", "backing", "bm25", "search", "embedding", "provider", "provider", "for", "generating", "query", "embeddings", "hybrid", "index", "combined", "sparse", "dense", "index", "used", "for", "retrieval", "knowledge", "store", "graph", "store", "used", "to", "expand", "dependency", "context", "config", "app", "config", "with", "reranking", "model", "settings", "use", "voyageai", "reranking", "whether", "to", "try", "voyage", "ai", "for", "reranking", "self", "chunk", "repo", "ch"], "metadata": {"kind": "class", "chunk_index": "0", "has_docstring": "true", "last_modified": "1768185812.9936173"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/retrieval/search_engine.py::SearchEngine::1", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/retrieval/search_engine.py::SearchEngine", "content": "_voyageai_reranking: Whether to try VoyageAI for reranking.\n        \"\"\"\n        self.chunk_repo = chunk_repo\n        self.embedding_provider = embedding_provider\n        self.hybrid_index = hybrid_index\n        self.knowledge_store = knowledge_store\n        self.reranker = Reranker(\n            use_voyageai=use_voyageai_reranking,\n            config=config,\n        )\n\n    def search_scored(\n        self,\n        query: str,\n        limit: int = 10,\n        expand_deps: bool = True,\n    ) -> list[ScoredChunk]:\n        \"\"\"Execute the full search pipeline and return scored chunks.\n\n        This is similar to search(), but retains relevance scores and labels\n        dependency-expanded chunks so callers can build evidence-aware outputs.\n\n        Args:\n            query: Natural language query string.\n            limit: Maximum number of primary chunks to return (before expansion).\n            expand_deps: Whether to include dependency context from the graph.\n\n        Returns:\n            R", "tokens": ["voyageai", "reranking", "whether", "to", "try", "voyage", "ai", "for", "reranking", "self", "chunk", "repo", "chunk", "repo", "self", "embedding", "provider", "embedding", "provider", "self", "hybrid", "index", "hybrid", "index", "self", "knowledge", "store", "knowledge", "store", "self", "reranker", "reranker", "use", "voyageai", "use", "voyageai", "reranking", "config", "config", "def", "search", "scored", "self", "query", "str", "limit", "int", "10", "expand", "deps", "bool", "true", "list", "scored", "chunk", "execute", "the", "full", "search", "pipeline", "and", "return", "scored", "chunks", "this", "is", "similar", "to", "search", "but", "retains", "relevance", "scores", "and", "labels", "dependency", "expanded", "chunks", "so", "callers", "can", "build", "evidence", "aware", "outputs", "args", "query", "natural", "language", "query", "string", "limit", "maximum", "number", "of", "primary", "chunks", "to", "return", "before", "expansion", "expand", "deps", "whether", "to", "include", "dependency", "context", "from", "the", "graph", "returns"], "metadata": {"kind": "class", "chunk_index": "1", "has_docstring": "true", "last_modified": "1768185812.9936173"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/retrieval/search_engine.py::SearchEngine::2", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/retrieval/search_engine.py::SearchEngine", "content": "  expand_deps: Whether to include dependency context from the graph.\n\n        Returns:\n            Ranked list of ScoredChunk objects.\n        \"\"\"\n        query_embedding = self.embedding_provider.embed_single(query)\n        results = self.hybrid_index.search(query, query_embedding, limit=limit * 2)\n        reranked = self.reranker.rerank(query, results, top_k=limit)\n        primary = [ScoredChunk(chunk=c, score=s, source=\"retrieved\") for c, s in reranked]\n\n        if not expand_deps:\n            return primary\n\n        expanded: list[ScoredChunk] = []\n        seen_ids: set[str] = set()\n\n        for scored in primary:\n            deps = expand_dependencies(\n                scored.chunk,\n                self.chunk_repo,\n                self.knowledge_store,\n                max_depth=1,\n            )\n            for dep in deps:\n                if dep.id in seen_ids:\n                    continue\n                seen_ids.add(dep.id)\n                expanded.append(\n                    Sco", "tokens": ["expand", "deps", "whether", "to", "include", "dependency", "context", "from", "the", "graph", "returns", "ranked", "list", "of", "scored", "chunk", "objects", "query", "embedding", "self", "embedding", "provider", "embed", "single", "query", "results", "self", "hybrid", "index", "search", "query", "query", "embedding", "limit", "limit", "reranked", "self", "reranker", "rerank", "query", "results", "top", "limit", "primary", "scored", "chunk", "chunk", "score", "source", "retrieved", "for", "in", "reranked", "if", "not", "expand", "deps", "return", "primary", "expanded", "list", "scored", "chunk", "seen", "ids", "set", "str", "set", "for", "scored", "in", "primary", "deps", "expand", "dependencies", "scored", "chunk", "self", "chunk", "repo", "self", "knowledge", "store", "max", "depth", "for", "dep", "in", "deps", "if", "dep", "id", "in", "seen", "ids", "continue", "seen", "ids", "add", "dep", "id", "expanded", "append", "sco"], "metadata": {"kind": "class", "chunk_index": "2", "has_docstring": "true", "last_modified": "1768185812.9936173"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/retrieval/search_engine.py::SearchEngine::3", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/retrieval/search_engine.py::SearchEngine", "content": "ntinue\n                seen_ids.add(dep.id)\n                expanded.append(\n                    ScoredChunk(\n                        chunk=dep,\n                        score=scored.score if dep.id == scored.chunk.id else 0.0,\n                        source=\"retrieved\" if dep.id == scored.chunk.id else \"dependency\",\n                    )\n                )\n\n        return expanded\n\n    def search(\n        self,\n        query: str,\n        limit: int = 10,\n        expand_deps: bool = True\n    ) -> list[CodeChunk]:\n        \"\"\"Execute the full search pipeline.\n\n        Args:\n            query: Natural language query string.\n            limit: Maximum number of chunks to return.\n            expand_deps: Whether to include dependency context from the graph.\n\n        Returns:\n            Ranked list of CodeChunk objects.\n        \"\"\"\n        scored = self.search_scored(query, limit=limit, expand_deps=expand_deps)\n        return [s.chunk for s in scored]\n\n    def _expand_dependencies(self, chun", "tokens": ["ntinue", "seen", "ids", "add", "dep", "id", "expanded", "append", "scored", "chunk", "chunk", "dep", "score", "scored", "score", "if", "dep", "id", "scored", "chunk", "id", "else", "source", "retrieved", "if", "dep", "id", "scored", "chunk", "id", "else", "dependency", "return", "expanded", "def", "search", "self", "query", "str", "limit", "int", "10", "expand", "deps", "bool", "true", "list", "code", "chunk", "execute", "the", "full", "search", "pipeline", "args", "query", "natural", "language", "query", "string", "limit", "maximum", "number", "of", "chunks", "to", "return", "expand", "deps", "whether", "to", "include", "dependency", "context", "from", "the", "graph", "returns", "ranked", "list", "of", "code", "chunk", "objects", "scored", "self", "search", "scored", "query", "limit", "limit", "expand", "deps", "expand", "deps", "return", "chunk", "for", "in", "scored", "def", "expand", "dependencies", "self", "chun"], "metadata": {"kind": "class", "chunk_index": "3", "has_docstring": "true", "last_modified": "1768185812.9936173"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/retrieval/search_engine.py::SearchEngine::4", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/retrieval/search_engine.py::SearchEngine", "content": "_deps=expand_deps)\n        return [s.chunk for s in scored]\n\n    def _expand_dependencies(self, chunks: list[CodeChunk]) -> list[CodeChunk]:\n        \"\"\"Add dependency context to the results using the knowledge graph.\"\"\"\n        expanded = []\n        seen_ids = set()\n        \n        for chunk in chunks:\n            # Expand using graph\n            deps = expand_dependencies(\n                chunk,\n                self.chunk_repo,\n                self.knowledge_store,\n                max_depth=1\n            )\n            for d in deps:\n                if d.id not in seen_ids:\n                    expanded.append(d)\n                    seen_ids.add(d.id)\n                    \n        return expanded", "tokens": ["deps", "expand", "deps", "return", "chunk", "for", "in", "scored", "def", "expand", "dependencies", "self", "chunks", "list", "code", "chunk", "list", "code", "chunk", "add", "dependency", "context", "to", "the", "results", "using", "the", "knowledge", "graph", "expanded", "seen", "ids", "set", "for", "chunk", "in", "chunks", "expand", "using", "graph", "deps", "expand", "dependencies", "chunk", "self", "chunk", "repo", "self", "knowledge", "store", "max", "depth", "for", "in", "deps", "if", "id", "not", "in", "seen", "ids", "expanded", "append", "seen", "ids", "add", "id", "return", "expanded"], "metadata": {"kind": "class", "chunk_index": "4", "has_docstring": "true", "last_modified": "1768185812.9936173"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/retrieval/search_engine.py::SearchEngine.__init__::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/retrieval/search_engine.py::SearchEngine.__init__", "content": "def __init__(self, chunk_repo: ChunkRepository, embedding_provider: EmbeddingProvider, hybrid_index: HybridIndex, knowledge_store: KnowledgeStore, config: Optional[AppConfig], use_voyageai_reranking: bool) -> None\n\"\"\"Initialize the search engine pipeline.\n\nArgs:\n    chunk_repo: Chunk repository backing BM25 search.\n    embedding_provider: Provider for generating query embeddings.\n    hybrid_index: Combined sparse+dense index used for retrieval.\n    knowledge_store: Graph store used to expand dependency context.\n    config: AppConfig with reranking model settings.\n    use_voyageai_reranking: Whether to try VoyageAI for reranking.\"\"\"\n    def __init__(\n        self,\n        chunk_repo: ChunkRepository,\n        embedding_provider: EmbeddingProvider,\n        hybrid_index: HybridIndex,\n        knowledge_store: KnowledgeStore,\n        config: Optional[AppConfig] = None,\n        use_voyageai_reranking: bool = True,\n    ) -> None:\n        \"\"\"Initialize the search engine pipeline.\n\n        Args:", "tokens": ["def", "init", "self", "chunk", "repo", "chunk", "repository", "embedding", "provider", "embedding", "provider", "hybrid", "index", "hybrid", "index", "knowledge", "store", "knowledge", "store", "config", "optional", "app", "config", "use", "voyageai", "reranking", "bool", "none", "initialize", "the", "search", "engine", "pipeline", "args", "chunk", "repo", "chunk", "repository", "backing", "bm25", "search", "embedding", "provider", "provider", "for", "generating", "query", "embeddings", "hybrid", "index", "combined", "sparse", "dense", "index", "used", "for", "retrieval", "knowledge", "store", "graph", "store", "used", "to", "expand", "dependency", "context", "config", "app", "config", "with", "reranking", "model", "settings", "use", "voyageai", "reranking", "whether", "to", "try", "voyage", "ai", "for", "reranking", "def", "init", "self", "chunk", "repo", "chunk", "repository", "embedding", "provider", "embedding", "provider", "hybrid", "index", "hybrid", "index", "knowledge", "store", "knowledge", "store", "config", "optional", "app", "config", "none", "use", "voyageai", "reranking", "bool", "true", "none", "initialize", "the", "search", "engine", "pipeline", "args"], "metadata": {"kind": "method", "chunk_index": "0", "has_docstring": "true", "last_modified": "1768185812.9936173"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/retrieval/search_engine.py::SearchEngine.__init__::1", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/retrieval/search_engine.py::SearchEngine.__init__", "content": "anking: bool = True,\n    ) -> None:\n        \"\"\"Initialize the search engine pipeline.\n\n        Args:\n            chunk_repo: Chunk repository backing BM25 search.\n            embedding_provider: Provider for generating query embeddings.\n            hybrid_index: Combined sparse+dense index used for retrieval.\n            knowledge_store: Graph store used to expand dependency context.\n            config: AppConfig with reranking model settings.\n            use_voyageai_reranking: Whether to try VoyageAI for reranking.\n        \"\"\"\n        self.chunk_repo = chunk_repo\n        self.embedding_provider = embedding_provider\n        self.hybrid_index = hybrid_index\n        self.knowledge_store = knowledge_store\n        self.reranker = Reranker(\n            use_voyageai=use_voyageai_reranking,\n            config=config,\n        )", "tokens": ["anking", "bool", "true", "none", "initialize", "the", "search", "engine", "pipeline", "args", "chunk", "repo", "chunk", "repository", "backing", "bm25", "search", "embedding", "provider", "provider", "for", "generating", "query", "embeddings", "hybrid", "index", "combined", "sparse", "dense", "index", "used", "for", "retrieval", "knowledge", "store", "graph", "store", "used", "to", "expand", "dependency", "context", "config", "app", "config", "with", "reranking", "model", "settings", "use", "voyageai", "reranking", "whether", "to", "try", "voyage", "ai", "for", "reranking", "self", "chunk", "repo", "chunk", "repo", "self", "embedding", "provider", "embedding", "provider", "self", "hybrid", "index", "hybrid", "index", "self", "knowledge", "store", "knowledge", "store", "self", "reranker", "reranker", "use", "voyageai", "use", "voyageai", "reranking", "config", "config"], "metadata": {"kind": "method", "chunk_index": "1", "has_docstring": "true", "last_modified": "1768185812.9936173"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/retrieval/search_engine.py::SearchEngine.search_scored::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/retrieval/search_engine.py::SearchEngine.search_scored", "content": "def search_scored(self, query: str, limit: int, expand_deps: bool) -> list[ScoredChunk]\n\"\"\"Execute the full search pipeline and return scored chunks.\n\nThis is similar to search(), but retains relevance scores and labels\ndependency-expanded chunks so callers can build evidence-aware outputs.\n\nArgs:\n    query: Natural language query string.\n    limit: Maximum number of primary chunks to return (before expansion).\n    expand_deps: Whether to include dependency context from the graph.\n\nReturns:\n    Ranked list of ScoredChunk objects.\"\"\"\n    def search_scored(\n        self,\n        query: str,\n        limit: int = 10,\n        expand_deps: bool = True,\n    ) -> list[ScoredChunk]:\n        \"\"\"Execute the full search pipeline and return scored chunks.\n\n        This is similar to search(), but retains relevance scores and labels\n        dependency-expanded chunks so callers can build evidence-aware outputs.\n\n        Args:\n            query: Natural language query string.\n            limit: Maxim", "tokens": ["def", "search", "scored", "self", "query", "str", "limit", "int", "expand", "deps", "bool", "list", "scored", "chunk", "execute", "the", "full", "search", "pipeline", "and", "return", "scored", "chunks", "this", "is", "similar", "to", "search", "but", "retains", "relevance", "scores", "and", "labels", "dependency", "expanded", "chunks", "so", "callers", "can", "build", "evidence", "aware", "outputs", "args", "query", "natural", "language", "query", "string", "limit", "maximum", "number", "of", "primary", "chunks", "to", "return", "before", "expansion", "expand", "deps", "whether", "to", "include", "dependency", "context", "from", "the", "graph", "returns", "ranked", "list", "of", "scored", "chunk", "objects", "def", "search", "scored", "self", "query", "str", "limit", "int", "10", "expand", "deps", "bool", "true", "list", "scored", "chunk", "execute", "the", "full", "search", "pipeline", "and", "return", "scored", "chunks", "this", "is", "similar", "to", "search", "but", "retains", "relevance", "scores", "and", "labels", "dependency", "expanded", "chunks", "so", "callers", "can", "build", "evidence", "aware", "outputs", "args", "query", "natural", "language", "query", "string", "limit", "maxim"], "metadata": {"kind": "method", "chunk_index": "0", "has_docstring": "true", "last_modified": "1768185812.9936173"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/retrieval/search_engine.py::SearchEngine.search_scored::1", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/retrieval/search_engine.py::SearchEngine.search_scored", "content": "e outputs.\n\n        Args:\n            query: Natural language query string.\n            limit: Maximum number of primary chunks to return (before expansion).\n            expand_deps: Whether to include dependency context from the graph.\n\n        Returns:\n            Ranked list of ScoredChunk objects.\n        \"\"\"\n        query_embedding = self.embedding_provider.embed_single(query)\n        results = self.hybrid_index.search(query, query_embedding, limit=limit * 2)\n        reranked = self.reranker.rerank(query, results, top_k=limit)\n        primary = [ScoredChunk(chunk=c, score=s, source=\"retrieved\") for c, s in reranked]\n\n        if not expand_deps:\n            return primary\n\n        expanded: list[ScoredChunk] = []\n        seen_ids: set[str] = set()\n\n        for scored in primary:\n            deps = expand_dependencies(\n                scored.chunk,\n                self.chunk_repo,\n                self.knowledge_store,\n                max_depth=1,\n            )\n            for dep in", "tokens": ["outputs", "args", "query", "natural", "language", "query", "string", "limit", "maximum", "number", "of", "primary", "chunks", "to", "return", "before", "expansion", "expand", "deps", "whether", "to", "include", "dependency", "context", "from", "the", "graph", "returns", "ranked", "list", "of", "scored", "chunk", "objects", "query", "embedding", "self", "embedding", "provider", "embed", "single", "query", "results", "self", "hybrid", "index", "search", "query", "query", "embedding", "limit", "limit", "reranked", "self", "reranker", "rerank", "query", "results", "top", "limit", "primary", "scored", "chunk", "chunk", "score", "source", "retrieved", "for", "in", "reranked", "if", "not", "expand", "deps", "return", "primary", "expanded", "list", "scored", "chunk", "seen", "ids", "set", "str", "set", "for", "scored", "in", "primary", "deps", "expand", "dependencies", "scored", "chunk", "self", "chunk", "repo", "self", "knowledge", "store", "max", "depth", "for", "dep", "in"], "metadata": {"kind": "method", "chunk_index": "1", "has_docstring": "true", "last_modified": "1768185812.9936173"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/retrieval/search_engine.py::SearchEngine.search_scored::2", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/retrieval/search_engine.py::SearchEngine.search_scored", "content": "             self.knowledge_store,\n                max_depth=1,\n            )\n            for dep in deps:\n                if dep.id in seen_ids:\n                    continue\n                seen_ids.add(dep.id)\n                expanded.append(\n                    ScoredChunk(\n                        chunk=dep,\n                        score=scored.score if dep.id == scored.chunk.id else 0.0,\n                        source=\"retrieved\" if dep.id == scored.chunk.id else \"dependency\",\n                    )\n                )\n\n        return expanded", "tokens": ["self", "knowledge", "store", "max", "depth", "for", "dep", "in", "deps", "if", "dep", "id", "in", "seen", "ids", "continue", "seen", "ids", "add", "dep", "id", "expanded", "append", "scored", "chunk", "chunk", "dep", "score", "scored", "score", "if", "dep", "id", "scored", "chunk", "id", "else", "source", "retrieved", "if", "dep", "id", "scored", "chunk", "id", "else", "dependency", "return", "expanded"], "metadata": {"kind": "method", "chunk_index": "2", "has_docstring": "true", "last_modified": "1768185812.9936173"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/retrieval/search_engine.py::SearchEngine.search::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/retrieval/search_engine.py::SearchEngine.search", "content": "def search(self, query: str, limit: int, expand_deps: bool) -> list[CodeChunk]\n\"\"\"Execute the full search pipeline.\n\nArgs:\n    query: Natural language query string.\n    limit: Maximum number of chunks to return.\n    expand_deps: Whether to include dependency context from the graph.\n\nReturns:\n    Ranked list of CodeChunk objects.\"\"\"\n    def search(\n        self,\n        query: str,\n        limit: int = 10,\n        expand_deps: bool = True\n    ) -> list[CodeChunk]:\n        \"\"\"Execute the full search pipeline.\n\n        Args:\n            query: Natural language query string.\n            limit: Maximum number of chunks to return.\n            expand_deps: Whether to include dependency context from the graph.\n\n        Returns:\n            Ranked list of CodeChunk objects.\n        \"\"\"\n        scored = self.search_scored(query, limit=limit, expand_deps=expand_deps)\n        return [s.chunk for s in scored]", "tokens": ["def", "search", "self", "query", "str", "limit", "int", "expand", "deps", "bool", "list", "code", "chunk", "execute", "the", "full", "search", "pipeline", "args", "query", "natural", "language", "query", "string", "limit", "maximum", "number", "of", "chunks", "to", "return", "expand", "deps", "whether", "to", "include", "dependency", "context", "from", "the", "graph", "returns", "ranked", "list", "of", "code", "chunk", "objects", "def", "search", "self", "query", "str", "limit", "int", "10", "expand", "deps", "bool", "true", "list", "code", "chunk", "execute", "the", "full", "search", "pipeline", "args", "query", "natural", "language", "query", "string", "limit", "maximum", "number", "of", "chunks", "to", "return", "expand", "deps", "whether", "to", "include", "dependency", "context", "from", "the", "graph", "returns", "ranked", "list", "of", "code", "chunk", "objects", "scored", "self", "search", "scored", "query", "limit", "limit", "expand", "deps", "expand", "deps", "return", "chunk", "for", "in", "scored"], "metadata": {"kind": "method", "has_docstring": "true", "last_modified": "1768185812.9936173"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/retrieval/search_engine.py::SearchEngine._expand_dependencies::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/retrieval/search_engine.py::SearchEngine._expand_dependencies", "content": "def _expand_dependencies(self, chunks: list[CodeChunk]) -> list[CodeChunk]\n\"\"\"Add dependency context to the results using the knowledge graph.\"\"\"\n    def _expand_dependencies(self, chunks: list[CodeChunk]) -> list[CodeChunk]:\n        \"\"\"Add dependency context to the results using the knowledge graph.\"\"\"\n        expanded = []\n        seen_ids = set()\n        \n        for chunk in chunks:\n            # Expand using graph\n            deps = expand_dependencies(\n                chunk,\n                self.chunk_repo,\n                self.knowledge_store,\n                max_depth=1\n            )\n            for d in deps:\n                if d.id not in seen_ids:\n                    expanded.append(d)\n                    seen_ids.add(d.id)\n                    \n        return expanded", "tokens": ["def", "expand", "dependencies", "self", "chunks", "list", "code", "chunk", "list", "code", "chunk", "add", "dependency", "context", "to", "the", "results", "using", "the", "knowledge", "graph", "def", "expand", "dependencies", "self", "chunks", "list", "code", "chunk", "list", "code", "chunk", "add", "dependency", "context", "to", "the", "results", "using", "the", "knowledge", "graph", "expanded", "seen", "ids", "set", "for", "chunk", "in", "chunks", "expand", "using", "graph", "deps", "expand", "dependencies", "chunk", "self", "chunk", "repo", "self", "knowledge", "store", "max", "depth", "for", "in", "deps", "if", "id", "not", "in", "seen", "ids", "expanded", "append", "seen", "ids", "add", "id", "return", "expanded"], "metadata": {"kind": "method", "has_docstring": "true", "last_modified": "1768185812.9936173"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/retrieval/hybrid_index.py::module::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/retrieval/hybrid_index.py::module", "content": "\"\"\"Hybrid BM25 + Vector search index.\"\"\"", "tokens": ["hybrid", "bm25", "vector", "search", "index"], "metadata": {"type": "module_header"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/retrieval/hybrid_index.py::imports::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/retrieval/hybrid_index.py::module", "content": "from knowcode.storage.chunk_repository import ChunkRepository\nfrom knowcode.data_models import CodeChunk\nfrom knowcode.utils.tokenizer import tokenize_code\nfrom knowcode.storage.vector_store import VectorStore", "tokens": ["from", "knowcode", "storage", "chunk", "repository", "import", "chunk", "repository", "from", "knowcode", "data", "models", "import", "code", "chunk", "from", "knowcode", "utils", "tokenizer", "import", "tokenize", "code", "from", "knowcode", "storage", "vector", "store", "import", "vector", "store"], "metadata": {"type": "imports"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/retrieval/hybrid_index.py::HybridIndex::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/retrieval/hybrid_index.py::HybridIndex", "content": "\"\"\"Combines BM25 sparse retrieval with dense vector search.\"\"\"\nclass HybridIndex:\n    \"\"\"Combines BM25 sparse retrieval with dense vector search.\"\"\"\n\n    def __init__(\n        self,\n        chunk_repo: ChunkRepository,\n        vector_store: VectorStore,\n        alpha: float = 0.5  # Weight for dense vs sparse (0.5 = equal weight)\n    ) -> None:\n        \"\"\"Initialize the hybrid index.\n\n        Args:\n            chunk_repo: Repository providing BM25-style token search.\n            vector_store: Dense vector store for semantic similarity.\n            alpha: Blend weight for dense vs sparse results.\n        \"\"\"\n        self.chunk_repo = chunk_repo\n        self.vector_store = vector_store\n        self.alpha = alpha\n\n    def search(\n        self,\n        query: str,\n        query_embedding: list[float],\n        limit: int = 10\n    ) -> list[tuple[CodeChunk, float]]:\n        \"\"\"Search using hybrid retrieval. \n        Combines BM25 sparse retrieval with dense vector search.         \n        Re", "tokens": ["combines", "bm25", "sparse", "retrieval", "with", "dense", "vector", "search", "class", "hybrid", "index", "combines", "bm25", "sparse", "retrieval", "with", "dense", "vector", "search", "def", "init", "self", "chunk", "repo", "chunk", "repository", "vector", "store", "vector", "store", "alpha", "float", "weight", "for", "dense", "vs", "sparse", "equal", "weight", "none", "initialize", "the", "hybrid", "index", "args", "chunk", "repo", "repository", "providing", "bm25", "style", "token", "search", "vector", "store", "dense", "vector", "store", "for", "semantic", "similarity", "alpha", "blend", "weight", "for", "dense", "vs", "sparse", "results", "self", "chunk", "repo", "chunk", "repo", "self", "vector", "store", "vector", "store", "self", "alpha", "alpha", "def", "search", "self", "query", "str", "query", "embedding", "list", "float", "limit", "int", "10", "list", "tuple", "code", "chunk", "float", "search", "using", "hybrid", "retrieval", "combines", "bm25", "sparse", "retrieval", "with", "dense", "vector", "search", "re"], "metadata": {"kind": "class", "chunk_index": "0", "has_docstring": "true", "last_modified": "1768185812.9936173"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/retrieval/hybrid_index.py::HybridIndex::1", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/retrieval/hybrid_index.py::HybridIndex", "content": "rid retrieval. \n        Combines BM25 sparse retrieval with dense vector search.         \n        Returns chunks with combined scores using Reciprocal Rank Fusion (RRF).\n\n        Args:\n            query: Raw query string for sparse matching.\n            query_embedding: Dense embedding of the query.\n            limit: Maximum number of chunks to return.\n\n        Returns:\n            List of (chunk, score) tuples ranked by reciprocal rank fusion.\n        \"\"\"\n        # 1. BM25 Search\n        query_tokens = tokenize_code(query)\n        # We get more results for fusion\n        sparse_results = self.chunk_repo.search_by_tokens(query_tokens, limit=limit * 2)\n        \n        # 2. Vector Search\n        dense_results = self.vector_store.search(query_embedding, limit=limit * 2)\n        \n        # 3. Combine scores (RRF)\n        combined_scores: dict[str, float] = {}\n        \n        # Constant for RRF to avoid division by zero and dampen top ranks\n        K = 60\n        \n        for rank, chunk", "tokens": ["rid", "retrieval", "combines", "bm25", "sparse", "retrieval", "with", "dense", "vector", "search", "returns", "chunks", "with", "combined", "scores", "using", "reciprocal", "rank", "fusion", "rrf", "args", "query", "raw", "query", "string", "for", "sparse", "matching", "query", "embedding", "dense", "embedding", "of", "the", "query", "limit", "maximum", "number", "of", "chunks", "to", "return", "returns", "list", "of", "chunk", "score", "tuples", "ranked", "by", "reciprocal", "rank", "fusion", "bm25", "search", "query", "tokens", "tokenize", "code", "query", "we", "get", "more", "results", "for", "fusion", "sparse", "results", "self", "chunk", "repo", "search", "by", "tokens", "query", "tokens", "limit", "limit", "vector", "search", "dense", "results", "self", "vector", "store", "search", "query", "embedding", "limit", "limit", "combine", "scores", "rrf", "combined", "scores", "dict", "str", "float", "constant", "for", "rrf", "to", "avoid", "division", "by", "zero", "and", "dampen", "top", "ranks", "60", "for", "rank", "chunk"], "metadata": {"kind": "class", "chunk_index": "1", "has_docstring": "true", "last_modified": "1768185812.9936173"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/retrieval/hybrid_index.py::HybridIndex::2", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/retrieval/hybrid_index.py::HybridIndex", "content": "r RRF to avoid division by zero and dampen top ranks\n        K = 60\n        \n        for rank, chunk in enumerate(sparse_results):\n            combined_scores[chunk.id] = combined_scores.get(chunk.id, 0.0) + (1.0 - self.alpha) / (K + rank + 1)\n            \n        for rank, (chunk_id, _) in enumerate(dense_results):\n            combined_scores[chunk_id] = combined_scores.get(chunk_id, 0.0) + self.alpha / (K + rank + 1)\n            \n        # 4. Sort and return\n        sorted_ids = sorted(combined_scores.items(), key=lambda x: x[1], reverse=True)\n        \n        results = []\n        for chunk_id, score in sorted_ids[:limit]:\n            chunk = self.chunk_repo.get(chunk_id)\n            if chunk:\n                results.append((chunk, score))\n                \n        return results", "tokens": ["rrf", "to", "avoid", "division", "by", "zero", "and", "dampen", "top", "ranks", "60", "for", "rank", "chunk", "in", "enumerate", "sparse", "results", "combined", "scores", "chunk", "id", "combined", "scores", "get", "chunk", "id", "self", "alpha", "rank", "for", "rank", "chunk", "id", "in", "enumerate", "dense", "results", "combined", "scores", "chunk", "id", "combined", "scores", "get", "chunk", "id", "self", "alpha", "rank", "sort", "and", "return", "sorted", "ids", "sorted", "combined", "scores", "items", "key", "lambda", "reverse", "true", "results", "for", "chunk", "id", "score", "in", "sorted", "ids", "limit", "chunk", "self", "chunk", "repo", "get", "chunk", "id", "if", "chunk", "results", "append", "chunk", "score", "return", "results"], "metadata": {"kind": "class", "chunk_index": "2", "has_docstring": "true", "last_modified": "1768185812.9936173"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/retrieval/hybrid_index.py::HybridIndex.__init__::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/retrieval/hybrid_index.py::HybridIndex.__init__", "content": "def __init__(self, chunk_repo: ChunkRepository, vector_store: VectorStore, alpha: float) -> None\n\"\"\"Initialize the hybrid index.\n\nArgs:\n    chunk_repo: Repository providing BM25-style token search.\n    vector_store: Dense vector store for semantic similarity.\n    alpha: Blend weight for dense vs sparse results.\"\"\"\n    def __init__(\n        self,\n        chunk_repo: ChunkRepository,\n        vector_store: VectorStore,\n        alpha: float = 0.5  # Weight for dense vs sparse (0.5 = equal weight)\n    ) -> None:\n        \"\"\"Initialize the hybrid index.\n\n        Args:\n            chunk_repo: Repository providing BM25-style token search.\n            vector_store: Dense vector store for semantic similarity.\n            alpha: Blend weight for dense vs sparse results.\n        \"\"\"\n        self.chunk_repo = chunk_repo\n        self.vector_store = vector_store\n        self.alpha = alpha", "tokens": ["def", "init", "self", "chunk", "repo", "chunk", "repository", "vector", "store", "vector", "store", "alpha", "float", "none", "initialize", "the", "hybrid", "index", "args", "chunk", "repo", "repository", "providing", "bm25", "style", "token", "search", "vector", "store", "dense", "vector", "store", "for", "semantic", "similarity", "alpha", "blend", "weight", "for", "dense", "vs", "sparse", "results", "def", "init", "self", "chunk", "repo", "chunk", "repository", "vector", "store", "vector", "store", "alpha", "float", "weight", "for", "dense", "vs", "sparse", "equal", "weight", "none", "initialize", "the", "hybrid", "index", "args", "chunk", "repo", "repository", "providing", "bm25", "style", "token", "search", "vector", "store", "dense", "vector", "store", "for", "semantic", "similarity", "alpha", "blend", "weight", "for", "dense", "vs", "sparse", "results", "self", "chunk", "repo", "chunk", "repo", "self", "vector", "store", "vector", "store", "self", "alpha", "alpha"], "metadata": {"kind": "method", "has_docstring": "true", "last_modified": "1768185812.9936173"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/retrieval/hybrid_index.py::HybridIndex.search::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/retrieval/hybrid_index.py::HybridIndex.search", "content": "def search(self, query: str, query_embedding: list[float], limit: int) -> list[tuple[CodeChunk, float]]\n\"\"\"Search using hybrid retrieval. \nCombines BM25 sparse retrieval with dense vector search.         \nReturns chunks with combined scores using Reciprocal Rank Fusion (RRF).\n\nArgs:\n    query: Raw query string for sparse matching.\n    query_embedding: Dense embedding of the query.\n    limit: Maximum number of chunks to return.\n\nReturns:\n    List of (chunk, score) tuples ranked by reciprocal rank fusion.\"\"\"\n    def search(\n        self,\n        query: str,\n        query_embedding: list[float],\n        limit: int = 10\n    ) -> list[tuple[CodeChunk, float]]:\n        \"\"\"Search using hybrid retrieval. \n        Combines BM25 sparse retrieval with dense vector search.         \n        Returns chunks with combined scores using Reciprocal Rank Fusion (RRF).\n\n        Args:\n            query: Raw query string for sparse matching.\n            query_embedding: Dense embedding of the query.\n        ", "tokens": ["def", "search", "self", "query", "str", "query", "embedding", "list", "float", "limit", "int", "list", "tuple", "code", "chunk", "float", "search", "using", "hybrid", "retrieval", "combines", "bm25", "sparse", "retrieval", "with", "dense", "vector", "search", "returns", "chunks", "with", "combined", "scores", "using", "reciprocal", "rank", "fusion", "rrf", "args", "query", "raw", "query", "string", "for", "sparse", "matching", "query", "embedding", "dense", "embedding", "of", "the", "query", "limit", "maximum", "number", "of", "chunks", "to", "return", "returns", "list", "of", "chunk", "score", "tuples", "ranked", "by", "reciprocal", "rank", "fusion", "def", "search", "self", "query", "str", "query", "embedding", "list", "float", "limit", "int", "10", "list", "tuple", "code", "chunk", "float", "search", "using", "hybrid", "retrieval", "combines", "bm25", "sparse", "retrieval", "with", "dense", "vector", "search", "returns", "chunks", "with", "combined", "scores", "using", "reciprocal", "rank", "fusion", "rrf", "args", "query", "raw", "query", "string", "for", "sparse", "matching", "query", "embedding", "dense", "embedding", "of", "the", "query"], "metadata": {"kind": "method", "chunk_index": "0", "has_docstring": "true", "last_modified": "1768185812.9936173"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/retrieval/hybrid_index.py::HybridIndex.search::1", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/retrieval/hybrid_index.py::HybridIndex.search", "content": "uery string for sparse matching.\n            query_embedding: Dense embedding of the query.\n            limit: Maximum number of chunks to return.\n\n        Returns:\n            List of (chunk, score) tuples ranked by reciprocal rank fusion.\n        \"\"\"\n        # 1. BM25 Search\n        query_tokens = tokenize_code(query)\n        # We get more results for fusion\n        sparse_results = self.chunk_repo.search_by_tokens(query_tokens, limit=limit * 2)\n        \n        # 2. Vector Search\n        dense_results = self.vector_store.search(query_embedding, limit=limit * 2)\n        \n        # 3. Combine scores (RRF)\n        combined_scores: dict[str, float] = {}\n        \n        # Constant for RRF to avoid division by zero and dampen top ranks\n        K = 60\n        \n        for rank, chunk in enumerate(sparse_results):\n            combined_scores[chunk.id] = combined_scores.get(chunk.id, 0.0) + (1.0 - self.alpha) / (K + rank + 1)\n            \n        for rank, (chunk_id, _) in enumerate(dense_r", "tokens": ["uery", "string", "for", "sparse", "matching", "query", "embedding", "dense", "embedding", "of", "the", "query", "limit", "maximum", "number", "of", "chunks", "to", "return", "returns", "list", "of", "chunk", "score", "tuples", "ranked", "by", "reciprocal", "rank", "fusion", "bm25", "search", "query", "tokens", "tokenize", "code", "query", "we", "get", "more", "results", "for", "fusion", "sparse", "results", "self", "chunk", "repo", "search", "by", "tokens", "query", "tokens", "limit", "limit", "vector", "search", "dense", "results", "self", "vector", "store", "search", "query", "embedding", "limit", "limit", "combine", "scores", "rrf", "combined", "scores", "dict", "str", "float", "constant", "for", "rrf", "to", "avoid", "division", "by", "zero", "and", "dampen", "top", "ranks", "60", "for", "rank", "chunk", "in", "enumerate", "sparse", "results", "combined", "scores", "chunk", "id", "combined", "scores", "get", "chunk", "id", "self", "alpha", "rank", "for", "rank", "chunk", "id", "in", "enumerate", "dense"], "metadata": {"kind": "method", "chunk_index": "1", "has_docstring": "true", "last_modified": "1768185812.9936173"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/retrieval/hybrid_index.py::HybridIndex.search::2", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/retrieval/hybrid_index.py::HybridIndex.search", "content": "1.0 - self.alpha) / (K + rank + 1)\n            \n        for rank, (chunk_id, _) in enumerate(dense_results):\n            combined_scores[chunk_id] = combined_scores.get(chunk_id, 0.0) + self.alpha / (K + rank + 1)\n            \n        # 4. Sort and return\n        sorted_ids = sorted(combined_scores.items(), key=lambda x: x[1], reverse=True)\n        \n        results = []\n        for chunk_id, score in sorted_ids[:limit]:\n            chunk = self.chunk_repo.get(chunk_id)\n            if chunk:\n                results.append((chunk, score))\n                \n        return results", "tokens": ["self", "alpha", "rank", "for", "rank", "chunk", "id", "in", "enumerate", "dense", "results", "combined", "scores", "chunk", "id", "combined", "scores", "get", "chunk", "id", "self", "alpha", "rank", "sort", "and", "return", "sorted", "ids", "sorted", "combined", "scores", "items", "key", "lambda", "reverse", "true", "results", "for", "chunk", "id", "score", "in", "sorted", "ids", "limit", "chunk", "self", "chunk", "repo", "get", "chunk", "id", "if", "chunk", "results", "append", "chunk", "score", "return", "results"], "metadata": {"kind": "method", "chunk_index": "2", "has_docstring": "true", "last_modified": "1768185812.9936173"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/retrieval/completeness.py::module::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/retrieval/completeness.py::module", "content": "\"\"\"Dependency-aware completeness expansion for code context.\"\"\"", "tokens": ["dependency", "aware", "completeness", "expansion", "for", "code", "context"], "metadata": {"type": "module_header"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/retrieval/completeness.py::imports::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/retrieval/completeness.py::module", "content": "from __future__ import annotations\nfrom typing import TYPE_CHECKING\n    from knowcode.storage.chunk_repository import ChunkRepository\n    from knowcode.storage.knowledge_store import KnowledgeStore\n    from knowcode.models import CodeChunk", "tokens": ["from", "future", "import", "annotations", "from", "typing", "import", "type", "checking", "from", "knowcode", "storage", "chunk", "repository", "import", "chunk", "repository", "from", "knowcode", "storage", "knowledge", "store", "import", "knowledge", "store", "from", "knowcode", "models", "import", "code", "chunk"], "metadata": {"type": "imports"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/retrieval/completeness.py::expand_dependencies::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/retrieval/completeness.py::expand_dependencies", "content": "def expand_dependencies(chunk: CodeChunk, chunk_repo: ChunkRepository, knowledge_store: KnowledgeStore, max_depth: int) -> list[CodeChunk]\n\"\"\"Expand a chunk to include dependency context.\nUses knowledge graph to find related entities,\nthen retrieves their chunks.\n\nArgs:\n    chunk: Starting chunk whose dependencies should be expanded.\n    chunk_repo: Repository used to fetch chunks by entity.\n    knowledge_store: Graph store used to resolve dependencies.\n    max_depth: Depth of dependency expansion (1 = direct callees only).\n\nReturns:\n    List of chunks including the input chunk and its dependencies.\"\"\"\ndef expand_dependencies(\n    chunk: CodeChunk,\n    chunk_repo: ChunkRepository,\n    knowledge_store: KnowledgeStore,\n    max_depth: int = 1\n) -> list[CodeChunk]:\n    \"\"\"Expand a chunk to include dependency context.\n    Uses knowledge graph to find related entities,\n    then retrieves their chunks.\n\n    Args:\n        chunk: Starting chunk whose dependencies should be expanded.\n        chu", "tokens": ["def", "expand", "dependencies", "chunk", "code", "chunk", "chunk", "repo", "chunk", "repository", "knowledge", "store", "knowledge", "store", "max", "depth", "int", "list", "code", "chunk", "expand", "chunk", "to", "include", "dependency", "context", "uses", "knowledge", "graph", "to", "find", "related", "entities", "then", "retrieves", "their", "chunks", "args", "chunk", "starting", "chunk", "whose", "dependencies", "should", "be", "expanded", "chunk", "repo", "repository", "used", "to", "fetch", "chunks", "by", "entity", "knowledge", "store", "graph", "store", "used", "to", "resolve", "dependencies", "max", "depth", "depth", "of", "dependency", "expansion", "direct", "callees", "only", "returns", "list", "of", "chunks", "including", "the", "input", "chunk", "and", "its", "dependencies", "def", "expand", "dependencies", "chunk", "code", "chunk", "chunk", "repo", "chunk", "repository", "knowledge", "store", "knowledge", "store", "max", "depth", "int", "list", "code", "chunk", "expand", "chunk", "to", "include", "dependency", "context", "uses", "knowledge", "graph", "to", "find", "related", "entities", "then", "retrieves", "their", "chunks", "args", "chunk", "starting", "chunk", "whose", "dependencies", "should", "be", "expanded", "chu"], "metadata": {"kind": "function", "chunk_index": "0", "has_docstring": "true", "last_modified": "1766231204.571363"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/retrieval/completeness.py::expand_dependencies::1", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/retrieval/completeness.py::expand_dependencies", "content": " chunks.\n\n    Args:\n        chunk: Starting chunk whose dependencies should be expanded.\n        chunk_repo: Repository used to fetch chunks by entity.\n        knowledge_store: Graph store used to resolve dependencies.\n        max_depth: Depth of dependency expansion (1 = direct callees only).\n\n    Returns:\n        List of chunks including the input chunk and its dependencies.\n    \"\"\"\n    expanded: list[CodeChunk] = [chunk]\n    visited: set[str] = {chunk.entity_id}\n    \n    to_expand = [chunk.entity_id]\n    depth = 0\n    \n    while to_expand and depth < max_depth:\n        next_level = []\n        for entity_id in to_expand:\n            # Get callees from graph\n            callees = knowledge_store.get_callees(entity_id)\n            for callee in callees:\n                if callee.id not in visited:\n                    visited.add(callee.id)\n                    next_level.append(callee.id)\n                    # Get chunks for this entity\n                    entity_chunks = chunk_repo.get", "tokens": ["chunks", "args", "chunk", "starting", "chunk", "whose", "dependencies", "should", "be", "expanded", "chunk", "repo", "repository", "used", "to", "fetch", "chunks", "by", "entity", "knowledge", "store", "graph", "store", "used", "to", "resolve", "dependencies", "max", "depth", "depth", "of", "dependency", "expansion", "direct", "callees", "only", "returns", "list", "of", "chunks", "including", "the", "input", "chunk", "and", "its", "dependencies", "expanded", "list", "code", "chunk", "chunk", "visited", "set", "str", "chunk", "entity", "id", "to", "expand", "chunk", "entity", "id", "depth", "while", "to", "expand", "and", "depth", "max", "depth", "next", "level", "for", "entity", "id", "in", "to", "expand", "get", "callees", "from", "graph", "callees", "knowledge", "store", "get", "callees", "entity", "id", "for", "callee", "in", "callees", "if", "callee", "id", "not", "in", "visited", "visited", "add", "callee", "id", "next", "level", "append", "callee", "id", "get", "chunks", "for", "this", "entity", "entity", "chunks", "chunk", "repo", "get"], "metadata": {"kind": "function", "chunk_index": "1", "has_docstring": "true", "last_modified": "1766231204.571363"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/retrieval/completeness.py::expand_dependencies::2", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/retrieval/completeness.py::expand_dependencies", "content": "\n                    # Get chunks for this entity\n                    entity_chunks = chunk_repo.get_by_entity(callee.id)\n                    expanded.extend(entity_chunks)\n        \n        to_expand = next_level\n        depth += 1\n    \n    return expanded", "tokens": ["get", "chunks", "for", "this", "entity", "entity", "chunks", "chunk", "repo", "get", "by", "entity", "callee", "id", "expanded", "extend", "entity", "chunks", "to", "expand", "next", "level", "depth", "return", "expanded"], "metadata": {"kind": "function", "chunk_index": "2", "has_docstring": "true", "last_modified": "1766231204.571363"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/retrieval/reranker.py::module::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/retrieval/reranker.py::module", "content": "\"\"\"Reranking for search results.\n\nSupports two reranking strategies:\n1. VoyageAI cross-encoder (rerank-2.5) - high quality, requires API key\n2. Signal-based scoring - local, no API required\n\"\"\"", "tokens": ["reranking", "for", "search", "results", "supports", "two", "reranking", "strategies", "voyage", "ai", "cross", "encoder", "rerank", "high", "quality", "requires", "api", "key", "signal", "based", "scoring", "local", "no", "api", "required"], "metadata": {"type": "module_header"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/retrieval/reranker.py::imports::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/retrieval/reranker.py::module", "content": "import time\nfrom typing import Optional\nfrom knowcode.data_models import CodeChunk\nfrom knowcode.config import AppConfig\n                from knowcode.llm.voyageai_client import get_voyageai_client", "tokens": ["import", "time", "from", "typing", "import", "optional", "from", "knowcode", "data", "models", "import", "code", "chunk", "from", "knowcode", "config", "import", "app", "config", "from", "knowcode", "llm", "voyageai", "client", "import", "get", "voyageai", "client"], "metadata": {"type": "imports"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/retrieval/reranker.py::Reranker::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/retrieval/reranker.py::Reranker", "content": "\"\"\"Reranks search results using cross-encoder or signal-based scoring.\"\"\"\nclass Reranker:\n    \"\"\"Reranks search results using cross-encoder or signal-based scoring.\"\"\"\n    \n    def __init__(\n        self,\n        use_voyageai: bool = True,\n        api_key_env: Optional[str] = None,\n        config: Optional[AppConfig] = None,\n    ) -> None:\n        \"\"\"Initialize reranker.\n        \n        Args:\n            use_voyageai: Try to use VoyageAI if available.\n            api_key_env: Environment variable for VoyageAI API key.\n            config: AppConfig with reranking model settings.\n        \"\"\"\n        self.voyage_client = None\n        self.model = \"rerank-2.5\"\n        \n        if use_voyageai:\n            # Determine API key env from config or default\n            if config and config.reranking_models:\n                api_key_env = config.reranking_models[0].api_key_env\n                self.model = config.reranking_models[0].name\n            else:\n                api_key_env = api_key_env ", "tokens": ["reranks", "search", "results", "using", "cross", "encoder", "or", "signal", "based", "scoring", "class", "reranker", "reranks", "search", "results", "using", "cross", "encoder", "or", "signal", "based", "scoring", "def", "init", "self", "use", "voyageai", "bool", "true", "api", "key", "env", "optional", "str", "none", "config", "optional", "app", "config", "none", "none", "initialize", "reranker", "args", "use", "voyageai", "try", "to", "use", "voyage", "ai", "if", "available", "api", "key", "env", "environment", "variable", "for", "voyage", "ai", "api", "key", "config", "app", "config", "with", "reranking", "model", "settings", "self", "voyage", "client", "none", "self", "model", "rerank", "if", "use", "voyageai", "determine", "api", "key", "env", "from", "config", "or", "default", "if", "config", "and", "config", "reranking", "models", "api", "key", "env", "config", "reranking", "models", "api", "key", "env", "self", "model", "config", "reranking", "models", "name", "else", "api", "key", "env", "api", "key", "env"], "metadata": {"kind": "class", "chunk_index": "0", "has_docstring": "true", "last_modified": "1768185812.9936173"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/retrieval/reranker.py::Reranker::1", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/retrieval/reranker.py::Reranker", "content": "model = config.reranking_models[0].name\n            else:\n                api_key_env = api_key_env or \"VOYAGE_API_KEY_1\"\n            \n            # Try to initialize VoyageAI client\n            try:\n                from knowcode.llm.voyageai_client import get_voyageai_client\n                self.voyage_client = get_voyageai_client(api_key_env)\n            except Exception:\n                pass  # Fall back to signal-based\n    \n    def rerank(\n        self,\n        query: str,\n        chunks: list[tuple[CodeChunk, float]],\n        boost_recent: bool = True,\n        boost_documented: bool = True,\n        top_k: Optional[int] = None,\n    ) -> list[tuple[CodeChunk, float]]:\n        \"\"\"Rerank chunks based on semantic relevance.\n        \n        Uses VoyageAI cross-encoder if available, otherwise falls back\n        to signal-based scoring.\n        \n        Args:\n            query: Original search query.\n            chunks: (chunk, score) tuples from initial retrieval.\n            boost_rece", "tokens": ["model", "config", "reranking", "models", "name", "else", "api", "key", "env", "api", "key", "env", "or", "voyage", "api", "key", "try", "to", "initialize", "voyage", "ai", "client", "try", "from", "knowcode", "llm", "voyageai", "client", "import", "get", "voyageai", "client", "self", "voyage", "client", "get", "voyageai", "client", "api", "key", "env", "except", "exception", "pass", "fall", "back", "to", "signal", "based", "def", "rerank", "self", "query", "str", "chunks", "list", "tuple", "code", "chunk", "float", "boost", "recent", "bool", "true", "boost", "documented", "bool", "true", "top", "optional", "int", "none", "list", "tuple", "code", "chunk", "float", "rerank", "chunks", "based", "on", "semantic", "relevance", "uses", "voyage", "ai", "cross", "encoder", "if", "available", "otherwise", "falls", "back", "to", "signal", "based", "scoring", "args", "query", "original", "search", "query", "chunks", "chunk", "score", "tuples", "from", "initial", "retrieval", "boost", "rece"], "metadata": {"kind": "class", "chunk_index": "1", "has_docstring": "true", "last_modified": "1768185812.9936173"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/retrieval/reranker.py::Reranker::2", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/retrieval/reranker.py::Reranker", "content": "arch query.\n            chunks: (chunk, score) tuples from initial retrieval.\n            boost_recent: Boost recently modified chunks.\n            boost_documented: Boost chunks with docstrings.\n            top_k: Return only top K results.\n            \n        Returns:\n            Reranked (chunk, score) tuples.\n        \"\"\"\n        if not chunks:\n            return []\n        \n        # Try VoyageAI cross-encoder reranking\n        if self.voyage_client:\n            try:\n                return self._rerank_with_voyageai(query, chunks, top_k)\n            except Exception as e:\n                print(f\"  \u26a0\ufe0f VoyageAI reranking failed: {e}. Using signal-based fallback.\")\n        \n        # Fallback to signal-based reranking\n        return self._rerank_with_signals(\n            query, chunks, boost_recent, boost_documented, top_k\n        )\n    \n    def _rerank_with_voyageai(\n        self,\n        query: str,\n        chunks: list[tuple[CodeChunk, float]],\n        top_k: Optional[int] = None,", "tokens": ["arch", "query", "chunks", "chunk", "score", "tuples", "from", "initial", "retrieval", "boost", "recent", "boost", "recently", "modified", "chunks", "boost", "documented", "boost", "chunks", "with", "docstrings", "top", "return", "only", "top", "results", "returns", "reranked", "chunk", "score", "tuples", "if", "not", "chunks", "return", "try", "voyage", "ai", "cross", "encoder", "reranking", "if", "self", "voyage", "client", "try", "return", "self", "rerank", "with", "voyageai", "query", "chunks", "top", "except", "exception", "as", "print", "voyage", "ai", "reranking", "failed", "using", "signal", "based", "fallback", "fallback", "to", "signal", "based", "reranking", "return", "self", "rerank", "with", "signals", "query", "chunks", "boost", "recent", "boost", "documented", "top", "def", "rerank", "with", "voyageai", "self", "query", "str", "chunks", "list", "tuple", "code", "chunk", "float", "top", "optional", "int", "none"], "metadata": {"kind": "class", "chunk_index": "2", "has_docstring": "true", "last_modified": "1768185812.9936173"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/retrieval/reranker.py::Reranker::3", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/retrieval/reranker.py::Reranker", "content": "     query: str,\n        chunks: list[tuple[CodeChunk, float]],\n        top_k: Optional[int] = None,\n    ) -> list[tuple[CodeChunk, float]]:\n        \"\"\"Rerank using VoyageAI cross-encoder.\n        \n        Args:\n            query: Search query.\n            chunks: (chunk, score) tuples.\n            top_k: Maximum results.\n            \n        Returns:\n            Reranked chunks with cross-encoder scores.\n        \"\"\"\n        # Prepare documents for reranking\n        documents = [chunk.content for chunk, _ in chunks]\n        \n        # Call VoyageAI rerank API\n        results = self.voyage_client.rerank(\n            query=query,\n            documents=documents,\n            model=self.model,\n            top_k=top_k,\n        )\n        \n        # Map back to chunks with new scores\n        reranked = []\n        for r in results:\n            idx = r[\"index\"]\n            chunk, _ = chunks[idx]\n            reranked.append((chunk, r[\"relevance_score\"]))\n        \n        return reranked\n    \n   ", "tokens": ["query", "str", "chunks", "list", "tuple", "code", "chunk", "float", "top", "optional", "int", "none", "list", "tuple", "code", "chunk", "float", "rerank", "using", "voyage", "ai", "cross", "encoder", "args", "query", "search", "query", "chunks", "chunk", "score", "tuples", "top", "maximum", "results", "returns", "reranked", "chunks", "with", "cross", "encoder", "scores", "prepare", "documents", "for", "reranking", "documents", "chunk", "content", "for", "chunk", "in", "chunks", "call", "voyage", "ai", "rerank", "api", "results", "self", "voyage", "client", "rerank", "query", "query", "documents", "documents", "model", "self", "model", "top", "top", "map", "back", "to", "chunks", "with", "new", "scores", "reranked", "for", "in", "results", "idx", "index", "chunk", "chunks", "idx", "reranked", "append", "chunk", "relevance", "score", "return", "reranked"], "metadata": {"kind": "class", "chunk_index": "3", "has_docstring": "true", "last_modified": "1768185812.9936173"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/retrieval/reranker.py::Reranker::4", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/retrieval/reranker.py::Reranker", "content": "            reranked.append((chunk, r[\"relevance_score\"]))\n        \n        return reranked\n    \n    def _rerank_with_signals(\n        self,\n        query: str,\n        chunks: list[tuple[CodeChunk, float]],\n        boost_recent: bool = True,\n        boost_documented: bool = True,\n        top_k: Optional[int] = None,\n    ) -> list[tuple[CodeChunk, float]]:\n        \"\"\"Rerank using local heuristic signals.\n        \n        Args:\n            query: Search query.\n            chunks: (chunk, score) tuples.\n            boost_recent: Boost recent modifications.\n            boost_documented: Boost documented code.\n            top_k: Maximum results.\n            \n        Returns:\n            Reranked chunks with adjusted scores.\n        \"\"\"\n        reranked = []\n        current_time = time.time()\n        \n        for chunk, score in chunks:\n            adjusted_score = score\n            \n            # Boost documented code\n            if boost_documented and str(chunk.metadata.get(\"has_docstrin", "tokens": ["reranked", "append", "chunk", "relevance", "score", "return", "reranked", "def", "rerank", "with", "signals", "self", "query", "str", "chunks", "list", "tuple", "code", "chunk", "float", "boost", "recent", "bool", "true", "boost", "documented", "bool", "true", "top", "optional", "int", "none", "list", "tuple", "code", "chunk", "float", "rerank", "using", "local", "heuristic", "signals", "args", "query", "search", "query", "chunks", "chunk", "score", "tuples", "boost", "recent", "boost", "recent", "modifications", "boost", "documented", "boost", "documented", "code", "top", "maximum", "results", "returns", "reranked", "chunks", "with", "adjusted", "scores", "reranked", "current", "time", "time", "time", "for", "chunk", "score", "in", "chunks", "adjusted", "score", "score", "boost", "documented", "code", "if", "boost", "documented", "and", "str", "chunk", "metadata", "get", "has", "docstrin"], "metadata": {"kind": "class", "chunk_index": "4", "has_docstring": "true", "last_modified": "1768185812.9936173"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/retrieval/reranker.py::Reranker::5", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/retrieval/reranker.py::Reranker", "content": "    # Boost documented code\n            if boost_documented and str(chunk.metadata.get(\"has_docstring\", \"\")).lower() == \"true\":\n                adjusted_score *= 1.2\n            \n            # Boost recently modified chunks (within 7 days)\n            if boost_recent and chunk.metadata.get(\"last_modified\"):\n                try:\n                    last_mod = float(chunk.metadata[\"last_modified\"])\n                    if current_time - last_mod < 7 * 24 * 3600:\n                        adjusted_score *= 1.1\n                except (ValueError, TypeError):\n                    pass\n            \n            # Boost exact name matches in content\n            if query.lower() in chunk.content.lower():\n                adjusted_score *= 1.5\n                \n            # Boost matches in metadata kind\n            if query.lower() == chunk.metadata.get(\"kind\", \"\").lower():\n                adjusted_score *= 2.0\n            \n            reranked.append((chunk, adjusted_score))\n        \n        rerank", "tokens": ["boost", "documented", "code", "if", "boost", "documented", "and", "str", "chunk", "metadata", "get", "has", "docstring", "lower", "true", "adjusted", "score", "boost", "recently", "modified", "chunks", "within", "days", "if", "boost", "recent", "and", "chunk", "metadata", "get", "last", "modified", "try", "last", "mod", "float", "chunk", "metadata", "last", "modified", "if", "current", "time", "last", "mod", "24", "3600", "adjusted", "score", "except", "value", "error", "type", "error", "pass", "boost", "exact", "name", "matches", "in", "content", "if", "query", "lower", "in", "chunk", "content", "lower", "adjusted", "score", "boost", "matches", "in", "metadata", "kind", "if", "query", "lower", "chunk", "metadata", "get", "kind", "lower", "adjusted", "score", "reranked", "append", "chunk", "adjusted", "score", "rerank"], "metadata": {"kind": "class", "chunk_index": "5", "has_docstring": "true", "last_modified": "1768185812.9936173"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/retrieval/reranker.py::Reranker::6", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/retrieval/reranker.py::Reranker", "content": "ore *= 2.0\n            \n            reranked.append((chunk, adjusted_score))\n        \n        reranked.sort(key=lambda x: x[1], reverse=True)\n        \n        if top_k:\n            reranked = reranked[:top_k]\n            \n        return reranked", "tokens": ["ore", "reranked", "append", "chunk", "adjusted", "score", "reranked", "sort", "key", "lambda", "reverse", "true", "if", "top", "reranked", "reranked", "top", "return", "reranked"], "metadata": {"kind": "class", "chunk_index": "6", "has_docstring": "true", "last_modified": "1768185812.9936173"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/retrieval/reranker.py::Reranker.__init__::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/retrieval/reranker.py::Reranker.__init__", "content": "def __init__(self, use_voyageai: bool, api_key_env: Optional[str], config: Optional[AppConfig]) -> None\n\"\"\"Initialize reranker.\n\nArgs:\n    use_voyageai: Try to use VoyageAI if available.\n    api_key_env: Environment variable for VoyageAI API key.\n    config: AppConfig with reranking model settings.\"\"\"\n    def __init__(\n        self,\n        use_voyageai: bool = True,\n        api_key_env: Optional[str] = None,\n        config: Optional[AppConfig] = None,\n    ) -> None:\n        \"\"\"Initialize reranker.\n        \n        Args:\n            use_voyageai: Try to use VoyageAI if available.\n            api_key_env: Environment variable for VoyageAI API key.\n            config: AppConfig with reranking model settings.\n        \"\"\"\n        self.voyage_client = None\n        self.model = \"rerank-2.5\"\n        \n        if use_voyageai:\n            # Determine API key env from config or default\n            if config and config.reranking_models:\n                api_key_env = config.reranking_models[0].api", "tokens": ["def", "init", "self", "use", "voyageai", "bool", "api", "key", "env", "optional", "str", "config", "optional", "app", "config", "none", "initialize", "reranker", "args", "use", "voyageai", "try", "to", "use", "voyage", "ai", "if", "available", "api", "key", "env", "environment", "variable", "for", "voyage", "ai", "api", "key", "config", "app", "config", "with", "reranking", "model", "settings", "def", "init", "self", "use", "voyageai", "bool", "true", "api", "key", "env", "optional", "str", "none", "config", "optional", "app", "config", "none", "none", "initialize", "reranker", "args", "use", "voyageai", "try", "to", "use", "voyage", "ai", "if", "available", "api", "key", "env", "environment", "variable", "for", "voyage", "ai", "api", "key", "config", "app", "config", "with", "reranking", "model", "settings", "self", "voyage", "client", "none", "self", "model", "rerank", "if", "use", "voyageai", "determine", "api", "key", "env", "from", "config", "or", "default", "if", "config", "and", "config", "reranking", "models", "api", "key", "env", "config", "reranking", "models", "api"], "metadata": {"kind": "method", "chunk_index": "0", "has_docstring": "true", "last_modified": "1768185812.9936173"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/retrieval/reranker.py::Reranker.__init__::1", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/retrieval/reranker.py::Reranker.__init__", "content": " if config and config.reranking_models:\n                api_key_env = config.reranking_models[0].api_key_env\n                self.model = config.reranking_models[0].name\n            else:\n                api_key_env = api_key_env or \"VOYAGE_API_KEY_1\"\n            \n            # Try to initialize VoyageAI client\n            try:\n                from knowcode.llm.voyageai_client import get_voyageai_client\n                self.voyage_client = get_voyageai_client(api_key_env)\n            except Exception:\n                pass  # Fall back to signal-based", "tokens": ["if", "config", "and", "config", "reranking", "models", "api", "key", "env", "config", "reranking", "models", "api", "key", "env", "self", "model", "config", "reranking", "models", "name", "else", "api", "key", "env", "api", "key", "env", "or", "voyage", "api", "key", "try", "to", "initialize", "voyage", "ai", "client", "try", "from", "knowcode", "llm", "voyageai", "client", "import", "get", "voyageai", "client", "self", "voyage", "client", "get", "voyageai", "client", "api", "key", "env", "except", "exception", "pass", "fall", "back", "to", "signal", "based"], "metadata": {"kind": "method", "chunk_index": "1", "has_docstring": "true", "last_modified": "1768185812.9936173"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/retrieval/reranker.py::Reranker.rerank::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/retrieval/reranker.py::Reranker.rerank", "content": "def rerank(self, query: str, chunks: list[tuple[CodeChunk, float]], boost_recent: bool, boost_documented: bool, top_k: Optional[int]) -> list[tuple[CodeChunk, float]]\n\"\"\"Rerank chunks based on semantic relevance.\n\nUses VoyageAI cross-encoder if available, otherwise falls back\nto signal-based scoring.\n\nArgs:\n    query: Original search query.\n    chunks: (chunk, score) tuples from initial retrieval.\n    boost_recent: Boost recently modified chunks.\n    boost_documented: Boost chunks with docstrings.\n    top_k: Return only top K results.\n    \nReturns:\n    Reranked (chunk, score) tuples.\"\"\"\n    def rerank(\n        self,\n        query: str,\n        chunks: list[tuple[CodeChunk, float]],\n        boost_recent: bool = True,\n        boost_documented: bool = True,\n        top_k: Optional[int] = None,\n    ) -> list[tuple[CodeChunk, float]]:\n        \"\"\"Rerank chunks based on semantic relevance.\n        \n        Uses VoyageAI cross-encoder if available, otherwise falls back\n        to signal-based ", "tokens": ["def", "rerank", "self", "query", "str", "chunks", "list", "tuple", "code", "chunk", "float", "boost", "recent", "bool", "boost", "documented", "bool", "top", "optional", "int", "list", "tuple", "code", "chunk", "float", "rerank", "chunks", "based", "on", "semantic", "relevance", "uses", "voyage", "ai", "cross", "encoder", "if", "available", "otherwise", "falls", "back", "to", "signal", "based", "scoring", "args", "query", "original", "search", "query", "chunks", "chunk", "score", "tuples", "from", "initial", "retrieval", "boost", "recent", "boost", "recently", "modified", "chunks", "boost", "documented", "boost", "chunks", "with", "docstrings", "top", "return", "only", "top", "results", "returns", "reranked", "chunk", "score", "tuples", "def", "rerank", "self", "query", "str", "chunks", "list", "tuple", "code", "chunk", "float", "boost", "recent", "bool", "true", "boost", "documented", "bool", "true", "top", "optional", "int", "none", "list", "tuple", "code", "chunk", "float", "rerank", "chunks", "based", "on", "semantic", "relevance", "uses", "voyage", "ai", "cross", "encoder", "if", "available", "otherwise", "falls", "back", "to", "signal", "based"], "metadata": {"kind": "method", "chunk_index": "0", "has_docstring": "true", "last_modified": "1768185812.9936173"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/retrieval/reranker.py::Reranker.rerank::1", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/retrieval/reranker.py::Reranker.rerank", "content": "    \n        Uses VoyageAI cross-encoder if available, otherwise falls back\n        to signal-based scoring.\n        \n        Args:\n            query: Original search query.\n            chunks: (chunk, score) tuples from initial retrieval.\n            boost_recent: Boost recently modified chunks.\n            boost_documented: Boost chunks with docstrings.\n            top_k: Return only top K results.\n            \n        Returns:\n            Reranked (chunk, score) tuples.\n        \"\"\"\n        if not chunks:\n            return []\n        \n        # Try VoyageAI cross-encoder reranking\n        if self.voyage_client:\n            try:\n                return self._rerank_with_voyageai(query, chunks, top_k)\n            except Exception as e:\n                print(f\"  \u26a0\ufe0f VoyageAI reranking failed: {e}. Using signal-based fallback.\")\n        \n        # Fallback to signal-based reranking\n        return self._rerank_with_signals(\n            query, chunks, boost_recent, boost_documented, top_k\n ", "tokens": ["uses", "voyage", "ai", "cross", "encoder", "if", "available", "otherwise", "falls", "back", "to", "signal", "based", "scoring", "args", "query", "original", "search", "query", "chunks", "chunk", "score", "tuples", "from", "initial", "retrieval", "boost", "recent", "boost", "recently", "modified", "chunks", "boost", "documented", "boost", "chunks", "with", "docstrings", "top", "return", "only", "top", "results", "returns", "reranked", "chunk", "score", "tuples", "if", "not", "chunks", "return", "try", "voyage", "ai", "cross", "encoder", "reranking", "if", "self", "voyage", "client", "try", "return", "self", "rerank", "with", "voyageai", "query", "chunks", "top", "except", "exception", "as", "print", "voyage", "ai", "reranking", "failed", "using", "signal", "based", "fallback", "fallback", "to", "signal", "based", "reranking", "return", "self", "rerank", "with", "signals", "query", "chunks", "boost", "recent", "boost", "documented", "top"], "metadata": {"kind": "method", "chunk_index": "1", "has_docstring": "true", "last_modified": "1768185812.9936173"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/retrieval/reranker.py::Reranker.rerank::2", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/retrieval/reranker.py::Reranker.rerank", "content": "return self._rerank_with_signals(\n            query, chunks, boost_recent, boost_documented, top_k\n        )", "tokens": ["return", "self", "rerank", "with", "signals", "query", "chunks", "boost", "recent", "boost", "documented", "top"], "metadata": {"kind": "method", "chunk_index": "2", "has_docstring": "true", "last_modified": "1768185812.9936173"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/retrieval/reranker.py::Reranker._rerank_with_voyageai::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/retrieval/reranker.py::Reranker._rerank_with_voyageai", "content": "def _rerank_with_voyageai(self, query: str, chunks: list[tuple[CodeChunk, float]], top_k: Optional[int]) -> list[tuple[CodeChunk, float]]\n\"\"\"Rerank using VoyageAI cross-encoder.\n\nArgs:\n    query: Search query.\n    chunks: (chunk, score) tuples.\n    top_k: Maximum results.\n    \nReturns:\n    Reranked chunks with cross-encoder scores.\"\"\"\n    def _rerank_with_voyageai(\n        self,\n        query: str,\n        chunks: list[tuple[CodeChunk, float]],\n        top_k: Optional[int] = None,\n    ) -> list[tuple[CodeChunk, float]]:\n        \"\"\"Rerank using VoyageAI cross-encoder.\n        \n        Args:\n            query: Search query.\n            chunks: (chunk, score) tuples.\n            top_k: Maximum results.\n            \n        Returns:\n            Reranked chunks with cross-encoder scores.\n        \"\"\"\n        # Prepare documents for reranking\n        documents = [chunk.content for chunk, _ in chunks]\n        \n        # Call VoyageAI rerank API\n        results = self.voyage_client.rerank(\n    ", "tokens": ["def", "rerank", "with", "voyageai", "self", "query", "str", "chunks", "list", "tuple", "code", "chunk", "float", "top", "optional", "int", "list", "tuple", "code", "chunk", "float", "rerank", "using", "voyage", "ai", "cross", "encoder", "args", "query", "search", "query", "chunks", "chunk", "score", "tuples", "top", "maximum", "results", "returns", "reranked", "chunks", "with", "cross", "encoder", "scores", "def", "rerank", "with", "voyageai", "self", "query", "str", "chunks", "list", "tuple", "code", "chunk", "float", "top", "optional", "int", "none", "list", "tuple", "code", "chunk", "float", "rerank", "using", "voyage", "ai", "cross", "encoder", "args", "query", "search", "query", "chunks", "chunk", "score", "tuples", "top", "maximum", "results", "returns", "reranked", "chunks", "with", "cross", "encoder", "scores", "prepare", "documents", "for", "reranking", "documents", "chunk", "content", "for", "chunk", "in", "chunks", "call", "voyage", "ai", "rerank", "api", "results", "self", "voyage", "client", "rerank"], "metadata": {"kind": "method", "chunk_index": "0", "has_docstring": "true", "last_modified": "1768185812.9936173"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/retrieval/reranker.py::Reranker._rerank_with_voyageai::1", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/retrieval/reranker.py::Reranker._rerank_with_voyageai", "content": "hunks]\n        \n        # Call VoyageAI rerank API\n        results = self.voyage_client.rerank(\n            query=query,\n            documents=documents,\n            model=self.model,\n            top_k=top_k,\n        )\n        \n        # Map back to chunks with new scores\n        reranked = []\n        for r in results:\n            idx = r[\"index\"]\n            chunk, _ = chunks[idx]\n            reranked.append((chunk, r[\"relevance_score\"]))\n        \n        return reranked", "tokens": ["hunks", "call", "voyage", "ai", "rerank", "api", "results", "self", "voyage", "client", "rerank", "query", "query", "documents", "documents", "model", "self", "model", "top", "top", "map", "back", "to", "chunks", "with", "new", "scores", "reranked", "for", "in", "results", "idx", "index", "chunk", "chunks", "idx", "reranked", "append", "chunk", "relevance", "score", "return", "reranked"], "metadata": {"kind": "method", "chunk_index": "1", "has_docstring": "true", "last_modified": "1768185812.9936173"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/retrieval/reranker.py::Reranker._rerank_with_signals::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/retrieval/reranker.py::Reranker._rerank_with_signals", "content": "def _rerank_with_signals(self, query: str, chunks: list[tuple[CodeChunk, float]], boost_recent: bool, boost_documented: bool, top_k: Optional[int]) -> list[tuple[CodeChunk, float]]\n\"\"\"Rerank using local heuristic signals.\n\nArgs:\n    query: Search query.\n    chunks: (chunk, score) tuples.\n    boost_recent: Boost recent modifications.\n    boost_documented: Boost documented code.\n    top_k: Maximum results.\n    \nReturns:\n    Reranked chunks with adjusted scores.\"\"\"\n    def _rerank_with_signals(\n        self,\n        query: str,\n        chunks: list[tuple[CodeChunk, float]],\n        boost_recent: bool = True,\n        boost_documented: bool = True,\n        top_k: Optional[int] = None,\n    ) -> list[tuple[CodeChunk, float]]:\n        \"\"\"Rerank using local heuristic signals.\n        \n        Args:\n            query: Search query.\n            chunks: (chunk, score) tuples.\n            boost_recent: Boost recent modifications.\n            boost_documented: Boost documented code.\n            top_", "tokens": ["def", "rerank", "with", "signals", "self", "query", "str", "chunks", "list", "tuple", "code", "chunk", "float", "boost", "recent", "bool", "boost", "documented", "bool", "top", "optional", "int", "list", "tuple", "code", "chunk", "float", "rerank", "using", "local", "heuristic", "signals", "args", "query", "search", "query", "chunks", "chunk", "score", "tuples", "boost", "recent", "boost", "recent", "modifications", "boost", "documented", "boost", "documented", "code", "top", "maximum", "results", "returns", "reranked", "chunks", "with", "adjusted", "scores", "def", "rerank", "with", "signals", "self", "query", "str", "chunks", "list", "tuple", "code", "chunk", "float", "boost", "recent", "bool", "true", "boost", "documented", "bool", "true", "top", "optional", "int", "none", "list", "tuple", "code", "chunk", "float", "rerank", "using", "local", "heuristic", "signals", "args", "query", "search", "query", "chunks", "chunk", "score", "tuples", "boost", "recent", "boost", "recent", "modifications", "boost", "documented", "boost", "documented", "code", "top"], "metadata": {"kind": "method", "chunk_index": "0", "has_docstring": "true", "last_modified": "1768185812.9936173"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/retrieval/reranker.py::Reranker._rerank_with_signals::1", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/retrieval/reranker.py::Reranker._rerank_with_signals", "content": "t: Boost recent modifications.\n            boost_documented: Boost documented code.\n            top_k: Maximum results.\n            \n        Returns:\n            Reranked chunks with adjusted scores.\n        \"\"\"\n        reranked = []\n        current_time = time.time()\n        \n        for chunk, score in chunks:\n            adjusted_score = score\n            \n            # Boost documented code\n            if boost_documented and str(chunk.metadata.get(\"has_docstring\", \"\")).lower() == \"true\":\n                adjusted_score *= 1.2\n            \n            # Boost recently modified chunks (within 7 days)\n            if boost_recent and chunk.metadata.get(\"last_modified\"):\n                try:\n                    last_mod = float(chunk.metadata[\"last_modified\"])\n                    if current_time - last_mod < 7 * 24 * 3600:\n                        adjusted_score *= 1.1\n                except (ValueError, TypeError):\n                    pass\n            \n            # Boost exact name mat", "tokens": ["boost", "recent", "modifications", "boost", "documented", "boost", "documented", "code", "top", "maximum", "results", "returns", "reranked", "chunks", "with", "adjusted", "scores", "reranked", "current", "time", "time", "time", "for", "chunk", "score", "in", "chunks", "adjusted", "score", "score", "boost", "documented", "code", "if", "boost", "documented", "and", "str", "chunk", "metadata", "get", "has", "docstring", "lower", "true", "adjusted", "score", "boost", "recently", "modified", "chunks", "within", "days", "if", "boost", "recent", "and", "chunk", "metadata", "get", "last", "modified", "try", "last", "mod", "float", "chunk", "metadata", "last", "modified", "if", "current", "time", "last", "mod", "24", "3600", "adjusted", "score", "except", "value", "error", "type", "error", "pass", "boost", "exact", "name", "mat"], "metadata": {"kind": "method", "chunk_index": "1", "has_docstring": "true", "last_modified": "1768185812.9936173"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/retrieval/reranker.py::Reranker._rerank_with_signals::2", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/retrieval/reranker.py::Reranker._rerank_with_signals", "content": "pt (ValueError, TypeError):\n                    pass\n            \n            # Boost exact name matches in content\n            if query.lower() in chunk.content.lower():\n                adjusted_score *= 1.5\n                \n            # Boost matches in metadata kind\n            if query.lower() == chunk.metadata.get(\"kind\", \"\").lower():\n                adjusted_score *= 2.0\n            \n            reranked.append((chunk, adjusted_score))\n        \n        reranked.sort(key=lambda x: x[1], reverse=True)\n        \n        if top_k:\n            reranked = reranked[:top_k]\n            \n        return reranked", "tokens": ["pt", "value", "error", "type", "error", "pass", "boost", "exact", "name", "matches", "in", "content", "if", "query", "lower", "in", "chunk", "content", "lower", "adjusted", "score", "boost", "matches", "in", "metadata", "kind", "if", "query", "lower", "chunk", "metadata", "get", "kind", "lower", "adjusted", "score", "reranked", "append", "chunk", "adjusted", "score", "reranked", "sort", "key", "lambda", "reverse", "true", "if", "top", "reranked", "reranked", "top", "return", "reranked"], "metadata": {"kind": "method", "chunk_index": "2", "has_docstring": "true", "last_modified": "1768185812.9936173"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/embedding.py::module::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/embedding.py::module", "content": "\"\"\"Embedding providers for semantic search.\"\"\"", "tokens": ["embedding", "providers", "for", "semantic", "search"], "metadata": {"type": "module_header"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/embedding.py::imports::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/embedding.py::module", "content": "from __future__ import annotations\nfrom abc import ABC, abstractmethod\nimport os\nfrom openai import OpenAI\nfrom knowcode.config import AppConfig\nfrom knowcode.data_models import EmbeddingConfig\n        import math\n            from knowcode.llm.voyageai_client import get_voyageai_client\n        import math", "tokens": ["from", "future", "import", "annotations", "from", "abc", "import", "abc", "abstractmethod", "import", "os", "from", "openai", "import", "open", "ai", "from", "knowcode", "config", "import", "app", "config", "from", "knowcode", "data", "models", "import", "embedding", "config", "import", "math", "from", "knowcode", "llm", "voyageai", "client", "import", "get", "voyageai", "client", "import", "math"], "metadata": {"type": "imports"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/embedding.py::EmbeddingProvider::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/embedding.py::EmbeddingProvider", "content": "\"\"\"Abstract interface for generating embeddings.\"\"\"\nclass EmbeddingProvider(ABC):\n    \"\"\"Abstract interface for generating embeddings.\"\"\"\n\n    def __init__(self, config: EmbeddingConfig) -> None:\n        \"\"\"Initialize the provider with the embedding configuration.\"\"\"\n        self.config = config\n\n    @abstractmethod\n    def embed(self, texts: list[str]) -> list[list[float]]:\n        \"\"\"Generate embeddings for a batch of texts.\"\"\"\n        pass\n\n    @abstractmethod\n    def embed_single(self, text: str) -> list[float]:\n        \"\"\"Generate embedding for a single text.\"\"\"\n        pass", "tokens": ["abstract", "interface", "for", "generating", "embeddings", "class", "embedding", "provider", "abc", "abstract", "interface", "for", "generating", "embeddings", "def", "init", "self", "config", "embedding", "config", "none", "initialize", "the", "provider", "with", "the", "embedding", "configuration", "self", "config", "config", "abstractmethod", "def", "embed", "self", "texts", "list", "str", "list", "list", "float", "generate", "embeddings", "for", "batch", "of", "texts", "pass", "abstractmethod", "def", "embed", "single", "self", "text", "str", "list", "float", "generate", "embedding", "for", "single", "text", "pass"], "metadata": {"kind": "class", "has_docstring": "true", "last_modified": "1768294091.1702"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/embedding.py::EmbeddingProvider.__init__::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/embedding.py::EmbeddingProvider.__init__", "content": "def __init__(self, config: EmbeddingConfig) -> None\n\"\"\"Initialize the provider with the embedding configuration.\"\"\"\n    def __init__(self, config: EmbeddingConfig) -> None:\n        \"\"\"Initialize the provider with the embedding configuration.\"\"\"\n        self.config = config", "tokens": ["def", "init", "self", "config", "embedding", "config", "none", "initialize", "the", "provider", "with", "the", "embedding", "configuration", "def", "init", "self", "config", "embedding", "config", "none", "initialize", "the", "provider", "with", "the", "embedding", "configuration", "self", "config", "config"], "metadata": {"kind": "method", "has_docstring": "true", "last_modified": "1768294091.1702"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/embedding.py::EmbeddingProvider.embed::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/embedding.py::EmbeddingProvider.embed", "content": "def embed(self, texts: list[str]) -> list[list[float]]\n\"\"\"Generate embeddings for a batch of texts.\"\"\"\n    def embed(self, texts: list[str]) -> list[list[float]]:\n        \"\"\"Generate embeddings for a batch of texts.\"\"\"\n        pass", "tokens": ["def", "embed", "self", "texts", "list", "str", "list", "list", "float", "generate", "embeddings", "for", "batch", "of", "texts", "def", "embed", "self", "texts", "list", "str", "list", "list", "float", "generate", "embeddings", "for", "batch", "of", "texts", "pass"], "metadata": {"kind": "method", "has_docstring": "true", "last_modified": "1768294091.1702"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/embedding.py::EmbeddingProvider.embed_single::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/embedding.py::EmbeddingProvider.embed_single", "content": "def embed_single(self, text: str) -> list[float]\n\"\"\"Generate embedding for a single text.\"\"\"\n    def embed_single(self, text: str) -> list[float]:\n        \"\"\"Generate embedding for a single text.\"\"\"\n        pass", "tokens": ["def", "embed", "single", "self", "text", "str", "list", "float", "generate", "embedding", "for", "single", "text", "def", "embed", "single", "self", "text", "str", "list", "float", "generate", "embedding", "for", "single", "text", "pass"], "metadata": {"kind": "method", "has_docstring": "true", "last_modified": "1768294091.1702"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/embedding.py::OpenAIEmbeddingProvider::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/embedding.py::OpenAIEmbeddingProvider", "content": "\"\"\"OpenAI embedding provider.\"\"\"\nclass OpenAIEmbeddingProvider(EmbeddingProvider):\n    \"\"\"OpenAI embedding provider.\"\"\"\n\n    def __init__(\n        self,\n        config: EmbeddingConfig,\n        api_key_env: str = \"OPENAI_API_KEY\",\n        base_url: str | None = None,\n    ) -> None:\n        \"\"\"Create an OpenAI-backed embedding provider.\n\n        Args:\n            config: Embedding configuration settings.\n            api_key_env: Environment variable containing the API key.\n            base_url: Optional base URL for OpenAI-compatible providers.\n        \"\"\"\n        super().__init__(config)\n        self.api_key_env = api_key_env\n        self.base_url = base_url\n\n        api_key = os.environ.get(self.api_key_env)\n        if not api_key:\n            # We allow init without key, but embed() will fail if not provided later\n            self.client = None\n        else:\n            self.client = OpenAI(api_key=api_key, base_url=base_url)\n\n    def _get_client(self) -> OpenAI:\n        \"\"\"Return an", "tokens": ["open", "ai", "embedding", "provider", "class", "open", "aiembedding", "provider", "embedding", "provider", "open", "ai", "embedding", "provider", "def", "init", "self", "config", "embedding", "config", "api", "key", "env", "str", "openai", "api", "key", "base", "url", "str", "none", "none", "none", "create", "an", "open", "ai", "backed", "embedding", "provider", "args", "config", "embedding", "configuration", "settings", "api", "key", "env", "environment", "variable", "containing", "the", "api", "key", "base", "url", "optional", "base", "url", "for", "open", "ai", "compatible", "providers", "super", "init", "config", "self", "api", "key", "env", "api", "key", "env", "self", "base", "url", "base", "url", "api", "key", "os", "environ", "get", "self", "api", "key", "env", "if", "not", "api", "key", "we", "allow", "init", "without", "key", "but", "embed", "will", "fail", "if", "not", "provided", "later", "self", "client", "none", "else", "self", "client", "open", "ai", "api", "key", "api", "key", "base", "url", "base", "url", "def", "get", "client", "self", "open", "ai", "return", "an"], "metadata": {"kind": "class", "chunk_index": "0", "has_docstring": "true", "last_modified": "1768294091.1702"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/embedding.py::OpenAIEmbeddingProvider::1", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/embedding.py::OpenAIEmbeddingProvider", "content": "penAI(api_key=api_key, base_url=base_url)\n\n    def _get_client(self) -> OpenAI:\n        \"\"\"Return an initialized OpenAI client, loading credentials if needed.\"\"\"\n        if not self.client:\n            api_key = os.environ.get(self.api_key_env)\n            if not api_key:\n                raise ValueError(f\"{self.api_key_env} environment variable is not set.\")\n            self.client = OpenAI(api_key=api_key, base_url=self.base_url)\n        return self.client\n\n    def embed(self, texts: list[str]) -> list[list[float]]:\n        \"\"\"Generate embeddings for a batch of texts.\n\n        Args:\n            texts: Input texts to embed.\n\n        Returns:\n            List of embedding vectors (one per input).\n        \"\"\"\n        if not texts:\n            return []\n            \n        client = self._get_client()\n        response = client.embeddings.create(\n            model=self.config.model_name,\n            input=texts\n        )\n        embeddings = [item.embedding for item in response.data]\n    ", "tokens": ["pen", "ai", "api", "key", "api", "key", "base", "url", "base", "url", "def", "get", "client", "self", "open", "ai", "return", "an", "initialized", "open", "ai", "client", "loading", "credentials", "if", "needed", "if", "not", "self", "client", "api", "key", "os", "environ", "get", "self", "api", "key", "env", "if", "not", "api", "key", "raise", "value", "error", "self", "api", "key", "env", "environment", "variable", "is", "not", "set", "self", "client", "open", "ai", "api", "key", "api", "key", "base", "url", "self", "base", "url", "return", "self", "client", "def", "embed", "self", "texts", "list", "str", "list", "list", "float", "generate", "embeddings", "for", "batch", "of", "texts", "args", "texts", "input", "texts", "to", "embed", "returns", "list", "of", "embedding", "vectors", "one", "per", "input", "if", "not", "texts", "return", "client", "self", "get", "client", "response", "client", "embeddings", "create", "model", "self", "config", "model", "name", "input", "texts", "embeddings", "item", "embedding", "for", "item", "in", "response", "data"], "metadata": {"kind": "class", "chunk_index": "1", "has_docstring": "true", "last_modified": "1768294091.1702"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/embedding.py::OpenAIEmbeddingProvider::2", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/embedding.py::OpenAIEmbeddingProvider", "content": "          input=texts\n        )\n        embeddings = [item.embedding for item in response.data]\n        \n        if self.config.normalize:\n            embeddings = [self._normalize(e) for e in embeddings]\n            \n        return embeddings\n\n    def embed_single(self, text: str) -> list[float]:\n        \"\"\"Generate an embedding for a single text input.\"\"\"\n        return self.embed([text])[0]\n\n    def _normalize(self, vec: list[float]) -> list[float]:\n        \"\"\"Normalize a vector to unit length for cosine similarity.\"\"\"\n        import math\n        norm = math.sqrt(sum(x*x for x in vec))\n        return [x / norm for x in vec] if norm > 0 else vec", "tokens": ["input", "texts", "embeddings", "item", "embedding", "for", "item", "in", "response", "data", "if", "self", "config", "normalize", "embeddings", "self", "normalize", "for", "in", "embeddings", "return", "embeddings", "def", "embed", "single", "self", "text", "str", "list", "float", "generate", "an", "embedding", "for", "single", "text", "input", "return", "self", "embed", "text", "def", "normalize", "self", "vec", "list", "float", "list", "float", "normalize", "vector", "to", "unit", "length", "for", "cosine", "similarity", "import", "math", "norm", "math", "sqrt", "sum", "for", "in", "vec", "return", "norm", "for", "in", "vec", "if", "norm", "else", "vec"], "metadata": {"kind": "class", "chunk_index": "2", "has_docstring": "true", "last_modified": "1768294091.1702"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/embedding.py::OpenAIEmbeddingProvider.__init__::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/embedding.py::OpenAIEmbeddingProvider.__init__", "content": "def __init__(self, config: EmbeddingConfig, api_key_env: str, base_url: str | None) -> None\n\"\"\"Create an OpenAI-backed embedding provider.\n\nArgs:\n    config: Embedding configuration settings.\n    api_key_env: Environment variable containing the API key.\n    base_url: Optional base URL for OpenAI-compatible providers.\"\"\"\n    def __init__(\n        self,\n        config: EmbeddingConfig,\n        api_key_env: str = \"OPENAI_API_KEY\",\n        base_url: str | None = None,\n    ) -> None:\n        \"\"\"Create an OpenAI-backed embedding provider.\n\n        Args:\n            config: Embedding configuration settings.\n            api_key_env: Environment variable containing the API key.\n            base_url: Optional base URL for OpenAI-compatible providers.\n        \"\"\"\n        super().__init__(config)\n        self.api_key_env = api_key_env\n        self.base_url = base_url\n\n        api_key = os.environ.get(self.api_key_env)\n        if not api_key:\n            # We allow init without key, but embed() wil", "tokens": ["def", "init", "self", "config", "embedding", "config", "api", "key", "env", "str", "base", "url", "str", "none", "none", "create", "an", "open", "ai", "backed", "embedding", "provider", "args", "config", "embedding", "configuration", "settings", "api", "key", "env", "environment", "variable", "containing", "the", "api", "key", "base", "url", "optional", "base", "url", "for", "open", "ai", "compatible", "providers", "def", "init", "self", "config", "embedding", "config", "api", "key", "env", "str", "openai", "api", "key", "base", "url", "str", "none", "none", "none", "create", "an", "open", "ai", "backed", "embedding", "provider", "args", "config", "embedding", "configuration", "settings", "api", "key", "env", "environment", "variable", "containing", "the", "api", "key", "base", "url", "optional", "base", "url", "for", "open", "ai", "compatible", "providers", "super", "init", "config", "self", "api", "key", "env", "api", "key", "env", "self", "base", "url", "base", "url", "api", "key", "os", "environ", "get", "self", "api", "key", "env", "if", "not", "api", "key", "we", "allow", "init", "without", "key", "but", "embed", "wil"], "metadata": {"kind": "method", "chunk_index": "0", "has_docstring": "true", "last_modified": "1768294091.1702"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/embedding.py::OpenAIEmbeddingProvider.__init__::1", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/embedding.py::OpenAIEmbeddingProvider.__init__", "content": "t(self.api_key_env)\n        if not api_key:\n            # We allow init without key, but embed() will fail if not provided later\n            self.client = None\n        else:\n            self.client = OpenAI(api_key=api_key, base_url=base_url)", "tokens": ["self", "api", "key", "env", "if", "not", "api", "key", "we", "allow", "init", "without", "key", "but", "embed", "will", "fail", "if", "not", "provided", "later", "self", "client", "none", "else", "self", "client", "open", "ai", "api", "key", "api", "key", "base", "url", "base", "url"], "metadata": {"kind": "method", "chunk_index": "1", "has_docstring": "true", "last_modified": "1768294091.1702"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/embedding.py::OpenAIEmbeddingProvider._get_client::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/embedding.py::OpenAIEmbeddingProvider._get_client", "content": "def _get_client(self) -> OpenAI\n\"\"\"Return an initialized OpenAI client, loading credentials if needed.\"\"\"\n    def _get_client(self) -> OpenAI:\n        \"\"\"Return an initialized OpenAI client, loading credentials if needed.\"\"\"\n        if not self.client:\n            api_key = os.environ.get(self.api_key_env)\n            if not api_key:\n                raise ValueError(f\"{self.api_key_env} environment variable is not set.\")\n            self.client = OpenAI(api_key=api_key, base_url=self.base_url)\n        return self.client", "tokens": ["def", "get", "client", "self", "open", "ai", "return", "an", "initialized", "open", "ai", "client", "loading", "credentials", "if", "needed", "def", "get", "client", "self", "open", "ai", "return", "an", "initialized", "open", "ai", "client", "loading", "credentials", "if", "needed", "if", "not", "self", "client", "api", "key", "os", "environ", "get", "self", "api", "key", "env", "if", "not", "api", "key", "raise", "value", "error", "self", "api", "key", "env", "environment", "variable", "is", "not", "set", "self", "client", "open", "ai", "api", "key", "api", "key", "base", "url", "self", "base", "url", "return", "self", "client"], "metadata": {"kind": "method", "has_docstring": "true", "last_modified": "1768294091.1702"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/embedding.py::OpenAIEmbeddingProvider.embed::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/embedding.py::OpenAIEmbeddingProvider.embed", "content": "def embed(self, texts: list[str]) -> list[list[float]]\n\"\"\"Generate embeddings for a batch of texts.\n\nArgs:\n    texts: Input texts to embed.\n\nReturns:\n    List of embedding vectors (one per input).\"\"\"\n    def embed(self, texts: list[str]) -> list[list[float]]:\n        \"\"\"Generate embeddings for a batch of texts.\n\n        Args:\n            texts: Input texts to embed.\n\n        Returns:\n            List of embedding vectors (one per input).\n        \"\"\"\n        if not texts:\n            return []\n            \n        client = self._get_client()\n        response = client.embeddings.create(\n            model=self.config.model_name,\n            input=texts\n        )\n        embeddings = [item.embedding for item in response.data]\n        \n        if self.config.normalize:\n            embeddings = [self._normalize(e) for e in embeddings]\n            \n        return embeddings", "tokens": ["def", "embed", "self", "texts", "list", "str", "list", "list", "float", "generate", "embeddings", "for", "batch", "of", "texts", "args", "texts", "input", "texts", "to", "embed", "returns", "list", "of", "embedding", "vectors", "one", "per", "input", "def", "embed", "self", "texts", "list", "str", "list", "list", "float", "generate", "embeddings", "for", "batch", "of", "texts", "args", "texts", "input", "texts", "to", "embed", "returns", "list", "of", "embedding", "vectors", "one", "per", "input", "if", "not", "texts", "return", "client", "self", "get", "client", "response", "client", "embeddings", "create", "model", "self", "config", "model", "name", "input", "texts", "embeddings", "item", "embedding", "for", "item", "in", "response", "data", "if", "self", "config", "normalize", "embeddings", "self", "normalize", "for", "in", "embeddings", "return", "embeddings"], "metadata": {"kind": "method", "has_docstring": "true", "last_modified": "1768294091.1702"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/embedding.py::OpenAIEmbeddingProvider.embed_single::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/embedding.py::OpenAIEmbeddingProvider.embed_single", "content": "def embed_single(self, text: str) -> list[float]\n\"\"\"Generate an embedding for a single text input.\"\"\"\n    def embed_single(self, text: str) -> list[float]:\n        \"\"\"Generate an embedding for a single text input.\"\"\"\n        return self.embed([text])[0]", "tokens": ["def", "embed", "single", "self", "text", "str", "list", "float", "generate", "an", "embedding", "for", "single", "text", "input", "def", "embed", "single", "self", "text", "str", "list", "float", "generate", "an", "embedding", "for", "single", "text", "input", "return", "self", "embed", "text"], "metadata": {"kind": "method", "has_docstring": "true", "last_modified": "1768294091.1702"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/embedding.py::OpenAIEmbeddingProvider._normalize::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/embedding.py::OpenAIEmbeddingProvider._normalize", "content": "def _normalize(self, vec: list[float]) -> list[float]\n\"\"\"Normalize a vector to unit length for cosine similarity.\"\"\"\n    def _normalize(self, vec: list[float]) -> list[float]:\n        \"\"\"Normalize a vector to unit length for cosine similarity.\"\"\"\n        import math\n        norm = math.sqrt(sum(x*x for x in vec))\n        return [x / norm for x in vec] if norm > 0 else vec", "tokens": ["def", "normalize", "self", "vec", "list", "float", "list", "float", "normalize", "vector", "to", "unit", "length", "for", "cosine", "similarity", "def", "normalize", "self", "vec", "list", "float", "list", "float", "normalize", "vector", "to", "unit", "length", "for", "cosine", "similarity", "import", "math", "norm", "math", "sqrt", "sum", "for", "in", "vec", "return", "norm", "for", "in", "vec", "if", "norm", "else", "vec"], "metadata": {"kind": "method", "has_docstring": "true", "last_modified": "1768294091.1702"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/embedding.py::VoyageAIEmbeddingProvider::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/embedding.py::VoyageAIEmbeddingProvider", "content": "\"\"\"VoyageAI embedding provider.\"\"\"\nclass VoyageAIEmbeddingProvider(EmbeddingProvider):\n    \"\"\"VoyageAI embedding provider.\"\"\"\n\n    def __init__(\n        self,\n        config: EmbeddingConfig,\n        api_key_env: str = \"VOYAGE_API_KEY_1\",\n    ) -> None:\n        \"\"\"Create a VoyageAI-backed embedding provider.\n\n        Args:\n            config: Embedding configuration settings.\n            api_key_env: Environment variable containing the VoyageAI API key.\n        \"\"\"\n        super().__init__(config)\n        self.api_key_env = api_key_env\n        self.client = None\n\n    def _get_client(self):\n        \"\"\"Return an initialized VoyageAI client, loading credentials if needed.\"\"\"\n        if self.client is None:\n            from knowcode.llm.voyageai_client import get_voyageai_client\n\n            self.client = get_voyageai_client(self.api_key_env)\n\n        if self.client is None:\n            raise ValueError(\n                f\"VoyageAI client unavailable; set {self.api_key_env} and install \"\n  ", "tokens": ["voyage", "ai", "embedding", "provider", "class", "voyage", "aiembedding", "provider", "embedding", "provider", "voyage", "ai", "embedding", "provider", "def", "init", "self", "config", "embedding", "config", "api", "key", "env", "str", "voyage", "api", "key", "none", "create", "voyage", "ai", "backed", "embedding", "provider", "args", "config", "embedding", "configuration", "settings", "api", "key", "env", "environment", "variable", "containing", "the", "voyage", "ai", "api", "key", "super", "init", "config", "self", "api", "key", "env", "api", "key", "env", "self", "client", "none", "def", "get", "client", "self", "return", "an", "initialized", "voyage", "ai", "client", "loading", "credentials", "if", "needed", "if", "self", "client", "is", "none", "from", "knowcode", "llm", "voyageai", "client", "import", "get", "voyageai", "client", "self", "client", "get", "voyageai", "client", "self", "api", "key", "env", "if", "self", "client", "is", "none", "raise", "value", "error", "voyage", "ai", "client", "unavailable", "set", "self", "api", "key", "env", "and", "install"], "metadata": {"kind": "class", "chunk_index": "0", "has_docstring": "true", "last_modified": "1768294091.1702"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/embedding.py::VoyageAIEmbeddingProvider::1", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/embedding.py::VoyageAIEmbeddingProvider", "content": "e ValueError(\n                f\"VoyageAI client unavailable; set {self.api_key_env} and install \"\n                \"optional dependency with: pip install \\\"knowcode[voyageai]\\\"\"\n            )\n\n        return self.client\n\n    def embed(self, texts: list[str]) -> list[list[float]]:\n        \"\"\"Generate document embeddings for a batch of texts.\"\"\"\n        if not texts:\n            return []\n\n        client = self._get_client()\n        embeddings = client.embed(\n            texts=texts,\n            model=self.config.model_name,\n            input_type=\"document\",\n        )\n        if not embeddings:\n            return []\n\n        if self.config.normalize:\n            embeddings = [self._normalize(e) for e in embeddings]\n\n        return embeddings\n\n    def embed_single(self, text: str) -> list[float]:\n        \"\"\"Generate a query embedding for a single text input.\"\"\"\n        client = self._get_client()\n        embeddings = client.embed(\n            texts=[text],\n            model=self.config.mo", "tokens": ["value", "error", "voyage", "ai", "client", "unavailable", "set", "self", "api", "key", "env", "and", "install", "optional", "dependency", "with", "pip", "install", "knowcode", "voyageai", "return", "self", "client", "def", "embed", "self", "texts", "list", "str", "list", "list", "float", "generate", "document", "embeddings", "for", "batch", "of", "texts", "if", "not", "texts", "return", "client", "self", "get", "client", "embeddings", "client", "embed", "texts", "texts", "model", "self", "config", "model", "name", "input", "type", "document", "if", "not", "embeddings", "return", "if", "self", "config", "normalize", "embeddings", "self", "normalize", "for", "in", "embeddings", "return", "embeddings", "def", "embed", "single", "self", "text", "str", "list", "float", "generate", "query", "embedding", "for", "single", "text", "input", "client", "self", "get", "client", "embeddings", "client", "embed", "texts", "text", "model", "self", "config", "mo"], "metadata": {"kind": "class", "chunk_index": "1", "has_docstring": "true", "last_modified": "1768294091.1702"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/embedding.py::VoyageAIEmbeddingProvider::2", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/embedding.py::VoyageAIEmbeddingProvider", "content": "ient()\n        embeddings = client.embed(\n            texts=[text],\n            model=self.config.model_name,\n            input_type=\"query\",\n        )\n        if not embeddings:\n            return []\n\n        emb = embeddings[0]\n        return self._normalize(emb) if self.config.normalize else emb\n\n    def _normalize(self, vec: list[float]) -> list[float]:\n        \"\"\"Normalize a vector to unit length for cosine similarity.\"\"\"\n        import math\n\n        norm = math.sqrt(sum(x * x for x in vec))\n        return [x / norm for x in vec] if norm > 0 else vec", "tokens": ["ient", "embeddings", "client", "embed", "texts", "text", "model", "self", "config", "model", "name", "input", "type", "query", "if", "not", "embeddings", "return", "emb", "embeddings", "return", "self", "normalize", "emb", "if", "self", "config", "normalize", "else", "emb", "def", "normalize", "self", "vec", "list", "float", "list", "float", "normalize", "vector", "to", "unit", "length", "for", "cosine", "similarity", "import", "math", "norm", "math", "sqrt", "sum", "for", "in", "vec", "return", "norm", "for", "in", "vec", "if", "norm", "else", "vec"], "metadata": {"kind": "class", "chunk_index": "2", "has_docstring": "true", "last_modified": "1768294091.1702"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/embedding.py::VoyageAIEmbeddingProvider.__init__::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/embedding.py::VoyageAIEmbeddingProvider.__init__", "content": "def __init__(self, config: EmbeddingConfig, api_key_env: str) -> None\n\"\"\"Create a VoyageAI-backed embedding provider.\n\nArgs:\n    config: Embedding configuration settings.\n    api_key_env: Environment variable containing the VoyageAI API key.\"\"\"\n    def __init__(\n        self,\n        config: EmbeddingConfig,\n        api_key_env: str = \"VOYAGE_API_KEY_1\",\n    ) -> None:\n        \"\"\"Create a VoyageAI-backed embedding provider.\n\n        Args:\n            config: Embedding configuration settings.\n            api_key_env: Environment variable containing the VoyageAI API key.\n        \"\"\"\n        super().__init__(config)\n        self.api_key_env = api_key_env\n        self.client = None", "tokens": ["def", "init", "self", "config", "embedding", "config", "api", "key", "env", "str", "none", "create", "voyage", "ai", "backed", "embedding", "provider", "args", "config", "embedding", "configuration", "settings", "api", "key", "env", "environment", "variable", "containing", "the", "voyage", "ai", "api", "key", "def", "init", "self", "config", "embedding", "config", "api", "key", "env", "str", "voyage", "api", "key", "none", "create", "voyage", "ai", "backed", "embedding", "provider", "args", "config", "embedding", "configuration", "settings", "api", "key", "env", "environment", "variable", "containing", "the", "voyage", "ai", "api", "key", "super", "init", "config", "self", "api", "key", "env", "api", "key", "env", "self", "client", "none"], "metadata": {"kind": "method", "has_docstring": "true", "last_modified": "1768294091.1702"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/embedding.py::VoyageAIEmbeddingProvider._get_client::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/embedding.py::VoyageAIEmbeddingProvider._get_client", "content": "def _get_client(self)\n\"\"\"Return an initialized VoyageAI client, loading credentials if needed.\"\"\"\n    def _get_client(self):\n        \"\"\"Return an initialized VoyageAI client, loading credentials if needed.\"\"\"\n        if self.client is None:\n            from knowcode.llm.voyageai_client import get_voyageai_client\n\n            self.client = get_voyageai_client(self.api_key_env)\n\n        if self.client is None:\n            raise ValueError(\n                f\"VoyageAI client unavailable; set {self.api_key_env} and install \"\n                \"optional dependency with: pip install \\\"knowcode[voyageai]\\\"\"\n            )\n\n        return self.client", "tokens": ["def", "get", "client", "self", "return", "an", "initialized", "voyage", "ai", "client", "loading", "credentials", "if", "needed", "def", "get", "client", "self", "return", "an", "initialized", "voyage", "ai", "client", "loading", "credentials", "if", "needed", "if", "self", "client", "is", "none", "from", "knowcode", "llm", "voyageai", "client", "import", "get", "voyageai", "client", "self", "client", "get", "voyageai", "client", "self", "api", "key", "env", "if", "self", "client", "is", "none", "raise", "value", "error", "voyage", "ai", "client", "unavailable", "set", "self", "api", "key", "env", "and", "install", "optional", "dependency", "with", "pip", "install", "knowcode", "voyageai", "return", "self", "client"], "metadata": {"kind": "method", "has_docstring": "true", "last_modified": "1768294091.1702"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/embedding.py::VoyageAIEmbeddingProvider.embed::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/embedding.py::VoyageAIEmbeddingProvider.embed", "content": "def embed(self, texts: list[str]) -> list[list[float]]\n\"\"\"Generate document embeddings for a batch of texts.\"\"\"\n    def embed(self, texts: list[str]) -> list[list[float]]:\n        \"\"\"Generate document embeddings for a batch of texts.\"\"\"\n        if not texts:\n            return []\n\n        client = self._get_client()\n        embeddings = client.embed(\n            texts=texts,\n            model=self.config.model_name,\n            input_type=\"document\",\n        )\n        if not embeddings:\n            return []\n\n        if self.config.normalize:\n            embeddings = [self._normalize(e) for e in embeddings]\n\n        return embeddings", "tokens": ["def", "embed", "self", "texts", "list", "str", "list", "list", "float", "generate", "document", "embeddings", "for", "batch", "of", "texts", "def", "embed", "self", "texts", "list", "str", "list", "list", "float", "generate", "document", "embeddings", "for", "batch", "of", "texts", "if", "not", "texts", "return", "client", "self", "get", "client", "embeddings", "client", "embed", "texts", "texts", "model", "self", "config", "model", "name", "input", "type", "document", "if", "not", "embeddings", "return", "if", "self", "config", "normalize", "embeddings", "self", "normalize", "for", "in", "embeddings", "return", "embeddings"], "metadata": {"kind": "method", "has_docstring": "true", "last_modified": "1768294091.1702"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/embedding.py::VoyageAIEmbeddingProvider.embed_single::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/embedding.py::VoyageAIEmbeddingProvider.embed_single", "content": "def embed_single(self, text: str) -> list[float]\n\"\"\"Generate a query embedding for a single text input.\"\"\"\n    def embed_single(self, text: str) -> list[float]:\n        \"\"\"Generate a query embedding for a single text input.\"\"\"\n        client = self._get_client()\n        embeddings = client.embed(\n            texts=[text],\n            model=self.config.model_name,\n            input_type=\"query\",\n        )\n        if not embeddings:\n            return []\n\n        emb = embeddings[0]\n        return self._normalize(emb) if self.config.normalize else emb", "tokens": ["def", "embed", "single", "self", "text", "str", "list", "float", "generate", "query", "embedding", "for", "single", "text", "input", "def", "embed", "single", "self", "text", "str", "list", "float", "generate", "query", "embedding", "for", "single", "text", "input", "client", "self", "get", "client", "embeddings", "client", "embed", "texts", "text", "model", "self", "config", "model", "name", "input", "type", "query", "if", "not", "embeddings", "return", "emb", "embeddings", "return", "self", "normalize", "emb", "if", "self", "config", "normalize", "else", "emb"], "metadata": {"kind": "method", "has_docstring": "true", "last_modified": "1768294091.1702"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/embedding.py::VoyageAIEmbeddingProvider._normalize::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/embedding.py::VoyageAIEmbeddingProvider._normalize", "content": "def _normalize(self, vec: list[float]) -> list[float]\n\"\"\"Normalize a vector to unit length for cosine similarity.\"\"\"\n    def _normalize(self, vec: list[float]) -> list[float]:\n        \"\"\"Normalize a vector to unit length for cosine similarity.\"\"\"\n        import math\n\n        norm = math.sqrt(sum(x * x for x in vec))\n        return [x / norm for x in vec] if norm > 0 else vec", "tokens": ["def", "normalize", "self", "vec", "list", "float", "list", "float", "normalize", "vector", "to", "unit", "length", "for", "cosine", "similarity", "def", "normalize", "self", "vec", "list", "float", "list", "float", "normalize", "vector", "to", "unit", "length", "for", "cosine", "similarity", "import", "math", "norm", "math", "sqrt", "sum", "for", "in", "vec", "return", "norm", "for", "in", "vec", "if", "norm", "else", "vec"], "metadata": {"kind": "method", "has_docstring": "true", "last_modified": "1768294091.1702"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/embedding.py::create_embedding_provider::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/embedding.py::create_embedding_provider", "content": "def create_embedding_provider(app_config: AppConfig | None, embedding_config: EmbeddingConfig | None) -> EmbeddingProvider\n\"\"\"Create an embedding provider from explicit config or AppConfig.\n\nSelection precedence:\n1) Explicit EmbeddingConfig (embedding_config.provider)\n2) First usable model in app_config.embedding_models\n3) Default OpenAIEmbeddingProvider with default EmbeddingConfig\"\"\"\ndef create_embedding_provider(\n    app_config: AppConfig | None = None,\n    embedding_config: EmbeddingConfig | None = None,\n) -> EmbeddingProvider:\n    \"\"\"Create an embedding provider from explicit config or AppConfig.\n\n    Selection precedence:\n    1) Explicit EmbeddingConfig (embedding_config.provider)\n    2) First usable model in app_config.embedding_models\n    3) Default OpenAIEmbeddingProvider with default EmbeddingConfig\n    \"\"\"\n    if embedding_config is not None:\n        provider = embedding_config.provider.lower()\n        if provider in {\"voyageai\", \"voyage\"}:\n            return VoyageAIEmbeddi", "tokens": ["def", "create", "embedding", "provider", "app", "config", "app", "config", "none", "embedding", "config", "embedding", "config", "none", "embedding", "provider", "create", "an", "embedding", "provider", "from", "explicit", "config", "or", "app", "config", "selection", "precedence", "explicit", "embedding", "config", "embedding", "config", "provider", "first", "usable", "model", "in", "app", "config", "embedding", "models", "default", "open", "aiembedding", "provider", "with", "default", "embedding", "config", "def", "create", "embedding", "provider", "app", "config", "app", "config", "none", "none", "embedding", "config", "embedding", "config", "none", "none", "embedding", "provider", "create", "an", "embedding", "provider", "from", "explicit", "config", "or", "app", "config", "selection", "precedence", "explicit", "embedding", "config", "embedding", "config", "provider", "first", "usable", "model", "in", "app", "config", "embedding", "models", "default", "open", "aiembedding", "provider", "with", "default", "embedding", "config", "if", "embedding", "config", "is", "not", "none", "provider", "embedding", "config", "provider", "lower", "if", "provider", "in", "voyageai", "voyage", "return", "voyage", "aiembeddi"], "metadata": {"kind": "function", "chunk_index": "0", "has_docstring": "true", "last_modified": "1768294091.1702"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/embedding.py::create_embedding_provider::1", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/embedding.py::create_embedding_provider", "content": "g.provider.lower()\n        if provider in {\"voyageai\", \"voyage\"}:\n            return VoyageAIEmbeddingProvider(embedding_config)\n        return OpenAIEmbeddingProvider(embedding_config)\n\n    if app_config and app_config.embedding_models:\n        for model in app_config.embedding_models:\n            api_key = os.environ.get(model.api_key_env)\n            if not api_key:\n                continue\n\n            provider = model.provider.lower()\n            if provider in {\"voyageai\", \"voyage\"}:\n                cfg = EmbeddingConfig(\n                    provider=\"voyageai\",\n                    model_name=model.name,\n                    dimension=_VOYAGE_EMBED_DIMENSIONS.get(model.name, 1024),\n                )\n                return VoyageAIEmbeddingProvider(cfg, api_key_env=model.api_key_env)\n\n            if provider in {\"openai\", \"openrouter\", \"mistralai\"}:\n                base_url = None\n                if provider in {\"openrouter\", \"mistralai\"}:\n                    base_url = \"https://op", "tokens": ["provider", "lower", "if", "provider", "in", "voyageai", "voyage", "return", "voyage", "aiembedding", "provider", "embedding", "config", "return", "open", "aiembedding", "provider", "embedding", "config", "if", "app", "config", "and", "app", "config", "embedding", "models", "for", "model", "in", "app", "config", "embedding", "models", "api", "key", "os", "environ", "get", "model", "api", "key", "env", "if", "not", "api", "key", "continue", "provider", "model", "provider", "lower", "if", "provider", "in", "voyageai", "voyage", "cfg", "embedding", "config", "provider", "voyageai", "model", "name", "model", "name", "dimension", "voyage", "embed", "dimensions", "get", "model", "name", "1024", "return", "voyage", "aiembedding", "provider", "cfg", "api", "key", "env", "model", "api", "key", "env", "if", "provider", "in", "openai", "openrouter", "mistralai", "base", "url", "none", "if", "provider", "in", "openrouter", "mistralai", "base", "url", "https", "op"], "metadata": {"kind": "function", "chunk_index": "1", "has_docstring": "true", "last_modified": "1768294091.1702"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/embedding.py::create_embedding_provider::2", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/embedding.py::create_embedding_provider", "content": "              if provider in {\"openrouter\", \"mistralai\"}:\n                    base_url = \"https://openrouter.ai/api/v1\"\n\n                cfg = EmbeddingConfig(\n                    provider=\"openai\",\n                    model_name=model.name,\n                    dimension=_OPENAI_EMBED_DIMENSIONS.get(model.name, 1536),\n                )\n                return OpenAIEmbeddingProvider(\n                    cfg,\n                    api_key_env=model.api_key_env,\n                    base_url=base_url,\n                )\n\n    # Final fallback: use defaults from EmbeddingConfig (now VoyageAI)\n    return VoyageAIEmbeddingProvider(EmbeddingConfig())", "tokens": ["if", "provider", "in", "openrouter", "mistralai", "base", "url", "https", "openrouter", "ai", "api", "v1", "cfg", "embedding", "config", "provider", "openai", "model", "name", "model", "name", "dimension", "openai", "embed", "dimensions", "get", "model", "name", "1536", "return", "open", "aiembedding", "provider", "cfg", "api", "key", "env", "model", "api", "key", "env", "base", "url", "base", "url", "final", "fallback", "use", "defaults", "from", "embedding", "config", "now", "voyage", "ai", "return", "voyage", "aiembedding", "provider", "embedding", "config"], "metadata": {"kind": "function", "chunk_index": "2", "has_docstring": "true", "last_modified": "1768294091.1702"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/query_classifier.py::module::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/query_classifier.py::module", "content": "\"\"\"Query classifier for detecting query/task types.\n\nClassifies user queries into TaskTypes (explain, debug, extend, review, locate)\nto enable task-specific context prioritization and prompt templates.\n\"\"\"", "tokens": ["query", "classifier", "for", "detecting", "query", "task", "types", "classifies", "user", "queries", "into", "task", "types", "explain", "debug", "extend", "review", "locate", "to", "enable", "task", "specific", "context", "prioritization", "and", "prompt", "templates"], "metadata": {"type": "module_header"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/query_classifier.py::imports::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/query_classifier.py::module", "content": "import re\nfrom typing import Tuple\nfrom knowcode.data_models import TaskType", "tokens": ["import", "re", "from", "typing", "import", "tuple", "from", "knowcode", "data", "models", "import", "task", "type"], "metadata": {"type": "imports"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/query_classifier.py::classify_query::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/query_classifier.py::classify_query", "content": "def classify_query(query: str) -> Tuple[TaskType, float]\n\"\"\"Classify a query into a TaskType with confidence score.\n\nArgs:\n    query: User's natural language query.\n    \nReturns:\n    Tuple of (TaskType, confidence) where confidence is 0.0-1.0.\n    Returns (TaskType.GENERAL, 0.0) if no patterns match.\"\"\"\ndef classify_query(query: str) -> Tuple[TaskType, float]:\n    \"\"\"Classify a query into a TaskType with confidence score.\n    \n    Args:\n        query: User's natural language query.\n        \n    Returns:\n        Tuple of (TaskType, confidence) where confidence is 0.0-1.0.\n        Returns (TaskType.GENERAL, 0.0) if no patterns match.\n    \"\"\"\n    scores: dict[TaskType, int] = {t: 0 for t in TaskType if t != TaskType.GENERAL}\n    \n    for task_type, patterns in TASK_PATTERNS.items():\n        for pattern, weight in patterns:\n            if pattern.search(query):\n                scores[task_type] += weight\n    \n    # Find highest scoring type\n    max_score = max(scores.values())\n    \n    if ", "tokens": ["def", "classify", "query", "query", "str", "tuple", "task", "type", "float", "classify", "query", "into", "task", "type", "with", "confidence", "score", "args", "query", "user", "natural", "language", "query", "returns", "tuple", "of", "task", "type", "confidence", "where", "confidence", "is", "returns", "task", "type", "general", "if", "no", "patterns", "match", "def", "classify", "query", "query", "str", "tuple", "task", "type", "float", "classify", "query", "into", "task", "type", "with", "confidence", "score", "args", "query", "user", "natural", "language", "query", "returns", "tuple", "of", "task", "type", "confidence", "where", "confidence", "is", "returns", "task", "type", "general", "if", "no", "patterns", "match", "scores", "dict", "task", "type", "int", "for", "in", "task", "type", "if", "task", "type", "general", "for", "task", "type", "patterns", "in", "task", "patterns", "items", "for", "pattern", "weight", "in", "patterns", "if", "pattern", "search", "query", "scores", "task", "type", "weight", "find", "highest", "scoring", "type", "max", "score", "max", "scores", "values", "if"], "metadata": {"kind": "function", "chunk_index": "0", "has_docstring": "true", "last_modified": "1768101513.6366417"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/query_classifier.py::classify_query::1", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/query_classifier.py::classify_query", "content": "pe] += weight\n    \n    # Find highest scoring type\n    max_score = max(scores.values())\n    \n    if max_score == 0:\n        return TaskType.GENERAL, 0.0\n    \n    best_type = max(scores, key=scores.get)  # type: ignore\n    \n    # Calculate confidence based on score relative to maximum possible\n    # and gap to second-best\n    total_possible = sum(weight for _, weight in TASK_PATTERNS[best_type])\n    base_confidence = min(1.0, max_score / (total_possible * 0.5))  # 50% of max = full confidence\n    \n    # Boost confidence if clear winner (large gap to second place)\n    sorted_scores = sorted(scores.values(), reverse=True)\n    if len(sorted_scores) > 1 and sorted_scores[0] > 0:\n        gap_ratio = 1 - (sorted_scores[1] / sorted_scores[0])\n        base_confidence = min(1.0, base_confidence * (1 + gap_ratio * 0.3))\n    \n    return best_type, round(base_confidence, 2)", "tokens": ["pe", "weight", "find", "highest", "scoring", "type", "max", "score", "max", "scores", "values", "if", "max", "score", "return", "task", "type", "general", "best", "type", "max", "scores", "key", "scores", "get", "type", "ignore", "calculate", "confidence", "based", "on", "score", "relative", "to", "maximum", "possible", "and", "gap", "to", "second", "best", "total", "possible", "sum", "weight", "for", "weight", "in", "task", "patterns", "best", "type", "base", "confidence", "min", "max", "score", "total", "possible", "50", "of", "max", "full", "confidence", "boost", "confidence", "if", "clear", "winner", "large", "gap", "to", "second", "place", "sorted", "scores", "sorted", "scores", "values", "reverse", "true", "if", "len", "sorted", "scores", "and", "sorted", "scores", "gap", "ratio", "sorted", "scores", "sorted", "scores", "base", "confidence", "min", "base", "confidence", "gap", "ratio", "return", "best", "type", "round", "base", "confidence"], "metadata": {"kind": "function", "chunk_index": "1", "has_docstring": "true", "last_modified": "1768101513.6366417"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/query_classifier.py::get_prompt_template::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/query_classifier.py::get_prompt_template", "content": "def get_prompt_template(task_type: TaskType) -> str\n\"\"\"Get the system prompt template for a task type.\n\nArgs:\n    task_type: The classified task type.\n    \nReturns:\n    System prompt string optimized for the task type.\"\"\"\ndef get_prompt_template(task_type: TaskType) -> str:\n    \"\"\"Get the system prompt template for a task type.\n    \n    Args:\n        task_type: The classified task type.\n        \n    Returns:\n        System prompt string optimized for the task type.\n    \"\"\"\n    return TASK_PROMPTS.get(task_type, TASK_PROMPTS[TaskType.GENERAL])", "tokens": ["def", "get", "prompt", "template", "task", "type", "task", "type", "str", "get", "the", "system", "prompt", "template", "for", "task", "type", "args", "task", "type", "the", "classified", "task", "type", "returns", "system", "prompt", "string", "optimized", "for", "the", "task", "type", "def", "get", "prompt", "template", "task", "type", "task", "type", "str", "get", "the", "system", "prompt", "template", "for", "task", "type", "args", "task", "type", "the", "classified", "task", "type", "returns", "system", "prompt", "string", "optimized", "for", "the", "task", "type", "return", "task", "prompts", "get", "task", "type", "task", "prompts", "task", "type", "general"], "metadata": {"kind": "function", "has_docstring": "true", "last_modified": "1768101513.6366417"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/agent.py::module::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/agent.py::module", "content": "\"\"\"Agent module for KnowCode.\"\"\"", "tokens": ["agent", "module", "for", "know", "code"], "metadata": {"type": "module_header"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/agent.py::imports::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/agent.py::module", "content": "import os\nfrom typing import Optional, Any\nfrom google import genai\nfrom google.api_core.exceptions import ResourceExhausted\nimport openai\nfrom knowcode.service import KnowCodeService\nfrom knowcode.config import AppConfig, ModelConfig\nfrom knowcode.llm.rate_limiter import RateLimiter\nfrom knowcode.llm.query_classifier import get_prompt_template\nfrom knowcode.data_models import TaskType", "tokens": ["import", "os", "from", "typing", "import", "optional", "any", "from", "google", "import", "genai", "from", "google", "api", "core", "exceptions", "import", "resource", "exhausted", "import", "openai", "from", "knowcode", "service", "import", "know", "code", "service", "from", "knowcode", "config", "import", "app", "config", "model", "config", "from", "knowcode", "llm", "rate", "limiter", "import", "rate", "limiter", "from", "knowcode", "llm", "query", "classifier", "import", "get", "prompt", "template", "from", "knowcode", "data", "models", "import", "task", "type"], "metadata": {"type": "imports"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/agent.py::Agent::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/agent.py::Agent", "content": "\"\"\"Agent that answers questions about the codebase using an LLM (Gemini or OpenAI/OpenRouter).\"\"\"\nclass Agent:\n    \"\"\"Agent that answers questions about the codebase using an LLM (Gemini or OpenAI/OpenRouter).\"\"\"\n\n    def __init__(self, service: KnowCodeService, config: AppConfig) -> None:\n        \"\"\"Initialize the agent.\n        \n        Args:\n            service: KnowCodeService instance for context retrieval.\n            config: Application configuration containing model priorities.\n        \"\"\"\n        self.service = service\n        self.config = config\n        self.clients: dict[str, Any] = {}\n        self.rate_limiter = RateLimiter()\n\n    def _get_client(self, config: ModelConfig) -> Optional[Any]:\n        \"\"\"Get or create client for a specific model configuration.\"\"\"\n        client_key = f\"{config.provider}_{config.api_key_env}\"\n        if client_key in self.clients:\n            return self.clients[client_key]\n            \n        api_key = os.environ.get(config.api_key_env)\n    ", "tokens": ["agent", "that", "answers", "questions", "about", "the", "codebase", "using", "an", "llm", "gemini", "or", "open", "ai", "open", "router", "class", "agent", "agent", "that", "answers", "questions", "about", "the", "codebase", "using", "an", "llm", "gemini", "or", "open", "ai", "open", "router", "def", "init", "self", "service", "know", "code", "service", "config", "app", "config", "none", "initialize", "the", "agent", "args", "service", "know", "code", "service", "instance", "for", "context", "retrieval", "config", "application", "configuration", "containing", "model", "priorities", "self", "service", "service", "self", "config", "config", "self", "clients", "dict", "str", "any", "self", "rate", "limiter", "rate", "limiter", "def", "get", "client", "self", "config", "model", "config", "optional", "any", "get", "or", "create", "client", "for", "specific", "model", "configuration", "client", "key", "config", "provider", "config", "api", "key", "env", "if", "client", "key", "in", "self", "clients", "return", "self", "clients", "client", "key", "api", "key", "os", "environ", "get", "config", "api", "key", "env"], "metadata": {"kind": "class", "chunk_index": "0", "has_docstring": "true", "last_modified": "1768185812.993273"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/agent.py::Agent::1", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/agent.py::Agent", "content": "turn self.clients[client_key]\n            \n        api_key = os.environ.get(config.api_key_env)\n        if not api_key:\n            return None\n            \n        if config.provider == \"google\":\n            client = genai.Client(api_key=api_key)\n        else:\n            # Assume OpenAI-compatible (OpenAI, OpenRouter, Mistral, etc.)\n            base_url = None\n            if config.provider == \"mistralai\" or \"openrouter\" in config.provider:\n                base_url = \"https://openrouter.ai/api/v1\"\n            \n            client = openai.OpenAI(\n                api_key=api_key,\n                base_url=base_url\n            )\n            \n        self.clients[client_key] = client\n        return client\n\n    def answer(self, query: str) -> str:\n        \"\"\"Answer a question about the codebase.\n\n        Args:\n            query: User's question.\n\n        Returns:\n            The agent's answer.\n            \n        Raises:\n            ValueError: If no API keys are set.\n            Excepti", "tokens": ["turn", "self", "clients", "client", "key", "api", "key", "os", "environ", "get", "config", "api", "key", "env", "if", "not", "api", "key", "return", "none", "if", "config", "provider", "google", "client", "genai", "client", "api", "key", "api", "key", "else", "assume", "open", "ai", "compatible", "open", "ai", "open", "router", "mistral", "etc", "base", "url", "none", "if", "config", "provider", "mistralai", "or", "openrouter", "in", "config", "provider", "base", "url", "https", "openrouter", "ai", "api", "v1", "client", "openai", "open", "ai", "api", "key", "api", "key", "base", "url", "base", "url", "self", "clients", "client", "key", "client", "return", "client", "def", "answer", "self", "query", "str", "str", "answer", "question", "about", "the", "codebase", "args", "query", "user", "question", "returns", "the", "agent", "answer", "raises", "value", "error", "if", "no", "api", "keys", "are", "set", "excepti"], "metadata": {"kind": "class", "chunk_index": "1", "has_docstring": "true", "last_modified": "1768185812.993273"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/agent.py::Agent::2", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/agent.py::Agent", "content": "er.\n            \n        Raises:\n            ValueError: If no API keys are set.\n            Exception: If all models fail.\n        \"\"\"\n        retrieval = self.service.retrieve_context_for_query(query)\n        task_type = TaskType(retrieval.get(\"task_type\", TaskType.GENERAL.value))\n        confidence = float(retrieval.get(\"task_confidence\", 0.0))\n        print(f\"  \ud83d\udccb Query type: {task_type.value} (confidence: {confidence:.0%})\")\n\n        context_str = retrieval.get(\"context_text\", \"\")\n        if not context_str:\n            context_str = (\n                \"No specific entities found in the codebase matching the query terms. \"\n                \"Answer based on general software engineering principles if possible.\"\n            )\n\n        # 2. Construct Prompt with task-specific system instructions\n        system_instructions = get_prompt_template(task_type)\n        \n        prompt = f\"{system_instructions}\\n\\nContext:\\n{context_str}\\n\\nQuestion: {query}\"\n\n        # 3. Call LLM with Failove", "tokens": ["er", "raises", "value", "error", "if", "no", "api", "keys", "are", "set", "exception", "if", "all", "models", "fail", "retrieval", "self", "service", "retrieve", "context", "for", "query", "query", "task", "type", "task", "type", "retrieval", "get", "task", "type", "task", "type", "general", "value", "confidence", "float", "retrieval", "get", "task", "confidence", "print", "query", "type", "task", "type", "value", "confidence", "confidence", "context", "str", "retrieval", "get", "context", "text", "if", "not", "context", "str", "context", "str", "no", "specific", "entities", "found", "in", "the", "codebase", "matching", "the", "query", "terms", "answer", "based", "on", "general", "software", "engineering", "principles", "if", "possible", "construct", "prompt", "with", "task", "specific", "system", "instructions", "system", "instructions", "get", "prompt", "template", "task", "type", "prompt", "system", "instructions", "context", "context", "str", "question", "query", "call", "llm", "with", "failove"], "metadata": {"kind": "class", "chunk_index": "2", "has_docstring": "true", "last_modified": "1768185812.993273"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/agent.py::Agent::3", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/agent.py::Agent", "content": "m_instructions}\\n\\nContext:\\n{context_str}\\n\\nQuestion: {query}\"\n\n        # 3. Call LLM with Failover\n        last_error = None\n        \n        for model_config in self.config.models:\n            print(f\"\ud83e\udd16 Trying model: {model_config.name} ({model_config.provider})...\") \n            \n            # Check Rate Limit (Client-side)\n            if not self.rate_limiter.check_availability(model_config):\n                # Warning already printed by check_availability\n                continue\n\n            client = self._get_client(model_config)\n            \n            if not client:\n                print(f\"  \u26a0\ufe0f Skipping {model_config.name}: {model_config.api_key_env} not set.\")\n                continue\n\n            try:\n                response_text = \"\"\n                if model_config.provider == \"google\":\n                    response = client.models.generate_content(\n                        model=model_config.name,\n                        contents=prompt,\n                    )\n            ", "tokens": ["instructions", "context", "context", "str", "question", "query", "call", "llm", "with", "failover", "last", "error", "none", "for", "model", "config", "in", "self", "config", "models", "print", "trying", "model", "model", "config", "name", "model", "config", "provider", "check", "rate", "limit", "client", "side", "if", "not", "self", "rate", "limiter", "check", "availability", "model", "config", "warning", "already", "printed", "by", "check", "availability", "continue", "client", "self", "get", "client", "model", "config", "if", "not", "client", "print", "skipping", "model", "config", "name", "model", "config", "api", "key", "env", "not", "set", "continue", "try", "response", "text", "if", "model", "config", "provider", "google", "response", "client", "models", "generate", "content", "model", "model", "config", "name", "contents", "prompt"], "metadata": {"kind": "class", "chunk_index": "3", "has_docstring": "true", "last_modified": "1768185812.993273"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/agent.py::Agent::4", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/agent.py::Agent", "content": "model=model_config.name,\n                        contents=prompt,\n                    )\n                    response_text = response.text or \"No response from LLM.\"\n                else:\n                    # OpenAI / OpenRouter style\n                    extra_headers = {}\n                    if \"openrouter\" in model_config.provider or model_config.provider == \"mistralai\":\n                         extra_headers = {\n                             \"HTTP-Referer\": \"https://github.com/deepakdgupta1/KnowCode\",\n                             \"X-Title\": \"KnowCode\",\n                         }\n                         \n                    chat_completion = client.chat.completions.create(\n                        model=model_config.name,\n                        messages=[\n                            {\"role\": \"user\", \"content\": prompt}\n                        ],\n                        extra_headers=extra_headers\n                    )\n                    response_text = chat_completion.choices[0].mess", "tokens": ["model", "model", "config", "name", "contents", "prompt", "response", "text", "response", "text", "or", "no", "response", "from", "llm", "else", "open", "ai", "open", "router", "style", "extra", "headers", "if", "openrouter", "in", "model", "config", "provider", "or", "model", "config", "provider", "mistralai", "extra", "headers", "http", "referer", "https", "github", "com", "deepakdgupta1", "know", "code", "title", "know", "code", "chat", "completion", "client", "chat", "completions", "create", "model", "model", "config", "name", "messages", "role", "user", "content", "prompt", "extra", "headers", "extra", "headers", "response", "text", "chat", "completion", "choices", "mess"], "metadata": {"kind": "class", "chunk_index": "4", "has_docstring": "true", "last_modified": "1768185812.993273"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/agent.py::Agent::5", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/agent.py::Agent", "content": "ra_headers\n                    )\n                    response_text = chat_completion.choices[0].message.content or \"No response from LLM.\"\n                \n                # Success! Record usage and return\n                self.rate_limiter.record_usage(model_config.name)\n                return response_text\n            \n            except ResourceExhausted as e:\n                 print(f\"  \u26a0\ufe0f Rate limit exceeded (Server) for {model_config.name}. Switching...\")\n                 last_error = e\n                 continue\n            except Exception as e:\n                 print(f\"  \u274c Error with {model_config.name}: {e}\")\n                 last_error = e\n                 continue\n\n        if last_error:\n            raise last_error\n        \n        raise ValueError(\"No valid configuration found or all models skipped (check API keys or limits).\")\n\n    def smart_answer(\n        self,\n        query: str,\n        force_llm: bool = False,\n    ) -> dict[str, Any]:\n        \"\"\"Smart answer with loca", "tokens": ["ra", "headers", "response", "text", "chat", "completion", "choices", "message", "content", "or", "no", "response", "from", "llm", "success", "record", "usage", "and", "return", "self", "rate", "limiter", "record", "usage", "model", "config", "name", "return", "response", "text", "except", "resource", "exhausted", "as", "print", "rate", "limit", "exceeded", "server", "for", "model", "config", "name", "switching", "last", "error", "continue", "except", "exception", "as", "print", "error", "with", "model", "config", "name", "last", "error", "continue", "if", "last", "error", "raise", "last", "error", "raise", "value", "error", "no", "valid", "configuration", "found", "or", "all", "models", "skipped", "check", "api", "keys", "or", "limits", "def", "smart", "answer", "self", "query", "str", "force", "llm", "bool", "false", "dict", "str", "any", "smart", "answer", "with", "loca"], "metadata": {"kind": "class", "chunk_index": "5", "has_docstring": "true", "last_modified": "1768185812.993273"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/agent.py::Agent::6", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/agent.py::Agent", "content": "ry: str,\n        force_llm: bool = False,\n    ) -> dict[str, Any]:\n        \"\"\"Smart answer with local-first mode.\n        \n        If context sufficiency >= threshold, returns local answer without LLM.\n        Only calls external LLM when context is insufficient.\n        \n        Args:\n            query: User's question.\n            force_llm: If True, always use LLM regardless of sufficiency.\n            \n        Returns:\n            Dict with:\n                - answer: The response text\n                - source: \"local\" or \"llm\"\n                - task_type: Detected query type\n                - sufficiency_score: Context quality score\n                - context: The retrieved context\n        \"\"\"\n        retrieval = self.service.retrieve_context_for_query(query)\n        task_type = TaskType(retrieval.get(\"task_type\", TaskType.GENERAL.value))\n        confidence = float(retrieval.get(\"task_confidence\", 0.0))\n        print(f\"  \ud83d\udccb Query type: {task_type.value} (confidence: {confidence:.0%})", "tokens": ["ry", "str", "force", "llm", "bool", "false", "dict", "str", "any", "smart", "answer", "with", "local", "first", "mode", "if", "context", "sufficiency", "threshold", "returns", "local", "answer", "without", "llm", "only", "calls", "external", "llm", "when", "context", "is", "insufficient", "args", "query", "user", "question", "force", "llm", "if", "true", "always", "use", "llm", "regardless", "of", "sufficiency", "returns", "dict", "with", "answer", "the", "response", "text", "source", "local", "or", "llm", "task", "type", "detected", "query", "type", "sufficiency", "score", "context", "quality", "score", "context", "the", "retrieved", "context", "retrieval", "self", "service", "retrieve", "context", "for", "query", "query", "task", "type", "task", "type", "retrieval", "get", "task", "type", "task", "type", "general", "value", "confidence", "float", "retrieval", "get", "task", "confidence", "print", "query", "type", "task", "type", "value", "confidence", "confidence"], "metadata": {"kind": "class", "chunk_index": "6", "has_docstring": "true", "last_modified": "1768185812.993273"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/agent.py::Agent::7", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/agent.py::Agent", "content": "_confidence\", 0.0))\n        print(f\"  \ud83d\udccb Query type: {task_type.value} (confidence: {confidence:.0%})\")\n\n        avg_sufficiency = float(retrieval.get(\"sufficiency_score\", 0.0))\n        context_str = retrieval.get(\"context_text\", \"\")\n\n        threshold = self.config.sufficiency_threshold\n        print(f\"  \ud83d\udcca Sufficiency: {avg_sufficiency:.0%} (threshold: {threshold:.0%})\")\n        \n        # 3. Decide: local answer or LLM\n        if not force_llm and avg_sufficiency >= threshold and context_str:\n            # Local-first: sufficient context found\n            print(\"  \u2705 Answering locally (sufficient context)\")\n            \n            local_answer = self._format_local_answer(query, task_type, context_str)\n            \n            return {\n                \"answer\": local_answer,\n                \"source\": \"local\",\n                \"task_type\": task_type.value,\n                \"sufficiency_score\": avg_sufficiency,\n                \"context\": context_str,\n                \"llm_tokens_saved\": len", "tokens": ["confidence", "print", "query", "type", "task", "type", "value", "confidence", "confidence", "avg", "sufficiency", "float", "retrieval", "get", "sufficiency", "score", "context", "str", "retrieval", "get", "context", "text", "threshold", "self", "config", "sufficiency", "threshold", "print", "sufficiency", "avg", "sufficiency", "threshold", "threshold", "decide", "local", "answer", "or", "llm", "if", "not", "force", "llm", "and", "avg", "sufficiency", "threshold", "and", "context", "str", "local", "first", "sufficient", "context", "found", "print", "answering", "locally", "sufficient", "context", "local", "answer", "self", "format", "local", "answer", "query", "task", "type", "context", "str", "return", "answer", "local", "answer", "source", "local", "task", "type", "task", "type", "value", "sufficiency", "score", "avg", "sufficiency", "context", "context", "str", "llm", "tokens", "saved", "len"], "metadata": {"kind": "class", "chunk_index": "7", "has_docstring": "true", "last_modified": "1768185812.993273"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/agent.py::Agent::8", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/agent.py::Agent", "content": "e\": avg_sufficiency,\n                \"context\": context_str,\n                \"llm_tokens_saved\": len(context_str.split()),  # Rough estimate\n            }\n        else:\n            # Need LLM\n            print(\"  \ud83e\udd16 Calling LLM (sufficiency below threshold or forced)\")\n            \n            llm_answer = self.answer(query)\n            \n            return {\n                \"answer\": llm_answer,\n                \"source\": \"llm\",\n                \"task_type\": task_type.value,\n                \"sufficiency_score\": avg_sufficiency,\n                \"context\": context_str,\n                \"llm_tokens_saved\": 0,\n            }\n\n    def _format_local_answer(\n        self,\n        query: str,\n        task_type: TaskType,\n        context: str,\n    ) -> str:\n        \"\"\"Format a local answer without LLM.\n        \n        For simple queries like 'locate', we can answer directly from context.\n        For more complex queries, we format the context nicely.\n        \"\"\"\n        if task_type == TaskType.LOC", "tokens": ["avg", "sufficiency", "context", "context", "str", "llm", "tokens", "saved", "len", "context", "str", "split", "rough", "estimate", "else", "need", "llm", "print", "calling", "llm", "sufficiency", "below", "threshold", "or", "forced", "llm", "answer", "self", "answer", "query", "return", "answer", "llm", "answer", "source", "llm", "task", "type", "task", "type", "value", "sufficiency", "score", "avg", "sufficiency", "context", "context", "str", "llm", "tokens", "saved", "def", "format", "local", "answer", "self", "query", "str", "task", "type", "task", "type", "context", "str", "str", "format", "local", "answer", "without", "llm", "for", "simple", "queries", "like", "locate", "we", "can", "answer", "directly", "from", "context", "for", "more", "complex", "queries", "we", "format", "the", "context", "nicely", "if", "task", "type", "task", "type", "loc"], "metadata": {"kind": "class", "chunk_index": "8", "has_docstring": "true", "last_modified": "1768185812.993273"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/agent.py::Agent::9", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/agent.py::Agent", "content": "more complex queries, we format the context nicely.\n        \"\"\"\n        if task_type == TaskType.LOCATE:\n            # Extract locations from context\n            return f\"**Found in codebase:**\\n\\n{context}\"\n        \n        elif task_type == TaskType.EXPLAIN:\n            return f\"**Based on the codebase context:**\\n\\n{context}\\n\\n*Note: This is a local answer based on retrieved context. For more detailed explanations, use `force_llm=True`.*\"\n        \n        else:\n            # General format\n            return f\"**Relevant context from codebase:**\\n\\n{context}\\n\\n*Local answer based on high-confidence context match. Use `force_llm=True` for LLM-enhanced responses.*\"", "tokens": ["more", "complex", "queries", "we", "format", "the", "context", "nicely", "if", "task", "type", "task", "type", "locate", "extract", "locations", "from", "context", "return", "found", "in", "codebase", "context", "elif", "task", "type", "task", "type", "explain", "return", "based", "on", "the", "codebase", "context", "context", "note", "this", "is", "local", "answer", "based", "on", "retrieved", "context", "for", "more", "detailed", "explanations", "use", "force", "llm", "true", "else", "general", "format", "return", "relevant", "context", "from", "codebase", "context", "local", "answer", "based", "on", "high", "confidence", "context", "match", "use", "force", "llm", "true", "for", "llm", "enhanced", "responses"], "metadata": {"kind": "class", "chunk_index": "9", "has_docstring": "true", "last_modified": "1768185812.993273"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/agent.py::Agent.__init__::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/agent.py::Agent.__init__", "content": "def __init__(self, service: KnowCodeService, config: AppConfig) -> None\n\"\"\"Initialize the agent.\n\nArgs:\n    service: KnowCodeService instance for context retrieval.\n    config: Application configuration containing model priorities.\"\"\"\n    def __init__(self, service: KnowCodeService, config: AppConfig) -> None:\n        \"\"\"Initialize the agent.\n        \n        Args:\n            service: KnowCodeService instance for context retrieval.\n            config: Application configuration containing model priorities.\n        \"\"\"\n        self.service = service\n        self.config = config\n        self.clients: dict[str, Any] = {}\n        self.rate_limiter = RateLimiter()", "tokens": ["def", "init", "self", "service", "know", "code", "service", "config", "app", "config", "none", "initialize", "the", "agent", "args", "service", "know", "code", "service", "instance", "for", "context", "retrieval", "config", "application", "configuration", "containing", "model", "priorities", "def", "init", "self", "service", "know", "code", "service", "config", "app", "config", "none", "initialize", "the", "agent", "args", "service", "know", "code", "service", "instance", "for", "context", "retrieval", "config", "application", "configuration", "containing", "model", "priorities", "self", "service", "service", "self", "config", "config", "self", "clients", "dict", "str", "any", "self", "rate", "limiter", "rate", "limiter"], "metadata": {"kind": "method", "has_docstring": "true", "last_modified": "1768185812.993273"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/agent.py::Agent._get_client::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/agent.py::Agent._get_client", "content": "def _get_client(self, config: ModelConfig) -> Optional[Any]\n\"\"\"Get or create client for a specific model configuration.\"\"\"\n    def _get_client(self, config: ModelConfig) -> Optional[Any]:\n        \"\"\"Get or create client for a specific model configuration.\"\"\"\n        client_key = f\"{config.provider}_{config.api_key_env}\"\n        if client_key in self.clients:\n            return self.clients[client_key]\n            \n        api_key = os.environ.get(config.api_key_env)\n        if not api_key:\n            return None\n            \n        if config.provider == \"google\":\n            client = genai.Client(api_key=api_key)\n        else:\n            # Assume OpenAI-compatible (OpenAI, OpenRouter, Mistral, etc.)\n            base_url = None\n            if config.provider == \"mistralai\" or \"openrouter\" in config.provider:\n                base_url = \"https://openrouter.ai/api/v1\"\n            \n            client = openai.OpenAI(\n                api_key=api_key,\n                base_url=base_url\n    ", "tokens": ["def", "get", "client", "self", "config", "model", "config", "optional", "any", "get", "or", "create", "client", "for", "specific", "model", "configuration", "def", "get", "client", "self", "config", "model", "config", "optional", "any", "get", "or", "create", "client", "for", "specific", "model", "configuration", "client", "key", "config", "provider", "config", "api", "key", "env", "if", "client", "key", "in", "self", "clients", "return", "self", "clients", "client", "key", "api", "key", "os", "environ", "get", "config", "api", "key", "env", "if", "not", "api", "key", "return", "none", "if", "config", "provider", "google", "client", "genai", "client", "api", "key", "api", "key", "else", "assume", "open", "ai", "compatible", "open", "ai", "open", "router", "mistral", "etc", "base", "url", "none", "if", "config", "provider", "mistralai", "or", "openrouter", "in", "config", "provider", "base", "url", "https", "openrouter", "ai", "api", "v1", "client", "openai", "open", "ai", "api", "key", "api", "key", "base", "url", "base", "url"], "metadata": {"kind": "method", "chunk_index": "0", "has_docstring": "true", "last_modified": "1768185812.993273"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/agent.py::Agent._get_client::1", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/agent.py::Agent._get_client", "content": "     client = openai.OpenAI(\n                api_key=api_key,\n                base_url=base_url\n            )\n            \n        self.clients[client_key] = client\n        return client", "tokens": ["client", "openai", "open", "ai", "api", "key", "api", "key", "base", "url", "base", "url", "self", "clients", "client", "key", "client", "return", "client"], "metadata": {"kind": "method", "chunk_index": "1", "has_docstring": "true", "last_modified": "1768185812.993273"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/agent.py::Agent.answer::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/agent.py::Agent.answer", "content": "def answer(self, query: str) -> str\n\"\"\"Answer a question about the codebase.\n\nArgs:\n    query: User's question.\n\nReturns:\n    The agent's answer.\n    \nRaises:\n    ValueError: If no API keys are set.\n    Exception: If all models fail.\"\"\"\n    def answer(self, query: str) -> str:\n        \"\"\"Answer a question about the codebase.\n\n        Args:\n            query: User's question.\n\n        Returns:\n            The agent's answer.\n            \n        Raises:\n            ValueError: If no API keys are set.\n            Exception: If all models fail.\n        \"\"\"\n        retrieval = self.service.retrieve_context_for_query(query)\n        task_type = TaskType(retrieval.get(\"task_type\", TaskType.GENERAL.value))\n        confidence = float(retrieval.get(\"task_confidence\", 0.0))\n        print(f\"  \ud83d\udccb Query type: {task_type.value} (confidence: {confidence:.0%})\")\n\n        context_str = retrieval.get(\"context_text\", \"\")\n        if not context_str:\n            context_str = (\n                \"No specific e", "tokens": ["def", "answer", "self", "query", "str", "str", "answer", "question", "about", "the", "codebase", "args", "query", "user", "question", "returns", "the", "agent", "answer", "raises", "value", "error", "if", "no", "api", "keys", "are", "set", "exception", "if", "all", "models", "fail", "def", "answer", "self", "query", "str", "str", "answer", "question", "about", "the", "codebase", "args", "query", "user", "question", "returns", "the", "agent", "answer", "raises", "value", "error", "if", "no", "api", "keys", "are", "set", "exception", "if", "all", "models", "fail", "retrieval", "self", "service", "retrieve", "context", "for", "query", "query", "task", "type", "task", "type", "retrieval", "get", "task", "type", "task", "type", "general", "value", "confidence", "float", "retrieval", "get", "task", "confidence", "print", "query", "type", "task", "type", "value", "confidence", "confidence", "context", "str", "retrieval", "get", "context", "text", "if", "not", "context", "str", "context", "str", "no", "specific"], "metadata": {"kind": "method", "chunk_index": "0", "has_docstring": "true", "last_modified": "1768185812.993273"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/agent.py::Agent.answer::1", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/agent.py::Agent.answer", "content": "xt_text\", \"\")\n        if not context_str:\n            context_str = (\n                \"No specific entities found in the codebase matching the query terms. \"\n                \"Answer based on general software engineering principles if possible.\"\n            )\n\n        # 2. Construct Prompt with task-specific system instructions\n        system_instructions = get_prompt_template(task_type)\n        \n        prompt = f\"{system_instructions}\\n\\nContext:\\n{context_str}\\n\\nQuestion: {query}\"\n\n        # 3. Call LLM with Failover\n        last_error = None\n        \n        for model_config in self.config.models:\n            print(f\"\ud83e\udd16 Trying model: {model_config.name} ({model_config.provider})...\") \n            \n            # Check Rate Limit (Client-side)\n            if not self.rate_limiter.check_availability(model_config):\n                # Warning already printed by check_availability\n                continue\n\n            client = self._get_client(model_config)\n            \n            if not ", "tokens": ["xt", "text", "if", "not", "context", "str", "context", "str", "no", "specific", "entities", "found", "in", "the", "codebase", "matching", "the", "query", "terms", "answer", "based", "on", "general", "software", "engineering", "principles", "if", "possible", "construct", "prompt", "with", "task", "specific", "system", "instructions", "system", "instructions", "get", "prompt", "template", "task", "type", "prompt", "system", "instructions", "context", "context", "str", "question", "query", "call", "llm", "with", "failover", "last", "error", "none", "for", "model", "config", "in", "self", "config", "models", "print", "trying", "model", "model", "config", "name", "model", "config", "provider", "check", "rate", "limit", "client", "side", "if", "not", "self", "rate", "limiter", "check", "availability", "model", "config", "warning", "already", "printed", "by", "check", "availability", "continue", "client", "self", "get", "client", "model", "config", "if", "not"], "metadata": {"kind": "method", "chunk_index": "1", "has_docstring": "true", "last_modified": "1768185812.993273"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/agent.py::Agent.answer::2", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/agent.py::Agent.answer", "content": "      continue\n\n            client = self._get_client(model_config)\n            \n            if not client:\n                print(f\"  \u26a0\ufe0f Skipping {model_config.name}: {model_config.api_key_env} not set.\")\n                continue\n\n            try:\n                response_text = \"\"\n                if model_config.provider == \"google\":\n                    response = client.models.generate_content(\n                        model=model_config.name,\n                        contents=prompt,\n                    )\n                    response_text = response.text or \"No response from LLM.\"\n                else:\n                    # OpenAI / OpenRouter style\n                    extra_headers = {}\n                    if \"openrouter\" in model_config.provider or model_config.provider == \"mistralai\":\n                         extra_headers = {\n                             \"HTTP-Referer\": \"https://github.com/deepakdgupta1/KnowCode\",\n                             \"X-Title\": \"KnowCode\",\n               ", "tokens": ["continue", "client", "self", "get", "client", "model", "config", "if", "not", "client", "print", "skipping", "model", "config", "name", "model", "config", "api", "key", "env", "not", "set", "continue", "try", "response", "text", "if", "model", "config", "provider", "google", "response", "client", "models", "generate", "content", "model", "model", "config", "name", "contents", "prompt", "response", "text", "response", "text", "or", "no", "response", "from", "llm", "else", "open", "ai", "open", "router", "style", "extra", "headers", "if", "openrouter", "in", "model", "config", "provider", "or", "model", "config", "provider", "mistralai", "extra", "headers", "http", "referer", "https", "github", "com", "deepakdgupta1", "know", "code", "title", "know", "code"], "metadata": {"kind": "method", "chunk_index": "2", "has_docstring": "true", "last_modified": "1768185812.993273"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/agent.py::Agent.answer::3", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/agent.py::Agent.answer", "content": "hub.com/deepakdgupta1/KnowCode\",\n                             \"X-Title\": \"KnowCode\",\n                         }\n                         \n                    chat_completion = client.chat.completions.create(\n                        model=model_config.name,\n                        messages=[\n                            {\"role\": \"user\", \"content\": prompt}\n                        ],\n                        extra_headers=extra_headers\n                    )\n                    response_text = chat_completion.choices[0].message.content or \"No response from LLM.\"\n                \n                # Success! Record usage and return\n                self.rate_limiter.record_usage(model_config.name)\n                return response_text\n            \n            except ResourceExhausted as e:\n                 print(f\"  \u26a0\ufe0f Rate limit exceeded (Server) for {model_config.name}. Switching...\")\n                 last_error = e\n                 continue\n            except Exception as e:\n                 p", "tokens": ["hub", "com", "deepakdgupta1", "know", "code", "title", "know", "code", "chat", "completion", "client", "chat", "completions", "create", "model", "model", "config", "name", "messages", "role", "user", "content", "prompt", "extra", "headers", "extra", "headers", "response", "text", "chat", "completion", "choices", "message", "content", "or", "no", "response", "from", "llm", "success", "record", "usage", "and", "return", "self", "rate", "limiter", "record", "usage", "model", "config", "name", "return", "response", "text", "except", "resource", "exhausted", "as", "print", "rate", "limit", "exceeded", "server", "for", "model", "config", "name", "switching", "last", "error", "continue", "except", "exception", "as"], "metadata": {"kind": "method", "chunk_index": "3", "has_docstring": "true", "last_modified": "1768185812.993273"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/agent.py::Agent.answer::4", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/agent.py::Agent.answer", "content": "      last_error = e\n                 continue\n            except Exception as e:\n                 print(f\"  \u274c Error with {model_config.name}: {e}\")\n                 last_error = e\n                 continue\n\n        if last_error:\n            raise last_error\n        \n        raise ValueError(\"No valid configuration found or all models skipped (check API keys or limits).\")", "tokens": ["last", "error", "continue", "except", "exception", "as", "print", "error", "with", "model", "config", "name", "last", "error", "continue", "if", "last", "error", "raise", "last", "error", "raise", "value", "error", "no", "valid", "configuration", "found", "or", "all", "models", "skipped", "check", "api", "keys", "or", "limits"], "metadata": {"kind": "method", "chunk_index": "4", "has_docstring": "true", "last_modified": "1768185812.993273"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/agent.py::Agent.smart_answer::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/agent.py::Agent.smart_answer", "content": "def smart_answer(self, query: str, force_llm: bool) -> dict[str, Any]\n\"\"\"Smart answer with local-first mode.\n\nIf context sufficiency >= threshold, returns local answer without LLM.\nOnly calls external LLM when context is insufficient.\n\nArgs:\n    query: User's question.\n    force_llm: If True, always use LLM regardless of sufficiency.\n    \nReturns:\n    Dict with:\n        - answer: The response text\n        - source: \"local\" or \"llm\"\n        - task_type: Detected query type\n        - sufficiency_score: Context quality score\n        - context: The retrieved context\"\"\"\n    def smart_answer(\n        self,\n        query: str,\n        force_llm: bool = False,\n    ) -> dict[str, Any]:\n        \"\"\"Smart answer with local-first mode.\n        \n        If context sufficiency >= threshold, returns local answer without LLM.\n        Only calls external LLM when context is insufficient.\n        \n        Args:\n            query: User's question.\n            force_llm: If True, always use LLM regardless ", "tokens": ["def", "smart", "answer", "self", "query", "str", "force", "llm", "bool", "dict", "str", "any", "smart", "answer", "with", "local", "first", "mode", "if", "context", "sufficiency", "threshold", "returns", "local", "answer", "without", "llm", "only", "calls", "external", "llm", "when", "context", "is", "insufficient", "args", "query", "user", "question", "force", "llm", "if", "true", "always", "use", "llm", "regardless", "of", "sufficiency", "returns", "dict", "with", "answer", "the", "response", "text", "source", "local", "or", "llm", "task", "type", "detected", "query", "type", "sufficiency", "score", "context", "quality", "score", "context", "the", "retrieved", "context", "def", "smart", "answer", "self", "query", "str", "force", "llm", "bool", "false", "dict", "str", "any", "smart", "answer", "with", "local", "first", "mode", "if", "context", "sufficiency", "threshold", "returns", "local", "answer", "without", "llm", "only", "calls", "external", "llm", "when", "context", "is", "insufficient", "args", "query", "user", "question", "force", "llm", "if", "true", "always", "use", "llm", "regardless"], "metadata": {"kind": "method", "chunk_index": "0", "has_docstring": "true", "last_modified": "1768185812.993273"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/agent.py::Agent.smart_answer::1", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/agent.py::Agent.smart_answer", "content": "Args:\n            query: User's question.\n            force_llm: If True, always use LLM regardless of sufficiency.\n            \n        Returns:\n            Dict with:\n                - answer: The response text\n                - source: \"local\" or \"llm\"\n                - task_type: Detected query type\n                - sufficiency_score: Context quality score\n                - context: The retrieved context\n        \"\"\"\n        retrieval = self.service.retrieve_context_for_query(query)\n        task_type = TaskType(retrieval.get(\"task_type\", TaskType.GENERAL.value))\n        confidence = float(retrieval.get(\"task_confidence\", 0.0))\n        print(f\"  \ud83d\udccb Query type: {task_type.value} (confidence: {confidence:.0%})\")\n\n        avg_sufficiency = float(retrieval.get(\"sufficiency_score\", 0.0))\n        context_str = retrieval.get(\"context_text\", \"\")\n\n        threshold = self.config.sufficiency_threshold\n        print(f\"  \ud83d\udcca Sufficiency: {avg_sufficiency:.0%} (threshold: {threshold:.0%})\")\n       ", "tokens": ["args", "query", "user", "question", "force", "llm", "if", "true", "always", "use", "llm", "regardless", "of", "sufficiency", "returns", "dict", "with", "answer", "the", "response", "text", "source", "local", "or", "llm", "task", "type", "detected", "query", "type", "sufficiency", "score", "context", "quality", "score", "context", "the", "retrieved", "context", "retrieval", "self", "service", "retrieve", "context", "for", "query", "query", "task", "type", "task", "type", "retrieval", "get", "task", "type", "task", "type", "general", "value", "confidence", "float", "retrieval", "get", "task", "confidence", "print", "query", "type", "task", "type", "value", "confidence", "confidence", "avg", "sufficiency", "float", "retrieval", "get", "sufficiency", "score", "context", "str", "retrieval", "get", "context", "text", "threshold", "self", "config", "sufficiency", "threshold", "print", "sufficiency", "avg", "sufficiency", "threshold", "threshold"], "metadata": {"kind": "method", "chunk_index": "1", "has_docstring": "true", "last_modified": "1768185812.993273"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/agent.py::Agent.smart_answer::2", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/agent.py::Agent.smart_answer", "content": "eshold\n        print(f\"  \ud83d\udcca Sufficiency: {avg_sufficiency:.0%} (threshold: {threshold:.0%})\")\n        \n        # 3. Decide: local answer or LLM\n        if not force_llm and avg_sufficiency >= threshold and context_str:\n            # Local-first: sufficient context found\n            print(\"  \u2705 Answering locally (sufficient context)\")\n            \n            local_answer = self._format_local_answer(query, task_type, context_str)\n            \n            return {\n                \"answer\": local_answer,\n                \"source\": \"local\",\n                \"task_type\": task_type.value,\n                \"sufficiency_score\": avg_sufficiency,\n                \"context\": context_str,\n                \"llm_tokens_saved\": len(context_str.split()),  # Rough estimate\n            }\n        else:\n            # Need LLM\n            print(\"  \ud83e\udd16 Calling LLM (sufficiency below threshold or forced)\")\n            \n            llm_answer = self.answer(query)\n            \n            return {\n                \"answ", "tokens": ["eshold", "print", "sufficiency", "avg", "sufficiency", "threshold", "threshold", "decide", "local", "answer", "or", "llm", "if", "not", "force", "llm", "and", "avg", "sufficiency", "threshold", "and", "context", "str", "local", "first", "sufficient", "context", "found", "print", "answering", "locally", "sufficient", "context", "local", "answer", "self", "format", "local", "answer", "query", "task", "type", "context", "str", "return", "answer", "local", "answer", "source", "local", "task", "type", "task", "type", "value", "sufficiency", "score", "avg", "sufficiency", "context", "context", "str", "llm", "tokens", "saved", "len", "context", "str", "split", "rough", "estimate", "else", "need", "llm", "print", "calling", "llm", "sufficiency", "below", "threshold", "or", "forced", "llm", "answer", "self", "answer", "query", "return", "answ"], "metadata": {"kind": "method", "chunk_index": "2", "has_docstring": "true", "last_modified": "1768185812.993273"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/agent.py::Agent.smart_answer::3", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/agent.py::Agent.smart_answer", "content": "\n            llm_answer = self.answer(query)\n            \n            return {\n                \"answer\": llm_answer,\n                \"source\": \"llm\",\n                \"task_type\": task_type.value,\n                \"sufficiency_score\": avg_sufficiency,\n                \"context\": context_str,\n                \"llm_tokens_saved\": 0,\n            }", "tokens": ["llm", "answer", "self", "answer", "query", "return", "answer", "llm", "answer", "source", "llm", "task", "type", "task", "type", "value", "sufficiency", "score", "avg", "sufficiency", "context", "context", "str", "llm", "tokens", "saved"], "metadata": {"kind": "method", "chunk_index": "3", "has_docstring": "true", "last_modified": "1768185812.993273"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/agent.py::Agent._format_local_answer::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/agent.py::Agent._format_local_answer", "content": "def _format_local_answer(self, query: str, task_type: TaskType, context: str) -> str\n\"\"\"Format a local answer without LLM.\n\nFor simple queries like 'locate', we can answer directly from context.\nFor more complex queries, we format the context nicely.\"\"\"\n    def _format_local_answer(\n        self,\n        query: str,\n        task_type: TaskType,\n        context: str,\n    ) -> str:\n        \"\"\"Format a local answer without LLM.\n        \n        For simple queries like 'locate', we can answer directly from context.\n        For more complex queries, we format the context nicely.\n        \"\"\"\n        if task_type == TaskType.LOCATE:\n            # Extract locations from context\n            return f\"**Found in codebase:**\\n\\n{context}\"\n        \n        elif task_type == TaskType.EXPLAIN:\n            return f\"**Based on the codebase context:**\\n\\n{context}\\n\\n*Note: This is a local answer based on retrieved context. For more detailed explanations, use `force_llm=True`.*\"\n        \n        else:\n ", "tokens": ["def", "format", "local", "answer", "self", "query", "str", "task", "type", "task", "type", "context", "str", "str", "format", "local", "answer", "without", "llm", "for", "simple", "queries", "like", "locate", "we", "can", "answer", "directly", "from", "context", "for", "more", "complex", "queries", "we", "format", "the", "context", "nicely", "def", "format", "local", "answer", "self", "query", "str", "task", "type", "task", "type", "context", "str", "str", "format", "local", "answer", "without", "llm", "for", "simple", "queries", "like", "locate", "we", "can", "answer", "directly", "from", "context", "for", "more", "complex", "queries", "we", "format", "the", "context", "nicely", "if", "task", "type", "task", "type", "locate", "extract", "locations", "from", "context", "return", "found", "in", "codebase", "context", "elif", "task", "type", "task", "type", "explain", "return", "based", "on", "the", "codebase", "context", "context", "note", "this", "is", "local", "answer", "based", "on", "retrieved", "context", "for", "more", "detailed", "explanations", "use", "force", "llm", "true", "else"], "metadata": {"kind": "method", "chunk_index": "0", "has_docstring": "true", "last_modified": "1768185812.993273"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/agent.py::Agent._format_local_answer::1", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/agent.py::Agent._format_local_answer", "content": " retrieved context. For more detailed explanations, use `force_llm=True`.*\"\n        \n        else:\n            # General format\n            return f\"**Relevant context from codebase:**\\n\\n{context}\\n\\n*Local answer based on high-confidence context match. Use `force_llm=True` for LLM-enhanced responses.*\"", "tokens": ["retrieved", "context", "for", "more", "detailed", "explanations", "use", "force", "llm", "true", "else", "general", "format", "return", "relevant", "context", "from", "codebase", "context", "local", "answer", "based", "on", "high", "confidence", "context", "match", "use", "force", "llm", "true", "for", "llm", "enhanced", "responses"], "metadata": {"kind": "method", "chunk_index": "1", "has_docstring": "true", "last_modified": "1768185812.993273"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/rate_limiter.py::module::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/rate_limiter.py::module", "content": "\"\"\"Rate limiter for LLM requests.\"\"\"", "tokens": ["rate", "limiter", "for", "llm", "requests"], "metadata": {"type": "module_header"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/rate_limiter.py::imports::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/rate_limiter.py::module", "content": "import json\nimport time\nfrom pathlib import Path\nfrom typing import Dict, List\nfrom knowcode.config import ModelConfig", "tokens": ["import", "json", "import", "time", "from", "pathlib", "import", "path", "from", "typing", "import", "dict", "list", "from", "knowcode", "config", "import", "model", "config"], "metadata": {"type": "imports"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/rate_limiter.py::RateLimiter::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/rate_limiter.py::RateLimiter", "content": "\"\"\"Tracks and limits LLM usage based on RPM and RPD.\"\"\"\nclass RateLimiter:\n    \"\"\"Tracks and limits LLM usage based on RPM and RPD.\"\"\"\n\n    def __init__(self, persistence_path: Path = Path.home() / \".knowcode\" / \"usage_stats.json\"):\n        \"\"\"Initialize the rate limiter.\n        \n        Args:\n            persistence_path: Path to the JSON file storing usage stats.\n        \"\"\"\n        self.persistence_path = persistence_path\n        self.usage_data: Dict[str, List[float]] = {}\n        self._load()\n\n    def _load(self) -> None:\n        \"\"\"Load usage data from disk.\"\"\"\n        if self.persistence_path.exists():\n            try:\n                with open(self.persistence_path, \"r\", encoding=\"utf-8\") as f:\n                    self.usage_data = json.load(f)\n            except (json.JSONDecodeError, OSError) as e:\n                print(f\"Warning: Failed to load usage stats, starting fresh. Error: {e}\")\n                self.usage_data = {}\n        else:\n            self.usage_data = {}\n\n    ", "tokens": ["tracks", "and", "limits", "llm", "usage", "based", "on", "rpm", "and", "rpd", "class", "rate", "limiter", "tracks", "and", "limits", "llm", "usage", "based", "on", "rpm", "and", "rpd", "def", "init", "self", "persistence", "path", "path", "path", "home", "knowcode", "usage", "stats", "json", "initialize", "the", "rate", "limiter", "args", "persistence", "path", "path", "to", "the", "json", "file", "storing", "usage", "stats", "self", "persistence", "path", "persistence", "path", "self", "usage", "data", "dict", "str", "list", "float", "self", "load", "def", "load", "self", "none", "load", "usage", "data", "from", "disk", "if", "self", "persistence", "path", "exists", "try", "with", "open", "self", "persistence", "path", "encoding", "utf", "as", "self", "usage", "data", "json", "load", "except", "json", "jsondecode", "error", "oserror", "as", "print", "warning", "failed", "to", "load", "usage", "stats", "starting", "fresh", "error", "self", "usage", "data", "else", "self", "usage", "data"], "metadata": {"kind": "class", "chunk_index": "0", "has_docstring": "true", "last_modified": "1768101513.6367009"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/rate_limiter.py::RateLimiter::1", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/rate_limiter.py::RateLimiter", "content": "ror: {e}\")\n                self.usage_data = {}\n        else:\n            self.usage_data = {}\n\n        # Ensure directory exists for future saves\n        self.persistence_path.parent.mkdir(parents=True, exist_ok=True)\n\n    def _save(self) -> None:\n        \"\"\"Save usage data to disk.\"\"\"\n        try:\n            # Clean up old data before saving to keep file small\n            self._cleanup()\n            with open(self.persistence_path, \"w\", encoding=\"utf-8\") as f:\n                json.dump(self.usage_data, f)\n        except OSError as e:\n             print(f\"Warning: Failed to save usage stats. Error: {e}\")\n\n    def _cleanup(self) -> None:\n        \"\"\"Remove timestamps older than 24 hours.\"\"\"\n        now = time.time()\n        cutoff = now - 86400  # 24 hours\n        \n        cleaned_data = {}\n        for model, timestamps in self.usage_data.items():\n            valid = [t for t in timestamps if t > cutoff]\n            if valid:\n                cleaned_data[model] = valid\n        \n       ", "tokens": ["ror", "self", "usage", "data", "else", "self", "usage", "data", "ensure", "directory", "exists", "for", "future", "saves", "self", "persistence", "path", "parent", "mkdir", "parents", "true", "exist", "ok", "true", "def", "save", "self", "none", "save", "usage", "data", "to", "disk", "try", "clean", "up", "old", "data", "before", "saving", "to", "keep", "file", "small", "self", "cleanup", "with", "open", "self", "persistence", "path", "encoding", "utf", "as", "json", "dump", "self", "usage", "data", "except", "oserror", "as", "print", "warning", "failed", "to", "save", "usage", "stats", "error", "def", "cleanup", "self", "none", "remove", "timestamps", "older", "than", "24", "hours", "now", "time", "time", "cutoff", "now", "86400", "24", "hours", "cleaned", "data", "for", "model", "timestamps", "in", "self", "usage", "data", "items", "valid", "for", "in", "timestamps", "if", "cutoff", "if", "valid", "cleaned", "data", "model", "valid"], "metadata": {"kind": "class", "chunk_index": "1", "has_docstring": "true", "last_modified": "1768101513.6367009"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/rate_limiter.py::RateLimiter::2", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/rate_limiter.py::RateLimiter", "content": "ps if t > cutoff]\n            if valid:\n                cleaned_data[model] = valid\n        \n        self.usage_data = cleaned_data\n\n    def check_availability(self, model_config: ModelConfig) -> bool:\n        \"\"\"Check if a model is within its rate limits.\n        \n        Args:\n            model_config: The model configuration containing limits.\n            \n        Returns:\n            True if available, False if limit exceeded.\n        \"\"\"\n        timestamps = self.usage_data.get(model_config.name, [])\n        now = time.time()\n        \n        # Check RPM (last 60 seconds)\n        cutoff_min = now - 60\n        last_minute_requests = [t for t in timestamps if t > cutoff_min]\n        if len(last_minute_requests) >= model_config.rpm_free_tier_limit:\n            print(f\"  \u26a0\ufe0f Limit Reached: {model_config.name} used {len(last_minute_requests)}/{model_config.rpm_free_tier_limit} RPM.\")\n            return False\n            \n        # Check RPD (last 24 hours)\n        cutoff_day = now - 864", "tokens": ["ps", "if", "cutoff", "if", "valid", "cleaned", "data", "model", "valid", "self", "usage", "data", "cleaned", "data", "def", "check", "availability", "self", "model", "config", "model", "config", "bool", "check", "if", "model", "is", "within", "its", "rate", "limits", "args", "model", "config", "the", "model", "configuration", "containing", "limits", "returns", "true", "if", "available", "false", "if", "limit", "exceeded", "timestamps", "self", "usage", "data", "get", "model", "config", "name", "now", "time", "time", "check", "rpm", "last", "60", "seconds", "cutoff", "min", "now", "60", "last", "minute", "requests", "for", "in", "timestamps", "if", "cutoff", "min", "if", "len", "last", "minute", "requests", "model", "config", "rpm", "free", "tier", "limit", "print", "limit", "reached", "model", "config", "name", "used", "len", "last", "minute", "requests", "model", "config", "rpm", "free", "tier", "limit", "rpm", "return", "false", "check", "rpd", "last", "24", "hours", "cutoff", "day", "now", "864"], "metadata": {"kind": "class", "chunk_index": "2", "has_docstring": "true", "last_modified": "1768101513.6367009"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/rate_limiter.py::RateLimiter::3", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/rate_limiter.py::RateLimiter", "content": "        return False\n            \n        # Check RPD (last 24 hours)\n        cutoff_day = now - 86400\n        last_day_requests = [t for t in timestamps if t > cutoff_day]\n        if len(last_day_requests) >= model_config.rpd_free_tier_limit:\n            print(f\"  \u26a0\ufe0f Limit Reached: {model_config.name} used {len(last_day_requests)}/{model_config.rpd_free_tier_limit} RPD.\")\n            return False\n            \n        return True\n\n    def record_usage(self, model_name: str) -> None:\n        \"\"\"Record a successful request.\"\"\"\n        if model_name not in self.usage_data:\n            self.usage_data[model_name] = []\n        \n        self.usage_data[model_name].append(time.time())\n        self._save()", "tokens": ["return", "false", "check", "rpd", "last", "24", "hours", "cutoff", "day", "now", "86400", "last", "day", "requests", "for", "in", "timestamps", "if", "cutoff", "day", "if", "len", "last", "day", "requests", "model", "config", "rpd", "free", "tier", "limit", "print", "limit", "reached", "model", "config", "name", "used", "len", "last", "day", "requests", "model", "config", "rpd", "free", "tier", "limit", "rpd", "return", "false", "return", "true", "def", "record", "usage", "self", "model", "name", "str", "none", "record", "successful", "request", "if", "model", "name", "not", "in", "self", "usage", "data", "self", "usage", "data", "model", "name", "self", "usage", "data", "model", "name", "append", "time", "time", "self", "save"], "metadata": {"kind": "class", "chunk_index": "3", "has_docstring": "true", "last_modified": "1768101513.6367009"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/rate_limiter.py::RateLimiter.__init__::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/rate_limiter.py::RateLimiter.__init__", "content": "def __init__(self, persistence_path: Path)\n\"\"\"Initialize the rate limiter.\n\nArgs:\n    persistence_path: Path to the JSON file storing usage stats.\"\"\"\n    def __init__(self, persistence_path: Path = Path.home() / \".knowcode\" / \"usage_stats.json\"):\n        \"\"\"Initialize the rate limiter.\n        \n        Args:\n            persistence_path: Path to the JSON file storing usage stats.\n        \"\"\"\n        self.persistence_path = persistence_path\n        self.usage_data: Dict[str, List[float]] = {}\n        self._load()", "tokens": ["def", "init", "self", "persistence", "path", "path", "initialize", "the", "rate", "limiter", "args", "persistence", "path", "path", "to", "the", "json", "file", "storing", "usage", "stats", "def", "init", "self", "persistence", "path", "path", "path", "home", "knowcode", "usage", "stats", "json", "initialize", "the", "rate", "limiter", "args", "persistence", "path", "path", "to", "the", "json", "file", "storing", "usage", "stats", "self", "persistence", "path", "persistence", "path", "self", "usage", "data", "dict", "str", "list", "float", "self", "load"], "metadata": {"kind": "method", "has_docstring": "true", "last_modified": "1768101513.6367009"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/rate_limiter.py::RateLimiter._load::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/rate_limiter.py::RateLimiter._load", "content": "def _load(self) -> None\n\"\"\"Load usage data from disk.\"\"\"\n    def _load(self) -> None:\n        \"\"\"Load usage data from disk.\"\"\"\n        if self.persistence_path.exists():\n            try:\n                with open(self.persistence_path, \"r\", encoding=\"utf-8\") as f:\n                    self.usage_data = json.load(f)\n            except (json.JSONDecodeError, OSError) as e:\n                print(f\"Warning: Failed to load usage stats, starting fresh. Error: {e}\")\n                self.usage_data = {}\n        else:\n            self.usage_data = {}\n\n        # Ensure directory exists for future saves\n        self.persistence_path.parent.mkdir(parents=True, exist_ok=True)", "tokens": ["def", "load", "self", "none", "load", "usage", "data", "from", "disk", "def", "load", "self", "none", "load", "usage", "data", "from", "disk", "if", "self", "persistence", "path", "exists", "try", "with", "open", "self", "persistence", "path", "encoding", "utf", "as", "self", "usage", "data", "json", "load", "except", "json", "jsondecode", "error", "oserror", "as", "print", "warning", "failed", "to", "load", "usage", "stats", "starting", "fresh", "error", "self", "usage", "data", "else", "self", "usage", "data", "ensure", "directory", "exists", "for", "future", "saves", "self", "persistence", "path", "parent", "mkdir", "parents", "true", "exist", "ok", "true"], "metadata": {"kind": "method", "has_docstring": "true", "last_modified": "1768101513.6367009"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/rate_limiter.py::RateLimiter._save::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/rate_limiter.py::RateLimiter._save", "content": "def _save(self) -> None\n\"\"\"Save usage data to disk.\"\"\"\n    def _save(self) -> None:\n        \"\"\"Save usage data to disk.\"\"\"\n        try:\n            # Clean up old data before saving to keep file small\n            self._cleanup()\n            with open(self.persistence_path, \"w\", encoding=\"utf-8\") as f:\n                json.dump(self.usage_data, f)\n        except OSError as e:\n             print(f\"Warning: Failed to save usage stats. Error: {e}\")", "tokens": ["def", "save", "self", "none", "save", "usage", "data", "to", "disk", "def", "save", "self", "none", "save", "usage", "data", "to", "disk", "try", "clean", "up", "old", "data", "before", "saving", "to", "keep", "file", "small", "self", "cleanup", "with", "open", "self", "persistence", "path", "encoding", "utf", "as", "json", "dump", "self", "usage", "data", "except", "oserror", "as", "print", "warning", "failed", "to", "save", "usage", "stats", "error"], "metadata": {"kind": "method", "has_docstring": "true", "last_modified": "1768101513.6367009"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/rate_limiter.py::RateLimiter._cleanup::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/rate_limiter.py::RateLimiter._cleanup", "content": "def _cleanup(self) -> None\n\"\"\"Remove timestamps older than 24 hours.\"\"\"\n    def _cleanup(self) -> None:\n        \"\"\"Remove timestamps older than 24 hours.\"\"\"\n        now = time.time()\n        cutoff = now - 86400  # 24 hours\n        \n        cleaned_data = {}\n        for model, timestamps in self.usage_data.items():\n            valid = [t for t in timestamps if t > cutoff]\n            if valid:\n                cleaned_data[model] = valid\n        \n        self.usage_data = cleaned_data", "tokens": ["def", "cleanup", "self", "none", "remove", "timestamps", "older", "than", "24", "hours", "def", "cleanup", "self", "none", "remove", "timestamps", "older", "than", "24", "hours", "now", "time", "time", "cutoff", "now", "86400", "24", "hours", "cleaned", "data", "for", "model", "timestamps", "in", "self", "usage", "data", "items", "valid", "for", "in", "timestamps", "if", "cutoff", "if", "valid", "cleaned", "data", "model", "valid", "self", "usage", "data", "cleaned", "data"], "metadata": {"kind": "method", "has_docstring": "true", "last_modified": "1768101513.6367009"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/rate_limiter.py::RateLimiter.check_availability::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/rate_limiter.py::RateLimiter.check_availability", "content": "def check_availability(self, model_config: ModelConfig) -> bool\n\"\"\"Check if a model is within its rate limits.\n\nArgs:\n    model_config: The model configuration containing limits.\n    \nReturns:\n    True if available, False if limit exceeded.\"\"\"\n    def check_availability(self, model_config: ModelConfig) -> bool:\n        \"\"\"Check if a model is within its rate limits.\n        \n        Args:\n            model_config: The model configuration containing limits.\n            \n        Returns:\n            True if available, False if limit exceeded.\n        \"\"\"\n        timestamps = self.usage_data.get(model_config.name, [])\n        now = time.time()\n        \n        # Check RPM (last 60 seconds)\n        cutoff_min = now - 60\n        last_minute_requests = [t for t in timestamps if t > cutoff_min]\n        if len(last_minute_requests) >= model_config.rpm_free_tier_limit:\n            print(f\"  \u26a0\ufe0f Limit Reached: {model_config.name} used {len(last_minute_requests)}/{model_config.rpm_free_tier_limit} ", "tokens": ["def", "check", "availability", "self", "model", "config", "model", "config", "bool", "check", "if", "model", "is", "within", "its", "rate", "limits", "args", "model", "config", "the", "model", "configuration", "containing", "limits", "returns", "true", "if", "available", "false", "if", "limit", "exceeded", "def", "check", "availability", "self", "model", "config", "model", "config", "bool", "check", "if", "model", "is", "within", "its", "rate", "limits", "args", "model", "config", "the", "model", "configuration", "containing", "limits", "returns", "true", "if", "available", "false", "if", "limit", "exceeded", "timestamps", "self", "usage", "data", "get", "model", "config", "name", "now", "time", "time", "check", "rpm", "last", "60", "seconds", "cutoff", "min", "now", "60", "last", "minute", "requests", "for", "in", "timestamps", "if", "cutoff", "min", "if", "len", "last", "minute", "requests", "model", "config", "rpm", "free", "tier", "limit", "print", "limit", "reached", "model", "config", "name", "used", "len", "last", "minute", "requests", "model", "config", "rpm", "free", "tier", "limit"], "metadata": {"kind": "method", "chunk_index": "0", "has_docstring": "true", "last_modified": "1768101513.6367009"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/rate_limiter.py::RateLimiter.check_availability::1", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/rate_limiter.py::RateLimiter.check_availability", "content": "it Reached: {model_config.name} used {len(last_minute_requests)}/{model_config.rpm_free_tier_limit} RPM.\")\n            return False\n            \n        # Check RPD (last 24 hours)\n        cutoff_day = now - 86400\n        last_day_requests = [t for t in timestamps if t > cutoff_day]\n        if len(last_day_requests) >= model_config.rpd_free_tier_limit:\n            print(f\"  \u26a0\ufe0f Limit Reached: {model_config.name} used {len(last_day_requests)}/{model_config.rpd_free_tier_limit} RPD.\")\n            return False\n            \n        return True", "tokens": ["it", "reached", "model", "config", "name", "used", "len", "last", "minute", "requests", "model", "config", "rpm", "free", "tier", "limit", "rpm", "return", "false", "check", "rpd", "last", "24", "hours", "cutoff", "day", "now", "86400", "last", "day", "requests", "for", "in", "timestamps", "if", "cutoff", "day", "if", "len", "last", "day", "requests", "model", "config", "rpd", "free", "tier", "limit", "print", "limit", "reached", "model", "config", "name", "used", "len", "last", "day", "requests", "model", "config", "rpd", "free", "tier", "limit", "rpd", "return", "false", "return", "true"], "metadata": {"kind": "method", "chunk_index": "1", "has_docstring": "true", "last_modified": "1768101513.6367009"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/rate_limiter.py::RateLimiter.record_usage::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/rate_limiter.py::RateLimiter.record_usage", "content": "def record_usage(self, model_name: str) -> None\n\"\"\"Record a successful request.\"\"\"\n    def record_usage(self, model_name: str) -> None:\n        \"\"\"Record a successful request.\"\"\"\n        if model_name not in self.usage_data:\n            self.usage_data[model_name] = []\n        \n        self.usage_data[model_name].append(time.time())\n        self._save()", "tokens": ["def", "record", "usage", "self", "model", "name", "str", "none", "record", "successful", "request", "def", "record", "usage", "self", "model", "name", "str", "none", "record", "successful", "request", "if", "model", "name", "not", "in", "self", "usage", "data", "self", "usage", "data", "model", "name", "self", "usage", "data", "model", "name", "append", "time", "time", "self", "save"], "metadata": {"kind": "method", "has_docstring": "true", "last_modified": "1768101513.6367009"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/voyageai_client.py::module::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/voyageai_client.py::module", "content": "\"\"\"VoyageAI client for embeddings and reranking.\n\nProvides integration with VoyageAI's embedding and reranking APIs:\n- voyage-3-lite: Fast embeddings (1024 dimensions)\n- rerank-2.5: Cross-encoder reranking for improved relevance\n\"\"\"", "tokens": ["voyage", "ai", "client", "for", "embeddings", "and", "reranking", "provides", "integration", "with", "voyage", "ai", "embedding", "and", "reranking", "apis", "voyage", "lite", "fast", "embeddings", "1024", "dimensions", "rerank", "cross", "encoder", "reranking", "for", "improved", "relevance"], "metadata": {"type": "module_header"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/voyageai_client.py::imports::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/voyageai_client.py::module", "content": "import os\nfrom typing import Any, Optional\n    import voyageai", "tokens": ["import", "os", "from", "typing", "import", "any", "optional", "import", "voyageai"], "metadata": {"type": "imports"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/voyageai_client.py::VoyageAIClient::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/voyageai_client.py::VoyageAIClient", "content": "\"\"\"Client for VoyageAI embedding and reranking APIs.\"\"\"\nclass VoyageAIClient:\n    \"\"\"Client for VoyageAI embedding and reranking APIs.\"\"\"\n    \n    def __init__(\n        self,\n        api_key: Optional[str] = None,\n        api_key_env: str = \"VOYAGE_API_KEY_1\",\n    ) -> None:\n        \"\"\"Initialize VoyageAI client.\n        \n        Args:\n            api_key: API key (if None, reads from api_key_env).\n            api_key_env: Environment variable name for API key.\n        \"\"\"\n        if not VOYAGEAI_AVAILABLE:\n            raise ImportError(\n                \"VoyageAI package not installed. Install with: pip install voyageai\"\n            )\n        \n        self.api_key = api_key or os.environ.get(api_key_env)\n        if not self.api_key:\n            raise ValueError(\n                f\"VoyageAI API key not found. Set {api_key_env} or pass api_key.\"\n            )\n        \n        self.client = voyageai.Client(api_key=self.api_key)\n    \n    def embed(\n        self,\n        texts: list[str],\n  ", "tokens": ["client", "for", "voyage", "ai", "embedding", "and", "reranking", "apis", "class", "voyage", "aiclient", "client", "for", "voyage", "ai", "embedding", "and", "reranking", "apis", "def", "init", "self", "api", "key", "optional", "str", "none", "api", "key", "env", "str", "voyage", "api", "key", "none", "initialize", "voyage", "ai", "client", "args", "api", "key", "api", "key", "if", "none", "reads", "from", "api", "key", "env", "api", "key", "env", "environment", "variable", "name", "for", "api", "key", "if", "not", "voyageai", "available", "raise", "import", "error", "voyage", "ai", "package", "not", "installed", "install", "with", "pip", "install", "voyageai", "self", "api", "key", "api", "key", "or", "os", "environ", "get", "api", "key", "env", "if", "not", "self", "api", "key", "raise", "value", "error", "voyage", "ai", "api", "key", "not", "found", "set", "api", "key", "env", "or", "pass", "api", "key", "self", "client", "voyageai", "client", "api", "key", "self", "api", "key", "def", "embed", "self", "texts", "list", "str"], "metadata": {"kind": "class", "chunk_index": "0", "has_docstring": "true", "last_modified": "1768101513.6367533"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/voyageai_client.py::VoyageAIClient::1", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/voyageai_client.py::VoyageAIClient", "content": "voyageai.Client(api_key=self.api_key)\n    \n    def embed(\n        self,\n        texts: list[str],\n        model: str = \"voyage-3-lite\",\n        input_type: str = \"document\",\n    ) -> list[list[float]]:\n        \"\"\"Generate embeddings for texts.\n        \n        Args:\n            texts: List of texts to embed.\n            model: Model name (voyage-3-lite, voyage-3, voyage-code-3).\n            input_type: \"query\" or \"document\".\n            \n        Returns:\n            List of embedding vectors.\n        \"\"\"\n        result = self.client.embed(\n            texts=texts,\n            model=model,\n            input_type=input_type,\n        )\n        return result.embeddings\n    \n    def rerank(\n        self,\n        query: str,\n        documents: list[str],\n        model: str = \"rerank-2.5\",\n        top_k: Optional[int] = None,\n    ) -> list[dict[str, Any]]:\n        \"\"\"Rerank documents using cross-encoder.\n        \n        Args:\n            query: Search query.\n            documents: List of do", "tokens": ["voyageai", "client", "api", "key", "self", "api", "key", "def", "embed", "self", "texts", "list", "str", "model", "str", "voyage", "lite", "input", "type", "str", "document", "list", "list", "float", "generate", "embeddings", "for", "texts", "args", "texts", "list", "of", "texts", "to", "embed", "model", "model", "name", "voyage", "lite", "voyage", "voyage", "code", "input", "type", "query", "or", "document", "returns", "list", "of", "embedding", "vectors", "result", "self", "client", "embed", "texts", "texts", "model", "model", "input", "type", "input", "type", "return", "result", "embeddings", "def", "rerank", "self", "query", "str", "documents", "list", "str", "model", "str", "rerank", "top", "optional", "int", "none", "list", "dict", "str", "any", "rerank", "documents", "using", "cross", "encoder", "args", "query", "search", "query", "documents", "list", "of", "do"], "metadata": {"kind": "class", "chunk_index": "1", "has_docstring": "true", "last_modified": "1768101513.6367533"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/voyageai_client.py::VoyageAIClient::2", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/voyageai_client.py::VoyageAIClient", "content": "s-encoder.\n        \n        Args:\n            query: Search query.\n            documents: List of document texts to rerank.\n            model: Reranking model (rerank-2.5).\n            top_k: Return only top K results (None = all).\n            \n        Returns:\n            List of dicts with 'index', 'relevance_score', 'document'.\n        \"\"\"\n        if not documents:\n            return []\n        \n        result = self.client.rerank(\n            query=query,\n            documents=documents,\n            model=model,\n            top_k=top_k or len(documents),\n        )\n        \n        return [\n            {\n                \"index\": r.index,\n                \"relevance_score\": r.relevance_score,\n                \"document\": documents[r.index],\n            }\n            for r in result.results\n        ]", "tokens": ["encoder", "args", "query", "search", "query", "documents", "list", "of", "document", "texts", "to", "rerank", "model", "reranking", "model", "rerank", "top", "return", "only", "top", "results", "none", "all", "returns", "list", "of", "dicts", "with", "index", "relevance", "score", "document", "if", "not", "documents", "return", "result", "self", "client", "rerank", "query", "query", "documents", "documents", "model", "model", "top", "top", "or", "len", "documents", "return", "index", "index", "relevance", "score", "relevance", "score", "document", "documents", "index", "for", "in", "result", "results"], "metadata": {"kind": "class", "chunk_index": "2", "has_docstring": "true", "last_modified": "1768101513.6367533"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/voyageai_client.py::VoyageAIClient.__init__::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/voyageai_client.py::VoyageAIClient.__init__", "content": "def __init__(self, api_key: Optional[str], api_key_env: str) -> None\n\"\"\"Initialize VoyageAI client.\n\nArgs:\n    api_key: API key (if None, reads from api_key_env).\n    api_key_env: Environment variable name for API key.\"\"\"\n    def __init__(\n        self,\n        api_key: Optional[str] = None,\n        api_key_env: str = \"VOYAGE_API_KEY_1\",\n    ) -> None:\n        \"\"\"Initialize VoyageAI client.\n        \n        Args:\n            api_key: API key (if None, reads from api_key_env).\n            api_key_env: Environment variable name for API key.\n        \"\"\"\n        if not VOYAGEAI_AVAILABLE:\n            raise ImportError(\n                \"VoyageAI package not installed. Install with: pip install voyageai\"\n            )\n        \n        self.api_key = api_key or os.environ.get(api_key_env)\n        if not self.api_key:\n            raise ValueError(\n                f\"VoyageAI API key not found. Set {api_key_env} or pass api_key.\"\n            )\n        \n        self.client = voyageai.Client(api_k", "tokens": ["def", "init", "self", "api", "key", "optional", "str", "api", "key", "env", "str", "none", "initialize", "voyage", "ai", "client", "args", "api", "key", "api", "key", "if", "none", "reads", "from", "api", "key", "env", "api", "key", "env", "environment", "variable", "name", "for", "api", "key", "def", "init", "self", "api", "key", "optional", "str", "none", "api", "key", "env", "str", "voyage", "api", "key", "none", "initialize", "voyage", "ai", "client", "args", "api", "key", "api", "key", "if", "none", "reads", "from", "api", "key", "env", "api", "key", "env", "environment", "variable", "name", "for", "api", "key", "if", "not", "voyageai", "available", "raise", "import", "error", "voyage", "ai", "package", "not", "installed", "install", "with", "pip", "install", "voyageai", "self", "api", "key", "api", "key", "or", "os", "environ", "get", "api", "key", "env", "if", "not", "self", "api", "key", "raise", "value", "error", "voyage", "ai", "api", "key", "not", "found", "set", "api", "key", "env", "or", "pass", "api", "key", "self", "client", "voyageai", "client", "api"], "metadata": {"kind": "method", "chunk_index": "0", "has_docstring": "true", "last_modified": "1768101513.6367533"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/voyageai_client.py::VoyageAIClient.__init__::1", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/voyageai_client.py::VoyageAIClient.__init__", "content": "t {api_key_env} or pass api_key.\"\n            )\n        \n        self.client = voyageai.Client(api_key=self.api_key)", "tokens": ["api", "key", "env", "or", "pass", "api", "key", "self", "client", "voyageai", "client", "api", "key", "self", "api", "key"], "metadata": {"kind": "method", "chunk_index": "1", "has_docstring": "true", "last_modified": "1768101513.6367533"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/voyageai_client.py::VoyageAIClient.embed::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/voyageai_client.py::VoyageAIClient.embed", "content": "def embed(self, texts: list[str], model: str, input_type: str) -> list[list[float]]\n\"\"\"Generate embeddings for texts.\n\nArgs:\n    texts: List of texts to embed.\n    model: Model name (voyage-3-lite, voyage-3, voyage-code-3).\n    input_type: \"query\" or \"document\".\n    \nReturns:\n    List of embedding vectors.\"\"\"\n    def embed(\n        self,\n        texts: list[str],\n        model: str = \"voyage-3-lite\",\n        input_type: str = \"document\",\n    ) -> list[list[float]]:\n        \"\"\"Generate embeddings for texts.\n        \n        Args:\n            texts: List of texts to embed.\n            model: Model name (voyage-3-lite, voyage-3, voyage-code-3).\n            input_type: \"query\" or \"document\".\n            \n        Returns:\n            List of embedding vectors.\n        \"\"\"\n        result = self.client.embed(\n            texts=texts,\n            model=model,\n            input_type=input_type,\n        )\n        return result.embeddings", "tokens": ["def", "embed", "self", "texts", "list", "str", "model", "str", "input", "type", "str", "list", "list", "float", "generate", "embeddings", "for", "texts", "args", "texts", "list", "of", "texts", "to", "embed", "model", "model", "name", "voyage", "lite", "voyage", "voyage", "code", "input", "type", "query", "or", "document", "returns", "list", "of", "embedding", "vectors", "def", "embed", "self", "texts", "list", "str", "model", "str", "voyage", "lite", "input", "type", "str", "document", "list", "list", "float", "generate", "embeddings", "for", "texts", "args", "texts", "list", "of", "texts", "to", "embed", "model", "model", "name", "voyage", "lite", "voyage", "voyage", "code", "input", "type", "query", "or", "document", "returns", "list", "of", "embedding", "vectors", "result", "self", "client", "embed", "texts", "texts", "model", "model", "input", "type", "input", "type", "return", "result", "embeddings"], "metadata": {"kind": "method", "has_docstring": "true", "last_modified": "1768101513.6367533"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/voyageai_client.py::VoyageAIClient.rerank::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/voyageai_client.py::VoyageAIClient.rerank", "content": "def rerank(self, query: str, documents: list[str], model: str, top_k: Optional[int]) -> list[dict[str, Any]]\n\"\"\"Rerank documents using cross-encoder.\n\nArgs:\n    query: Search query.\n    documents: List of document texts to rerank.\n    model: Reranking model (rerank-2.5).\n    top_k: Return only top K results (None = all).\n    \nReturns:\n    List of dicts with 'index', 'relevance_score', 'document'.\"\"\"\n    def rerank(\n        self,\n        query: str,\n        documents: list[str],\n        model: str = \"rerank-2.5\",\n        top_k: Optional[int] = None,\n    ) -> list[dict[str, Any]]:\n        \"\"\"Rerank documents using cross-encoder.\n        \n        Args:\n            query: Search query.\n            documents: List of document texts to rerank.\n            model: Reranking model (rerank-2.5).\n            top_k: Return only top K results (None = all).\n            \n        Returns:\n            List of dicts with 'index', 'relevance_score', 'document'.\n        \"\"\"\n        if not documents:\n     ", "tokens": ["def", "rerank", "self", "query", "str", "documents", "list", "str", "model", "str", "top", "optional", "int", "list", "dict", "str", "any", "rerank", "documents", "using", "cross", "encoder", "args", "query", "search", "query", "documents", "list", "of", "document", "texts", "to", "rerank", "model", "reranking", "model", "rerank", "top", "return", "only", "top", "results", "none", "all", "returns", "list", "of", "dicts", "with", "index", "relevance", "score", "document", "def", "rerank", "self", "query", "str", "documents", "list", "str", "model", "str", "rerank", "top", "optional", "int", "none", "list", "dict", "str", "any", "rerank", "documents", "using", "cross", "encoder", "args", "query", "search", "query", "documents", "list", "of", "document", "texts", "to", "rerank", "model", "reranking", "model", "rerank", "top", "return", "only", "top", "results", "none", "all", "returns", "list", "of", "dicts", "with", "index", "relevance", "score", "document", "if", "not", "documents"], "metadata": {"kind": "method", "chunk_index": "0", "has_docstring": "true", "last_modified": "1768101513.6367533"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/voyageai_client.py::VoyageAIClient.rerank::1", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/voyageai_client.py::VoyageAIClient.rerank", "content": "st of dicts with 'index', 'relevance_score', 'document'.\n        \"\"\"\n        if not documents:\n            return []\n        \n        result = self.client.rerank(\n            query=query,\n            documents=documents,\n            model=model,\n            top_k=top_k or len(documents),\n        )\n        \n        return [\n            {\n                \"index\": r.index,\n                \"relevance_score\": r.relevance_score,\n                \"document\": documents[r.index],\n            }\n            for r in result.results\n        ]", "tokens": ["st", "of", "dicts", "with", "index", "relevance", "score", "document", "if", "not", "documents", "return", "result", "self", "client", "rerank", "query", "query", "documents", "documents", "model", "model", "top", "top", "or", "len", "documents", "return", "index", "index", "relevance", "score", "relevance", "score", "document", "documents", "index", "for", "in", "result", "results"], "metadata": {"kind": "method", "chunk_index": "1", "has_docstring": "true", "last_modified": "1768101513.6367533"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/voyageai_client.py::get_voyageai_client::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/llm/voyageai_client.py::get_voyageai_client", "content": "def get_voyageai_client(api_key_env: str) -> Optional[VoyageAIClient]\n\"\"\"Get VoyageAI client if available and configured.\n\nArgs:\n    api_key_env: Environment variable for API key.\n    \nReturns:\n    VoyageAIClient or None if not available.\"\"\"\ndef get_voyageai_client(api_key_env: str = \"VOYAGE_API_KEY_1\") -> Optional[VoyageAIClient]:\n    \"\"\"Get VoyageAI client if available and configured.\n    \n    Args:\n        api_key_env: Environment variable for API key.\n        \n    Returns:\n        VoyageAIClient or None if not available.\n    \"\"\"\n    try:\n        return VoyageAIClient(api_key_env=api_key_env)\n    except (ImportError, ValueError):\n        return None", "tokens": ["def", "get", "voyageai", "client", "api", "key", "env", "str", "optional", "voyage", "aiclient", "get", "voyage", "ai", "client", "if", "available", "and", "configured", "args", "api", "key", "env", "environment", "variable", "for", "api", "key", "returns", "voyage", "aiclient", "or", "none", "if", "not", "available", "def", "get", "voyageai", "client", "api", "key", "env", "str", "voyage", "api", "key", "optional", "voyage", "aiclient", "get", "voyage", "ai", "client", "if", "available", "and", "configured", "args", "api", "key", "env", "environment", "variable", "for", "api", "key", "returns", "voyage", "aiclient", "or", "none", "if", "not", "available", "try", "return", "voyage", "aiclient", "api", "key", "env", "api", "key", "env", "except", "import", "error", "value", "error", "return", "none"], "metadata": {"kind": "function", "has_docstring": "true", "last_modified": "1768101513.6367533"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/storage/knowledge_store.py::module::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/storage/knowledge_store.py::module", "content": "\"\"\"Knowledge store with JSON persistence and querying.\"\"\"", "tokens": ["knowledge", "store", "with", "json", "persistence", "and", "querying"], "metadata": {"type": "module_header"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/storage/knowledge_store.py::imports::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/storage/knowledge_store.py::module", "content": "from __future__ import annotations\nimport json\nfrom dataclasses import asdict\nfrom pathlib import Path\nfrom typing import Any, Optional\nfrom knowcode.indexing.graph_builder import GraphBuilder\nfrom knowcode.data_models import (", "tokens": ["from", "future", "import", "annotations", "import", "json", "from", "dataclasses", "import", "asdict", "from", "pathlib", "import", "path", "from", "typing", "import", "any", "optional", "from", "knowcode", "indexing", "graph", "builder", "import", "graph", "builder", "from", "knowcode", "data", "models", "import"], "metadata": {"type": "imports"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/storage/knowledge_store.py::KnowledgeStore::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/storage/knowledge_store.py::KnowledgeStore", "content": "\"\"\"In-memory knowledge store with JSON persistence.\"\"\"\nclass KnowledgeStore:\n    \"\"\"In-memory knowledge store with JSON persistence.\"\"\"\n\n    DEFAULT_FILENAME = \"knowcode_knowledge.json\"\n\n    def __init__(self) -> None:\n        \"\"\"Initialize empty knowledge store.\"\"\"\n        self.entities: dict[str, Entity] = {}\n        self.relationships: list[Relationship] = []\n        self.metadata: dict[str, Any] = {}\n\n    @classmethod\n    def from_graph_builder(cls, builder: GraphBuilder) -> \"KnowledgeStore\":\n        \"\"\"Create store from a graph builder.\n\n        Args:\n            builder: GraphBuilder with parsed data.\n\n        Returns:\n            New KnowledgeStore instance.\n        \"\"\"\n        store = cls()\n        store.entities = builder.entities.copy()\n        store.relationships = builder.relationships.copy()\n        store.metadata = {\n            \"stats\": builder.stats(),\n            \"errors\": builder.errors,\n        }\n        return store\n\n    def save(self, path: str | Path) -> None:\n   ", "tokens": ["in", "memory", "knowledge", "store", "with", "json", "persistence", "class", "knowledge", "store", "in", "memory", "knowledge", "store", "with", "json", "persistence", "default", "filename", "knowcode", "knowledge", "json", "def", "init", "self", "none", "initialize", "empty", "knowledge", "store", "self", "entities", "dict", "str", "entity", "self", "relationships", "list", "relationship", "self", "metadata", "dict", "str", "any", "classmethod", "def", "from", "graph", "builder", "cls", "builder", "graph", "builder", "knowledge", "store", "create", "store", "from", "graph", "builder", "args", "builder", "graph", "builder", "with", "parsed", "data", "returns", "new", "knowledge", "store", "instance", "store", "cls", "store", "entities", "builder", "entities", "copy", "store", "relationships", "builder", "relationships", "copy", "store", "metadata", "stats", "builder", "stats", "errors", "builder", "errors", "return", "store", "def", "save", "self", "path", "str", "path", "none"], "metadata": {"kind": "class", "chunk_index": "0", "has_docstring": "true", "last_modified": "1768101513.6372573"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/storage/knowledge_store.py::KnowledgeStore::1", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/storage/knowledge_store.py::KnowledgeStore", "content": "\": builder.errors,\n        }\n        return store\n\n    def save(self, path: str | Path) -> None:\n        \"\"\"Save knowledge store to JSON file.\n        \n        The format includes:\n        - version: Schema version for compatibility.\n        - metadata: Global scan stats and errors.\n        - entities: Dictionary mapping Entity IDs to their full data.\n        - relationships: List of all edges in the graph.\n\n        Args:\n            path: Path to save file (directory or file).\n        \"\"\"\n        path = Path(path)\n        if path.is_dir():\n            path = path / self.DEFAULT_FILENAME\n\n        data = {\n            \"version\": \"1.0\",\n            \"metadata\": self.metadata,\n            \"entities\": {\n                eid: self._entity_to_dict(e)\n                for eid, e in self.entities.items()\n            },\n            \"relationships\": [\n                self._relationship_to_dict(r)\n                for r in self.relationships\n            ],\n        }\n\n        path.parent.mkdir(parents", "tokens": ["builder", "errors", "return", "store", "def", "save", "self", "path", "str", "path", "none", "save", "knowledge", "store", "to", "json", "file", "the", "format", "includes", "version", "schema", "version", "for", "compatibility", "metadata", "global", "scan", "stats", "and", "errors", "entities", "dictionary", "mapping", "entity", "ids", "to", "their", "full", "data", "relationships", "list", "of", "all", "edges", "in", "the", "graph", "args", "path", "path", "to", "save", "file", "directory", "or", "file", "path", "path", "path", "if", "path", "is", "dir", "path", "path", "self", "default", "filename", "data", "version", "metadata", "self", "metadata", "entities", "eid", "self", "entity", "to", "dict", "for", "eid", "in", "self", "entities", "items", "relationships", "self", "relationship", "to", "dict", "for", "in", "self", "relationships", "path", "parent", "mkdir", "parents"], "metadata": {"kind": "class", "chunk_index": "1", "has_docstring": "true", "last_modified": "1768101513.6372573"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/storage/knowledge_store.py::KnowledgeStore::2", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/storage/knowledge_store.py::KnowledgeStore", "content": "             for r in self.relationships\n            ],\n        }\n\n        path.parent.mkdir(parents=True, exist_ok=True)\n        with open(path, \"w\", encoding=\"utf-8\") as f:\n            json.dump(data, f, indent=2)\n\n    @classmethod\n    def load(cls, path: str | Path) -> \"KnowledgeStore\":\n        \"\"\"Load knowledge store from JSON file.\n\n        Args:\n            path: Path to load file from.\n\n        Returns:\n            Loaded KnowledgeStore instance.\n        \"\"\"\n        path = Path(path)\n        if path.is_dir():\n            path = path / cls.DEFAULT_FILENAME\n\n        with open(path, \"r\", encoding=\"utf-8\") as f:\n            data = json.load(f)\n\n        store = cls()\n        store.metadata = data.get(\"metadata\", {})\n\n        for eid, edata in data.get(\"entities\", {}).items():\n            store.entities[eid] = cls._dict_to_entity(edata)\n\n        for rdata in data.get(\"relationships\", []):\n            store.relationships.append(cls._dict_to_relationship(rdata))\n\n        return store\n\n ", "tokens": ["for", "in", "self", "relationships", "path", "parent", "mkdir", "parents", "true", "exist", "ok", "true", "with", "open", "path", "encoding", "utf", "as", "json", "dump", "data", "indent", "classmethod", "def", "load", "cls", "path", "str", "path", "knowledge", "store", "load", "knowledge", "store", "from", "json", "file", "args", "path", "path", "to", "load", "file", "from", "returns", "loaded", "knowledge", "store", "instance", "path", "path", "path", "if", "path", "is", "dir", "path", "path", "cls", "default", "filename", "with", "open", "path", "encoding", "utf", "as", "data", "json", "load", "store", "cls", "store", "metadata", "data", "get", "metadata", "for", "eid", "edata", "in", "data", "get", "entities", "items", "store", "entities", "eid", "cls", "dict", "to", "entity", "edata", "for", "rdata", "in", "data", "get", "relationships", "store", "relationships", "append", "cls", "dict", "to", "relationship", "rdata", "return", "store"], "metadata": {"kind": "class", "chunk_index": "2", "has_docstring": "true", "last_modified": "1768101513.6372573"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/storage/knowledge_store.py::KnowledgeStore::3", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/storage/knowledge_store.py::KnowledgeStore", "content": "):\n            store.relationships.append(cls._dict_to_relationship(rdata))\n\n        return store\n\n    def _entity_to_dict(self, entity: Entity) -> dict[str, Any]:\n        \"\"\"Convert entity to dictionary.\"\"\"\n        return {\n            \"id\": entity.id,\n            \"kind\": entity.kind.value,\n            \"name\": entity.name,\n            \"qualified_name\": entity.qualified_name,\n            \"location\": asdict(entity.location),\n            \"docstring\": entity.docstring,\n            \"signature\": entity.signature,\n            \"source_code\": entity.source_code,\n            \"metadata\": entity.metadata,\n        }\n\n    @staticmethod\n    def _dict_to_entity(data: dict[str, Any]) -> Entity:\n        \"\"\"Convert dictionary to entity.\"\"\"\n        return Entity(\n            id=data[\"id\"],\n            kind=EntityKind(data[\"kind\"]),\n            name=data[\"name\"],\n            qualified_name=data[\"qualified_name\"],\n            location=Location(**data[\"location\"]),\n            docstring=data.get(\"docstring\"", "tokens": ["store", "relationships", "append", "cls", "dict", "to", "relationship", "rdata", "return", "store", "def", "entity", "to", "dict", "self", "entity", "entity", "dict", "str", "any", "convert", "entity", "to", "dictionary", "return", "id", "entity", "id", "kind", "entity", "kind", "value", "name", "entity", "name", "qualified", "name", "entity", "qualified", "name", "location", "asdict", "entity", "location", "docstring", "entity", "docstring", "signature", "entity", "signature", "source", "code", "entity", "source", "code", "metadata", "entity", "metadata", "staticmethod", "def", "dict", "to", "entity", "data", "dict", "str", "any", "entity", "convert", "dictionary", "to", "entity", "return", "entity", "id", "data", "id", "kind", "entity", "kind", "data", "kind", "name", "data", "name", "qualified", "name", "data", "qualified", "name", "location", "location", "data", "location", "docstring", "data", "get", "docstring"], "metadata": {"kind": "class", "chunk_index": "3", "has_docstring": "true", "last_modified": "1768101513.6372573"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/storage/knowledge_store.py::KnowledgeStore::4", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/storage/knowledge_store.py::KnowledgeStore", "content": "ame\"],\n            location=Location(**data[\"location\"]),\n            docstring=data.get(\"docstring\"),\n            signature=data.get(\"signature\"),\n            source_code=data.get(\"source_code\"),\n            metadata=data.get(\"metadata\", {}),\n        )\n\n    def _relationship_to_dict(self, rel: Relationship) -> dict[str, Any]:\n        \"\"\"Convert relationship to dictionary.\"\"\"\n        return {\n            \"source_id\": rel.source_id,\n            \"target_id\": rel.target_id,\n            \"kind\": rel.kind.value,\n            \"metadata\": rel.metadata,\n        }\n\n    @staticmethod\n    def _dict_to_relationship(data: dict[str, Any]) -> Relationship:\n        \"\"\"Convert dictionary to relationship.\"\"\"\n        return Relationship(\n            source_id=data[\"source_id\"],\n            target_id=data[\"target_id\"],\n            kind=RelationshipKind(data[\"kind\"]),\n            metadata=data.get(\"metadata\", {}),\n        )\n\n    # Query methods\n\n    def get_entity(self, entity_id: str) -> Optional[Entity]:\n ", "tokens": ["ame", "location", "location", "data", "location", "docstring", "data", "get", "docstring", "signature", "data", "get", "signature", "source", "code", "data", "get", "source", "code", "metadata", "data", "get", "metadata", "def", "relationship", "to", "dict", "self", "rel", "relationship", "dict", "str", "any", "convert", "relationship", "to", "dictionary", "return", "source", "id", "rel", "source", "id", "target", "id", "rel", "target", "id", "kind", "rel", "kind", "value", "metadata", "rel", "metadata", "staticmethod", "def", "dict", "to", "relationship", "data", "dict", "str", "any", "relationship", "convert", "dictionary", "to", "relationship", "return", "relationship", "source", "id", "data", "source", "id", "target", "id", "data", "target", "id", "kind", "relationship", "kind", "data", "kind", "metadata", "data", "get", "metadata", "query", "methods", "def", "get", "entity", "self", "entity", "id", "str", "optional", "entity"], "metadata": {"kind": "class", "chunk_index": "4", "has_docstring": "true", "last_modified": "1768101513.6372573"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/storage/knowledge_store.py::KnowledgeStore::5", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/storage/knowledge_store.py::KnowledgeStore", "content": "{}),\n        )\n\n    # Query methods\n\n    def get_entity(self, entity_id: str) -> Optional[Entity]:\n        \"\"\"Get entity by ID.\"\"\"\n        return self.entities.get(entity_id)\n\n    def search(self, pattern: str) -> list[Entity]:\n        \"\"\"Search entities by name pattern.\"\"\"\n        pattern_lower = pattern.lower()\n        return [\n            e for e in self.entities.values()\n            if pattern_lower in e.name.lower()\n            or pattern_lower in e.qualified_name.lower()\n        ]\n\n    def get_callers(self, entity_id: str) -> list[Entity]:\n        \"\"\"Get entities that call the given entity.\"\"\"\n        caller_ids = [\n            r.source_id for r in self.relationships\n            if r.target_id == entity_id and r.kind == RelationshipKind.CALLS\n        ]\n        return [\n            self.entities[cid] for cid in caller_ids\n            if cid in self.entities\n        ]\n\n    def get_callees(self, entity_id: str) -> list[Entity]:\n        \"\"\"Get entities called by the given entity.\"\"\"\n", "tokens": ["query", "methods", "def", "get", "entity", "self", "entity", "id", "str", "optional", "entity", "get", "entity", "by", "id", "return", "self", "entities", "get", "entity", "id", "def", "search", "self", "pattern", "str", "list", "entity", "search", "entities", "by", "name", "pattern", "pattern", "lower", "pattern", "lower", "return", "for", "in", "self", "entities", "values", "if", "pattern", "lower", "in", "name", "lower", "or", "pattern", "lower", "in", "qualified", "name", "lower", "def", "get", "callers", "self", "entity", "id", "str", "list", "entity", "get", "entities", "that", "call", "the", "given", "entity", "caller", "ids", "source", "id", "for", "in", "self", "relationships", "if", "target", "id", "entity", "id", "and", "kind", "relationship", "kind", "calls", "return", "self", "entities", "cid", "for", "cid", "in", "caller", "ids", "if", "cid", "in", "self", "entities", "def", "get", "callees", "self", "entity", "id", "str", "list", "entity", "get", "entities", "called", "by", "the", "given", "entity"], "metadata": {"kind": "class", "chunk_index": "5", "has_docstring": "true", "last_modified": "1768101513.6372573"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/storage/knowledge_store.py::KnowledgeStore::6", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/storage/knowledge_store.py::KnowledgeStore", "content": "llees(self, entity_id: str) -> list[Entity]:\n        \"\"\"Get entities called by the given entity.\"\"\"\n        callee_ids = [\n            r.target_id for r in self.relationships\n            if r.source_id == entity_id and r.kind == RelationshipKind.CALLS\n        ]\n        return [\n            self.entities[cid] for cid in callee_ids\n            if cid in self.entities\n        ]\n\n    def get_imports(self, entity_id: str) -> list[str]:\n        \"\"\"Get imports for a module entity.\"\"\"\n        return [\n            r.target_id for r in self.relationships\n            if r.source_id == entity_id and r.kind == RelationshipKind.IMPORTS\n        ]\n\n    def get_children(self, entity_id: str) -> list[Entity]:\n        \"\"\"Get entities contained by the given entity.\"\"\"\n        child_ids = [\n            r.target_id for r in self.relationships\n            if r.source_id == entity_id and r.kind == RelationshipKind.CONTAINS\n        ]\n        return [\n            self.entities[cid] for cid in child_ids\n        ", "tokens": ["llees", "self", "entity", "id", "str", "list", "entity", "get", "entities", "called", "by", "the", "given", "entity", "callee", "ids", "target", "id", "for", "in", "self", "relationships", "if", "source", "id", "entity", "id", "and", "kind", "relationship", "kind", "calls", "return", "self", "entities", "cid", "for", "cid", "in", "callee", "ids", "if", "cid", "in", "self", "entities", "def", "get", "imports", "self", "entity", "id", "str", "list", "str", "get", "imports", "for", "module", "entity", "return", "target", "id", "for", "in", "self", "relationships", "if", "source", "id", "entity", "id", "and", "kind", "relationship", "kind", "imports", "def", "get", "children", "self", "entity", "id", "str", "list", "entity", "get", "entities", "contained", "by", "the", "given", "entity", "child", "ids", "target", "id", "for", "in", "self", "relationships", "if", "source", "id", "entity", "id", "and", "kind", "relationship", "kind", "contains", "return", "self", "entities", "cid", "for", "cid", "in", "child", "ids"], "metadata": {"kind": "class", "chunk_index": "6", "has_docstring": "true", "last_modified": "1768101513.6372573"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/storage/knowledge_store.py::KnowledgeStore::7", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/storage/knowledge_store.py::KnowledgeStore", "content": "ind.CONTAINS\n        ]\n        return [\n            self.entities[cid] for cid in child_ids\n            if cid in self.entities\n        ]\n\n    def get_parent(self, entity_id: str) -> Optional[Entity]:\n        \"\"\"Get the parent entity (container) of an entity.\"\"\"\n        for r in self.relationships:\n            if r.target_id == entity_id and r.kind == RelationshipKind.CONTAINS:\n                return self.entities.get(r.source_id)\n        return None\n\n    def get_dependencies(self, entity_id: str) -> list[Entity]:\n        \"\"\"Get all dependencies of an entity (calls + imports).\"\"\"\n        dep_ids = set()\n        for r in self.relationships:\n            if r.source_id == entity_id:\n                if r.kind in {RelationshipKind.CALLS, RelationshipKind.IMPORTS}:\n                    dep_ids.add(r.target_id)\n        return [\n            self.entities[did] for did in dep_ids\n            if did in self.entities\n        ]\n\n    def get_dependents(self, entity_id: str) -> list[Entity]:\n        \"", "tokens": ["ind", "contains", "return", "self", "entities", "cid", "for", "cid", "in", "child", "ids", "if", "cid", "in", "self", "entities", "def", "get", "parent", "self", "entity", "id", "str", "optional", "entity", "get", "the", "parent", "entity", "container", "of", "an", "entity", "for", "in", "self", "relationships", "if", "target", "id", "entity", "id", "and", "kind", "relationship", "kind", "contains", "return", "self", "entities", "get", "source", "id", "return", "none", "def", "get", "dependencies", "self", "entity", "id", "str", "list", "entity", "get", "all", "dependencies", "of", "an", "entity", "calls", "imports", "dep", "ids", "set", "for", "in", "self", "relationships", "if", "source", "id", "entity", "id", "if", "kind", "in", "relationship", "kind", "calls", "relationship", "kind", "imports", "dep", "ids", "add", "target", "id", "return", "self", "entities", "did", "for", "did", "in", "dep", "ids", "if", "did", "in", "self", "entities", "def", "get", "dependents", "self", "entity", "id", "str", "list", "entity"], "metadata": {"kind": "class", "chunk_index": "7", "has_docstring": "true", "last_modified": "1768101513.6372573"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/storage/knowledge_store.py::KnowledgeStore::8", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/storage/knowledge_store.py::KnowledgeStore", "content": " in self.entities\n        ]\n\n    def get_dependents(self, entity_id: str) -> list[Entity]:\n        \"\"\"Get entities that depend on the given entity.\"\"\"\n        dependent_ids = set()\n        for r in self.relationships:\n            if r.target_id == entity_id:\n                if r.kind in {RelationshipKind.CALLS, RelationshipKind.IMPORTS}:\n                    dependent_ids.add(r.source_id)\n        return [\n            self.entities[did] for did in dependent_ids\n            if did in self.entities\n        ]\n\n    def list_by_kind(self, kind: EntityKind | str) -> list[Entity]:\n        \"\"\"List all entities of a given kind.\n\n        Args:\n            kind: EntityKind enum or its string value (e.g., \"class\", \"commit\").\n\n        Returns:\n            Entities matching the requested kind.\n        \"\"\"\n        return self.get_entities_by_kind(kind)\n\n    def get_entities_by_kind(self, kind: EntityKind | str) -> list[Entity]:\n        \"\"\"Return entities filtered by kind.\n\n        Args:\n            kin", "tokens": ["in", "self", "entities", "def", "get", "dependents", "self", "entity", "id", "str", "list", "entity", "get", "entities", "that", "depend", "on", "the", "given", "entity", "dependent", "ids", "set", "for", "in", "self", "relationships", "if", "target", "id", "entity", "id", "if", "kind", "in", "relationship", "kind", "calls", "relationship", "kind", "imports", "dependent", "ids", "add", "source", "id", "return", "self", "entities", "did", "for", "did", "in", "dependent", "ids", "if", "did", "in", "self", "entities", "def", "list", "by", "kind", "self", "kind", "entity", "kind", "str", "list", "entity", "list", "all", "entities", "of", "given", "kind", "args", "kind", "entity", "kind", "enum", "or", "its", "string", "value", "class", "commit", "returns", "entities", "matching", "the", "requested", "kind", "return", "self", "get", "entities", "by", "kind", "kind", "def", "get", "entities", "by", "kind", "self", "kind", "entity", "kind", "str", "list", "entity", "return", "entities", "filtered", "by", "kind", "args", "kin"], "metadata": {"kind": "class", "chunk_index": "8", "has_docstring": "true", "last_modified": "1768101513.6372573"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/storage/knowledge_store.py::KnowledgeStore::9", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/storage/knowledge_store.py::KnowledgeStore", "content": " | str) -> list[Entity]:\n        \"\"\"Return entities filtered by kind.\n\n        Args:\n            kind: EntityKind enum or its string value.\n\n        Returns:\n            Entities whose kind matches the provided value.\n        \"\"\"\n        if isinstance(kind, str):\n            try:\n                kind = EntityKind(kind)\n            except ValueError:\n                return []\n        return [e for e in self.entities.values() if e.kind == kind]\n\n    def get_outgoing_relationships(self, entity_id: str) -> list[Relationship]:\n        \"\"\"Return relationships where the entity is the source.\"\"\"\n        return [r for r in self.relationships if r.source_id == entity_id]\n\n    def get_incoming_relationships(self, entity_id: str) -> list[Relationship]:\n        \"\"\"Return relationships where the entity is the target.\"\"\"\n        return [r for r in self.relationships if r.target_id == entity_id]\n\n    def trace_calls(\n        self,\n        entity_id: str,\n        direction: str = \"callees\",\n        dep", "tokens": ["str", "list", "entity", "return", "entities", "filtered", "by", "kind", "args", "kind", "entity", "kind", "enum", "or", "its", "string", "value", "returns", "entities", "whose", "kind", "matches", "the", "provided", "value", "if", "isinstance", "kind", "str", "try", "kind", "entity", "kind", "kind", "except", "value", "error", "return", "return", "for", "in", "self", "entities", "values", "if", "kind", "kind", "def", "get", "outgoing", "relationships", "self", "entity", "id", "str", "list", "relationship", "return", "relationships", "where", "the", "entity", "is", "the", "source", "return", "for", "in", "self", "relationships", "if", "source", "id", "entity", "id", "def", "get", "incoming", "relationships", "self", "entity", "id", "str", "list", "relationship", "return", "relationships", "where", "the", "entity", "is", "the", "target", "return", "for", "in", "self", "relationships", "if", "target", "id", "entity", "id", "def", "trace", "calls", "self", "entity", "id", "str", "direction", "str", "callees", "dep"], "metadata": {"kind": "class", "chunk_index": "9", "has_docstring": "true", "last_modified": "1768101513.6372573"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/storage/knowledge_store.py::KnowledgeStore::10", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/storage/knowledge_store.py::KnowledgeStore", "content": "f trace_calls(\n        self,\n        entity_id: str,\n        direction: str = \"callees\",\n        depth: int = 1,\n        max_results: int = 50,\n    ) -> list[dict[str, Any]]:\n        \"\"\"Multi-hop call graph traversal.\n        \n        Traverses the call graph from a starting entity to find all callers\n        or callees up to the specified depth.\n        \n        Args:\n            entity_id: Starting entity ID.\n            direction: \"callers\" (who calls this) or \"callees\" (what this calls).\n            depth: Maximum traversal depth (1 = direct only).\n            max_results: Maximum results to return.\n            \n        Returns:\n            List of dicts with entity info and call_depth.\n        \"\"\"\n        if direction not in (\"callers\", \"callees\"):\n            raise ValueError(f\"direction must be 'callers' or 'callees', got {direction}\")\n            \n        results: list[dict[str, Any]] = []\n        visited: set[str] = {entity_id}\n        frontier: list[tuple[str, int]] = [(entit", "tokens": ["trace", "calls", "self", "entity", "id", "str", "direction", "str", "callees", "depth", "int", "max", "results", "int", "50", "list", "dict", "str", "any", "multi", "hop", "call", "graph", "traversal", "traverses", "the", "call", "graph", "from", "starting", "entity", "to", "find", "all", "callers", "or", "callees", "up", "to", "the", "specified", "depth", "args", "entity", "id", "starting", "entity", "id", "direction", "callers", "who", "calls", "this", "or", "callees", "what", "this", "calls", "depth", "maximum", "traversal", "depth", "direct", "only", "max", "results", "maximum", "results", "to", "return", "returns", "list", "of", "dicts", "with", "entity", "info", "and", "call", "depth", "if", "direction", "not", "in", "callers", "callees", "raise", "value", "error", "direction", "must", "be", "callers", "or", "callees", "got", "direction", "results", "list", "dict", "str", "any", "visited", "set", "str", "entity", "id", "frontier", "list", "tuple", "str", "int", "entit"], "metadata": {"kind": "class", "chunk_index": "10", "has_docstring": "true", "last_modified": "1768101513.6372573"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/storage/knowledge_store.py::KnowledgeStore::11", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/storage/knowledge_store.py::KnowledgeStore", "content": "Any]] = []\n        visited: set[str] = {entity_id}\n        frontier: list[tuple[str, int]] = [(entity_id, 0)]\n        \n        while frontier and len(results) < max_results:\n            current_id, current_depth = frontier.pop(0)\n            \n            if current_depth >= depth:\n                continue\n                \n            # Get next hop entities\n            if direction == \"callees\":\n                next_ids = [\n                    r.target_id for r in self.relationships\n                    if r.source_id == current_id and r.kind == RelationshipKind.CALLS\n                ]\n            else:  # callers\n                next_ids = [\n                    r.source_id for r in self.relationships\n                    if r.target_id == current_id and r.kind == RelationshipKind.CALLS\n                ]\n            \n            for next_id in next_ids:\n                if next_id in visited:\n                    continue\n                    \n                visited.add(next_id)\n          ", "tokens": ["any", "visited", "set", "str", "entity", "id", "frontier", "list", "tuple", "str", "int", "entity", "id", "while", "frontier", "and", "len", "results", "max", "results", "current", "id", "current", "depth", "frontier", "pop", "if", "current", "depth", "depth", "continue", "get", "next", "hop", "entities", "if", "direction", "callees", "next", "ids", "target", "id", "for", "in", "self", "relationships", "if", "source", "id", "current", "id", "and", "kind", "relationship", "kind", "calls", "else", "callers", "next", "ids", "source", "id", "for", "in", "self", "relationships", "if", "target", "id", "current", "id", "and", "kind", "relationship", "kind", "calls", "for", "next", "id", "in", "next", "ids", "if", "next", "id", "in", "visited", "continue", "visited", "add", "next", "id"], "metadata": {"kind": "class", "chunk_index": "11", "has_docstring": "true", "last_modified": "1768101513.6372573"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/storage/knowledge_store.py::KnowledgeStore::12", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/storage/knowledge_store.py::KnowledgeStore", "content": "d:\n                    continue\n                    \n                visited.add(next_id)\n                entity = self.entities.get(next_id)\n                \n                if entity:\n                    results.append({\n                        \"entity_id\": entity.id,\n                        \"name\": entity.name,\n                        \"qualified_name\": entity.qualified_name,\n                        \"kind\": entity.kind.value,\n                        \"file\": entity.location.file_path,\n                        \"line\": entity.location.line_start,\n                        \"call_depth\": current_depth + 1,\n                    })\n                    \n                    if current_depth + 1 < depth:\n                        frontier.append((next_id, current_depth + 1))\n        \n        return results\n\n    def get_impact(self, entity_id: str, max_depth: int = 3) -> dict[str, Any]:\n        \"\"\"Analyze the impact of modifying or deleting an entity.\n        \n        Returns direct dependents (calle", "tokens": ["continue", "visited", "add", "next", "id", "entity", "self", "entities", "get", "next", "id", "if", "entity", "results", "append", "entity", "id", "entity", "id", "name", "entity", "name", "qualified", "name", "entity", "qualified", "name", "kind", "entity", "kind", "value", "file", "entity", "location", "file", "path", "line", "entity", "location", "line", "start", "call", "depth", "current", "depth", "if", "current", "depth", "depth", "frontier", "append", "next", "id", "current", "depth", "return", "results", "def", "get", "impact", "self", "entity", "id", "str", "max", "depth", "int", "dict", "str", "any", "analyze", "the", "impact", "of", "modifying", "or", "deleting", "an", "entity", "returns", "direct", "dependents", "calle"], "metadata": {"kind": "class", "chunk_index": "12", "has_docstring": "true", "last_modified": "1768101513.6372573"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/storage/knowledge_store.py::KnowledgeStore::13", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/storage/knowledge_store.py::KnowledgeStore", "content": "yze the impact of modifying or deleting an entity.\n        \n        Returns direct dependents (callers, importers) and transitive dependents\n        up to max_depth, with a risk score based on impact breadth.\n        \n        Args:\n            entity_id: Entity to analyze impact for.\n            max_depth: Maximum depth for transitive analysis.\n            \n        Returns:\n            Dict with direct_dependents, transitive_dependents, and risk_score.\n        \"\"\"\n        entity = self.entities.get(entity_id)\n        if not entity:\n            return {\n                \"entity_id\": entity_id,\n                \"direct_dependents\": [],\n                \"transitive_dependents\": [],\n                \"risk_score\": 0.0,\n                \"error\": \"Entity not found\",\n            }\n        \n        # Get direct dependents (1-hop)\n        direct = self.trace_calls(entity_id, direction=\"callers\", depth=1, max_results=100)\n        \n        # Get transitive dependents (multi-hop)\n        transitive = se", "tokens": ["yze", "the", "impact", "of", "modifying", "or", "deleting", "an", "entity", "returns", "direct", "dependents", "callers", "importers", "and", "transitive", "dependents", "up", "to", "max", "depth", "with", "risk", "score", "based", "on", "impact", "breadth", "args", "entity", "id", "entity", "to", "analyze", "impact", "for", "max", "depth", "maximum", "depth", "for", "transitive", "analysis", "returns", "dict", "with", "direct", "dependents", "transitive", "dependents", "and", "risk", "score", "entity", "self", "entities", "get", "entity", "id", "if", "not", "entity", "return", "entity", "id", "entity", "id", "direct", "dependents", "transitive", "dependents", "risk", "score", "error", "entity", "not", "found", "get", "direct", "dependents", "hop", "direct", "self", "trace", "calls", "entity", "id", "direction", "callers", "depth", "max", "results", "100", "get", "transitive", "dependents", "multi", "hop", "transitive", "se"], "metadata": {"kind": "class", "chunk_index": "13", "has_docstring": "true", "last_modified": "1768101513.6372573"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/storage/knowledge_store.py::KnowledgeStore::14", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/storage/knowledge_store.py::KnowledgeStore", "content": "1, max_results=100)\n        \n        # Get transitive dependents (multi-hop)\n        transitive = self.trace_calls(entity_id, direction=\"callers\", depth=max_depth, max_results=100)\n        # Remove direct from transitive\n        direct_ids = {d[\"entity_id\"] for d in direct}\n        transitive_only = [t for t in transitive if t[\"entity_id\"] not in direct_ids]\n        \n        # Calculate risk score (0.0-1.0)\n        # Based on: number of dependents, depth of impact, entity types affected\n        direct_count = len(direct)\n        transitive_count = len(transitive_only)\n        \n        # Higher risk if many dependents\n        breadth_score = min(1.0, (direct_count + transitive_count * 0.5) / 20)\n        \n        # Higher risk if affects multiple files\n        affected_files = {d.get(\"file\") for d in direct + transitive_only}\n        file_score = min(1.0, len(affected_files) / 5)\n        \n        # Higher risk if entity is a class or module (wider impact)\n        type_score = 0.3\n       ", "tokens": ["max", "results", "100", "get", "transitive", "dependents", "multi", "hop", "transitive", "self", "trace", "calls", "entity", "id", "direction", "callers", "depth", "max", "depth", "max", "results", "100", "remove", "direct", "from", "transitive", "direct", "ids", "entity", "id", "for", "in", "direct", "transitive", "only", "for", "in", "transitive", "if", "entity", "id", "not", "in", "direct", "ids", "calculate", "risk", "score", "based", "on", "number", "of", "dependents", "depth", "of", "impact", "entity", "types", "affected", "direct", "count", "len", "direct", "transitive", "count", "len", "transitive", "only", "higher", "risk", "if", "many", "dependents", "breadth", "score", "min", "direct", "count", "transitive", "count", "20", "higher", "risk", "if", "affects", "multiple", "files", "affected", "files", "get", "file", "for", "in", "direct", "transitive", "only", "file", "score", "min", "len", "affected", "files", "higher", "risk", "if", "entity", "is", "class", "or", "module", "wider", "impact", "type", "score"], "metadata": {"kind": "class", "chunk_index": "14", "has_docstring": "true", "last_modified": "1768101513.6372573"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/storage/knowledge_store.py::KnowledgeStore::15", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/storage/knowledge_store.py::KnowledgeStore", "content": "        # Higher risk if entity is a class or module (wider impact)\n        type_score = 0.3\n        if entity.kind == EntityKind.CLASS:\n            type_score = 0.6\n        elif entity.kind == EntityKind.MODULE:\n            type_score = 0.8\n            \n        risk_score = round((breadth_score + file_score + type_score) / 3, 2)\n        \n        return {\n            \"entity_id\": entity_id,\n            \"entity_name\": entity.qualified_name,\n            \"direct_dependents\": direct,\n            \"transitive_dependents\": transitive_only,\n            \"total_affected\": direct_count + transitive_count,\n            \"affected_files\": list(affected_files),\n            \"risk_score\": min(1.0, risk_score),\n        }", "tokens": ["higher", "risk", "if", "entity", "is", "class", "or", "module", "wider", "impact", "type", "score", "if", "entity", "kind", "entity", "kind", "class", "type", "score", "elif", "entity", "kind", "entity", "kind", "module", "type", "score", "risk", "score", "round", "breadth", "score", "file", "score", "type", "score", "return", "entity", "id", "entity", "id", "entity", "name", "entity", "qualified", "name", "direct", "dependents", "direct", "transitive", "dependents", "transitive", "only", "total", "affected", "direct", "count", "transitive", "count", "affected", "files", "list", "affected", "files", "risk", "score", "min", "risk", "score"], "metadata": {"kind": "class", "chunk_index": "15", "has_docstring": "true", "last_modified": "1768101513.6372573"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/storage/knowledge_store.py::KnowledgeStore.__init__::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/storage/knowledge_store.py::KnowledgeStore.__init__", "content": "def __init__(self) -> None\n\"\"\"Initialize empty knowledge store.\"\"\"\n    def __init__(self) -> None:\n        \"\"\"Initialize empty knowledge store.\"\"\"\n        self.entities: dict[str, Entity] = {}\n        self.relationships: list[Relationship] = []\n        self.metadata: dict[str, Any] = {}", "tokens": ["def", "init", "self", "none", "initialize", "empty", "knowledge", "store", "def", "init", "self", "none", "initialize", "empty", "knowledge", "store", "self", "entities", "dict", "str", "entity", "self", "relationships", "list", "relationship", "self", "metadata", "dict", "str", "any"], "metadata": {"kind": "method", "has_docstring": "true", "last_modified": "1768101513.6372573"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/storage/knowledge_store.py::KnowledgeStore.from_graph_builder::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/storage/knowledge_store.py::KnowledgeStore.from_graph_builder", "content": "def from_graph_builder(cls, builder: GraphBuilder) -> 'KnowledgeStore'\n\"\"\"Create store from a graph builder.\n\nArgs:\n    builder: GraphBuilder with parsed data.\n\nReturns:\n    New KnowledgeStore instance.\"\"\"\n    def from_graph_builder(cls, builder: GraphBuilder) -> \"KnowledgeStore\":\n        \"\"\"Create store from a graph builder.\n\n        Args:\n            builder: GraphBuilder with parsed data.\n\n        Returns:\n            New KnowledgeStore instance.\n        \"\"\"\n        store = cls()\n        store.entities = builder.entities.copy()\n        store.relationships = builder.relationships.copy()\n        store.metadata = {\n            \"stats\": builder.stats(),\n            \"errors\": builder.errors,\n        }\n        return store", "tokens": ["def", "from", "graph", "builder", "cls", "builder", "graph", "builder", "knowledge", "store", "create", "store", "from", "graph", "builder", "args", "builder", "graph", "builder", "with", "parsed", "data", "returns", "new", "knowledge", "store", "instance", "def", "from", "graph", "builder", "cls", "builder", "graph", "builder", "knowledge", "store", "create", "store", "from", "graph", "builder", "args", "builder", "graph", "builder", "with", "parsed", "data", "returns", "new", "knowledge", "store", "instance", "store", "cls", "store", "entities", "builder", "entities", "copy", "store", "relationships", "builder", "relationships", "copy", "store", "metadata", "stats", "builder", "stats", "errors", "builder", "errors", "return", "store"], "metadata": {"kind": "method", "has_docstring": "true", "last_modified": "1768101513.6372573"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/storage/knowledge_store.py::KnowledgeStore.save::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/storage/knowledge_store.py::KnowledgeStore.save", "content": "def save(self, path: str | Path) -> None\n\"\"\"Save knowledge store to JSON file.\n\nThe format includes:\n- version: Schema version for compatibility.\n- metadata: Global scan stats and errors.\n- entities: Dictionary mapping Entity IDs to their full data.\n- relationships: List of all edges in the graph.\n\nArgs:\n    path: Path to save file (directory or file).\"\"\"\n    def save(self, path: str | Path) -> None:\n        \"\"\"Save knowledge store to JSON file.\n        \n        The format includes:\n        - version: Schema version for compatibility.\n        - metadata: Global scan stats and errors.\n        - entities: Dictionary mapping Entity IDs to their full data.\n        - relationships: List of all edges in the graph.\n\n        Args:\n            path: Path to save file (directory or file).\n        \"\"\"\n        path = Path(path)\n        if path.is_dir():\n            path = path / self.DEFAULT_FILENAME\n\n        data = {\n            \"version\": \"1.0\",\n            \"metadata\": self.metadata,\n           ", "tokens": ["def", "save", "self", "path", "str", "path", "none", "save", "knowledge", "store", "to", "json", "file", "the", "format", "includes", "version", "schema", "version", "for", "compatibility", "metadata", "global", "scan", "stats", "and", "errors", "entities", "dictionary", "mapping", "entity", "ids", "to", "their", "full", "data", "relationships", "list", "of", "all", "edges", "in", "the", "graph", "args", "path", "path", "to", "save", "file", "directory", "or", "file", "def", "save", "self", "path", "str", "path", "none", "save", "knowledge", "store", "to", "json", "file", "the", "format", "includes", "version", "schema", "version", "for", "compatibility", "metadata", "global", "scan", "stats", "and", "errors", "entities", "dictionary", "mapping", "entity", "ids", "to", "their", "full", "data", "relationships", "list", "of", "all", "edges", "in", "the", "graph", "args", "path", "path", "to", "save", "file", "directory", "or", "file", "path", "path", "path", "if", "path", "is", "dir", "path", "path", "self", "default", "filename", "data", "version", "metadata", "self", "metadata"], "metadata": {"kind": "method", "chunk_index": "0", "has_docstring": "true", "last_modified": "1768101513.6372573"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/storage/knowledge_store.py::KnowledgeStore.save::1", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/storage/knowledge_store.py::KnowledgeStore.save", "content": "E\n\n        data = {\n            \"version\": \"1.0\",\n            \"metadata\": self.metadata,\n            \"entities\": {\n                eid: self._entity_to_dict(e)\n                for eid, e in self.entities.items()\n            },\n            \"relationships\": [\n                self._relationship_to_dict(r)\n                for r in self.relationships\n            ],\n        }\n\n        path.parent.mkdir(parents=True, exist_ok=True)\n        with open(path, \"w\", encoding=\"utf-8\") as f:\n            json.dump(data, f, indent=2)", "tokens": ["data", "version", "metadata", "self", "metadata", "entities", "eid", "self", "entity", "to", "dict", "for", "eid", "in", "self", "entities", "items", "relationships", "self", "relationship", "to", "dict", "for", "in", "self", "relationships", "path", "parent", "mkdir", "parents", "true", "exist", "ok", "true", "with", "open", "path", "encoding", "utf", "as", "json", "dump", "data", "indent"], "metadata": {"kind": "method", "chunk_index": "1", "has_docstring": "true", "last_modified": "1768101513.6372573"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/storage/knowledge_store.py::KnowledgeStore.load::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/storage/knowledge_store.py::KnowledgeStore.load", "content": "def load(cls, path: str | Path) -> 'KnowledgeStore'\n\"\"\"Load knowledge store from JSON file.\n\nArgs:\n    path: Path to load file from.\n\nReturns:\n    Loaded KnowledgeStore instance.\"\"\"\n    def load(cls, path: str | Path) -> \"KnowledgeStore\":\n        \"\"\"Load knowledge store from JSON file.\n\n        Args:\n            path: Path to load file from.\n\n        Returns:\n            Loaded KnowledgeStore instance.\n        \"\"\"\n        path = Path(path)\n        if path.is_dir():\n            path = path / cls.DEFAULT_FILENAME\n\n        with open(path, \"r\", encoding=\"utf-8\") as f:\n            data = json.load(f)\n\n        store = cls()\n        store.metadata = data.get(\"metadata\", {})\n\n        for eid, edata in data.get(\"entities\", {}).items():\n            store.entities[eid] = cls._dict_to_entity(edata)\n\n        for rdata in data.get(\"relationships\", []):\n            store.relationships.append(cls._dict_to_relationship(rdata))\n\n        return store", "tokens": ["def", "load", "cls", "path", "str", "path", "knowledge", "store", "load", "knowledge", "store", "from", "json", "file", "args", "path", "path", "to", "load", "file", "from", "returns", "loaded", "knowledge", "store", "instance", "def", "load", "cls", "path", "str", "path", "knowledge", "store", "load", "knowledge", "store", "from", "json", "file", "args", "path", "path", "to", "load", "file", "from", "returns", "loaded", "knowledge", "store", "instance", "path", "path", "path", "if", "path", "is", "dir", "path", "path", "cls", "default", "filename", "with", "open", "path", "encoding", "utf", "as", "data", "json", "load", "store", "cls", "store", "metadata", "data", "get", "metadata", "for", "eid", "edata", "in", "data", "get", "entities", "items", "store", "entities", "eid", "cls", "dict", "to", "entity", "edata", "for", "rdata", "in", "data", "get", "relationships", "store", "relationships", "append", "cls", "dict", "to", "relationship", "rdata", "return", "store"], "metadata": {"kind": "method", "has_docstring": "true", "last_modified": "1768101513.6372573"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/storage/knowledge_store.py::KnowledgeStore._entity_to_dict::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/storage/knowledge_store.py::KnowledgeStore._entity_to_dict", "content": "def _entity_to_dict(self, entity: Entity) -> dict[str, Any]\n\"\"\"Convert entity to dictionary.\"\"\"\n    def _entity_to_dict(self, entity: Entity) -> dict[str, Any]:\n        \"\"\"Convert entity to dictionary.\"\"\"\n        return {\n            \"id\": entity.id,\n            \"kind\": entity.kind.value,\n            \"name\": entity.name,\n            \"qualified_name\": entity.qualified_name,\n            \"location\": asdict(entity.location),\n            \"docstring\": entity.docstring,\n            \"signature\": entity.signature,\n            \"source_code\": entity.source_code,\n            \"metadata\": entity.metadata,\n        }", "tokens": ["def", "entity", "to", "dict", "self", "entity", "entity", "dict", "str", "any", "convert", "entity", "to", "dictionary", "def", "entity", "to", "dict", "self", "entity", "entity", "dict", "str", "any", "convert", "entity", "to", "dictionary", "return", "id", "entity", "id", "kind", "entity", "kind", "value", "name", "entity", "name", "qualified", "name", "entity", "qualified", "name", "location", "asdict", "entity", "location", "docstring", "entity", "docstring", "signature", "entity", "signature", "source", "code", "entity", "source", "code", "metadata", "entity", "metadata"], "metadata": {"kind": "method", "has_docstring": "true", "last_modified": "1768101513.6372573"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/storage/knowledge_store.py::KnowledgeStore._dict_to_entity::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/storage/knowledge_store.py::KnowledgeStore._dict_to_entity", "content": "def _dict_to_entity(data: dict[str, Any]) -> Entity\n\"\"\"Convert dictionary to entity.\"\"\"\n    def _dict_to_entity(data: dict[str, Any]) -> Entity:\n        \"\"\"Convert dictionary to entity.\"\"\"\n        return Entity(\n            id=data[\"id\"],\n            kind=EntityKind(data[\"kind\"]),\n            name=data[\"name\"],\n            qualified_name=data[\"qualified_name\"],\n            location=Location(**data[\"location\"]),\n            docstring=data.get(\"docstring\"),\n            signature=data.get(\"signature\"),\n            source_code=data.get(\"source_code\"),\n            metadata=data.get(\"metadata\", {}),\n        )", "tokens": ["def", "dict", "to", "entity", "data", "dict", "str", "any", "entity", "convert", "dictionary", "to", "entity", "def", "dict", "to", "entity", "data", "dict", "str", "any", "entity", "convert", "dictionary", "to", "entity", "return", "entity", "id", "data", "id", "kind", "entity", "kind", "data", "kind", "name", "data", "name", "qualified", "name", "data", "qualified", "name", "location", "location", "data", "location", "docstring", "data", "get", "docstring", "signature", "data", "get", "signature", "source", "code", "data", "get", "source", "code", "metadata", "data", "get", "metadata"], "metadata": {"kind": "method", "has_docstring": "true", "last_modified": "1768101513.6372573"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/storage/knowledge_store.py::KnowledgeStore._relationship_to_dict::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/storage/knowledge_store.py::KnowledgeStore._relationship_to_dict", "content": "def _relationship_to_dict(self, rel: Relationship) -> dict[str, Any]\n\"\"\"Convert relationship to dictionary.\"\"\"\n    def _relationship_to_dict(self, rel: Relationship) -> dict[str, Any]:\n        \"\"\"Convert relationship to dictionary.\"\"\"\n        return {\n            \"source_id\": rel.source_id,\n            \"target_id\": rel.target_id,\n            \"kind\": rel.kind.value,\n            \"metadata\": rel.metadata,\n        }", "tokens": ["def", "relationship", "to", "dict", "self", "rel", "relationship", "dict", "str", "any", "convert", "relationship", "to", "dictionary", "def", "relationship", "to", "dict", "self", "rel", "relationship", "dict", "str", "any", "convert", "relationship", "to", "dictionary", "return", "source", "id", "rel", "source", "id", "target", "id", "rel", "target", "id", "kind", "rel", "kind", "value", "metadata", "rel", "metadata"], "metadata": {"kind": "method", "has_docstring": "true", "last_modified": "1768101513.6372573"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/storage/knowledge_store.py::KnowledgeStore._dict_to_relationship::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/storage/knowledge_store.py::KnowledgeStore._dict_to_relationship", "content": "def _dict_to_relationship(data: dict[str, Any]) -> Relationship\n\"\"\"Convert dictionary to relationship.\"\"\"\n    def _dict_to_relationship(data: dict[str, Any]) -> Relationship:\n        \"\"\"Convert dictionary to relationship.\"\"\"\n        return Relationship(\n            source_id=data[\"source_id\"],\n            target_id=data[\"target_id\"],\n            kind=RelationshipKind(data[\"kind\"]),\n            metadata=data.get(\"metadata\", {}),\n        )", "tokens": ["def", "dict", "to", "relationship", "data", "dict", "str", "any", "relationship", "convert", "dictionary", "to", "relationship", "def", "dict", "to", "relationship", "data", "dict", "str", "any", "relationship", "convert", "dictionary", "to", "relationship", "return", "relationship", "source", "id", "data", "source", "id", "target", "id", "data", "target", "id", "kind", "relationship", "kind", "data", "kind", "metadata", "data", "get", "metadata"], "metadata": {"kind": "method", "has_docstring": "true", "last_modified": "1768101513.6372573"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/storage/knowledge_store.py::KnowledgeStore.get_entity::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/storage/knowledge_store.py::KnowledgeStore.get_entity", "content": "def get_entity(self, entity_id: str) -> Optional[Entity]\n\"\"\"Get entity by ID.\"\"\"\n    def get_entity(self, entity_id: str) -> Optional[Entity]:\n        \"\"\"Get entity by ID.\"\"\"\n        return self.entities.get(entity_id)", "tokens": ["def", "get", "entity", "self", "entity", "id", "str", "optional", "entity", "get", "entity", "by", "id", "def", "get", "entity", "self", "entity", "id", "str", "optional", "entity", "get", "entity", "by", "id", "return", "self", "entities", "get", "entity", "id"], "metadata": {"kind": "method", "has_docstring": "true", "last_modified": "1768101513.6372573"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/storage/knowledge_store.py::KnowledgeStore.search::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/storage/knowledge_store.py::KnowledgeStore.search", "content": "def search(self, pattern: str) -> list[Entity]\n\"\"\"Search entities by name pattern.\"\"\"\n    def search(self, pattern: str) -> list[Entity]:\n        \"\"\"Search entities by name pattern.\"\"\"\n        pattern_lower = pattern.lower()\n        return [\n            e for e in self.entities.values()\n            if pattern_lower in e.name.lower()\n            or pattern_lower in e.qualified_name.lower()\n        ]", "tokens": ["def", "search", "self", "pattern", "str", "list", "entity", "search", "entities", "by", "name", "pattern", "def", "search", "self", "pattern", "str", "list", "entity", "search", "entities", "by", "name", "pattern", "pattern", "lower", "pattern", "lower", "return", "for", "in", "self", "entities", "values", "if", "pattern", "lower", "in", "name", "lower", "or", "pattern", "lower", "in", "qualified", "name", "lower"], "metadata": {"kind": "method", "has_docstring": "true", "last_modified": "1768101513.6372573"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/storage/knowledge_store.py::KnowledgeStore.get_callers::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/storage/knowledge_store.py::KnowledgeStore.get_callers", "content": "def get_callers(self, entity_id: str) -> list[Entity]\n\"\"\"Get entities that call the given entity.\"\"\"\n    def get_callers(self, entity_id: str) -> list[Entity]:\n        \"\"\"Get entities that call the given entity.\"\"\"\n        caller_ids = [\n            r.source_id for r in self.relationships\n            if r.target_id == entity_id and r.kind == RelationshipKind.CALLS\n        ]\n        return [\n            self.entities[cid] for cid in caller_ids\n            if cid in self.entities\n        ]", "tokens": ["def", "get", "callers", "self", "entity", "id", "str", "list", "entity", "get", "entities", "that", "call", "the", "given", "entity", "def", "get", "callers", "self", "entity", "id", "str", "list", "entity", "get", "entities", "that", "call", "the", "given", "entity", "caller", "ids", "source", "id", "for", "in", "self", "relationships", "if", "target", "id", "entity", "id", "and", "kind", "relationship", "kind", "calls", "return", "self", "entities", "cid", "for", "cid", "in", "caller", "ids", "if", "cid", "in", "self", "entities"], "metadata": {"kind": "method", "has_docstring": "true", "last_modified": "1768101513.6372573"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/storage/knowledge_store.py::KnowledgeStore.get_callees::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/storage/knowledge_store.py::KnowledgeStore.get_callees", "content": "def get_callees(self, entity_id: str) -> list[Entity]\n\"\"\"Get entities called by the given entity.\"\"\"\n    def get_callees(self, entity_id: str) -> list[Entity]:\n        \"\"\"Get entities called by the given entity.\"\"\"\n        callee_ids = [\n            r.target_id for r in self.relationships\n            if r.source_id == entity_id and r.kind == RelationshipKind.CALLS\n        ]\n        return [\n            self.entities[cid] for cid in callee_ids\n            if cid in self.entities\n        ]", "tokens": ["def", "get", "callees", "self", "entity", "id", "str", "list", "entity", "get", "entities", "called", "by", "the", "given", "entity", "def", "get", "callees", "self", "entity", "id", "str", "list", "entity", "get", "entities", "called", "by", "the", "given", "entity", "callee", "ids", "target", "id", "for", "in", "self", "relationships", "if", "source", "id", "entity", "id", "and", "kind", "relationship", "kind", "calls", "return", "self", "entities", "cid", "for", "cid", "in", "callee", "ids", "if", "cid", "in", "self", "entities"], "metadata": {"kind": "method", "has_docstring": "true", "last_modified": "1768101513.6372573"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/storage/knowledge_store.py::KnowledgeStore.get_imports::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/storage/knowledge_store.py::KnowledgeStore.get_imports", "content": "def get_imports(self, entity_id: str) -> list[str]\n\"\"\"Get imports for a module entity.\"\"\"\n    def get_imports(self, entity_id: str) -> list[str]:\n        \"\"\"Get imports for a module entity.\"\"\"\n        return [\n            r.target_id for r in self.relationships\n            if r.source_id == entity_id and r.kind == RelationshipKind.IMPORTS\n        ]", "tokens": ["def", "get", "imports", "self", "entity", "id", "str", "list", "str", "get", "imports", "for", "module", "entity", "def", "get", "imports", "self", "entity", "id", "str", "list", "str", "get", "imports", "for", "module", "entity", "return", "target", "id", "for", "in", "self", "relationships", "if", "source", "id", "entity", "id", "and", "kind", "relationship", "kind", "imports"], "metadata": {"kind": "method", "has_docstring": "true", "last_modified": "1768101513.6372573"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/storage/knowledge_store.py::KnowledgeStore.get_children::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/storage/knowledge_store.py::KnowledgeStore.get_children", "content": "def get_children(self, entity_id: str) -> list[Entity]\n\"\"\"Get entities contained by the given entity.\"\"\"\n    def get_children(self, entity_id: str) -> list[Entity]:\n        \"\"\"Get entities contained by the given entity.\"\"\"\n        child_ids = [\n            r.target_id for r in self.relationships\n            if r.source_id == entity_id and r.kind == RelationshipKind.CONTAINS\n        ]\n        return [\n            self.entities[cid] for cid in child_ids\n            if cid in self.entities\n        ]", "tokens": ["def", "get", "children", "self", "entity", "id", "str", "list", "entity", "get", "entities", "contained", "by", "the", "given", "entity", "def", "get", "children", "self", "entity", "id", "str", "list", "entity", "get", "entities", "contained", "by", "the", "given", "entity", "child", "ids", "target", "id", "for", "in", "self", "relationships", "if", "source", "id", "entity", "id", "and", "kind", "relationship", "kind", "contains", "return", "self", "entities", "cid", "for", "cid", "in", "child", "ids", "if", "cid", "in", "self", "entities"], "metadata": {"kind": "method", "has_docstring": "true", "last_modified": "1768101513.6372573"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/storage/knowledge_store.py::KnowledgeStore.get_parent::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/storage/knowledge_store.py::KnowledgeStore.get_parent", "content": "def get_parent(self, entity_id: str) -> Optional[Entity]\n\"\"\"Get the parent entity (container) of an entity.\"\"\"\n    def get_parent(self, entity_id: str) -> Optional[Entity]:\n        \"\"\"Get the parent entity (container) of an entity.\"\"\"\n        for r in self.relationships:\n            if r.target_id == entity_id and r.kind == RelationshipKind.CONTAINS:\n                return self.entities.get(r.source_id)\n        return None", "tokens": ["def", "get", "parent", "self", "entity", "id", "str", "optional", "entity", "get", "the", "parent", "entity", "container", "of", "an", "entity", "def", "get", "parent", "self", "entity", "id", "str", "optional", "entity", "get", "the", "parent", "entity", "container", "of", "an", "entity", "for", "in", "self", "relationships", "if", "target", "id", "entity", "id", "and", "kind", "relationship", "kind", "contains", "return", "self", "entities", "get", "source", "id", "return", "none"], "metadata": {"kind": "method", "has_docstring": "true", "last_modified": "1768101513.6372573"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/storage/knowledge_store.py::KnowledgeStore.get_dependencies::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/storage/knowledge_store.py::KnowledgeStore.get_dependencies", "content": "def get_dependencies(self, entity_id: str) -> list[Entity]\n\"\"\"Get all dependencies of an entity (calls + imports).\"\"\"\n    def get_dependencies(self, entity_id: str) -> list[Entity]:\n        \"\"\"Get all dependencies of an entity (calls + imports).\"\"\"\n        dep_ids = set()\n        for r in self.relationships:\n            if r.source_id == entity_id:\n                if r.kind in {RelationshipKind.CALLS, RelationshipKind.IMPORTS}:\n                    dep_ids.add(r.target_id)\n        return [\n            self.entities[did] for did in dep_ids\n            if did in self.entities\n        ]", "tokens": ["def", "get", "dependencies", "self", "entity", "id", "str", "list", "entity", "get", "all", "dependencies", "of", "an", "entity", "calls", "imports", "def", "get", "dependencies", "self", "entity", "id", "str", "list", "entity", "get", "all", "dependencies", "of", "an", "entity", "calls", "imports", "dep", "ids", "set", "for", "in", "self", "relationships", "if", "source", "id", "entity", "id", "if", "kind", "in", "relationship", "kind", "calls", "relationship", "kind", "imports", "dep", "ids", "add", "target", "id", "return", "self", "entities", "did", "for", "did", "in", "dep", "ids", "if", "did", "in", "self", "entities"], "metadata": {"kind": "method", "has_docstring": "true", "last_modified": "1768101513.6372573"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/storage/knowledge_store.py::KnowledgeStore.get_dependents::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/storage/knowledge_store.py::KnowledgeStore.get_dependents", "content": "def get_dependents(self, entity_id: str) -> list[Entity]\n\"\"\"Get entities that depend on the given entity.\"\"\"\n    def get_dependents(self, entity_id: str) -> list[Entity]:\n        \"\"\"Get entities that depend on the given entity.\"\"\"\n        dependent_ids = set()\n        for r in self.relationships:\n            if r.target_id == entity_id:\n                if r.kind in {RelationshipKind.CALLS, RelationshipKind.IMPORTS}:\n                    dependent_ids.add(r.source_id)\n        return [\n            self.entities[did] for did in dependent_ids\n            if did in self.entities\n        ]", "tokens": ["def", "get", "dependents", "self", "entity", "id", "str", "list", "entity", "get", "entities", "that", "depend", "on", "the", "given", "entity", "def", "get", "dependents", "self", "entity", "id", "str", "list", "entity", "get", "entities", "that", "depend", "on", "the", "given", "entity", "dependent", "ids", "set", "for", "in", "self", "relationships", "if", "target", "id", "entity", "id", "if", "kind", "in", "relationship", "kind", "calls", "relationship", "kind", "imports", "dependent", "ids", "add", "source", "id", "return", "self", "entities", "did", "for", "did", "in", "dependent", "ids", "if", "did", "in", "self", "entities"], "metadata": {"kind": "method", "has_docstring": "true", "last_modified": "1768101513.6372573"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/storage/knowledge_store.py::KnowledgeStore.list_by_kind::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/storage/knowledge_store.py::KnowledgeStore.list_by_kind", "content": "def list_by_kind(self, kind: EntityKind | str) -> list[Entity]\n\"\"\"List all entities of a given kind.\n\nArgs:\n    kind: EntityKind enum or its string value (e.g., \"class\", \"commit\").\n\nReturns:\n    Entities matching the requested kind.\"\"\"\n    def list_by_kind(self, kind: EntityKind | str) -> list[Entity]:\n        \"\"\"List all entities of a given kind.\n\n        Args:\n            kind: EntityKind enum or its string value (e.g., \"class\", \"commit\").\n\n        Returns:\n            Entities matching the requested kind.\n        \"\"\"\n        return self.get_entities_by_kind(kind)", "tokens": ["def", "list", "by", "kind", "self", "kind", "entity", "kind", "str", "list", "entity", "list", "all", "entities", "of", "given", "kind", "args", "kind", "entity", "kind", "enum", "or", "its", "string", "value", "class", "commit", "returns", "entities", "matching", "the", "requested", "kind", "def", "list", "by", "kind", "self", "kind", "entity", "kind", "str", "list", "entity", "list", "all", "entities", "of", "given", "kind", "args", "kind", "entity", "kind", "enum", "or", "its", "string", "value", "class", "commit", "returns", "entities", "matching", "the", "requested", "kind", "return", "self", "get", "entities", "by", "kind", "kind"], "metadata": {"kind": "method", "has_docstring": "true", "last_modified": "1768101513.6372573"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/storage/knowledge_store.py::KnowledgeStore.get_entities_by_kind::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/storage/knowledge_store.py::KnowledgeStore.get_entities_by_kind", "content": "def get_entities_by_kind(self, kind: EntityKind | str) -> list[Entity]\n\"\"\"Return entities filtered by kind.\n\nArgs:\n    kind: EntityKind enum or its string value.\n\nReturns:\n    Entities whose kind matches the provided value.\"\"\"\n    def get_entities_by_kind(self, kind: EntityKind | str) -> list[Entity]:\n        \"\"\"Return entities filtered by kind.\n\n        Args:\n            kind: EntityKind enum or its string value.\n\n        Returns:\n            Entities whose kind matches the provided value.\n        \"\"\"\n        if isinstance(kind, str):\n            try:\n                kind = EntityKind(kind)\n            except ValueError:\n                return []\n        return [e for e in self.entities.values() if e.kind == kind]", "tokens": ["def", "get", "entities", "by", "kind", "self", "kind", "entity", "kind", "str", "list", "entity", "return", "entities", "filtered", "by", "kind", "args", "kind", "entity", "kind", "enum", "or", "its", "string", "value", "returns", "entities", "whose", "kind", "matches", "the", "provided", "value", "def", "get", "entities", "by", "kind", "self", "kind", "entity", "kind", "str", "list", "entity", "return", "entities", "filtered", "by", "kind", "args", "kind", "entity", "kind", "enum", "or", "its", "string", "value", "returns", "entities", "whose", "kind", "matches", "the", "provided", "value", "if", "isinstance", "kind", "str", "try", "kind", "entity", "kind", "kind", "except", "value", "error", "return", "return", "for", "in", "self", "entities", "values", "if", "kind", "kind"], "metadata": {"kind": "method", "has_docstring": "true", "last_modified": "1768101513.6372573"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/storage/knowledge_store.py::KnowledgeStore.get_outgoing_relationships::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/storage/knowledge_store.py::KnowledgeStore.get_outgoing_relationships", "content": "def get_outgoing_relationships(self, entity_id: str) -> list[Relationship]\n\"\"\"Return relationships where the entity is the source.\"\"\"\n    def get_outgoing_relationships(self, entity_id: str) -> list[Relationship]:\n        \"\"\"Return relationships where the entity is the source.\"\"\"\n        return [r for r in self.relationships if r.source_id == entity_id]", "tokens": ["def", "get", "outgoing", "relationships", "self", "entity", "id", "str", "list", "relationship", "return", "relationships", "where", "the", "entity", "is", "the", "source", "def", "get", "outgoing", "relationships", "self", "entity", "id", "str", "list", "relationship", "return", "relationships", "where", "the", "entity", "is", "the", "source", "return", "for", "in", "self", "relationships", "if", "source", "id", "entity", "id"], "metadata": {"kind": "method", "has_docstring": "true", "last_modified": "1768101513.6372573"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/storage/knowledge_store.py::KnowledgeStore.get_incoming_relationships::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/storage/knowledge_store.py::KnowledgeStore.get_incoming_relationships", "content": "def get_incoming_relationships(self, entity_id: str) -> list[Relationship]\n\"\"\"Return relationships where the entity is the target.\"\"\"\n    def get_incoming_relationships(self, entity_id: str) -> list[Relationship]:\n        \"\"\"Return relationships where the entity is the target.\"\"\"\n        return [r for r in self.relationships if r.target_id == entity_id]", "tokens": ["def", "get", "incoming", "relationships", "self", "entity", "id", "str", "list", "relationship", "return", "relationships", "where", "the", "entity", "is", "the", "target", "def", "get", "incoming", "relationships", "self", "entity", "id", "str", "list", "relationship", "return", "relationships", "where", "the", "entity", "is", "the", "target", "return", "for", "in", "self", "relationships", "if", "target", "id", "entity", "id"], "metadata": {"kind": "method", "has_docstring": "true", "last_modified": "1768101513.6372573"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/storage/knowledge_store.py::KnowledgeStore.trace_calls::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/storage/knowledge_store.py::KnowledgeStore.trace_calls", "content": "def trace_calls(self, entity_id: str, direction: str, depth: int, max_results: int) -> list[dict[str, Any]]\n\"\"\"Multi-hop call graph traversal.\n\nTraverses the call graph from a starting entity to find all callers\nor callees up to the specified depth.\n\nArgs:\n    entity_id: Starting entity ID.\n    direction: \"callers\" (who calls this) or \"callees\" (what this calls).\n    depth: Maximum traversal depth (1 = direct only).\n    max_results: Maximum results to return.\n    \nReturns:\n    List of dicts with entity info and call_depth.\"\"\"\n    def trace_calls(\n        self,\n        entity_id: str,\n        direction: str = \"callees\",\n        depth: int = 1,\n        max_results: int = 50,\n    ) -> list[dict[str, Any]]:\n        \"\"\"Multi-hop call graph traversal.\n        \n        Traverses the call graph from a starting entity to find all callers\n        or callees up to the specified depth.\n        \n        Args:\n            entity_id: Starting entity ID.\n            direction: \"callers\" (who calls thi", "tokens": ["def", "trace", "calls", "self", "entity", "id", "str", "direction", "str", "depth", "int", "max", "results", "int", "list", "dict", "str", "any", "multi", "hop", "call", "graph", "traversal", "traverses", "the", "call", "graph", "from", "starting", "entity", "to", "find", "all", "callers", "or", "callees", "up", "to", "the", "specified", "depth", "args", "entity", "id", "starting", "entity", "id", "direction", "callers", "who", "calls", "this", "or", "callees", "what", "this", "calls", "depth", "maximum", "traversal", "depth", "direct", "only", "max", "results", "maximum", "results", "to", "return", "returns", "list", "of", "dicts", "with", "entity", "info", "and", "call", "depth", "def", "trace", "calls", "self", "entity", "id", "str", "direction", "str", "callees", "depth", "int", "max", "results", "int", "50", "list", "dict", "str", "any", "multi", "hop", "call", "graph", "traversal", "traverses", "the", "call", "graph", "from", "starting", "entity", "to", "find", "all", "callers", "or", "callees", "up", "to", "the", "specified", "depth", "args", "entity", "id", "starting", "entity", "id", "direction", "callers", "who", "calls", "thi"], "metadata": {"kind": "method", "chunk_index": "0", "has_docstring": "true", "last_modified": "1768101513.6372573"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/storage/knowledge_store.py::KnowledgeStore.trace_calls::1", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/storage/knowledge_store.py::KnowledgeStore.trace_calls", "content": "    Args:\n            entity_id: Starting entity ID.\n            direction: \"callers\" (who calls this) or \"callees\" (what this calls).\n            depth: Maximum traversal depth (1 = direct only).\n            max_results: Maximum results to return.\n            \n        Returns:\n            List of dicts with entity info and call_depth.\n        \"\"\"\n        if direction not in (\"callers\", \"callees\"):\n            raise ValueError(f\"direction must be 'callers' or 'callees', got {direction}\")\n            \n        results: list[dict[str, Any]] = []\n        visited: set[str] = {entity_id}\n        frontier: list[tuple[str, int]] = [(entity_id, 0)]\n        \n        while frontier and len(results) < max_results:\n            current_id, current_depth = frontier.pop(0)\n            \n            if current_depth >= depth:\n                continue\n                \n            # Get next hop entities\n            if direction == \"callees\":\n                next_ids = [\n                    r.target_id fo", "tokens": ["args", "entity", "id", "starting", "entity", "id", "direction", "callers", "who", "calls", "this", "or", "callees", "what", "this", "calls", "depth", "maximum", "traversal", "depth", "direct", "only", "max", "results", "maximum", "results", "to", "return", "returns", "list", "of", "dicts", "with", "entity", "info", "and", "call", "depth", "if", "direction", "not", "in", "callers", "callees", "raise", "value", "error", "direction", "must", "be", "callers", "or", "callees", "got", "direction", "results", "list", "dict", "str", "any", "visited", "set", "str", "entity", "id", "frontier", "list", "tuple", "str", "int", "entity", "id", "while", "frontier", "and", "len", "results", "max", "results", "current", "id", "current", "depth", "frontier", "pop", "if", "current", "depth", "depth", "continue", "get", "next", "hop", "entities", "if", "direction", "callees", "next", "ids", "target", "id", "fo"], "metadata": {"kind": "method", "chunk_index": "1", "has_docstring": "true", "last_modified": "1768101513.6372573"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/storage/knowledge_store.py::KnowledgeStore.trace_calls::2", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/storage/knowledge_store.py::KnowledgeStore.trace_calls", "content": "          if direction == \"callees\":\n                next_ids = [\n                    r.target_id for r in self.relationships\n                    if r.source_id == current_id and r.kind == RelationshipKind.CALLS\n                ]\n            else:  # callers\n                next_ids = [\n                    r.source_id for r in self.relationships\n                    if r.target_id == current_id and r.kind == RelationshipKind.CALLS\n                ]\n            \n            for next_id in next_ids:\n                if next_id in visited:\n                    continue\n                    \n                visited.add(next_id)\n                entity = self.entities.get(next_id)\n                \n                if entity:\n                    results.append({\n                        \"entity_id\": entity.id,\n                        \"name\": entity.name,\n                        \"qualified_name\": entity.qualified_name,\n                        \"kind\": entity.kind.value,\n                        \"file\"", "tokens": ["if", "direction", "callees", "next", "ids", "target", "id", "for", "in", "self", "relationships", "if", "source", "id", "current", "id", "and", "kind", "relationship", "kind", "calls", "else", "callers", "next", "ids", "source", "id", "for", "in", "self", "relationships", "if", "target", "id", "current", "id", "and", "kind", "relationship", "kind", "calls", "for", "next", "id", "in", "next", "ids", "if", "next", "id", "in", "visited", "continue", "visited", "add", "next", "id", "entity", "self", "entities", "get", "next", "id", "if", "entity", "results", "append", "entity", "id", "entity", "id", "name", "entity", "name", "qualified", "name", "entity", "qualified", "name", "kind", "entity", "kind", "value", "file"], "metadata": {"kind": "method", "chunk_index": "2", "has_docstring": "true", "last_modified": "1768101513.6372573"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/storage/knowledge_store.py::KnowledgeStore.trace_calls::3", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/storage/knowledge_store.py::KnowledgeStore.trace_calls", "content": "ty.qualified_name,\n                        \"kind\": entity.kind.value,\n                        \"file\": entity.location.file_path,\n                        \"line\": entity.location.line_start,\n                        \"call_depth\": current_depth + 1,\n                    })\n                    \n                    if current_depth + 1 < depth:\n                        frontier.append((next_id, current_depth + 1))\n        \n        return results", "tokens": ["ty", "qualified", "name", "kind", "entity", "kind", "value", "file", "entity", "location", "file", "path", "line", "entity", "location", "line", "start", "call", "depth", "current", "depth", "if", "current", "depth", "depth", "frontier", "append", "next", "id", "current", "depth", "return", "results"], "metadata": {"kind": "method", "chunk_index": "3", "has_docstring": "true", "last_modified": "1768101513.6372573"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/storage/knowledge_store.py::KnowledgeStore.get_impact::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/storage/knowledge_store.py::KnowledgeStore.get_impact", "content": "def get_impact(self, entity_id: str, max_depth: int) -> dict[str, Any]\n\"\"\"Analyze the impact of modifying or deleting an entity.\n\nReturns direct dependents (callers, importers) and transitive dependents\nup to max_depth, with a risk score based on impact breadth.\n\nArgs:\n    entity_id: Entity to analyze impact for.\n    max_depth: Maximum depth for transitive analysis.\n    \nReturns:\n    Dict with direct_dependents, transitive_dependents, and risk_score.\"\"\"\n    def get_impact(self, entity_id: str, max_depth: int = 3) -> dict[str, Any]:\n        \"\"\"Analyze the impact of modifying or deleting an entity.\n        \n        Returns direct dependents (callers, importers) and transitive dependents\n        up to max_depth, with a risk score based on impact breadth.\n        \n        Args:\n            entity_id: Entity to analyze impact for.\n            max_depth: Maximum depth for transitive analysis.\n            \n        Returns:\n            Dict with direct_dependents, transitive_dependents, and ri", "tokens": ["def", "get", "impact", "self", "entity", "id", "str", "max", "depth", "int", "dict", "str", "any", "analyze", "the", "impact", "of", "modifying", "or", "deleting", "an", "entity", "returns", "direct", "dependents", "callers", "importers", "and", "transitive", "dependents", "up", "to", "max", "depth", "with", "risk", "score", "based", "on", "impact", "breadth", "args", "entity", "id", "entity", "to", "analyze", "impact", "for", "max", "depth", "maximum", "depth", "for", "transitive", "analysis", "returns", "dict", "with", "direct", "dependents", "transitive", "dependents", "and", "risk", "score", "def", "get", "impact", "self", "entity", "id", "str", "max", "depth", "int", "dict", "str", "any", "analyze", "the", "impact", "of", "modifying", "or", "deleting", "an", "entity", "returns", "direct", "dependents", "callers", "importers", "and", "transitive", "dependents", "up", "to", "max", "depth", "with", "risk", "score", "based", "on", "impact", "breadth", "args", "entity", "id", "entity", "to", "analyze", "impact", "for", "max", "depth", "maximum", "depth", "for", "transitive", "analysis", "returns", "dict", "with", "direct", "dependents", "transitive", "dependents", "and", "ri"], "metadata": {"kind": "method", "chunk_index": "0", "has_docstring": "true", "last_modified": "1768101513.6372573"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/storage/knowledge_store.py::KnowledgeStore.get_impact::1", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/storage/knowledge_store.py::KnowledgeStore.get_impact", "content": "            \n        Returns:\n            Dict with direct_dependents, transitive_dependents, and risk_score.\n        \"\"\"\n        entity = self.entities.get(entity_id)\n        if not entity:\n            return {\n                \"entity_id\": entity_id,\n                \"direct_dependents\": [],\n                \"transitive_dependents\": [],\n                \"risk_score\": 0.0,\n                \"error\": \"Entity not found\",\n            }\n        \n        # Get direct dependents (1-hop)\n        direct = self.trace_calls(entity_id, direction=\"callers\", depth=1, max_results=100)\n        \n        # Get transitive dependents (multi-hop)\n        transitive = self.trace_calls(entity_id, direction=\"callers\", depth=max_depth, max_results=100)\n        # Remove direct from transitive\n        direct_ids = {d[\"entity_id\"] for d in direct}\n        transitive_only = [t for t in transitive if t[\"entity_id\"] not in direct_ids]\n        \n        # Calculate risk score (0.0-1.0)\n        # Based on: number of depend", "tokens": ["returns", "dict", "with", "direct", "dependents", "transitive", "dependents", "and", "risk", "score", "entity", "self", "entities", "get", "entity", "id", "if", "not", "entity", "return", "entity", "id", "entity", "id", "direct", "dependents", "transitive", "dependents", "risk", "score", "error", "entity", "not", "found", "get", "direct", "dependents", "hop", "direct", "self", "trace", "calls", "entity", "id", "direction", "callers", "depth", "max", "results", "100", "get", "transitive", "dependents", "multi", "hop", "transitive", "self", "trace", "calls", "entity", "id", "direction", "callers", "depth", "max", "depth", "max", "results", "100", "remove", "direct", "from", "transitive", "direct", "ids", "entity", "id", "for", "in", "direct", "transitive", "only", "for", "in", "transitive", "if", "entity", "id", "not", "in", "direct", "ids", "calculate", "risk", "score", "based", "on", "number", "of", "depend"], "metadata": {"kind": "method", "chunk_index": "1", "has_docstring": "true", "last_modified": "1768101513.6372573"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/storage/knowledge_store.py::KnowledgeStore.get_impact::2", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/storage/knowledge_store.py::KnowledgeStore.get_impact", "content": "n direct_ids]\n        \n        # Calculate risk score (0.0-1.0)\n        # Based on: number of dependents, depth of impact, entity types affected\n        direct_count = len(direct)\n        transitive_count = len(transitive_only)\n        \n        # Higher risk if many dependents\n        breadth_score = min(1.0, (direct_count + transitive_count * 0.5) / 20)\n        \n        # Higher risk if affects multiple files\n        affected_files = {d.get(\"file\") for d in direct + transitive_only}\n        file_score = min(1.0, len(affected_files) / 5)\n        \n        # Higher risk if entity is a class or module (wider impact)\n        type_score = 0.3\n        if entity.kind == EntityKind.CLASS:\n            type_score = 0.6\n        elif entity.kind == EntityKind.MODULE:\n            type_score = 0.8\n            \n        risk_score = round((breadth_score + file_score + type_score) / 3, 2)\n        \n        return {\n            \"entity_id\": entity_id,\n            \"entity_name\": entity.qualified_name,\n   ", "tokens": ["direct", "ids", "calculate", "risk", "score", "based", "on", "number", "of", "dependents", "depth", "of", "impact", "entity", "types", "affected", "direct", "count", "len", "direct", "transitive", "count", "len", "transitive", "only", "higher", "risk", "if", "many", "dependents", "breadth", "score", "min", "direct", "count", "transitive", "count", "20", "higher", "risk", "if", "affects", "multiple", "files", "affected", "files", "get", "file", "for", "in", "direct", "transitive", "only", "file", "score", "min", "len", "affected", "files", "higher", "risk", "if", "entity", "is", "class", "or", "module", "wider", "impact", "type", "score", "if", "entity", "kind", "entity", "kind", "class", "type", "score", "elif", "entity", "kind", "entity", "kind", "module", "type", "score", "risk", "score", "round", "breadth", "score", "file", "score", "type", "score", "return", "entity", "id", "entity", "id", "entity", "name", "entity", "qualified", "name"], "metadata": {"kind": "method", "chunk_index": "2", "has_docstring": "true", "last_modified": "1768101513.6372573"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/storage/knowledge_store.py::KnowledgeStore.get_impact::3", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/storage/knowledge_store.py::KnowledgeStore.get_impact", "content": "  return {\n            \"entity_id\": entity_id,\n            \"entity_name\": entity.qualified_name,\n            \"direct_dependents\": direct,\n            \"transitive_dependents\": transitive_only,\n            \"total_affected\": direct_count + transitive_count,\n            \"affected_files\": list(affected_files),\n            \"risk_score\": min(1.0, risk_score),\n        }", "tokens": ["return", "entity", "id", "entity", "id", "entity", "name", "entity", "qualified", "name", "direct", "dependents", "direct", "transitive", "dependents", "transitive", "only", "total", "affected", "direct", "count", "transitive", "count", "affected", "files", "list", "affected", "files", "risk", "score", "min", "risk", "score"], "metadata": {"kind": "method", "chunk_index": "3", "has_docstring": "true", "last_modified": "1768101513.6372573"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/storage/chunk_repository.py::module::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/storage/chunk_repository.py::module", "content": "\"\"\"Repository interface for code chunks.\"\"\"", "tokens": ["repository", "interface", "for", "code", "chunks"], "metadata": {"type": "module_header"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/storage/chunk_repository.py::imports::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/storage/chunk_repository.py::module", "content": "from abc import ABC, abstractmethod\nfrom typing import Optional\nfrom knowcode.data_models import CodeChunk", "tokens": ["from", "abc", "import", "abc", "abstractmethod", "from", "typing", "import", "optional", "from", "knowcode", "data", "models", "import", "code", "chunk"], "metadata": {"type": "imports"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/storage/chunk_repository.py::ChunkRepository::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/storage/chunk_repository.py::ChunkRepository", "content": "\"\"\"Abstract interface for chunk storage and retrieval.\"\"\"\nclass ChunkRepository(ABC):\n    \"\"\"Abstract interface for chunk storage and retrieval.\"\"\"\n\n    @abstractmethod\n    def add(self, chunk: CodeChunk) -> None:\n        \"\"\"Add a chunk to the repository.\"\"\"\n        pass\n\n    @abstractmethod\n    def get(self, chunk_id: str) -> Optional[CodeChunk]:\n        \"\"\"Get a chunk by ID.\"\"\"\n        pass\n\n    @abstractmethod\n    def get_by_entity(self, entity_id: str) -> list[CodeChunk]:\n        \"\"\"Get all chunks for an entity.\"\"\"\n        pass\n\n    @abstractmethod\n    def search_by_tokens(self, tokens: list[str], limit: int = 10) -> list[CodeChunk]:\n        \"\"\"Search chunks by BM25 tokens.\"\"\"\n        pass\n\n    @abstractmethod\n    def clear(self) -> None:\n        \"\"\"Clear all chunks.\"\"\"\n        pass", "tokens": ["abstract", "interface", "for", "chunk", "storage", "and", "retrieval", "class", "chunk", "repository", "abc", "abstract", "interface", "for", "chunk", "storage", "and", "retrieval", "abstractmethod", "def", "add", "self", "chunk", "code", "chunk", "none", "add", "chunk", "to", "the", "repository", "pass", "abstractmethod", "def", "get", "self", "chunk", "id", "str", "optional", "code", "chunk", "get", "chunk", "by", "id", "pass", "abstractmethod", "def", "get", "by", "entity", "self", "entity", "id", "str", "list", "code", "chunk", "get", "all", "chunks", "for", "an", "entity", "pass", "abstractmethod", "def", "search", "by", "tokens", "self", "tokens", "list", "str", "limit", "int", "10", "list", "code", "chunk", "search", "chunks", "by", "bm25", "tokens", "pass", "abstractmethod", "def", "clear", "self", "none", "clear", "all", "chunks", "pass"], "metadata": {"kind": "class", "has_docstring": "true", "last_modified": "1766236633.3726954"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/storage/chunk_repository.py::ChunkRepository.add::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/storage/chunk_repository.py::ChunkRepository.add", "content": "def add(self, chunk: CodeChunk) -> None\n\"\"\"Add a chunk to the repository.\"\"\"\n    def add(self, chunk: CodeChunk) -> None:\n        \"\"\"Add a chunk to the repository.\"\"\"\n        pass", "tokens": ["def", "add", "self", "chunk", "code", "chunk", "none", "add", "chunk", "to", "the", "repository", "def", "add", "self", "chunk", "code", "chunk", "none", "add", "chunk", "to", "the", "repository", "pass"], "metadata": {"kind": "method", "has_docstring": "true", "last_modified": "1766236633.3726954"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/storage/chunk_repository.py::ChunkRepository.get::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/storage/chunk_repository.py::ChunkRepository.get", "content": "def get(self, chunk_id: str) -> Optional[CodeChunk]\n\"\"\"Get a chunk by ID.\"\"\"\n    def get(self, chunk_id: str) -> Optional[CodeChunk]:\n        \"\"\"Get a chunk by ID.\"\"\"\n        pass", "tokens": ["def", "get", "self", "chunk", "id", "str", "optional", "code", "chunk", "get", "chunk", "by", "id", "def", "get", "self", "chunk", "id", "str", "optional", "code", "chunk", "get", "chunk", "by", "id", "pass"], "metadata": {"kind": "method", "has_docstring": "true", "last_modified": "1766236633.3726954"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/storage/chunk_repository.py::ChunkRepository.get_by_entity::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/storage/chunk_repository.py::ChunkRepository.get_by_entity", "content": "def get_by_entity(self, entity_id: str) -> list[CodeChunk]\n\"\"\"Get all chunks for an entity.\"\"\"\n    def get_by_entity(self, entity_id: str) -> list[CodeChunk]:\n        \"\"\"Get all chunks for an entity.\"\"\"\n        pass", "tokens": ["def", "get", "by", "entity", "self", "entity", "id", "str", "list", "code", "chunk", "get", "all", "chunks", "for", "an", "entity", "def", "get", "by", "entity", "self", "entity", "id", "str", "list", "code", "chunk", "get", "all", "chunks", "for", "an", "entity", "pass"], "metadata": {"kind": "method", "has_docstring": "true", "last_modified": "1766236633.3726954"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/storage/chunk_repository.py::ChunkRepository.search_by_tokens::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/storage/chunk_repository.py::ChunkRepository.search_by_tokens", "content": "def search_by_tokens(self, tokens: list[str], limit: int) -> list[CodeChunk]\n\"\"\"Search chunks by BM25 tokens.\"\"\"\n    def search_by_tokens(self, tokens: list[str], limit: int = 10) -> list[CodeChunk]:\n        \"\"\"Search chunks by BM25 tokens.\"\"\"\n        pass", "tokens": ["def", "search", "by", "tokens", "self", "tokens", "list", "str", "limit", "int", "list", "code", "chunk", "search", "chunks", "by", "bm25", "tokens", "def", "search", "by", "tokens", "self", "tokens", "list", "str", "limit", "int", "10", "list", "code", "chunk", "search", "chunks", "by", "bm25", "tokens", "pass"], "metadata": {"kind": "method", "has_docstring": "true", "last_modified": "1766236633.3726954"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/storage/chunk_repository.py::ChunkRepository.clear::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/storage/chunk_repository.py::ChunkRepository.clear", "content": "def clear(self) -> None\n\"\"\"Clear all chunks.\"\"\"\n    def clear(self) -> None:\n        \"\"\"Clear all chunks.\"\"\"\n        pass", "tokens": ["def", "clear", "self", "none", "clear", "all", "chunks", "def", "clear", "self", "none", "clear", "all", "chunks", "pass"], "metadata": {"kind": "method", "has_docstring": "true", "last_modified": "1766236633.3726954"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/storage/chunk_repository.py::InMemoryChunkRepository::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/storage/chunk_repository.py::InMemoryChunkRepository", "content": "\"\"\"In-memory implementation of ChunkRepository.\"\"\"\nclass InMemoryChunkRepository(ChunkRepository):\n    \"\"\"In-memory implementation of ChunkRepository.\"\"\"\n\n    def __init__(self) -> None:\n        \"\"\"Initialize the in-memory storage structures.\"\"\"\n        self._chunks: dict[str, CodeChunk] = {}\n        self._by_entity: dict[str, list[str]] = {}  # entity_id -> chunk_ids\n\n    def add(self, chunk: CodeChunk) -> None:\n        \"\"\"Add a chunk to the in-memory index.\"\"\"\n        self._chunks[chunk.id] = chunk\n        if chunk.entity_id not in self._by_entity:\n            self._by_entity[chunk.entity_id] = []\n        if chunk.id not in self._by_entity[chunk.entity_id]:\n            self._by_entity[chunk.entity_id].append(chunk.id)\n\n    def get(self, chunk_id: str) -> Optional[CodeChunk]:\n        \"\"\"Fetch a chunk by its ID.\"\"\"\n        return self._chunks.get(chunk_id)\n\n    def get_by_entity(self, entity_id: str) -> list[CodeChunk]:\n        \"\"\"Return all chunks associated with an entity.\"\"\"\n       ", "tokens": ["in", "memory", "implementation", "of", "chunk", "repository", "class", "in", "memory", "chunk", "repository", "chunk", "repository", "in", "memory", "implementation", "of", "chunk", "repository", "def", "init", "self", "none", "initialize", "the", "in", "memory", "storage", "structures", "self", "chunks", "dict", "str", "code", "chunk", "self", "by", "entity", "dict", "str", "list", "str", "entity", "id", "chunk", "ids", "def", "add", "self", "chunk", "code", "chunk", "none", "add", "chunk", "to", "the", "in", "memory", "index", "self", "chunks", "chunk", "id", "chunk", "if", "chunk", "entity", "id", "not", "in", "self", "by", "entity", "self", "by", "entity", "chunk", "entity", "id", "if", "chunk", "id", "not", "in", "self", "by", "entity", "chunk", "entity", "id", "self", "by", "entity", "chunk", "entity", "id", "append", "chunk", "id", "def", "get", "self", "chunk", "id", "str", "optional", "code", "chunk", "fetch", "chunk", "by", "its", "id", "return", "self", "chunks", "get", "chunk", "id", "def", "get", "by", "entity", "self", "entity", "id", "str", "list", "code", "chunk", "return", "all", "chunks", "associated", "with", "an", "entity"], "metadata": {"kind": "class", "chunk_index": "0", "has_docstring": "true", "last_modified": "1766236633.3726954"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/storage/chunk_repository.py::InMemoryChunkRepository::1", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/storage/chunk_repository.py::InMemoryChunkRepository", "content": "tity_id: str) -> list[CodeChunk]:\n        \"\"\"Return all chunks associated with an entity.\"\"\"\n        chunk_ids = self._by_entity.get(entity_id, [])\n        return [self._chunks[cid] for cid in chunk_ids if cid in self._chunks]\n\n    def search_by_tokens(self, tokens: list[str], limit: int = 10) -> list[CodeChunk]:\n        \"\"\"Perform a simple token-overlap search over stored chunks.\"\"\"\n        # Simple token overlap scoring\n        scores: list[tuple[float, CodeChunk]] = []\n        query_set = set(tokens)\n        for chunk in self._chunks.values():\n            if chunk.tokens:\n                overlap = len(query_set & set(chunk.tokens))\n                if overlap > 0:\n                    scores.append((float(overlap), chunk))\n        scores.sort(key=lambda x: x[0], reverse=True)\n        return [chunk for _, chunk in scores[:limit]]\n\n    def clear(self) -> None:\n        self._chunks.clear()\n        self._by_entity.clear()", "tokens": ["tity", "id", "str", "list", "code", "chunk", "return", "all", "chunks", "associated", "with", "an", "entity", "chunk", "ids", "self", "by", "entity", "get", "entity", "id", "return", "self", "chunks", "cid", "for", "cid", "in", "chunk", "ids", "if", "cid", "in", "self", "chunks", "def", "search", "by", "tokens", "self", "tokens", "list", "str", "limit", "int", "10", "list", "code", "chunk", "perform", "simple", "token", "overlap", "search", "over", "stored", "chunks", "simple", "token", "overlap", "scoring", "scores", "list", "tuple", "float", "code", "chunk", "query", "set", "set", "tokens", "for", "chunk", "in", "self", "chunks", "values", "if", "chunk", "tokens", "overlap", "len", "query", "set", "set", "chunk", "tokens", "if", "overlap", "scores", "append", "float", "overlap", "chunk", "scores", "sort", "key", "lambda", "reverse", "true", "return", "chunk", "for", "chunk", "in", "scores", "limit", "def", "clear", "self", "none", "self", "chunks", "clear", "self", "by", "entity", "clear"], "metadata": {"kind": "class", "chunk_index": "1", "has_docstring": "true", "last_modified": "1766236633.3726954"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/storage/chunk_repository.py::InMemoryChunkRepository.__init__::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/storage/chunk_repository.py::InMemoryChunkRepository.__init__", "content": "def __init__(self) -> None\n\"\"\"Initialize the in-memory storage structures.\"\"\"\n    def __init__(self) -> None:\n        \"\"\"Initialize the in-memory storage structures.\"\"\"\n        self._chunks: dict[str, CodeChunk] = {}\n        self._by_entity: dict[str, list[str]] = {}  # entity_id -> chunk_ids", "tokens": ["def", "init", "self", "none", "initialize", "the", "in", "memory", "storage", "structures", "def", "init", "self", "none", "initialize", "the", "in", "memory", "storage", "structures", "self", "chunks", "dict", "str", "code", "chunk", "self", "by", "entity", "dict", "str", "list", "str", "entity", "id", "chunk", "ids"], "metadata": {"kind": "method", "has_docstring": "true", "last_modified": "1766236633.3726954"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/storage/chunk_repository.py::InMemoryChunkRepository.add::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/storage/chunk_repository.py::InMemoryChunkRepository.add", "content": "def add(self, chunk: CodeChunk) -> None\n\"\"\"Add a chunk to the in-memory index.\"\"\"\n    def add(self, chunk: CodeChunk) -> None:\n        \"\"\"Add a chunk to the in-memory index.\"\"\"\n        self._chunks[chunk.id] = chunk\n        if chunk.entity_id not in self._by_entity:\n            self._by_entity[chunk.entity_id] = []\n        if chunk.id not in self._by_entity[chunk.entity_id]:\n            self._by_entity[chunk.entity_id].append(chunk.id)", "tokens": ["def", "add", "self", "chunk", "code", "chunk", "none", "add", "chunk", "to", "the", "in", "memory", "index", "def", "add", "self", "chunk", "code", "chunk", "none", "add", "chunk", "to", "the", "in", "memory", "index", "self", "chunks", "chunk", "id", "chunk", "if", "chunk", "entity", "id", "not", "in", "self", "by", "entity", "self", "by", "entity", "chunk", "entity", "id", "if", "chunk", "id", "not", "in", "self", "by", "entity", "chunk", "entity", "id", "self", "by", "entity", "chunk", "entity", "id", "append", "chunk", "id"], "metadata": {"kind": "method", "has_docstring": "true", "last_modified": "1766236633.3726954"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/storage/chunk_repository.py::InMemoryChunkRepository.get::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/storage/chunk_repository.py::InMemoryChunkRepository.get", "content": "def get(self, chunk_id: str) -> Optional[CodeChunk]\n\"\"\"Fetch a chunk by its ID.\"\"\"\n    def get(self, chunk_id: str) -> Optional[CodeChunk]:\n        \"\"\"Fetch a chunk by its ID.\"\"\"\n        return self._chunks.get(chunk_id)", "tokens": ["def", "get", "self", "chunk", "id", "str", "optional", "code", "chunk", "fetch", "chunk", "by", "its", "id", "def", "get", "self", "chunk", "id", "str", "optional", "code", "chunk", "fetch", "chunk", "by", "its", "id", "return", "self", "chunks", "get", "chunk", "id"], "metadata": {"kind": "method", "has_docstring": "true", "last_modified": "1766236633.3726954"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/storage/chunk_repository.py::InMemoryChunkRepository.get_by_entity::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/storage/chunk_repository.py::InMemoryChunkRepository.get_by_entity", "content": "def get_by_entity(self, entity_id: str) -> list[CodeChunk]\n\"\"\"Return all chunks associated with an entity.\"\"\"\n    def get_by_entity(self, entity_id: str) -> list[CodeChunk]:\n        \"\"\"Return all chunks associated with an entity.\"\"\"\n        chunk_ids = self._by_entity.get(entity_id, [])\n        return [self._chunks[cid] for cid in chunk_ids if cid in self._chunks]", "tokens": ["def", "get", "by", "entity", "self", "entity", "id", "str", "list", "code", "chunk", "return", "all", "chunks", "associated", "with", "an", "entity", "def", "get", "by", "entity", "self", "entity", "id", "str", "list", "code", "chunk", "return", "all", "chunks", "associated", "with", "an", "entity", "chunk", "ids", "self", "by", "entity", "get", "entity", "id", "return", "self", "chunks", "cid", "for", "cid", "in", "chunk", "ids", "if", "cid", "in", "self", "chunks"], "metadata": {"kind": "method", "has_docstring": "true", "last_modified": "1766236633.3726954"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/storage/chunk_repository.py::InMemoryChunkRepository.search_by_tokens::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/storage/chunk_repository.py::InMemoryChunkRepository.search_by_tokens", "content": "def search_by_tokens(self, tokens: list[str], limit: int) -> list[CodeChunk]\n\"\"\"Perform a simple token-overlap search over stored chunks.\"\"\"\n    def search_by_tokens(self, tokens: list[str], limit: int = 10) -> list[CodeChunk]:\n        \"\"\"Perform a simple token-overlap search over stored chunks.\"\"\"\n        # Simple token overlap scoring\n        scores: list[tuple[float, CodeChunk]] = []\n        query_set = set(tokens)\n        for chunk in self._chunks.values():\n            if chunk.tokens:\n                overlap = len(query_set & set(chunk.tokens))\n                if overlap > 0:\n                    scores.append((float(overlap), chunk))\n        scores.sort(key=lambda x: x[0], reverse=True)\n        return [chunk for _, chunk in scores[:limit]]", "tokens": ["def", "search", "by", "tokens", "self", "tokens", "list", "str", "limit", "int", "list", "code", "chunk", "perform", "simple", "token", "overlap", "search", "over", "stored", "chunks", "def", "search", "by", "tokens", "self", "tokens", "list", "str", "limit", "int", "10", "list", "code", "chunk", "perform", "simple", "token", "overlap", "search", "over", "stored", "chunks", "simple", "token", "overlap", "scoring", "scores", "list", "tuple", "float", "code", "chunk", "query", "set", "set", "tokens", "for", "chunk", "in", "self", "chunks", "values", "if", "chunk", "tokens", "overlap", "len", "query", "set", "set", "chunk", "tokens", "if", "overlap", "scores", "append", "float", "overlap", "chunk", "scores", "sort", "key", "lambda", "reverse", "true", "return", "chunk", "for", "chunk", "in", "scores", "limit"], "metadata": {"kind": "method", "has_docstring": "true", "last_modified": "1766236633.3726954"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/storage/chunk_repository.py::InMemoryChunkRepository.clear::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/storage/chunk_repository.py::InMemoryChunkRepository.clear", "content": "def clear(self) -> None\n    def clear(self) -> None:\n        self._chunks.clear()\n        self._by_entity.clear()", "tokens": ["def", "clear", "self", "none", "def", "clear", "self", "none", "self", "chunks", "clear", "self", "by", "entity", "clear"], "metadata": {"kind": "method", "has_docstring": "false", "last_modified": "1766236633.3726954"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/storage/vector_store.py::module::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/storage/vector_store.py::module", "content": "\"\"\"Vector store for dense retrieval using FAISS.\"\"\"", "tokens": ["vector", "store", "for", "dense", "retrieval", "using", "faiss"], "metadata": {"type": "module_header"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/storage/vector_store.py::imports::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/storage/vector_store.py::module", "content": "import json\nfrom pathlib import Path\nfrom typing import Optional\nimport numpy as np\n    import faiss", "tokens": ["import", "json", "from", "pathlib", "import", "path", "from", "typing", "import", "optional", "import", "numpy", "as", "np", "import", "faiss"], "metadata": {"type": "imports"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/storage/vector_store.py::VectorStore::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/storage/vector_store.py::VectorStore", "content": "\"\"\"FAISS-based vector store for code embeddings.\"\"\"\nclass VectorStore:\n    \"\"\"FAISS-based vector store for code embeddings.\"\"\"\n\n    def __init__(self, dimension: int = 1536, index_path: Optional[Path] = None) -> None:\n        \"\"\"Initialize the vector index.\n\n        Args:\n            dimension: Expected embedding dimensionality.\n            index_path: Optional path to load an existing index from disk.\n        \"\"\"\n        self.dimension = dimension\n        self.index_path = index_path\n        \n        if faiss:\n            # Task 3.4: Use Inner Product for cosine similarity (with normalized vectors)\n            self.index = faiss.IndexFlatIP(dimension)\n        else:\n            self.index = None\n            \n        self.id_map: dict[int, str] = {}  # index -> chunk_id\n        \n        if index_path and index_path.exists():\n            self.load(index_path)\n\n    def add(self, chunk_id: str, embedding: list[float]) -> None:\n        \"\"\"Add a chunk embedding to the index.\n\n        No-op i", "tokens": ["faiss", "based", "vector", "store", "for", "code", "embeddings", "class", "vector", "store", "faiss", "based", "vector", "store", "for", "code", "embeddings", "def", "init", "self", "dimension", "int", "1536", "index", "path", "optional", "path", "none", "none", "initialize", "the", "vector", "index", "args", "dimension", "expected", "embedding", "dimensionality", "index", "path", "optional", "path", "to", "load", "an", "existing", "index", "from", "disk", "self", "dimension", "dimension", "self", "index", "path", "index", "path", "if", "faiss", "task", "use", "inner", "product", "for", "cosine", "similarity", "with", "normalized", "vectors", "self", "index", "faiss", "index", "flat", "ip", "dimension", "else", "self", "index", "none", "self", "id", "map", "dict", "int", "str", "index", "chunk", "id", "if", "index", "path", "and", "index", "path", "exists", "self", "load", "index", "path", "def", "add", "self", "chunk", "id", "str", "embedding", "list", "float", "none", "add", "chunk", "embedding", "to", "the", "index", "no", "op"], "metadata": {"kind": "class", "chunk_index": "0", "has_docstring": "true", "last_modified": "1766231204.571363"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/storage/vector_store.py::VectorStore::1", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/storage/vector_store.py::VectorStore", "content": "tr, embedding: list[float]) -> None:\n        \"\"\"Add a chunk embedding to the index.\n\n        No-op if FAISS is unavailable.\n        \"\"\"\n        if not self.index:\n             return\n             \n        vec = np.array([embedding]).astype(\"float32\")\n        idx = self.index.ntotal\n        self.index.add(vec)\n        self.id_map[idx] = chunk_id\n\n    def search(self, embedding: list[float], limit: int = 10) -> list[tuple[str, float]]:\n        \"\"\"Search for similar embeddings.\n\n        Args:\n            embedding: Query embedding to search for.\n            limit: Maximum number of results to return.\n\n        Returns:\n            List of (chunk_id, score) tuples.\n        \"\"\"\n        if not self.index:\n            return []\n            \n        vec = np.array([embedding]).astype(\"float32\")\n        distances, indices = self.index.search(vec, limit)\n        \n        results = []\n        for dist, idx in zip(distances[0], indices[0]):\n            if idx in self.id_map:\n                results", "tokens": ["tr", "embedding", "list", "float", "none", "add", "chunk", "embedding", "to", "the", "index", "no", "op", "if", "faiss", "is", "unavailable", "if", "not", "self", "index", "return", "vec", "np", "array", "embedding", "astype", "float32", "idx", "self", "index", "ntotal", "self", "index", "add", "vec", "self", "id", "map", "idx", "chunk", "id", "def", "search", "self", "embedding", "list", "float", "limit", "int", "10", "list", "tuple", "str", "float", "search", "for", "similar", "embeddings", "args", "embedding", "query", "embedding", "to", "search", "for", "limit", "maximum", "number", "of", "results", "to", "return", "returns", "list", "of", "chunk", "id", "score", "tuples", "if", "not", "self", "index", "return", "vec", "np", "array", "embedding", "astype", "float32", "distances", "indices", "self", "index", "search", "vec", "limit", "results", "for", "dist", "idx", "in", "zip", "distances", "indices", "if", "idx", "in", "self", "id", "map", "results"], "metadata": {"kind": "class", "chunk_index": "1", "has_docstring": "true", "last_modified": "1766231204.571363"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/storage/vector_store.py::VectorStore::2", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/storage/vector_store.py::VectorStore", "content": "st, idx in zip(distances[0], indices[0]):\n            if idx in self.id_map:\n                results.append((self.id_map[int(idx)], float(dist)))\n                \n        return results\n\n    def save(self, path: Path) -> None:\n        \"\"\"Save index and ID map to disk.\"\"\"\n        if not self.index:\n            return\n            \n        path = Path(path)\n        path.parent.mkdir(parents=True, exist_ok=True)\n        \n        # Save FAISS index\n        faiss.write_index(self.index, str(path.with_suffix(\".index\")))\n        \n        # Save ID map\n        with open(path.with_suffix(\".json\"), \"w\") as f:\n            json.dump({\"id_map\": {str(k): v for k, v in self.id_map.items()}, \"dimension\": self.dimension}, f)\n\n    def load(self, path: Path) -> None:\n        \"\"\"Load index and ID map from disk.\n\n        No-op if FAISS is unavailable.\n        \"\"\"\n        if not faiss:\n            return\n            \n        path = Path(path)\n        index_file = path.with_suffix(\".index\")\n        json_file ", "tokens": ["st", "idx", "in", "zip", "distances", "indices", "if", "idx", "in", "self", "id", "map", "results", "append", "self", "id", "map", "int", "idx", "float", "dist", "return", "results", "def", "save", "self", "path", "path", "none", "save", "index", "and", "id", "map", "to", "disk", "if", "not", "self", "index", "return", "path", "path", "path", "path", "parent", "mkdir", "parents", "true", "exist", "ok", "true", "save", "faiss", "index", "faiss", "write", "index", "self", "index", "str", "path", "with", "suffix", "index", "save", "id", "map", "with", "open", "path", "with", "suffix", "json", "as", "json", "dump", "id", "map", "str", "for", "in", "self", "id", "map", "items", "dimension", "self", "dimension", "def", "load", "self", "path", "path", "none", "load", "index", "and", "id", "map", "from", "disk", "no", "op", "if", "faiss", "is", "unavailable", "if", "not", "faiss", "return", "path", "path", "path", "index", "file", "path", "with", "suffix", "index", "json", "file"], "metadata": {"kind": "class", "chunk_index": "2", "has_docstring": "true", "last_modified": "1766231204.571363"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/storage/vector_store.py::VectorStore::3", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/storage/vector_store.py::VectorStore", "content": "       \n        path = Path(path)\n        index_file = path.with_suffix(\".index\")\n        json_file = path.with_suffix(\".json\")\n        \n        if index_file.exists():\n            self.index = faiss.read_index(str(index_file))\n            \n        if json_file.exists():\n            with open(json_file) as f:\n                data = json.load(f)\n                # Task 3.3: Fix persistence bug (ensure we don't reset after loading)\n                self.id_map = {int(k): v for k, v in data[\"id_map\"].items()}\n                self.dimension = data.get(\"dimension\", self.dimension)\n                \n    def clear(self) -> None:\n        \"\"\"Clear the index and reset the ID map.\"\"\"\n        if faiss:\n            self.index = faiss.IndexFlatIP(self.dimension)\n        self.id_map = {}", "tokens": ["path", "path", "path", "index", "file", "path", "with", "suffix", "index", "json", "file", "path", "with", "suffix", "json", "if", "index", "file", "exists", "self", "index", "faiss", "read", "index", "str", "index", "file", "if", "json", "file", "exists", "with", "open", "json", "file", "as", "data", "json", "load", "task", "fix", "persistence", "bug", "ensure", "we", "don", "reset", "after", "loading", "self", "id", "map", "int", "for", "in", "data", "id", "map", "items", "self", "dimension", "data", "get", "dimension", "self", "dimension", "def", "clear", "self", "none", "clear", "the", "index", "and", "reset", "the", "id", "map", "if", "faiss", "self", "index", "faiss", "index", "flat", "ip", "self", "dimension", "self", "id", "map"], "metadata": {"kind": "class", "chunk_index": "3", "has_docstring": "true", "last_modified": "1766231204.571363"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/storage/vector_store.py::VectorStore.__init__::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/storage/vector_store.py::VectorStore.__init__", "content": "def __init__(self, dimension: int, index_path: Optional[Path]) -> None\n\"\"\"Initialize the vector index.\n\nArgs:\n    dimension: Expected embedding dimensionality.\n    index_path: Optional path to load an existing index from disk.\"\"\"\n    def __init__(self, dimension: int = 1536, index_path: Optional[Path] = None) -> None:\n        \"\"\"Initialize the vector index.\n\n        Args:\n            dimension: Expected embedding dimensionality.\n            index_path: Optional path to load an existing index from disk.\n        \"\"\"\n        self.dimension = dimension\n        self.index_path = index_path\n        \n        if faiss:\n            # Task 3.4: Use Inner Product for cosine similarity (with normalized vectors)\n            self.index = faiss.IndexFlatIP(dimension)\n        else:\n            self.index = None\n            \n        self.id_map: dict[int, str] = {}  # index -> chunk_id\n        \n        if index_path and index_path.exists():\n            self.load(index_path)", "tokens": ["def", "init", "self", "dimension", "int", "index", "path", "optional", "path", "none", "initialize", "the", "vector", "index", "args", "dimension", "expected", "embedding", "dimensionality", "index", "path", "optional", "path", "to", "load", "an", "existing", "index", "from", "disk", "def", "init", "self", "dimension", "int", "1536", "index", "path", "optional", "path", "none", "none", "initialize", "the", "vector", "index", "args", "dimension", "expected", "embedding", "dimensionality", "index", "path", "optional", "path", "to", "load", "an", "existing", "index", "from", "disk", "self", "dimension", "dimension", "self", "index", "path", "index", "path", "if", "faiss", "task", "use", "inner", "product", "for", "cosine", "similarity", "with", "normalized", "vectors", "self", "index", "faiss", "index", "flat", "ip", "dimension", "else", "self", "index", "none", "self", "id", "map", "dict", "int", "str", "index", "chunk", "id", "if", "index", "path", "and", "index", "path", "exists", "self", "load", "index", "path"], "metadata": {"kind": "method", "has_docstring": "true", "last_modified": "1766231204.571363"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/storage/vector_store.py::VectorStore.add::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/storage/vector_store.py::VectorStore.add", "content": "def add(self, chunk_id: str, embedding: list[float]) -> None\n\"\"\"Add a chunk embedding to the index.\n\nNo-op if FAISS is unavailable.\"\"\"\n    def add(self, chunk_id: str, embedding: list[float]) -> None:\n        \"\"\"Add a chunk embedding to the index.\n\n        No-op if FAISS is unavailable.\n        \"\"\"\n        if not self.index:\n             return\n             \n        vec = np.array([embedding]).astype(\"float32\")\n        idx = self.index.ntotal\n        self.index.add(vec)\n        self.id_map[idx] = chunk_id", "tokens": ["def", "add", "self", "chunk", "id", "str", "embedding", "list", "float", "none", "add", "chunk", "embedding", "to", "the", "index", "no", "op", "if", "faiss", "is", "unavailable", "def", "add", "self", "chunk", "id", "str", "embedding", "list", "float", "none", "add", "chunk", "embedding", "to", "the", "index", "no", "op", "if", "faiss", "is", "unavailable", "if", "not", "self", "index", "return", "vec", "np", "array", "embedding", "astype", "float32", "idx", "self", "index", "ntotal", "self", "index", "add", "vec", "self", "id", "map", "idx", "chunk", "id"], "metadata": {"kind": "method", "has_docstring": "true", "last_modified": "1766231204.571363"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/storage/vector_store.py::VectorStore.search::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/storage/vector_store.py::VectorStore.search", "content": "def search(self, embedding: list[float], limit: int) -> list[tuple[str, float]]\n\"\"\"Search for similar embeddings.\n\nArgs:\n    embedding: Query embedding to search for.\n    limit: Maximum number of results to return.\n\nReturns:\n    List of (chunk_id, score) tuples.\"\"\"\n    def search(self, embedding: list[float], limit: int = 10) -> list[tuple[str, float]]:\n        \"\"\"Search for similar embeddings.\n\n        Args:\n            embedding: Query embedding to search for.\n            limit: Maximum number of results to return.\n\n        Returns:\n            List of (chunk_id, score) tuples.\n        \"\"\"\n        if not self.index:\n            return []\n            \n        vec = np.array([embedding]).astype(\"float32\")\n        distances, indices = self.index.search(vec, limit)\n        \n        results = []\n        for dist, idx in zip(distances[0], indices[0]):\n            if idx in self.id_map:\n                results.append((self.id_map[int(idx)], float(dist)))\n                \n        return resu", "tokens": ["def", "search", "self", "embedding", "list", "float", "limit", "int", "list", "tuple", "str", "float", "search", "for", "similar", "embeddings", "args", "embedding", "query", "embedding", "to", "search", "for", "limit", "maximum", "number", "of", "results", "to", "return", "returns", "list", "of", "chunk", "id", "score", "tuples", "def", "search", "self", "embedding", "list", "float", "limit", "int", "10", "list", "tuple", "str", "float", "search", "for", "similar", "embeddings", "args", "embedding", "query", "embedding", "to", "search", "for", "limit", "maximum", "number", "of", "results", "to", "return", "returns", "list", "of", "chunk", "id", "score", "tuples", "if", "not", "self", "index", "return", "vec", "np", "array", "embedding", "astype", "float32", "distances", "indices", "self", "index", "search", "vec", "limit", "results", "for", "dist", "idx", "in", "zip", "distances", "indices", "if", "idx", "in", "self", "id", "map", "results", "append", "self", "id", "map", "int", "idx", "float", "dist", "return", "resu"], "metadata": {"kind": "method", "chunk_index": "0", "has_docstring": "true", "last_modified": "1766231204.571363"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/storage/vector_store.py::VectorStore.search::1", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/storage/vector_store.py::VectorStore.search", "content": "           results.append((self.id_map[int(idx)], float(dist)))\n                \n        return results", "tokens": ["results", "append", "self", "id", "map", "int", "idx", "float", "dist", "return", "results"], "metadata": {"kind": "method", "chunk_index": "1", "has_docstring": "true", "last_modified": "1766231204.571363"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/storage/vector_store.py::VectorStore.save::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/storage/vector_store.py::VectorStore.save", "content": "def save(self, path: Path) -> None\n\"\"\"Save index and ID map to disk.\"\"\"\n    def save(self, path: Path) -> None:\n        \"\"\"Save index and ID map to disk.\"\"\"\n        if not self.index:\n            return\n            \n        path = Path(path)\n        path.parent.mkdir(parents=True, exist_ok=True)\n        \n        # Save FAISS index\n        faiss.write_index(self.index, str(path.with_suffix(\".index\")))\n        \n        # Save ID map\n        with open(path.with_suffix(\".json\"), \"w\") as f:\n            json.dump({\"id_map\": {str(k): v for k, v in self.id_map.items()}, \"dimension\": self.dimension}, f)", "tokens": ["def", "save", "self", "path", "path", "none", "save", "index", "and", "id", "map", "to", "disk", "def", "save", "self", "path", "path", "none", "save", "index", "and", "id", "map", "to", "disk", "if", "not", "self", "index", "return", "path", "path", "path", "path", "parent", "mkdir", "parents", "true", "exist", "ok", "true", "save", "faiss", "index", "faiss", "write", "index", "self", "index", "str", "path", "with", "suffix", "index", "save", "id", "map", "with", "open", "path", "with", "suffix", "json", "as", "json", "dump", "id", "map", "str", "for", "in", "self", "id", "map", "items", "dimension", "self", "dimension"], "metadata": {"kind": "method", "has_docstring": "true", "last_modified": "1766231204.571363"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/storage/vector_store.py::VectorStore.load::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/storage/vector_store.py::VectorStore.load", "content": "def load(self, path: Path) -> None\n\"\"\"Load index and ID map from disk.\n\nNo-op if FAISS is unavailable.\"\"\"\n    def load(self, path: Path) -> None:\n        \"\"\"Load index and ID map from disk.\n\n        No-op if FAISS is unavailable.\n        \"\"\"\n        if not faiss:\n            return\n            \n        path = Path(path)\n        index_file = path.with_suffix(\".index\")\n        json_file = path.with_suffix(\".json\")\n        \n        if index_file.exists():\n            self.index = faiss.read_index(str(index_file))\n            \n        if json_file.exists():\n            with open(json_file) as f:\n                data = json.load(f)\n                # Task 3.3: Fix persistence bug (ensure we don't reset after loading)\n                self.id_map = {int(k): v for k, v in data[\"id_map\"].items()}\n                self.dimension = data.get(\"dimension\", self.dimension)", "tokens": ["def", "load", "self", "path", "path", "none", "load", "index", "and", "id", "map", "from", "disk", "no", "op", "if", "faiss", "is", "unavailable", "def", "load", "self", "path", "path", "none", "load", "index", "and", "id", "map", "from", "disk", "no", "op", "if", "faiss", "is", "unavailable", "if", "not", "faiss", "return", "path", "path", "path", "index", "file", "path", "with", "suffix", "index", "json", "file", "path", "with", "suffix", "json", "if", "index", "file", "exists", "self", "index", "faiss", "read", "index", "str", "index", "file", "if", "json", "file", "exists", "with", "open", "json", "file", "as", "data", "json", "load", "task", "fix", "persistence", "bug", "ensure", "we", "don", "reset", "after", "loading", "self", "id", "map", "int", "for", "in", "data", "id", "map", "items", "self", "dimension", "data", "get", "dimension", "self", "dimension"], "metadata": {"kind": "method", "has_docstring": "true", "last_modified": "1766231204.571363"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/storage/vector_store.py::VectorStore.clear::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/storage/vector_store.py::VectorStore.clear", "content": "def clear(self) -> None\n\"\"\"Clear the index and reset the ID map.\"\"\"\n    def clear(self) -> None:\n        \"\"\"Clear the index and reset the ID map.\"\"\"\n        if faiss:\n            self.index = faiss.IndexFlatIP(self.dimension)\n        self.id_map = {}", "tokens": ["def", "clear", "self", "none", "clear", "the", "index", "and", "reset", "the", "id", "map", "def", "clear", "self", "none", "clear", "the", "index", "and", "reset", "the", "id", "map", "if", "faiss", "self", "index", "faiss", "index", "flat", "ip", "self", "dimension", "self", "id", "map"], "metadata": {"kind": "method", "has_docstring": "true", "last_modified": "1766231204.571363"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/javascript_parser.py::module::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/javascript_parser.py::module", "content": "\"\"\"JavaScript parser using Tree-sitter.\"\"\"", "tokens": ["java", "script", "parser", "using", "tree", "sitter"], "metadata": {"type": "module_header"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/javascript_parser.py::imports::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/javascript_parser.py::module", "content": "from pathlib import Path\nfrom typing import Any\nfrom knowcode.data_models import Entity, EntityKind, Relationship, RelationshipKind\nfrom knowcode.parsers.base import TreeSitterParser", "tokens": ["from", "pathlib", "import", "path", "from", "typing", "import", "any", "from", "knowcode", "data", "models", "import", "entity", "entity", "kind", "relationship", "relationship", "kind", "from", "knowcode", "parsers", "base", "import", "tree", "sitter", "parser"], "metadata": {"type": "imports"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/javascript_parser.py::JavaScriptParser::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/javascript_parser.py::JavaScriptParser", "content": "\"\"\"Parses JavaScript/TypeScript files.\"\"\"\nclass JavaScriptParser(TreeSitterParser):\n    \"\"\"Parses JavaScript/TypeScript files.\"\"\"\n\n    def __init__(self) -> None:\n        \"\"\"Initialize JavaScript parser.\"\"\"\n        super().__init__(\"javascript\")\n\n    def _extract_entities(\n        self,\n        node: Any,\n        file_path: Path,\n        parent_id: str,\n        source_code: str,\n        source_lines: list[str],\n    ) -> tuple[list[Entity], list[Relationship]]:\n        \"\"\"Extract entities from JavaScript AST.\"\"\"\n        entities: list[Entity] = []\n        relationships: list[Relationship] = []\n\n\n\n        # Traverse children\n        \n        # We need to iterate over all children. walk() gives a cursor.\n        # Tree-sitter cursors are stateful.\n        # Simplest way is often just to iterate node.children if the tree isn't massive,\n        # or use a recursive visitor pattern.\n        # For this implementation, we will iterate over node.children for the current scope,\n        # and rec", "tokens": ["parses", "java", "script", "type", "script", "files", "class", "java", "script", "parser", "tree", "sitter", "parser", "parses", "java", "script", "type", "script", "files", "def", "init", "self", "none", "initialize", "java", "script", "parser", "super", "init", "javascript", "def", "extract", "entities", "self", "node", "any", "file", "path", "path", "parent", "id", "str", "source", "code", "str", "source", "lines", "list", "str", "tuple", "list", "entity", "list", "relationship", "extract", "entities", "from", "java", "script", "ast", "entities", "list", "entity", "relationships", "list", "relationship", "traverse", "children", "we", "need", "to", "iterate", "over", "all", "children", "walk", "gives", "cursor", "tree", "sitter", "cursors", "are", "stateful", "simplest", "way", "is", "often", "just", "to", "iterate", "node", "children", "if", "the", "tree", "isn", "massive", "or", "use", "recursive", "visitor", "pattern", "for", "this", "implementation", "we", "will", "iterate", "over", "node", "children", "for", "the", "current", "scope", "and", "rec"], "metadata": {"kind": "class", "chunk_index": "0", "has_docstring": "true", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/javascript_parser.py::JavaScriptParser::1", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/javascript_parser.py::JavaScriptParser", "content": "For this implementation, we will iterate over node.children for the current scope,\n        # and recurse into relevant containers (class body, function body).\n        \n        for child in node.children:\n            child_type = child.type\n            \n            if child_type == \"class_declaration\":\n                class_entities, class_rels = self._parse_class(\n                    child, file_path, parent_id, source_code, source_lines\n                )\n                entities.extend(class_entities)\n                relationships.extend(class_rels)\n                \n            elif child_type == \"function_declaration\":\n                func_entity, func_rels = self._parse_function(\n                    child, file_path, parent_id, source_code, source_lines, kind=EntityKind.FUNCTION\n                )\n                entities.append(func_entity)\n                relationships.extend(func_rels)\n                \n            elif child_type == \"variable_declaration\":\n                 # Check", "tokens": ["for", "this", "implementation", "we", "will", "iterate", "over", "node", "children", "for", "the", "current", "scope", "and", "recurse", "into", "relevant", "containers", "class", "body", "function", "body", "for", "child", "in", "node", "children", "child", "type", "child", "type", "if", "child", "type", "class", "declaration", "class", "entities", "class", "rels", "self", "parse", "class", "child", "file", "path", "parent", "id", "source", "code", "source", "lines", "entities", "extend", "class", "entities", "relationships", "extend", "class", "rels", "elif", "child", "type", "function", "declaration", "func", "entity", "func", "rels", "self", "parse", "function", "child", "file", "path", "parent", "id", "source", "code", "source", "lines", "kind", "entity", "kind", "function", "entities", "append", "func", "entity", "relationships", "extend", "func", "rels", "elif", "child", "type", "variable", "declaration", "check"], "metadata": {"kind": "class", "chunk_index": "1", "has_docstring": "true", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/javascript_parser.py::JavaScriptParser::2", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/javascript_parser.py::JavaScriptParser", "content": "ls)\n                \n            elif child_type == \"variable_declaration\":\n                 # Check for arrow functions assigned to variables: const foo = () => {}\n                 for decl in child.children:\n                     if decl.type == \"variable_declarator\":\n                         # name is first child, value is last child\n                         var_name_node = decl.child_by_field_name(\"name\")\n                         value_node = decl.child_by_field_name(\"value\")\n                         \n                         if value_node and value_node.type == \"arrow_function\":\n                             # Treat as function\n                             func_entity, func_rels = self._parse_arrow_function(\n                                 value_node, var_name_node, file_path, parent_id, source_code, source_lines\n                             )\n                             entities.append(func_entity)\n                             relationships.extend(func_rels)\n\n            elif chi", "tokens": ["ls", "elif", "child", "type", "variable", "declaration", "check", "for", "arrow", "functions", "assigned", "to", "variables", "const", "foo", "for", "decl", "in", "child", "children", "if", "decl", "type", "variable", "declarator", "name", "is", "first", "child", "value", "is", "last", "child", "var", "name", "node", "decl", "child", "by", "field", "name", "name", "value", "node", "decl", "child", "by", "field", "name", "value", "if", "value", "node", "and", "value", "node", "type", "arrow", "function", "treat", "as", "function", "func", "entity", "func", "rels", "self", "parse", "arrow", "function", "value", "node", "var", "name", "node", "file", "path", "parent", "id", "source", "code", "source", "lines", "entities", "append", "func", "entity", "relationships", "extend", "func", "rels", "elif", "chi"], "metadata": {"kind": "class", "chunk_index": "2", "has_docstring": "true", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/javascript_parser.py::JavaScriptParser::3", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/javascript_parser.py::JavaScriptParser", "content": "pend(func_entity)\n                             relationships.extend(func_rels)\n\n            elif child_type == \"import_statement\":\n                # import { foo } from 'bar';\n                # Source is usually the string literal at the end\n                source_node = child.child_by_field_name(\"source\")\n                if source_node:\n                    # Remove quotes\n                    module_name = self._get_text(source_node, None).strip(\"'\\\"\")\n                    relationships.append(\n                        Relationship(\n                            source_id=parent_id, # Imports belong to the module scope usually\n                            target_id=f\"external::{module_name}\",\n                            kind=RelationshipKind.IMPORTS\n                        )\n                    )\n            \n            elif child_type == \"call_expression\":\n                 # Extract calls\n                 call_rel = self._extract_call(child, parent_id)\n                 if call_rel:\n      ", "tokens": ["pend", "func", "entity", "relationships", "extend", "func", "rels", "elif", "child", "type", "import", "statement", "import", "foo", "from", "bar", "source", "is", "usually", "the", "string", "literal", "at", "the", "end", "source", "node", "child", "child", "by", "field", "name", "source", "if", "source", "node", "remove", "quotes", "module", "name", "self", "get", "text", "source", "node", "none", "strip", "relationships", "append", "relationship", "source", "id", "parent", "id", "imports", "belong", "to", "the", "module", "scope", "usually", "target", "id", "external", "module", "name", "kind", "relationship", "kind", "imports", "elif", "child", "type", "call", "expression", "extract", "calls", "call", "rel", "self", "extract", "call", "child", "parent", "id", "if", "call", "rel"], "metadata": {"kind": "class", "chunk_index": "3", "has_docstring": "true", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/javascript_parser.py::JavaScriptParser::4", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/javascript_parser.py::JavaScriptParser", "content": "                call_rel = self._extract_call(child, parent_id)\n                 if call_rel:\n                     relationships.append(call_rel)\n\n        return entities, relationships\n\n    def _parse_class(\n        self,\n        node: Any,\n        file_path: Path,\n        parent_id: str,\n        source_code: str,\n        source_lines: list[str],\n    ) -> tuple[list[Entity], list[Relationship]]:\n        entities: list[Entity] = []\n        relationships: list[Relationship] = []\n\n        name_node = node.child_by_field_name(\"name\")\n        if not name_node:\n            return [], [] # Anonymous class\n\n        class_name = self._get_text(name_node, None)\n        qualified_name = class_name # Simplified for now\n        class_id = f\"{file_path}::{qualified_name}\"\n        \n        # Check parent info for inheritance\n        # In tree-sitter-javascript: class_heritage -> extends_clause -> call_expression or identifier\n        # Actually structure is class_declaration -> class_heritage -> ext", "tokens": ["call", "rel", "self", "extract", "call", "child", "parent", "id", "if", "call", "rel", "relationships", "append", "call", "rel", "return", "entities", "relationships", "def", "parse", "class", "self", "node", "any", "file", "path", "path", "parent", "id", "str", "source", "code", "str", "source", "lines", "list", "str", "tuple", "list", "entity", "list", "relationship", "entities", "list", "entity", "relationships", "list", "relationship", "name", "node", "node", "child", "by", "field", "name", "name", "if", "not", "name", "node", "return", "anonymous", "class", "class", "name", "self", "get", "text", "name", "node", "none", "qualified", "name", "class", "name", "simplified", "for", "now", "class", "id", "file", "path", "qualified", "name", "check", "parent", "info", "for", "inheritance", "in", "tree", "sitter", "javascript", "class", "heritage", "extends", "clause", "call", "expression", "or", "identifier", "actually", "structure", "is", "class", "declaration", "class", "heritage", "ext"], "metadata": {"kind": "class", "chunk_index": "4", "has_docstring": "true", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/javascript_parser.py::JavaScriptParser::5", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/javascript_parser.py::JavaScriptParser", "content": "_expression or identifier\n        # Actually structure is class_declaration -> class_heritage -> extends_clause\n        # Let's check node children for \"class_heritage\"\n        \n        for child in node.children:\n            if child.type == \"class_heritage\":\n                 # extends Foo\n                 extends_node = child.child_by_field_name(\"super_class\") # or just iterate\n                 if extends_node: # Usually the last child of heritage\n                     base_name = self._get_text(extends_node, None)\n                     relationships.append(\n                        Relationship(\n                            source_id=class_id,\n                            target_id=f\"ref::{base_name}\",\n                            kind=RelationshipKind.INHERITS\n                        )\n                     )\n\n        entity = self._create_entity(\n            node, EntityKind.CLASS, class_name, qualified_name, file_path, source_lines\n        )\n        entities.append(entity)\n        \n    ", "tokens": ["expression", "or", "identifier", "actually", "structure", "is", "class", "declaration", "class", "heritage", "extends", "clause", "let", "check", "node", "children", "for", "class", "heritage", "for", "child", "in", "node", "children", "if", "child", "type", "class", "heritage", "extends", "foo", "extends", "node", "child", "child", "by", "field", "name", "super", "class", "or", "just", "iterate", "if", "extends", "node", "usually", "the", "last", "child", "of", "heritage", "base", "name", "self", "get", "text", "extends", "node", "none", "relationships", "append", "relationship", "source", "id", "class", "id", "target", "id", "ref", "base", "name", "kind", "relationship", "kind", "inherits", "entity", "self", "create", "entity", "node", "entity", "kind", "class", "class", "name", "qualified", "name", "file", "path", "source", "lines", "entities", "append", "entity"], "metadata": {"kind": "class", "chunk_index": "5", "has_docstring": "true", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/javascript_parser.py::JavaScriptParser::6", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/javascript_parser.py::JavaScriptParser", "content": "ame, qualified_name, file_path, source_lines\n        )\n        entities.append(entity)\n        \n        relationships.append(\n            Relationship(source_id=parent_id, target_id=class_id, kind=RelationshipKind.CONTAINS)\n        )\n\n        body_node = node.child_by_field_name(\"body\")\n        if body_node:\n            # Parse methods\n            for child in body_node.children:\n                if child.type == \"method_definition\":\n                    method_entity, method_rels = self._parse_function(\n                        child, file_path, class_id, source_code, source_lines, kind=EntityKind.METHOD, parent_name=class_name\n                    )\n                    entities.append(method_entity)\n                    relationships.extend(method_rels)\n\n        return entities, relationships\n\n    def _parse_function(\n        self,\n        node: Any,\n        file_path: Path,\n        parent_id: str,\n        source_code: str,\n        source_lines: list[str],\n        kind: EntityKind,\n      ", "tokens": ["ame", "qualified", "name", "file", "path", "source", "lines", "entities", "append", "entity", "relationships", "append", "relationship", "source", "id", "parent", "id", "target", "id", "class", "id", "kind", "relationship", "kind", "contains", "body", "node", "node", "child", "by", "field", "name", "body", "if", "body", "node", "parse", "methods", "for", "child", "in", "body", "node", "children", "if", "child", "type", "method", "definition", "method", "entity", "method", "rels", "self", "parse", "function", "child", "file", "path", "class", "id", "source", "code", "source", "lines", "kind", "entity", "kind", "method", "parent", "name", "class", "name", "entities", "append", "method", "entity", "relationships", "extend", "method", "rels", "return", "entities", "relationships", "def", "parse", "function", "self", "node", "any", "file", "path", "path", "parent", "id", "str", "source", "code", "str", "source", "lines", "list", "str", "kind", "entity", "kind"], "metadata": {"kind": "class", "chunk_index": "6", "has_docstring": "true", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/javascript_parser.py::JavaScriptParser::7", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/javascript_parser.py::JavaScriptParser", "content": "id: str,\n        source_code: str,\n        source_lines: list[str],\n        kind: EntityKind,\n        parent_name: str = \"\"\n    ) -> tuple[Entity, list[Relationship]]:\n        name_node = node.child_by_field_name(\"name\")\n        if not name_node:\n            # Check if it is a constructor\n            if kind == EntityKind.METHOD:\n                 name_node = node.child_by_field_name(\"name\") # method_definition has name\n                 if not name_node and self._get_text(node, None).startswith(\"constructor\"):\n                     name = \"constructor\"\n                 else:\n                     name = self._get_text(name_node, None) if name_node else \"anonymous\"\n            else:\n                return Exception(\"Anonymous function not fully supported yet\"), [] \n                \n        name = self._get_text(name_node, None) if name_node else \"constructor\"\n        \n        if parent_name:\n            qualified_name = f\"{parent_name}.{name}\"\n        else:\n            qualified_name = nam", "tokens": ["id", "str", "source", "code", "str", "source", "lines", "list", "str", "kind", "entity", "kind", "parent", "name", "str", "tuple", "entity", "list", "relationship", "name", "node", "node", "child", "by", "field", "name", "name", "if", "not", "name", "node", "check", "if", "it", "is", "constructor", "if", "kind", "entity", "kind", "method", "name", "node", "node", "child", "by", "field", "name", "name", "method", "definition", "has", "name", "if", "not", "name", "node", "and", "self", "get", "text", "node", "none", "startswith", "constructor", "name", "constructor", "else", "name", "self", "get", "text", "name", "node", "none", "if", "name", "node", "else", "anonymous", "else", "return", "exception", "anonymous", "function", "not", "fully", "supported", "yet", "name", "self", "get", "text", "name", "node", "none", "if", "name", "node", "else", "constructor", "if", "parent", "name", "qualified", "name", "parent", "name", "name", "else", "qualified", "name", "nam"], "metadata": {"kind": "class", "chunk_index": "7", "has_docstring": "true", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/javascript_parser.py::JavaScriptParser::8", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/javascript_parser.py::JavaScriptParser", "content": "\n            qualified_name = f\"{parent_name}.{name}\"\n        else:\n            qualified_name = name\n            \n        func_id = f\"{file_path}::{qualified_name}\"\n        \n        entity = self._create_entity(\n            node, kind, name, qualified_name, file_path, source_lines\n        )\n        \n        relationships = [\n            Relationship(source_id=parent_id, target_id=func_id, kind=RelationshipKind.CONTAINS)\n        ]\n        \n        # Extract calls from body\n        body_node = node.child_by_field_name(\"body\")\n        if body_node:\n            child_entities, child_rels = self._extract_entities(body_node, file_path, func_id, source_code, source_lines)\n            # We ignore child entities declared INSIDE functions for now (local vars/funcs), \n            # but we want the calls from child_rels\n            # Actually, _extract_entities returns variable_declarations too.\n            # For now, let's just grab calls.\n            \n            # Helper to just walk for calls", "tokens": ["qualified", "name", "parent", "name", "name", "else", "qualified", "name", "name", "func", "id", "file", "path", "qualified", "name", "entity", "self", "create", "entity", "node", "kind", "name", "qualified", "name", "file", "path", "source", "lines", "relationships", "relationship", "source", "id", "parent", "id", "target", "id", "func", "id", "kind", "relationship", "kind", "contains", "extract", "calls", "from", "body", "body", "node", "node", "child", "by", "field", "name", "body", "if", "body", "node", "child", "entities", "child", "rels", "self", "extract", "entities", "body", "node", "file", "path", "func", "id", "source", "code", "source", "lines", "we", "ignore", "child", "entities", "declared", "inside", "functions", "for", "now", "local", "vars", "funcs", "but", "we", "want", "the", "calls", "from", "child", "rels", "actually", "extract", "entities", "returns", "variable", "declarations", "too", "for", "now", "let", "just", "grab", "calls", "helper", "to", "just", "walk", "for", "calls"], "metadata": {"kind": "class", "chunk_index": "8", "has_docstring": "true", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/javascript_parser.py::JavaScriptParser::9", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/javascript_parser.py::JavaScriptParser", "content": "          # For now, let's just grab calls.\n            \n            # Helper to just walk for calls\n            calls = self._walk_for_calls(body_node, func_id)\n            relationships.extend(calls)\n\n        return entity, relationships\n\n    def _parse_arrow_function(self, node, name_node, file_path, parent_id, source_code, source_lines):\n        name = self._get_text(name_node, None)\n        func_id = f\"{file_path}::{name}\"\n        \n        entity = self._create_entity(\n            node, EntityKind.FUNCTION, name, name, file_path, source_lines\n        )\n        \n        relationships = [\n            Relationship(source_id=parent_id, target_id=func_id, kind=RelationshipKind.CONTAINS)\n        ]\n        \n        body_node = node.child_by_field_name(\"body\")\n        if body_node:\n            calls = self._walk_for_calls(body_node, func_id)\n            relationships.extend(calls)\n            \n        return entity, relationships\n\n    def _walk_for_calls(self, node, source_id):\n        \"\"", "tokens": ["for", "now", "let", "just", "grab", "calls", "helper", "to", "just", "walk", "for", "calls", "calls", "self", "walk", "for", "calls", "body", "node", "func", "id", "relationships", "extend", "calls", "return", "entity", "relationships", "def", "parse", "arrow", "function", "self", "node", "name", "node", "file", "path", "parent", "id", "source", "code", "source", "lines", "name", "self", "get", "text", "name", "node", "none", "func", "id", "file", "path", "name", "entity", "self", "create", "entity", "node", "entity", "kind", "function", "name", "name", "file", "path", "source", "lines", "relationships", "relationship", "source", "id", "parent", "id", "target", "id", "func", "id", "kind", "relationship", "kind", "contains", "body", "node", "node", "child", "by", "field", "name", "body", "if", "body", "node", "calls", "self", "walk", "for", "calls", "body", "node", "func", "id", "relationships", "extend", "calls", "return", "entity", "relationships", "def", "walk", "for", "calls", "self", "node", "source", "id"], "metadata": {"kind": "class", "chunk_index": "9", "has_docstring": "true", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/javascript_parser.py::JavaScriptParser::10", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/javascript_parser.py::JavaScriptParser", "content": "   \n        return entity, relationships\n\n    def _walk_for_calls(self, node, source_id):\n        \"\"\"Recursive walk to find call_expression.\n        \n        Note: We use a cursor walk here which is significantly more performant \n        than recursively creating Node objects for every child in the tree.\n        \"\"\"\n        rels = []\n        cursor = node.walk()\n\n        visited_children = False\n        \n        while True:\n            if cursor.node.type == \"call_expression\":\n                rel = self._extract_call(cursor.node, source_id)\n                if rel:\n                    rels.append(rel)\n            \n            # Traverse\n            if not visited_children and cursor.goto_first_child():\n                visited_children = False\n                continue\n            \n            if cursor.goto_next_sibling():\n                visited_children = False\n                continue\n            \n            if cursor.goto_parent():\n                visited_children = True\n           ", "tokens": ["return", "entity", "relationships", "def", "walk", "for", "calls", "self", "node", "source", "id", "recursive", "walk", "to", "find", "call", "expression", "note", "we", "use", "cursor", "walk", "here", "which", "is", "significantly", "more", "performant", "than", "recursively", "creating", "node", "objects", "for", "every", "child", "in", "the", "tree", "rels", "cursor", "node", "walk", "visited", "children", "false", "while", "true", "if", "cursor", "node", "type", "call", "expression", "rel", "self", "extract", "call", "cursor", "node", "source", "id", "if", "rel", "rels", "append", "rel", "traverse", "if", "not", "visited", "children", "and", "cursor", "goto", "first", "child", "visited", "children", "false", "continue", "if", "cursor", "goto", "next", "sibling", "visited", "children", "false", "continue", "if", "cursor", "goto", "parent", "visited", "children", "true"], "metadata": {"kind": "class", "chunk_index": "10", "has_docstring": "true", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/javascript_parser.py::JavaScriptParser::11", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/javascript_parser.py::JavaScriptParser", "content": "           \n            if cursor.goto_parent():\n                visited_children = True\n                if cursor.node == node: # Back at start\n                    break\n                continue\n            else:\n                break\n                \n        return rels\n\n    def _extract_call(self, node, source_id):\n        # call_expression: function: (identifier) arguments: (arguments)\n        func_node = node.child_by_field_name(\"function\")\n        if not func_node:\n            return None\n        \n        callee_name = self._get_text(func_node, None)\n        # Verify it's not a keyword/syntax\n        if \" \" in callee_name or \"\\n\" in callee_name:\n            # Complex expression call like (a+b)() or require('foo')\n            # Handle require specially?\n             if callee_name == \"require\":\n                 # handle require('module')\n                 args = node.child_by_field_name(\"arguments\")\n                 if args and args.named_child_count > 0:\n                     first", "tokens": ["if", "cursor", "goto", "parent", "visited", "children", "true", "if", "cursor", "node", "node", "back", "at", "start", "break", "continue", "else", "break", "return", "rels", "def", "extract", "call", "self", "node", "source", "id", "call", "expression", "function", "identifier", "arguments", "arguments", "func", "node", "node", "child", "by", "field", "name", "function", "if", "not", "func", "node", "return", "none", "callee", "name", "self", "get", "text", "func", "node", "none", "verify", "it", "not", "keyword", "syntax", "if", "in", "callee", "name", "or", "in", "callee", "name", "complex", "expression", "call", "like", "or", "require", "foo", "handle", "require", "specially", "if", "callee", "name", "require", "handle", "require", "module", "args", "node", "child", "by", "field", "name", "arguments", "if", "args", "and", "args", "named", "child", "count", "first"], "metadata": {"kind": "class", "chunk_index": "11", "has_docstring": "true", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/javascript_parser.py::JavaScriptParser::12", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/javascript_parser.py::JavaScriptParser", "content": "ame(\"arguments\")\n                 if args and args.named_child_count > 0:\n                     first_arg = args.named_child(0)\n                     if first_arg.type == \"string\":\n                         module = self._get_text(first_arg, None).strip(\"'\\\"\")\n                         return Relationship(\n                             source_id=source_id,\n                             target_id=f\"external::{module}\",\n                             kind=RelationshipKind.IMPORTS # Treat as import\n                         )\n             return None\n             \n        return Relationship(\n            source_id=source_id,\n            target_id=f\"ref::{callee_name}\",\n            kind=RelationshipKind.CALLS\n        )", "tokens": ["ame", "arguments", "if", "args", "and", "args", "named", "child", "count", "first", "arg", "args", "named", "child", "if", "first", "arg", "type", "string", "module", "self", "get", "text", "first", "arg", "none", "strip", "return", "relationship", "source", "id", "source", "id", "target", "id", "external", "module", "kind", "relationship", "kind", "imports", "treat", "as", "import", "return", "none", "return", "relationship", "source", "id", "source", "id", "target", "id", "ref", "callee", "name", "kind", "relationship", "kind", "calls"], "metadata": {"kind": "class", "chunk_index": "12", "has_docstring": "true", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/javascript_parser.py::JavaScriptParser.__init__::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/javascript_parser.py::JavaScriptParser.__init__", "content": "def __init__(self) -> None\n\"\"\"Initialize JavaScript parser.\"\"\"\n    def __init__(self) -> None:\n        \"\"\"Initialize JavaScript parser.\"\"\"\n        super().__init__(\"javascript\")", "tokens": ["def", "init", "self", "none", "initialize", "java", "script", "parser", "def", "init", "self", "none", "initialize", "java", "script", "parser", "super", "init", "javascript"], "metadata": {"kind": "method", "has_docstring": "true", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/javascript_parser.py::JavaScriptParser._extract_entities::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/javascript_parser.py::JavaScriptParser._extract_entities", "content": "def _extract_entities(self, node: Any, file_path: Path, parent_id: str, source_code: str, source_lines: list[str]) -> tuple[list[Entity], list[Relationship]]\n\"\"\"Extract entities from JavaScript AST.\"\"\"\n    def _extract_entities(\n        self,\n        node: Any,\n        file_path: Path,\n        parent_id: str,\n        source_code: str,\n        source_lines: list[str],\n    ) -> tuple[list[Entity], list[Relationship]]:\n        \"\"\"Extract entities from JavaScript AST.\"\"\"\n        entities: list[Entity] = []\n        relationships: list[Relationship] = []\n\n\n\n        # Traverse children\n        \n        # We need to iterate over all children. walk() gives a cursor.\n        # Tree-sitter cursors are stateful.\n        # Simplest way is often just to iterate node.children if the tree isn't massive,\n        # or use a recursive visitor pattern.\n        # For this implementation, we will iterate over node.children for the current scope,\n        # and recurse into relevant containers (class body, fu", "tokens": ["def", "extract", "entities", "self", "node", "any", "file", "path", "path", "parent", "id", "str", "source", "code", "str", "source", "lines", "list", "str", "tuple", "list", "entity", "list", "relationship", "extract", "entities", "from", "java", "script", "ast", "def", "extract", "entities", "self", "node", "any", "file", "path", "path", "parent", "id", "str", "source", "code", "str", "source", "lines", "list", "str", "tuple", "list", "entity", "list", "relationship", "extract", "entities", "from", "java", "script", "ast", "entities", "list", "entity", "relationships", "list", "relationship", "traverse", "children", "we", "need", "to", "iterate", "over", "all", "children", "walk", "gives", "cursor", "tree", "sitter", "cursors", "are", "stateful", "simplest", "way", "is", "often", "just", "to", "iterate", "node", "children", "if", "the", "tree", "isn", "massive", "or", "use", "recursive", "visitor", "pattern", "for", "this", "implementation", "we", "will", "iterate", "over", "node", "children", "for", "the", "current", "scope", "and", "recurse", "into", "relevant", "containers", "class", "body", "fu"], "metadata": {"kind": "method", "chunk_index": "0", "has_docstring": "true", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/javascript_parser.py::JavaScriptParser._extract_entities::1", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/javascript_parser.py::JavaScriptParser._extract_entities", "content": " node.children for the current scope,\n        # and recurse into relevant containers (class body, function body).\n        \n        for child in node.children:\n            child_type = child.type\n            \n            if child_type == \"class_declaration\":\n                class_entities, class_rels = self._parse_class(\n                    child, file_path, parent_id, source_code, source_lines\n                )\n                entities.extend(class_entities)\n                relationships.extend(class_rels)\n                \n            elif child_type == \"function_declaration\":\n                func_entity, func_rels = self._parse_function(\n                    child, file_path, parent_id, source_code, source_lines, kind=EntityKind.FUNCTION\n                )\n                entities.append(func_entity)\n                relationships.extend(func_rels)\n                \n            elif child_type == \"variable_declaration\":\n                 # Check for arrow functions assigned to variables: c", "tokens": ["node", "children", "for", "the", "current", "scope", "and", "recurse", "into", "relevant", "containers", "class", "body", "function", "body", "for", "child", "in", "node", "children", "child", "type", "child", "type", "if", "child", "type", "class", "declaration", "class", "entities", "class", "rels", "self", "parse", "class", "child", "file", "path", "parent", "id", "source", "code", "source", "lines", "entities", "extend", "class", "entities", "relationships", "extend", "class", "rels", "elif", "child", "type", "function", "declaration", "func", "entity", "func", "rels", "self", "parse", "function", "child", "file", "path", "parent", "id", "source", "code", "source", "lines", "kind", "entity", "kind", "function", "entities", "append", "func", "entity", "relationships", "extend", "func", "rels", "elif", "child", "type", "variable", "declaration", "check", "for", "arrow", "functions", "assigned", "to", "variables"], "metadata": {"kind": "method", "chunk_index": "1", "has_docstring": "true", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/javascript_parser.py::JavaScriptParser._extract_entities::2", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/javascript_parser.py::JavaScriptParser._extract_entities", "content": "ype == \"variable_declaration\":\n                 # Check for arrow functions assigned to variables: const foo = () => {}\n                 for decl in child.children:\n                     if decl.type == \"variable_declarator\":\n                         # name is first child, value is last child\n                         var_name_node = decl.child_by_field_name(\"name\")\n                         value_node = decl.child_by_field_name(\"value\")\n                         \n                         if value_node and value_node.type == \"arrow_function\":\n                             # Treat as function\n                             func_entity, func_rels = self._parse_arrow_function(\n                                 value_node, var_name_node, file_path, parent_id, source_code, source_lines\n                             )\n                             entities.append(func_entity)\n                             relationships.extend(func_rels)\n\n            elif child_type == \"import_statement\":\n              ", "tokens": ["ype", "variable", "declaration", "check", "for", "arrow", "functions", "assigned", "to", "variables", "const", "foo", "for", "decl", "in", "child", "children", "if", "decl", "type", "variable", "declarator", "name", "is", "first", "child", "value", "is", "last", "child", "var", "name", "node", "decl", "child", "by", "field", "name", "name", "value", "node", "decl", "child", "by", "field", "name", "value", "if", "value", "node", "and", "value", "node", "type", "arrow", "function", "treat", "as", "function", "func", "entity", "func", "rels", "self", "parse", "arrow", "function", "value", "node", "var", "name", "node", "file", "path", "parent", "id", "source", "code", "source", "lines", "entities", "append", "func", "entity", "relationships", "extend", "func", "rels", "elif", "child", "type", "import", "statement"], "metadata": {"kind": "method", "chunk_index": "2", "has_docstring": "true", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/javascript_parser.py::JavaScriptParser._extract_entities::3", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/javascript_parser.py::JavaScriptParser._extract_entities", "content": "  relationships.extend(func_rels)\n\n            elif child_type == \"import_statement\":\n                # import { foo } from 'bar';\n                # Source is usually the string literal at the end\n                source_node = child.child_by_field_name(\"source\")\n                if source_node:\n                    # Remove quotes\n                    module_name = self._get_text(source_node, None).strip(\"'\\\"\")\n                    relationships.append(\n                        Relationship(\n                            source_id=parent_id, # Imports belong to the module scope usually\n                            target_id=f\"external::{module_name}\",\n                            kind=RelationshipKind.IMPORTS\n                        )\n                    )\n            \n            elif child_type == \"call_expression\":\n                 # Extract calls\n                 call_rel = self._extract_call(child, parent_id)\n                 if call_rel:\n                     relationships.append(call_rel)", "tokens": ["relationships", "extend", "func", "rels", "elif", "child", "type", "import", "statement", "import", "foo", "from", "bar", "source", "is", "usually", "the", "string", "literal", "at", "the", "end", "source", "node", "child", "child", "by", "field", "name", "source", "if", "source", "node", "remove", "quotes", "module", "name", "self", "get", "text", "source", "node", "none", "strip", "relationships", "append", "relationship", "source", "id", "parent", "id", "imports", "belong", "to", "the", "module", "scope", "usually", "target", "id", "external", "module", "name", "kind", "relationship", "kind", "imports", "elif", "child", "type", "call", "expression", "extract", "calls", "call", "rel", "self", "extract", "call", "child", "parent", "id", "if", "call", "rel", "relationships", "append", "call", "rel"], "metadata": {"kind": "method", "chunk_index": "3", "has_docstring": "true", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/javascript_parser.py::JavaScriptParser._extract_entities::4", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/javascript_parser.py::JavaScriptParser._extract_entities", "content": "(child, parent_id)\n                 if call_rel:\n                     relationships.append(call_rel)\n\n        return entities, relationships", "tokens": ["child", "parent", "id", "if", "call", "rel", "relationships", "append", "call", "rel", "return", "entities", "relationships"], "metadata": {"kind": "method", "chunk_index": "4", "has_docstring": "true", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/javascript_parser.py::JavaScriptParser._parse_class::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/javascript_parser.py::JavaScriptParser._parse_class", "content": "def _parse_class(self, node: Any, file_path: Path, parent_id: str, source_code: str, source_lines: list[str]) -> tuple[list[Entity], list[Relationship]]\n    def _parse_class(\n        self,\n        node: Any,\n        file_path: Path,\n        parent_id: str,\n        source_code: str,\n        source_lines: list[str],\n    ) -> tuple[list[Entity], list[Relationship]]:\n        entities: list[Entity] = []\n        relationships: list[Relationship] = []\n\n        name_node = node.child_by_field_name(\"name\")\n        if not name_node:\n            return [], [] # Anonymous class\n\n        class_name = self._get_text(name_node, None)\n        qualified_name = class_name # Simplified for now\n        class_id = f\"{file_path}::{qualified_name}\"\n        \n        # Check parent info for inheritance\n        # In tree-sitter-javascript: class_heritage -> extends_clause -> call_expression or identifier\n        # Actually structure is class_declaration -> class_heritage -> extends_clause\n        # Let's check ", "tokens": ["def", "parse", "class", "self", "node", "any", "file", "path", "path", "parent", "id", "str", "source", "code", "str", "source", "lines", "list", "str", "tuple", "list", "entity", "list", "relationship", "def", "parse", "class", "self", "node", "any", "file", "path", "path", "parent", "id", "str", "source", "code", "str", "source", "lines", "list", "str", "tuple", "list", "entity", "list", "relationship", "entities", "list", "entity", "relationships", "list", "relationship", "name", "node", "node", "child", "by", "field", "name", "name", "if", "not", "name", "node", "return", "anonymous", "class", "class", "name", "self", "get", "text", "name", "node", "none", "qualified", "name", "class", "name", "simplified", "for", "now", "class", "id", "file", "path", "qualified", "name", "check", "parent", "info", "for", "inheritance", "in", "tree", "sitter", "javascript", "class", "heritage", "extends", "clause", "call", "expression", "or", "identifier", "actually", "structure", "is", "class", "declaration", "class", "heritage", "extends", "clause", "let", "check"], "metadata": {"kind": "method", "chunk_index": "0", "has_docstring": "false", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/javascript_parser.py::JavaScriptParser._parse_class::1", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/javascript_parser.py::JavaScriptParser._parse_class", "content": "# Actually structure is class_declaration -> class_heritage -> extends_clause\n        # Let's check node children for \"class_heritage\"\n        \n        for child in node.children:\n            if child.type == \"class_heritage\":\n                 # extends Foo\n                 extends_node = child.child_by_field_name(\"super_class\") # or just iterate\n                 if extends_node: # Usually the last child of heritage\n                     base_name = self._get_text(extends_node, None)\n                     relationships.append(\n                        Relationship(\n                            source_id=class_id,\n                            target_id=f\"ref::{base_name}\",\n                            kind=RelationshipKind.INHERITS\n                        )\n                     )\n\n        entity = self._create_entity(\n            node, EntityKind.CLASS, class_name, qualified_name, file_path, source_lines\n        )\n        entities.append(entity)\n        \n        relationships.append(\n        ", "tokens": ["actually", "structure", "is", "class", "declaration", "class", "heritage", "extends", "clause", "let", "check", "node", "children", "for", "class", "heritage", "for", "child", "in", "node", "children", "if", "child", "type", "class", "heritage", "extends", "foo", "extends", "node", "child", "child", "by", "field", "name", "super", "class", "or", "just", "iterate", "if", "extends", "node", "usually", "the", "last", "child", "of", "heritage", "base", "name", "self", "get", "text", "extends", "node", "none", "relationships", "append", "relationship", "source", "id", "class", "id", "target", "id", "ref", "base", "name", "kind", "relationship", "kind", "inherits", "entity", "self", "create", "entity", "node", "entity", "kind", "class", "class", "name", "qualified", "name", "file", "path", "source", "lines", "entities", "append", "entity", "relationships", "append"], "metadata": {"kind": "method", "chunk_index": "1", "has_docstring": "false", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/javascript_parser.py::JavaScriptParser._parse_class::2", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/javascript_parser.py::JavaScriptParser._parse_class", "content": "urce_lines\n        )\n        entities.append(entity)\n        \n        relationships.append(\n            Relationship(source_id=parent_id, target_id=class_id, kind=RelationshipKind.CONTAINS)\n        )\n\n        body_node = node.child_by_field_name(\"body\")\n        if body_node:\n            # Parse methods\n            for child in body_node.children:\n                if child.type == \"method_definition\":\n                    method_entity, method_rels = self._parse_function(\n                        child, file_path, class_id, source_code, source_lines, kind=EntityKind.METHOD, parent_name=class_name\n                    )\n                    entities.append(method_entity)\n                    relationships.extend(method_rels)\n\n        return entities, relationships", "tokens": ["urce", "lines", "entities", "append", "entity", "relationships", "append", "relationship", "source", "id", "parent", "id", "target", "id", "class", "id", "kind", "relationship", "kind", "contains", "body", "node", "node", "child", "by", "field", "name", "body", "if", "body", "node", "parse", "methods", "for", "child", "in", "body", "node", "children", "if", "child", "type", "method", "definition", "method", "entity", "method", "rels", "self", "parse", "function", "child", "file", "path", "class", "id", "source", "code", "source", "lines", "kind", "entity", "kind", "method", "parent", "name", "class", "name", "entities", "append", "method", "entity", "relationships", "extend", "method", "rels", "return", "entities", "relationships"], "metadata": {"kind": "method", "chunk_index": "2", "has_docstring": "false", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/javascript_parser.py::JavaScriptParser._parse_function::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/javascript_parser.py::JavaScriptParser._parse_function", "content": "def _parse_function(self, node: Any, file_path: Path, parent_id: str, source_code: str, source_lines: list[str], kind: EntityKind, parent_name: str) -> tuple[Entity, list[Relationship]]\n    def _parse_function(\n        self,\n        node: Any,\n        file_path: Path,\n        parent_id: str,\n        source_code: str,\n        source_lines: list[str],\n        kind: EntityKind,\n        parent_name: str = \"\"\n    ) -> tuple[Entity, list[Relationship]]:\n        name_node = node.child_by_field_name(\"name\")\n        if not name_node:\n            # Check if it is a constructor\n            if kind == EntityKind.METHOD:\n                 name_node = node.child_by_field_name(\"name\") # method_definition has name\n                 if not name_node and self._get_text(node, None).startswith(\"constructor\"):\n                     name = \"constructor\"\n                 else:\n                     name = self._get_text(name_node, None) if name_node else \"anonymous\"\n            else:\n                return Excep", "tokens": ["def", "parse", "function", "self", "node", "any", "file", "path", "path", "parent", "id", "str", "source", "code", "str", "source", "lines", "list", "str", "kind", "entity", "kind", "parent", "name", "str", "tuple", "entity", "list", "relationship", "def", "parse", "function", "self", "node", "any", "file", "path", "path", "parent", "id", "str", "source", "code", "str", "source", "lines", "list", "str", "kind", "entity", "kind", "parent", "name", "str", "tuple", "entity", "list", "relationship", "name", "node", "node", "child", "by", "field", "name", "name", "if", "not", "name", "node", "check", "if", "it", "is", "constructor", "if", "kind", "entity", "kind", "method", "name", "node", "node", "child", "by", "field", "name", "name", "method", "definition", "has", "name", "if", "not", "name", "node", "and", "self", "get", "text", "node", "none", "startswith", "constructor", "name", "constructor", "else", "name", "self", "get", "text", "name", "node", "none", "if", "name", "node", "else", "anonymous", "else", "return", "excep"], "metadata": {"kind": "method", "chunk_index": "0", "has_docstring": "false", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/javascript_parser.py::JavaScriptParser._parse_function::1", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/javascript_parser.py::JavaScriptParser._parse_function", "content": "t_text(name_node, None) if name_node else \"anonymous\"\n            else:\n                return Exception(\"Anonymous function not fully supported yet\"), [] \n                \n        name = self._get_text(name_node, None) if name_node else \"constructor\"\n        \n        if parent_name:\n            qualified_name = f\"{parent_name}.{name}\"\n        else:\n            qualified_name = name\n            \n        func_id = f\"{file_path}::{qualified_name}\"\n        \n        entity = self._create_entity(\n            node, kind, name, qualified_name, file_path, source_lines\n        )\n        \n        relationships = [\n            Relationship(source_id=parent_id, target_id=func_id, kind=RelationshipKind.CONTAINS)\n        ]\n        \n        # Extract calls from body\n        body_node = node.child_by_field_name(\"body\")\n        if body_node:\n            child_entities, child_rels = self._extract_entities(body_node, file_path, func_id, source_code, source_lines)\n            # We ignore child entities de", "tokens": ["text", "name", "node", "none", "if", "name", "node", "else", "anonymous", "else", "return", "exception", "anonymous", "function", "not", "fully", "supported", "yet", "name", "self", "get", "text", "name", "node", "none", "if", "name", "node", "else", "constructor", "if", "parent", "name", "qualified", "name", "parent", "name", "name", "else", "qualified", "name", "name", "func", "id", "file", "path", "qualified", "name", "entity", "self", "create", "entity", "node", "kind", "name", "qualified", "name", "file", "path", "source", "lines", "relationships", "relationship", "source", "id", "parent", "id", "target", "id", "func", "id", "kind", "relationship", "kind", "contains", "extract", "calls", "from", "body", "body", "node", "node", "child", "by", "field", "name", "body", "if", "body", "node", "child", "entities", "child", "rels", "self", "extract", "entities", "body", "node", "file", "path", "func", "id", "source", "code", "source", "lines", "we", "ignore", "child", "entities", "de"], "metadata": {"kind": "method", "chunk_index": "1", "has_docstring": "false", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/javascript_parser.py::JavaScriptParser._parse_function::2", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/javascript_parser.py::JavaScriptParser._parse_function", "content": "(body_node, file_path, func_id, source_code, source_lines)\n            # We ignore child entities declared INSIDE functions for now (local vars/funcs), \n            # but we want the calls from child_rels\n            # Actually, _extract_entities returns variable_declarations too.\n            # For now, let's just grab calls.\n            \n            # Helper to just walk for calls\n            calls = self._walk_for_calls(body_node, func_id)\n            relationships.extend(calls)\n\n        return entity, relationships", "tokens": ["body", "node", "file", "path", "func", "id", "source", "code", "source", "lines", "we", "ignore", "child", "entities", "declared", "inside", "functions", "for", "now", "local", "vars", "funcs", "but", "we", "want", "the", "calls", "from", "child", "rels", "actually", "extract", "entities", "returns", "variable", "declarations", "too", "for", "now", "let", "just", "grab", "calls", "helper", "to", "just", "walk", "for", "calls", "calls", "self", "walk", "for", "calls", "body", "node", "func", "id", "relationships", "extend", "calls", "return", "entity", "relationships"], "metadata": {"kind": "method", "chunk_index": "2", "has_docstring": "false", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/javascript_parser.py::JavaScriptParser._parse_arrow_function::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/javascript_parser.py::JavaScriptParser._parse_arrow_function", "content": "def _parse_arrow_function(self, node, name_node, file_path, parent_id, source_code, source_lines)\n    def _parse_arrow_function(self, node, name_node, file_path, parent_id, source_code, source_lines):\n        name = self._get_text(name_node, None)\n        func_id = f\"{file_path}::{name}\"\n        \n        entity = self._create_entity(\n            node, EntityKind.FUNCTION, name, name, file_path, source_lines\n        )\n        \n        relationships = [\n            Relationship(source_id=parent_id, target_id=func_id, kind=RelationshipKind.CONTAINS)\n        ]\n        \n        body_node = node.child_by_field_name(\"body\")\n        if body_node:\n            calls = self._walk_for_calls(body_node, func_id)\n            relationships.extend(calls)\n            \n        return entity, relationships", "tokens": ["def", "parse", "arrow", "function", "self", "node", "name", "node", "file", "path", "parent", "id", "source", "code", "source", "lines", "def", "parse", "arrow", "function", "self", "node", "name", "node", "file", "path", "parent", "id", "source", "code", "source", "lines", "name", "self", "get", "text", "name", "node", "none", "func", "id", "file", "path", "name", "entity", "self", "create", "entity", "node", "entity", "kind", "function", "name", "name", "file", "path", "source", "lines", "relationships", "relationship", "source", "id", "parent", "id", "target", "id", "func", "id", "kind", "relationship", "kind", "contains", "body", "node", "node", "child", "by", "field", "name", "body", "if", "body", "node", "calls", "self", "walk", "for", "calls", "body", "node", "func", "id", "relationships", "extend", "calls", "return", "entity", "relationships"], "metadata": {"kind": "method", "has_docstring": "false", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/javascript_parser.py::JavaScriptParser._walk_for_calls::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/javascript_parser.py::JavaScriptParser._walk_for_calls", "content": "def _walk_for_calls(self, node, source_id)\n\"\"\"Recursive walk to find call_expression.\n\nNote: We use a cursor walk here which is significantly more performant \nthan recursively creating Node objects for every child in the tree.\"\"\"\n    def _walk_for_calls(self, node, source_id):\n        \"\"\"Recursive walk to find call_expression.\n        \n        Note: We use a cursor walk here which is significantly more performant \n        than recursively creating Node objects for every child in the tree.\n        \"\"\"\n        rels = []\n        cursor = node.walk()\n\n        visited_children = False\n        \n        while True:\n            if cursor.node.type == \"call_expression\":\n                rel = self._extract_call(cursor.node, source_id)\n                if rel:\n                    rels.append(rel)\n            \n            # Traverse\n            if not visited_children and cursor.goto_first_child():\n                visited_children = False\n                continue\n            \n            if cursor.", "tokens": ["def", "walk", "for", "calls", "self", "node", "source", "id", "recursive", "walk", "to", "find", "call", "expression", "note", "we", "use", "cursor", "walk", "here", "which", "is", "significantly", "more", "performant", "than", "recursively", "creating", "node", "objects", "for", "every", "child", "in", "the", "tree", "def", "walk", "for", "calls", "self", "node", "source", "id", "recursive", "walk", "to", "find", "call", "expression", "note", "we", "use", "cursor", "walk", "here", "which", "is", "significantly", "more", "performant", "than", "recursively", "creating", "node", "objects", "for", "every", "child", "in", "the", "tree", "rels", "cursor", "node", "walk", "visited", "children", "false", "while", "true", "if", "cursor", "node", "type", "call", "expression", "rel", "self", "extract", "call", "cursor", "node", "source", "id", "if", "rel", "rels", "append", "rel", "traverse", "if", "not", "visited", "children", "and", "cursor", "goto", "first", "child", "visited", "children", "false", "continue", "if", "cursor"], "metadata": {"kind": "method", "chunk_index": "0", "has_docstring": "true", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/javascript_parser.py::JavaScriptParser._walk_for_calls::1", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/javascript_parser.py::JavaScriptParser._walk_for_calls", "content": "               visited_children = False\n                continue\n            \n            if cursor.goto_next_sibling():\n                visited_children = False\n                continue\n            \n            if cursor.goto_parent():\n                visited_children = True\n                if cursor.node == node: # Back at start\n                    break\n                continue\n            else:\n                break\n                \n        return rels", "tokens": ["visited", "children", "false", "continue", "if", "cursor", "goto", "next", "sibling", "visited", "children", "false", "continue", "if", "cursor", "goto", "parent", "visited", "children", "true", "if", "cursor", "node", "node", "back", "at", "start", "break", "continue", "else", "break", "return", "rels"], "metadata": {"kind": "method", "chunk_index": "1", "has_docstring": "true", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/javascript_parser.py::JavaScriptParser._extract_call::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/javascript_parser.py::JavaScriptParser._extract_call", "content": "def _extract_call(self, node, source_id)\n    def _extract_call(self, node, source_id):\n        # call_expression: function: (identifier) arguments: (arguments)\n        func_node = node.child_by_field_name(\"function\")\n        if not func_node:\n            return None\n        \n        callee_name = self._get_text(func_node, None)\n        # Verify it's not a keyword/syntax\n        if \" \" in callee_name or \"\\n\" in callee_name:\n            # Complex expression call like (a+b)() or require('foo')\n            # Handle require specially?\n             if callee_name == \"require\":\n                 # handle require('module')\n                 args = node.child_by_field_name(\"arguments\")\n                 if args and args.named_child_count > 0:\n                     first_arg = args.named_child(0)\n                     if first_arg.type == \"string\":\n                         module = self._get_text(first_arg, None).strip(\"'\\\"\")\n                         return Relationship(\n                             ", "tokens": ["def", "extract", "call", "self", "node", "source", "id", "def", "extract", "call", "self", "node", "source", "id", "call", "expression", "function", "identifier", "arguments", "arguments", "func", "node", "node", "child", "by", "field", "name", "function", "if", "not", "func", "node", "return", "none", "callee", "name", "self", "get", "text", "func", "node", "none", "verify", "it", "not", "keyword", "syntax", "if", "in", "callee", "name", "or", "in", "callee", "name", "complex", "expression", "call", "like", "or", "require", "foo", "handle", "require", "specially", "if", "callee", "name", "require", "handle", "require", "module", "args", "node", "child", "by", "field", "name", "arguments", "if", "args", "and", "args", "named", "child", "count", "first", "arg", "args", "named", "child", "if", "first", "arg", "type", "string", "module", "self", "get", "text", "first", "arg", "none", "strip", "return", "relationship"], "metadata": {"kind": "method", "chunk_index": "0", "has_docstring": "false", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/javascript_parser.py::JavaScriptParser._extract_call::1", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/javascript_parser.py::JavaScriptParser._extract_call", "content": "_arg, None).strip(\"'\\\"\")\n                         return Relationship(\n                             source_id=source_id,\n                             target_id=f\"external::{module}\",\n                             kind=RelationshipKind.IMPORTS # Treat as import\n                         )\n             return None\n             \n        return Relationship(\n            source_id=source_id,\n            target_id=f\"ref::{callee_name}\",\n            kind=RelationshipKind.CALLS\n        )", "tokens": ["arg", "none", "strip", "return", "relationship", "source", "id", "source", "id", "target", "id", "external", "module", "kind", "relationship", "kind", "imports", "treat", "as", "import", "return", "none", "return", "relationship", "source", "id", "source", "id", "target", "id", "ref", "callee", "name", "kind", "relationship", "kind", "calls"], "metadata": {"kind": "method", "chunk_index": "1", "has_docstring": "false", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/python_parser.py::module::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/python_parser.py::module", "content": "\"\"\"Python parser using standard ast module.\"\"\"", "tokens": ["python", "parser", "using", "standard", "ast", "module"], "metadata": {"type": "module_header"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/python_parser.py::imports::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/python_parser.py::module", "content": "from __future__ import annotations\nimport ast\nfrom pathlib import Path\nfrom typing import Optional\nfrom knowcode.data_models import (", "tokens": ["from", "future", "import", "annotations", "import", "ast", "from", "pathlib", "import", "path", "from", "typing", "import", "optional", "from", "knowcode", "data", "models", "import"], "metadata": {"type": "imports"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/python_parser.py::PythonParser::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/python_parser.py::PythonParser", "content": "\"\"\"Parses Python source files into entities and relationships.\"\"\"\nclass PythonParser:\n    \"\"\"Parses Python source files into entities and relationships.\"\"\"\n\n    def parse_file(self, file_path: str | Path) -> ParseResult:\n        \"\"\"Parse a Python file.\n\n        Args:\n            file_path: Path to the Python file.\n\n        Returns:\n            ParseResult with entities and relationships.\n        \"\"\"\n        file_path = Path(file_path)\n        errors: list[str] = []\n\n        try:\n            source_code = file_path.read_text(encoding=\"utf-8\")\n        except Exception as e:\n            return ParseResult(\n                file_path=str(file_path),\n                entities=[],\n                relationships=[],\n                errors=[f\"Failed to read file: {e}\"],\n            )\n\n        try:\n            tree = ast.parse(source_code, filename=str(file_path))\n        except SyntaxError as e:\n            return ParseResult(\n                file_path=str(file_path),\n                entities=[],", "tokens": ["parses", "python", "source", "files", "into", "entities", "and", "relationships", "class", "python", "parser", "parses", "python", "source", "files", "into", "entities", "and", "relationships", "def", "parse", "file", "self", "file", "path", "str", "path", "parse", "result", "parse", "python", "file", "args", "file", "path", "path", "to", "the", "python", "file", "returns", "parse", "result", "with", "entities", "and", "relationships", "file", "path", "path", "file", "path", "errors", "list", "str", "try", "source", "code", "file", "path", "read", "text", "encoding", "utf", "except", "exception", "as", "return", "parse", "result", "file", "path", "str", "file", "path", "entities", "relationships", "errors", "failed", "to", "read", "file", "try", "tree", "ast", "parse", "source", "code", "filename", "str", "file", "path", "except", "syntax", "error", "as", "return", "parse", "result", "file", "path", "str", "file", "path", "entities"], "metadata": {"kind": "class", "chunk_index": "0", "has_docstring": "true", "last_modified": "1768185812.9936173"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/python_parser.py::PythonParser::1", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/python_parser.py::PythonParser", "content": "          return ParseResult(\n                file_path=str(file_path),\n                entities=[],\n                relationships=[],\n                errors=[f\"Syntax error: {e}\"],\n            )\n\n        entities: list[Entity] = []\n        relationships: list[Relationship] = []\n        source_lines = source_code.splitlines()\n\n        # Create module entity\n        module_name = file_path.stem\n        module_id = f\"{file_path}::{module_name}\"\n        module_entity = Entity(\n            id=module_id,\n            kind=EntityKind.MODULE,\n            name=module_name,\n            qualified_name=module_name,\n            location=Location(\n                file_path=str(file_path),\n                line_start=1,\n                line_end=len(source_lines),\n            ),\n            docstring=ast.get_docstring(tree),\n        )\n        entities.append(module_entity)\n\n        # Extract imports\n        for node in ast.walk(tree):\n            if isinstance(node, ast.Import):\n                for ali", "tokens": ["return", "parse", "result", "file", "path", "str", "file", "path", "entities", "relationships", "errors", "syntax", "error", "entities", "list", "entity", "relationships", "list", "relationship", "source", "lines", "source", "code", "splitlines", "create", "module", "entity", "module", "name", "file", "path", "stem", "module", "id", "file", "path", "module", "name", "module", "entity", "entity", "id", "module", "id", "kind", "entity", "kind", "module", "name", "module", "name", "qualified", "name", "module", "name", "location", "location", "file", "path", "str", "file", "path", "line", "start", "line", "end", "len", "source", "lines", "docstring", "ast", "get", "docstring", "tree", "entities", "append", "module", "entity", "extract", "imports", "for", "node", "in", "ast", "walk", "tree", "if", "isinstance", "node", "ast", "import", "for", "ali"], "metadata": {"kind": "class", "chunk_index": "1", "has_docstring": "true", "last_modified": "1768185812.9936173"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/python_parser.py::PythonParser::2", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/python_parser.py::PythonParser", "content": "    for node in ast.walk(tree):\n            if isinstance(node, ast.Import):\n                for alias in node.names:\n                    relationships.append(\n                        Relationship(\n                            source_id=module_id,\n                            target_id=f\"external::{alias.name}\",\n                            kind=RelationshipKind.IMPORTS,\n                        )\n                    )\n            elif isinstance(node, ast.ImportFrom):\n                if node.module:\n                    relationships.append(\n                        Relationship(\n                            source_id=module_id,\n                            target_id=f\"external::{node.module}\",\n                            kind=RelationshipKind.IMPORTS,\n                        )\n                    )\n\n        # Process top-level definitions\n        for node in ast.iter_child_nodes(tree):\n            if isinstance(node, ast.ClassDef):\n                class_entities, class_rels = self._parse_cla", "tokens": ["for", "node", "in", "ast", "walk", "tree", "if", "isinstance", "node", "ast", "import", "for", "alias", "in", "node", "names", "relationships", "append", "relationship", "source", "id", "module", "id", "target", "id", "external", "alias", "name", "kind", "relationship", "kind", "imports", "elif", "isinstance", "node", "ast", "import", "from", "if", "node", "module", "relationships", "append", "relationship", "source", "id", "module", "id", "target", "id", "external", "node", "module", "kind", "relationship", "kind", "imports", "process", "top", "level", "definitions", "for", "node", "in", "ast", "iter", "child", "nodes", "tree", "if", "isinstance", "node", "ast", "class", "def", "class", "entities", "class", "rels", "self", "parse", "cla"], "metadata": {"kind": "class", "chunk_index": "2", "has_docstring": "true", "last_modified": "1768185812.9936173"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/python_parser.py::PythonParser::3", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/python_parser.py::PythonParser", "content": "     if isinstance(node, ast.ClassDef):\n                class_entities, class_rels = self._parse_class(\n                    node, file_path, module_id, source_lines\n                )\n                entities.extend(class_entities)\n                relationships.extend(class_rels)\n\n            elif isinstance(node, (ast.FunctionDef, ast.AsyncFunctionDef)):\n                func_entity, func_rels = self._parse_function(\n                    node, file_path, module_id, source_lines\n                )\n                entities.append(func_entity)\n                relationships.extend(func_rels)\n\n        return ParseResult(\n            file_path=str(file_path),\n            entities=entities,\n            relationships=relationships,\n            errors=errors,\n        )\n\n    def _parse_class(\n        self,\n        node: ast.ClassDef,\n        file_path: Path,\n        parent_id: str,\n        source_lines: list[str],\n    ) -> tuple[list[Entity], list[Relationship]]:\n        \"\"\"Parse a class definition", "tokens": ["if", "isinstance", "node", "ast", "class", "def", "class", "entities", "class", "rels", "self", "parse", "class", "node", "file", "path", "module", "id", "source", "lines", "entities", "extend", "class", "entities", "relationships", "extend", "class", "rels", "elif", "isinstance", "node", "ast", "function", "def", "ast", "async", "function", "def", "func", "entity", "func", "rels", "self", "parse", "function", "node", "file", "path", "module", "id", "source", "lines", "entities", "append", "func", "entity", "relationships", "extend", "func", "rels", "return", "parse", "result", "file", "path", "str", "file", "path", "entities", "entities", "relationships", "relationships", "errors", "errors", "def", "parse", "class", "self", "node", "ast", "class", "def", "file", "path", "path", "parent", "id", "str", "source", "lines", "list", "str", "tuple", "list", "entity", "list", "relationship", "parse", "class", "definition"], "metadata": {"kind": "class", "chunk_index": "3", "has_docstring": "true", "last_modified": "1768185812.9936173"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/python_parser.py::PythonParser::4", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/python_parser.py::PythonParser", "content": "es: list[str],\n    ) -> tuple[list[Entity], list[Relationship]]:\n        \"\"\"Parse a class definition.\"\"\"\n        entities: list[Entity] = []\n        relationships: list[Relationship] = []\n\n        class_id = f\"{file_path}::{node.name}\"\n\n        # Get source code for the class\n        source_code = self._get_source(node, source_lines)\n\n        class_entity = Entity(\n            id=class_id,\n            kind=EntityKind.CLASS,\n            name=node.name,\n            qualified_name=node.name,\n            location=Location(\n                file_path=str(file_path),\n                line_start=node.lineno,\n                line_end=node.end_lineno or node.lineno,\n                column_start=node.col_offset,\n                column_end=node.end_col_offset or 0,\n            ),\n            docstring=ast.get_docstring(node),\n            source_code=source_code,\n        )\n        entities.append(class_entity)\n\n        # Add contains relationship\n        relationships.append(\n            Relationshi", "tokens": ["es", "list", "str", "tuple", "list", "entity", "list", "relationship", "parse", "class", "definition", "entities", "list", "entity", "relationships", "list", "relationship", "class", "id", "file", "path", "node", "name", "get", "source", "code", "for", "the", "class", "source", "code", "self", "get", "source", "node", "source", "lines", "class", "entity", "entity", "id", "class", "id", "kind", "entity", "kind", "class", "name", "node", "name", "qualified", "name", "node", "name", "location", "location", "file", "path", "str", "file", "path", "line", "start", "node", "lineno", "line", "end", "node", "end", "lineno", "or", "node", "lineno", "column", "start", "node", "col", "offset", "column", "end", "node", "end", "col", "offset", "or", "docstring", "ast", "get", "docstring", "node", "source", "code", "source", "code", "entities", "append", "class", "entity", "add", "contains", "relationship", "relationships", "append", "relationshi"], "metadata": {"kind": "class", "chunk_index": "4", "has_docstring": "true", "last_modified": "1768185812.9936173"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/python_parser.py::PythonParser::5", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/python_parser.py::PythonParser", "content": "s_entity)\n\n        # Add contains relationship\n        relationships.append(\n            Relationship(\n                source_id=parent_id,\n                target_id=class_id,\n                kind=RelationshipKind.CONTAINS,\n            )\n        )\n\n        # Add inheritance relationships\n        for base in node.bases:\n            base_name = self._get_name(base)\n            if base_name:\n                relationships.append(\n                    Relationship(\n                        source_id=class_id,\n                        target_id=f\"ref::{base_name}\",\n                        kind=RelationshipKind.INHERITS,\n                    )\n                )\n\n        # Parse methods\n        for child in node.body:\n            if isinstance(child, (ast.FunctionDef, ast.AsyncFunctionDef)):\n                method_entity, method_rels = self._parse_method(\n                    child, file_path, class_id, node.name, source_lines\n                )\n                entities.append(method_entity)\n       ", "tokens": ["entity", "add", "contains", "relationship", "relationships", "append", "relationship", "source", "id", "parent", "id", "target", "id", "class", "id", "kind", "relationship", "kind", "contains", "add", "inheritance", "relationships", "for", "base", "in", "node", "bases", "base", "name", "self", "get", "name", "base", "if", "base", "name", "relationships", "append", "relationship", "source", "id", "class", "id", "target", "id", "ref", "base", "name", "kind", "relationship", "kind", "inherits", "parse", "methods", "for", "child", "in", "node", "body", "if", "isinstance", "child", "ast", "function", "def", "ast", "async", "function", "def", "method", "entity", "method", "rels", "self", "parse", "method", "child", "file", "path", "class", "id", "node", "name", "source", "lines", "entities", "append", "method", "entity"], "metadata": {"kind": "class", "chunk_index": "5", "has_docstring": "true", "last_modified": "1768185812.9936173"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/python_parser.py::PythonParser::6", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/python_parser.py::PythonParser", "content": "id, node.name, source_lines\n                )\n                entities.append(method_entity)\n                relationships.extend(method_rels)\n\n        return entities, relationships\n\n    def _parse_function(\n        self,\n        node: ast.FunctionDef | ast.AsyncFunctionDef,\n        file_path: Path,\n        parent_id: str,\n        source_lines: list[str],\n    ) -> tuple[Entity, list[Relationship]]:\n        \"\"\"Parse a function definition.\"\"\"\n        relationships: list[Relationship] = []\n\n        func_id = f\"{file_path}::{node.name}\"\n        source_code = self._get_source(node, source_lines)\n        signature = self._get_signature(node)\n\n        entity = Entity(\n            id=func_id,\n            kind=EntityKind.FUNCTION,\n            name=node.name,\n            qualified_name=node.name,\n            location=Location(\n                file_path=str(file_path),\n                line_start=node.lineno,\n                line_end=node.end_lineno or node.lineno,\n                column_start=no", "tokens": ["id", "node", "name", "source", "lines", "entities", "append", "method", "entity", "relationships", "extend", "method", "rels", "return", "entities", "relationships", "def", "parse", "function", "self", "node", "ast", "function", "def", "ast", "async", "function", "def", "file", "path", "path", "parent", "id", "str", "source", "lines", "list", "str", "tuple", "entity", "list", "relationship", "parse", "function", "definition", "relationships", "list", "relationship", "func", "id", "file", "path", "node", "name", "source", "code", "self", "get", "source", "node", "source", "lines", "signature", "self", "get", "signature", "node", "entity", "entity", "id", "func", "id", "kind", "entity", "kind", "function", "name", "node", "name", "qualified", "name", "node", "name", "location", "location", "file", "path", "str", "file", "path", "line", "start", "node", "lineno", "line", "end", "node", "end", "lineno", "or", "node", "lineno", "column", "start", "no"], "metadata": {"kind": "class", "chunk_index": "6", "has_docstring": "true", "last_modified": "1768185812.9936173"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/python_parser.py::PythonParser::7", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/python_parser.py::PythonParser", "content": "ode.lineno,\n                line_end=node.end_lineno or node.lineno,\n                column_start=node.col_offset,\n                column_end=node.end_col_offset or 0,\n            ),\n            docstring=ast.get_docstring(node),\n            signature=signature,\n            source_code=source_code,\n        )\n\n        # Add contains relationship\n        relationships.append(\n            Relationship(\n                source_id=parent_id,\n                target_id=func_id,\n                kind=RelationshipKind.CONTAINS,\n            )\n        )\n\n        # Find calls within the function\n        call_rels = self._extract_calls(node, func_id)\n        relationships.extend(call_rels)\n\n        return entity, relationships\n\n    def _parse_method(\n        self,\n        node: ast.FunctionDef | ast.AsyncFunctionDef,\n        file_path: Path,\n        class_id: str,\n        class_name: str,\n        source_lines: list[str],\n    ) -> tuple[Entity, list[Relationship]]:\n        \"\"\"Parse a method definition", "tokens": ["ode", "lineno", "line", "end", "node", "end", "lineno", "or", "node", "lineno", "column", "start", "node", "col", "offset", "column", "end", "node", "end", "col", "offset", "or", "docstring", "ast", "get", "docstring", "node", "signature", "signature", "source", "code", "source", "code", "add", "contains", "relationship", "relationships", "append", "relationship", "source", "id", "parent", "id", "target", "id", "func", "id", "kind", "relationship", "kind", "contains", "find", "calls", "within", "the", "function", "call", "rels", "self", "extract", "calls", "node", "func", "id", "relationships", "extend", "call", "rels", "return", "entity", "relationships", "def", "parse", "method", "self", "node", "ast", "function", "def", "ast", "async", "function", "def", "file", "path", "path", "class", "id", "str", "class", "name", "str", "source", "lines", "list", "str", "tuple", "entity", "list", "relationship", "parse", "method", "definition"], "metadata": {"kind": "class", "chunk_index": "7", "has_docstring": "true", "last_modified": "1768185812.9936173"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/python_parser.py::PythonParser::8", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/python_parser.py::PythonParser", "content": "e_lines: list[str],\n    ) -> tuple[Entity, list[Relationship]]:\n        \"\"\"Parse a method definition.\"\"\"\n        relationships: list[Relationship] = []\n\n        method_id = f\"{file_path}::{class_name}.{node.name}\"\n        source_code = self._get_source(node, source_lines)\n        signature = self._get_signature(node)\n\n        entity = Entity(\n            id=method_id,\n            kind=EntityKind.METHOD,\n            name=node.name,\n            qualified_name=f\"{class_name}.{node.name}\",\n            location=Location(\n                file_path=str(file_path),\n                line_start=node.lineno,\n                line_end=node.end_lineno or node.lineno,\n                column_start=node.col_offset,\n                column_end=node.end_col_offset or 0,\n            ),\n            docstring=ast.get_docstring(node),\n            signature=signature,\n            source_code=source_code,\n        )\n\n        # Add contains relationship\n        relationships.append(\n            Relationship(\n     ", "tokens": ["lines", "list", "str", "tuple", "entity", "list", "relationship", "parse", "method", "definition", "relationships", "list", "relationship", "method", "id", "file", "path", "class", "name", "node", "name", "source", "code", "self", "get", "source", "node", "source", "lines", "signature", "self", "get", "signature", "node", "entity", "entity", "id", "method", "id", "kind", "entity", "kind", "method", "name", "node", "name", "qualified", "name", "class", "name", "node", "name", "location", "location", "file", "path", "str", "file", "path", "line", "start", "node", "lineno", "line", "end", "node", "end", "lineno", "or", "node", "lineno", "column", "start", "node", "col", "offset", "column", "end", "node", "end", "col", "offset", "or", "docstring", "ast", "get", "docstring", "node", "signature", "signature", "source", "code", "source", "code", "add", "contains", "relationship", "relationships", "append", "relationship"], "metadata": {"kind": "class", "chunk_index": "8", "has_docstring": "true", "last_modified": "1768185812.9936173"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/python_parser.py::PythonParser::9", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/python_parser.py::PythonParser", "content": ")\n\n        # Add contains relationship\n        relationships.append(\n            Relationship(\n                source_id=class_id,\n                target_id=method_id,\n                kind=RelationshipKind.CONTAINS,\n            )\n        )\n\n        # Find calls within the method\n        call_rels = self._extract_calls(node, method_id)\n        relationships.extend(call_rels)\n\n        return entity, relationships\n\n    def _extract_calls(\n        self,\n        node: ast.AST,\n        caller_id: str,\n    ) -> list[Relationship]:\n        \"\"\"Extract function/method calls from a node.\"\"\"\n        relationships: list[Relationship] = []\n\n        for child in ast.walk(node):\n            if isinstance(child, ast.Call):\n                callee_name = self._get_call_name(child)\n                if callee_name:\n                    relationships.append(\n                        Relationship(\n                            source_id=caller_id,\n                            target_id=f\"ref::{callee_name}\",\n     ", "tokens": ["add", "contains", "relationship", "relationships", "append", "relationship", "source", "id", "class", "id", "target", "id", "method", "id", "kind", "relationship", "kind", "contains", "find", "calls", "within", "the", "method", "call", "rels", "self", "extract", "calls", "node", "method", "id", "relationships", "extend", "call", "rels", "return", "entity", "relationships", "def", "extract", "calls", "self", "node", "ast", "ast", "caller", "id", "str", "list", "relationship", "extract", "function", "method", "calls", "from", "node", "relationships", "list", "relationship", "for", "child", "in", "ast", "walk", "node", "if", "isinstance", "child", "ast", "call", "callee", "name", "self", "get", "call", "name", "child", "if", "callee", "name", "relationships", "append", "relationship", "source", "id", "caller", "id", "target", "id", "ref", "callee", "name"], "metadata": {"kind": "class", "chunk_index": "9", "has_docstring": "true", "last_modified": "1768185812.9936173"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/python_parser.py::PythonParser::10", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/python_parser.py::PythonParser", "content": "             source_id=caller_id,\n                            target_id=f\"ref::{callee_name}\",\n                            kind=RelationshipKind.CALLS,\n                        )\n                    )\n\n        return relationships\n\n    def _get_call_name(self, node: ast.Call) -> Optional[str]:\n        \"\"\"Get the name of a called function.\"\"\"\n        if isinstance(node.func, ast.Name):\n            return node.func.id\n        elif isinstance(node.func, ast.Attribute):\n            value_name = self._get_name(node.func.value)\n            if value_name:\n                return f\"{value_name}.{node.func.attr}\"\n            return node.func.attr\n        return None\n\n    def _get_name(self, node: ast.expr) -> Optional[str]:\n        \"\"\"Get name from an expression node.\"\"\"\n        if isinstance(node, ast.Name):\n            return node.id\n        elif isinstance(node, ast.Attribute):\n            value = self._get_name(node.value)\n            if value:\n                return f\"{value}.{node.attr}\"\n  ", "tokens": ["source", "id", "caller", "id", "target", "id", "ref", "callee", "name", "kind", "relationship", "kind", "calls", "return", "relationships", "def", "get", "call", "name", "self", "node", "ast", "call", "optional", "str", "get", "the", "name", "of", "called", "function", "if", "isinstance", "node", "func", "ast", "name", "return", "node", "func", "id", "elif", "isinstance", "node", "func", "ast", "attribute", "value", "name", "self", "get", "name", "node", "func", "value", "if", "value", "name", "return", "value", "name", "node", "func", "attr", "return", "node", "func", "attr", "return", "none", "def", "get", "name", "self", "node", "ast", "expr", "optional", "str", "get", "name", "from", "an", "expression", "node", "if", "isinstance", "node", "ast", "name", "return", "node", "id", "elif", "isinstance", "node", "ast", "attribute", "value", "self", "get", "name", "node", "value", "if", "value", "return", "value", "node", "attr"], "metadata": {"kind": "class", "chunk_index": "10", "has_docstring": "true", "last_modified": "1768185812.9936173"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/python_parser.py::PythonParser::11", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/python_parser.py::PythonParser", "content": " = self._get_name(node.value)\n            if value:\n                return f\"{value}.{node.attr}\"\n            return node.attr\n        return None\n\n    def _get_source(self, node: ast.AST, source_lines: list[str]) -> str:\n        \"\"\"Get source code for a node.\"\"\"\n        if not hasattr(node, \"lineno\") or not hasattr(node, \"end_lineno\"):\n            return \"\"\n        start = node.lineno - 1\n        end = node.end_lineno if node.end_lineno else node.lineno\n        return \"\\n\".join(source_lines[start:end])\n\n    def _get_signature(\n        self, node: ast.FunctionDef | ast.AsyncFunctionDef\n    ) -> str:\n        \"\"\"Generate function signature string.\"\"\"\n        args = node.args\n        params: list[str] = []\n\n        # Positional args\n        for arg in args.args:\n            param = arg.arg\n            if arg.annotation:\n                param += f\": {ast.unparse(arg.annotation)}\"\n            params.append(param)\n\n        # *args\n        if args.vararg:\n            param = f\"*{args.vararg.a", "tokens": ["self", "get", "name", "node", "value", "if", "value", "return", "value", "node", "attr", "return", "node", "attr", "return", "none", "def", "get", "source", "self", "node", "ast", "ast", "source", "lines", "list", "str", "str", "get", "source", "code", "for", "node", "if", "not", "hasattr", "node", "lineno", "or", "not", "hasattr", "node", "end", "lineno", "return", "start", "node", "lineno", "end", "node", "end", "lineno", "if", "node", "end", "lineno", "else", "node", "lineno", "return", "join", "source", "lines", "start", "end", "def", "get", "signature", "self", "node", "ast", "function", "def", "ast", "async", "function", "def", "str", "generate", "function", "signature", "string", "args", "node", "args", "params", "list", "str", "positional", "args", "for", "arg", "in", "args", "args", "param", "arg", "arg", "if", "arg", "annotation", "param", "ast", "unparse", "arg", "annotation", "params", "append", "param", "args", "if", "args", "vararg", "param", "args", "vararg"], "metadata": {"kind": "class", "chunk_index": "11", "has_docstring": "true", "last_modified": "1768185812.9936173"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/python_parser.py::PythonParser::12", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/python_parser.py::PythonParser", "content": " params.append(param)\n\n        # *args\n        if args.vararg:\n            param = f\"*{args.vararg.arg}\"\n            if args.vararg.annotation:\n                param += f\": {ast.unparse(args.vararg.annotation)}\"\n            params.append(param)\n\n        # **kwargs\n        if args.kwarg:\n            param = f\"**{args.kwarg.arg}\"\n            if args.kwarg.annotation:\n                param += f\": {ast.unparse(args.kwarg.annotation)}\"\n            params.append(param)\n\n        # Return type\n        returns = \"\"\n        if node.returns:\n            returns = f\" -> {ast.unparse(node.returns)}\"\n\n        async_prefix = \"async \" if isinstance(node, ast.AsyncFunctionDef) else \"\"\n        return f\"{async_prefix}def {node.name}({', '.join(params)}){returns}\"", "tokens": ["params", "append", "param", "args", "if", "args", "vararg", "param", "args", "vararg", "arg", "if", "args", "vararg", "annotation", "param", "ast", "unparse", "args", "vararg", "annotation", "params", "append", "param", "kwargs", "if", "args", "kwarg", "param", "args", "kwarg", "arg", "if", "args", "kwarg", "annotation", "param", "ast", "unparse", "args", "kwarg", "annotation", "params", "append", "param", "return", "type", "returns", "if", "node", "returns", "returns", "ast", "unparse", "node", "returns", "async", "prefix", "async", "if", "isinstance", "node", "ast", "async", "function", "def", "else", "return", "async", "prefix", "def", "node", "name", "join", "params", "returns"], "metadata": {"kind": "class", "chunk_index": "12", "has_docstring": "true", "last_modified": "1768185812.9936173"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/python_parser.py::PythonParser.parse_file::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/python_parser.py::PythonParser.parse_file", "content": "def parse_file(self, file_path: str | Path) -> ParseResult\n\"\"\"Parse a Python file.\n\nArgs:\n    file_path: Path to the Python file.\n\nReturns:\n    ParseResult with entities and relationships.\"\"\"\n    def parse_file(self, file_path: str | Path) -> ParseResult:\n        \"\"\"Parse a Python file.\n\n        Args:\n            file_path: Path to the Python file.\n\n        Returns:\n            ParseResult with entities and relationships.\n        \"\"\"\n        file_path = Path(file_path)\n        errors: list[str] = []\n\n        try:\n            source_code = file_path.read_text(encoding=\"utf-8\")\n        except Exception as e:\n            return ParseResult(\n                file_path=str(file_path),\n                entities=[],\n                relationships=[],\n                errors=[f\"Failed to read file: {e}\"],\n            )\n\n        try:\n            tree = ast.parse(source_code, filename=str(file_path))\n        except SyntaxError as e:\n            return ParseResult(\n                file_path=str(file_", "tokens": ["def", "parse", "file", "self", "file", "path", "str", "path", "parse", "result", "parse", "python", "file", "args", "file", "path", "path", "to", "the", "python", "file", "returns", "parse", "result", "with", "entities", "and", "relationships", "def", "parse", "file", "self", "file", "path", "str", "path", "parse", "result", "parse", "python", "file", "args", "file", "path", "path", "to", "the", "python", "file", "returns", "parse", "result", "with", "entities", "and", "relationships", "file", "path", "path", "file", "path", "errors", "list", "str", "try", "source", "code", "file", "path", "read", "text", "encoding", "utf", "except", "exception", "as", "return", "parse", "result", "file", "path", "str", "file", "path", "entities", "relationships", "errors", "failed", "to", "read", "file", "try", "tree", "ast", "parse", "source", "code", "filename", "str", "file", "path", "except", "syntax", "error", "as", "return", "parse", "result", "file", "path", "str", "file"], "metadata": {"kind": "method", "chunk_index": "0", "has_docstring": "true", "last_modified": "1768185812.9936173"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/python_parser.py::PythonParser.parse_file::1", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/python_parser.py::PythonParser.parse_file", "content": "        except SyntaxError as e:\n            return ParseResult(\n                file_path=str(file_path),\n                entities=[],\n                relationships=[],\n                errors=[f\"Syntax error: {e}\"],\n            )\n\n        entities: list[Entity] = []\n        relationships: list[Relationship] = []\n        source_lines = source_code.splitlines()\n\n        # Create module entity\n        module_name = file_path.stem\n        module_id = f\"{file_path}::{module_name}\"\n        module_entity = Entity(\n            id=module_id,\n            kind=EntityKind.MODULE,\n            name=module_name,\n            qualified_name=module_name,\n            location=Location(\n                file_path=str(file_path),\n                line_start=1,\n                line_end=len(source_lines),\n            ),\n            docstring=ast.get_docstring(tree),\n        )\n        entities.append(module_entity)\n\n        # Extract imports\n        for node in ast.walk(tree):\n            if isinstance(node, a", "tokens": ["except", "syntax", "error", "as", "return", "parse", "result", "file", "path", "str", "file", "path", "entities", "relationships", "errors", "syntax", "error", "entities", "list", "entity", "relationships", "list", "relationship", "source", "lines", "source", "code", "splitlines", "create", "module", "entity", "module", "name", "file", "path", "stem", "module", "id", "file", "path", "module", "name", "module", "entity", "entity", "id", "module", "id", "kind", "entity", "kind", "module", "name", "module", "name", "qualified", "name", "module", "name", "location", "location", "file", "path", "str", "file", "path", "line", "start", "line", "end", "len", "source", "lines", "docstring", "ast", "get", "docstring", "tree", "entities", "append", "module", "entity", "extract", "imports", "for", "node", "in", "ast", "walk", "tree", "if", "isinstance", "node"], "metadata": {"kind": "method", "chunk_index": "1", "has_docstring": "true", "last_modified": "1768185812.9936173"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/python_parser.py::PythonParser.parse_file::2", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/python_parser.py::PythonParser.parse_file", "content": "ty)\n\n        # Extract imports\n        for node in ast.walk(tree):\n            if isinstance(node, ast.Import):\n                for alias in node.names:\n                    relationships.append(\n                        Relationship(\n                            source_id=module_id,\n                            target_id=f\"external::{alias.name}\",\n                            kind=RelationshipKind.IMPORTS,\n                        )\n                    )\n            elif isinstance(node, ast.ImportFrom):\n                if node.module:\n                    relationships.append(\n                        Relationship(\n                            source_id=module_id,\n                            target_id=f\"external::{node.module}\",\n                            kind=RelationshipKind.IMPORTS,\n                        )\n                    )\n\n        # Process top-level definitions\n        for node in ast.iter_child_nodes(tree):\n            if isinstance(node, ast.ClassDef):\n                class_ent", "tokens": ["ty", "extract", "imports", "for", "node", "in", "ast", "walk", "tree", "if", "isinstance", "node", "ast", "import", "for", "alias", "in", "node", "names", "relationships", "append", "relationship", "source", "id", "module", "id", "target", "id", "external", "alias", "name", "kind", "relationship", "kind", "imports", "elif", "isinstance", "node", "ast", "import", "from", "if", "node", "module", "relationships", "append", "relationship", "source", "id", "module", "id", "target", "id", "external", "node", "module", "kind", "relationship", "kind", "imports", "process", "top", "level", "definitions", "for", "node", "in", "ast", "iter", "child", "nodes", "tree", "if", "isinstance", "node", "ast", "class", "def", "class", "ent"], "metadata": {"kind": "method", "chunk_index": "2", "has_docstring": "true", "last_modified": "1768185812.9936173"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/python_parser.py::PythonParser.parse_file::3", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/python_parser.py::PythonParser.parse_file", "content": "ast.iter_child_nodes(tree):\n            if isinstance(node, ast.ClassDef):\n                class_entities, class_rels = self._parse_class(\n                    node, file_path, module_id, source_lines\n                )\n                entities.extend(class_entities)\n                relationships.extend(class_rels)\n\n            elif isinstance(node, (ast.FunctionDef, ast.AsyncFunctionDef)):\n                func_entity, func_rels = self._parse_function(\n                    node, file_path, module_id, source_lines\n                )\n                entities.append(func_entity)\n                relationships.extend(func_rels)\n\n        return ParseResult(\n            file_path=str(file_path),\n            entities=entities,\n            relationships=relationships,\n            errors=errors,\n        )", "tokens": ["ast", "iter", "child", "nodes", "tree", "if", "isinstance", "node", "ast", "class", "def", "class", "entities", "class", "rels", "self", "parse", "class", "node", "file", "path", "module", "id", "source", "lines", "entities", "extend", "class", "entities", "relationships", "extend", "class", "rels", "elif", "isinstance", "node", "ast", "function", "def", "ast", "async", "function", "def", "func", "entity", "func", "rels", "self", "parse", "function", "node", "file", "path", "module", "id", "source", "lines", "entities", "append", "func", "entity", "relationships", "extend", "func", "rels", "return", "parse", "result", "file", "path", "str", "file", "path", "entities", "entities", "relationships", "relationships", "errors", "errors"], "metadata": {"kind": "method", "chunk_index": "3", "has_docstring": "true", "last_modified": "1768185812.9936173"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/python_parser.py::PythonParser._parse_class::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/python_parser.py::PythonParser._parse_class", "content": "def _parse_class(self, node: ast.ClassDef, file_path: Path, parent_id: str, source_lines: list[str]) -> tuple[list[Entity], list[Relationship]]\n\"\"\"Parse a class definition.\"\"\"\n    def _parse_class(\n        self,\n        node: ast.ClassDef,\n        file_path: Path,\n        parent_id: str,\n        source_lines: list[str],\n    ) -> tuple[list[Entity], list[Relationship]]:\n        \"\"\"Parse a class definition.\"\"\"\n        entities: list[Entity] = []\n        relationships: list[Relationship] = []\n\n        class_id = f\"{file_path}::{node.name}\"\n\n        # Get source code for the class\n        source_code = self._get_source(node, source_lines)\n\n        class_entity = Entity(\n            id=class_id,\n            kind=EntityKind.CLASS,\n            name=node.name,\n            qualified_name=node.name,\n            location=Location(\n                file_path=str(file_path),\n                line_start=node.lineno,\n                line_end=node.end_lineno or node.lineno,\n                column_start=", "tokens": ["def", "parse", "class", "self", "node", "ast", "class", "def", "file", "path", "path", "parent", "id", "str", "source", "lines", "list", "str", "tuple", "list", "entity", "list", "relationship", "parse", "class", "definition", "def", "parse", "class", "self", "node", "ast", "class", "def", "file", "path", "path", "parent", "id", "str", "source", "lines", "list", "str", "tuple", "list", "entity", "list", "relationship", "parse", "class", "definition", "entities", "list", "entity", "relationships", "list", "relationship", "class", "id", "file", "path", "node", "name", "get", "source", "code", "for", "the", "class", "source", "code", "self", "get", "source", "node", "source", "lines", "class", "entity", "entity", "id", "class", "id", "kind", "entity", "kind", "class", "name", "node", "name", "qualified", "name", "node", "name", "location", "location", "file", "path", "str", "file", "path", "line", "start", "node", "lineno", "line", "end", "node", "end", "lineno", "or", "node", "lineno", "column", "start"], "metadata": {"kind": "method", "chunk_index": "0", "has_docstring": "true", "last_modified": "1768185812.9936173"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/python_parser.py::PythonParser._parse_class::1", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/python_parser.py::PythonParser._parse_class", "content": "=node.lineno,\n                line_end=node.end_lineno or node.lineno,\n                column_start=node.col_offset,\n                column_end=node.end_col_offset or 0,\n            ),\n            docstring=ast.get_docstring(node),\n            source_code=source_code,\n        )\n        entities.append(class_entity)\n\n        # Add contains relationship\n        relationships.append(\n            Relationship(\n                source_id=parent_id,\n                target_id=class_id,\n                kind=RelationshipKind.CONTAINS,\n            )\n        )\n\n        # Add inheritance relationships\n        for base in node.bases:\n            base_name = self._get_name(base)\n            if base_name:\n                relationships.append(\n                    Relationship(\n                        source_id=class_id,\n                        target_id=f\"ref::{base_name}\",\n                        kind=RelationshipKind.INHERITS,\n                    )\n                )\n\n        # Parse methods\n        f", "tokens": ["node", "lineno", "line", "end", "node", "end", "lineno", "or", "node", "lineno", "column", "start", "node", "col", "offset", "column", "end", "node", "end", "col", "offset", "or", "docstring", "ast", "get", "docstring", "node", "source", "code", "source", "code", "entities", "append", "class", "entity", "add", "contains", "relationship", "relationships", "append", "relationship", "source", "id", "parent", "id", "target", "id", "class", "id", "kind", "relationship", "kind", "contains", "add", "inheritance", "relationships", "for", "base", "in", "node", "bases", "base", "name", "self", "get", "name", "base", "if", "base", "name", "relationships", "append", "relationship", "source", "id", "class", "id", "target", "id", "ref", "base", "name", "kind", "relationship", "kind", "inherits", "parse", "methods"], "metadata": {"kind": "method", "chunk_index": "1", "has_docstring": "true", "last_modified": "1768185812.9936173"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/python_parser.py::PythonParser._parse_class::2", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/python_parser.py::PythonParser._parse_class", "content": "elationshipKind.INHERITS,\n                    )\n                )\n\n        # Parse methods\n        for child in node.body:\n            if isinstance(child, (ast.FunctionDef, ast.AsyncFunctionDef)):\n                method_entity, method_rels = self._parse_method(\n                    child, file_path, class_id, node.name, source_lines\n                )\n                entities.append(method_entity)\n                relationships.extend(method_rels)\n\n        return entities, relationships", "tokens": ["elationship", "kind", "inherits", "parse", "methods", "for", "child", "in", "node", "body", "if", "isinstance", "child", "ast", "function", "def", "ast", "async", "function", "def", "method", "entity", "method", "rels", "self", "parse", "method", "child", "file", "path", "class", "id", "node", "name", "source", "lines", "entities", "append", "method", "entity", "relationships", "extend", "method", "rels", "return", "entities", "relationships"], "metadata": {"kind": "method", "chunk_index": "2", "has_docstring": "true", "last_modified": "1768185812.9936173"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/python_parser.py::PythonParser._parse_function::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/python_parser.py::PythonParser._parse_function", "content": "def _parse_function(self, node: ast.FunctionDef | ast.AsyncFunctionDef, file_path: Path, parent_id: str, source_lines: list[str]) -> tuple[Entity, list[Relationship]]\n\"\"\"Parse a function definition.\"\"\"\n    def _parse_function(\n        self,\n        node: ast.FunctionDef | ast.AsyncFunctionDef,\n        file_path: Path,\n        parent_id: str,\n        source_lines: list[str],\n    ) -> tuple[Entity, list[Relationship]]:\n        \"\"\"Parse a function definition.\"\"\"\n        relationships: list[Relationship] = []\n\n        func_id = f\"{file_path}::{node.name}\"\n        source_code = self._get_source(node, source_lines)\n        signature = self._get_signature(node)\n\n        entity = Entity(\n            id=func_id,\n            kind=EntityKind.FUNCTION,\n            name=node.name,\n            qualified_name=node.name,\n            location=Location(\n                file_path=str(file_path),\n                line_start=node.lineno,\n                line_end=node.end_lineno or node.lineno,\n             ", "tokens": ["def", "parse", "function", "self", "node", "ast", "function", "def", "ast", "async", "function", "def", "file", "path", "path", "parent", "id", "str", "source", "lines", "list", "str", "tuple", "entity", "list", "relationship", "parse", "function", "definition", "def", "parse", "function", "self", "node", "ast", "function", "def", "ast", "async", "function", "def", "file", "path", "path", "parent", "id", "str", "source", "lines", "list", "str", "tuple", "entity", "list", "relationship", "parse", "function", "definition", "relationships", "list", "relationship", "func", "id", "file", "path", "node", "name", "source", "code", "self", "get", "source", "node", "source", "lines", "signature", "self", "get", "signature", "node", "entity", "entity", "id", "func", "id", "kind", "entity", "kind", "function", "name", "node", "name", "qualified", "name", "node", "name", "location", "location", "file", "path", "str", "file", "path", "line", "start", "node", "lineno", "line", "end", "node", "end", "lineno", "or", "node", "lineno"], "metadata": {"kind": "method", "chunk_index": "0", "has_docstring": "true", "last_modified": "1768185812.9936173"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/python_parser.py::PythonParser._parse_function::1", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/python_parser.py::PythonParser._parse_function", "content": "      line_start=node.lineno,\n                line_end=node.end_lineno or node.lineno,\n                column_start=node.col_offset,\n                column_end=node.end_col_offset or 0,\n            ),\n            docstring=ast.get_docstring(node),\n            signature=signature,\n            source_code=source_code,\n        )\n\n        # Add contains relationship\n        relationships.append(\n            Relationship(\n                source_id=parent_id,\n                target_id=func_id,\n                kind=RelationshipKind.CONTAINS,\n            )\n        )\n\n        # Find calls within the function\n        call_rels = self._extract_calls(node, func_id)\n        relationships.extend(call_rels)\n\n        return entity, relationships", "tokens": ["line", "start", "node", "lineno", "line", "end", "node", "end", "lineno", "or", "node", "lineno", "column", "start", "node", "col", "offset", "column", "end", "node", "end", "col", "offset", "or", "docstring", "ast", "get", "docstring", "node", "signature", "signature", "source", "code", "source", "code", "add", "contains", "relationship", "relationships", "append", "relationship", "source", "id", "parent", "id", "target", "id", "func", "id", "kind", "relationship", "kind", "contains", "find", "calls", "within", "the", "function", "call", "rels", "self", "extract", "calls", "node", "func", "id", "relationships", "extend", "call", "rels", "return", "entity", "relationships"], "metadata": {"kind": "method", "chunk_index": "1", "has_docstring": "true", "last_modified": "1768185812.9936173"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/python_parser.py::PythonParser._parse_method::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/python_parser.py::PythonParser._parse_method", "content": "def _parse_method(self, node: ast.FunctionDef | ast.AsyncFunctionDef, file_path: Path, class_id: str, class_name: str, source_lines: list[str]) -> tuple[Entity, list[Relationship]]\n\"\"\"Parse a method definition.\"\"\"\n    def _parse_method(\n        self,\n        node: ast.FunctionDef | ast.AsyncFunctionDef,\n        file_path: Path,\n        class_id: str,\n        class_name: str,\n        source_lines: list[str],\n    ) -> tuple[Entity, list[Relationship]]:\n        \"\"\"Parse a method definition.\"\"\"\n        relationships: list[Relationship] = []\n\n        method_id = f\"{file_path}::{class_name}.{node.name}\"\n        source_code = self._get_source(node, source_lines)\n        signature = self._get_signature(node)\n\n        entity = Entity(\n            id=method_id,\n            kind=EntityKind.METHOD,\n            name=node.name,\n            qualified_name=f\"{class_name}.{node.name}\",\n            location=Location(\n                file_path=str(file_path),\n                line_start=node.lineno,\n     ", "tokens": ["def", "parse", "method", "self", "node", "ast", "function", "def", "ast", "async", "function", "def", "file", "path", "path", "class", "id", "str", "class", "name", "str", "source", "lines", "list", "str", "tuple", "entity", "list", "relationship", "parse", "method", "definition", "def", "parse", "method", "self", "node", "ast", "function", "def", "ast", "async", "function", "def", "file", "path", "path", "class", "id", "str", "class", "name", "str", "source", "lines", "list", "str", "tuple", "entity", "list", "relationship", "parse", "method", "definition", "relationships", "list", "relationship", "method", "id", "file", "path", "class", "name", "node", "name", "source", "code", "self", "get", "source", "node", "source", "lines", "signature", "self", "get", "signature", "node", "entity", "entity", "id", "method", "id", "kind", "entity", "kind", "method", "name", "node", "name", "qualified", "name", "class", "name", "node", "name", "location", "location", "file", "path", "str", "file", "path", "line", "start", "node", "lineno"], "metadata": {"kind": "method", "chunk_index": "0", "has_docstring": "true", "last_modified": "1768185812.9936173"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/python_parser.py::PythonParser._parse_method::1", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/python_parser.py::PythonParser._parse_method", "content": "on=Location(\n                file_path=str(file_path),\n                line_start=node.lineno,\n                line_end=node.end_lineno or node.lineno,\n                column_start=node.col_offset,\n                column_end=node.end_col_offset or 0,\n            ),\n            docstring=ast.get_docstring(node),\n            signature=signature,\n            source_code=source_code,\n        )\n\n        # Add contains relationship\n        relationships.append(\n            Relationship(\n                source_id=class_id,\n                target_id=method_id,\n                kind=RelationshipKind.CONTAINS,\n            )\n        )\n\n        # Find calls within the method\n        call_rels = self._extract_calls(node, method_id)\n        relationships.extend(call_rels)\n\n        return entity, relationships", "tokens": ["on", "location", "file", "path", "str", "file", "path", "line", "start", "node", "lineno", "line", "end", "node", "end", "lineno", "or", "node", "lineno", "column", "start", "node", "col", "offset", "column", "end", "node", "end", "col", "offset", "or", "docstring", "ast", "get", "docstring", "node", "signature", "signature", "source", "code", "source", "code", "add", "contains", "relationship", "relationships", "append", "relationship", "source", "id", "class", "id", "target", "id", "method", "id", "kind", "relationship", "kind", "contains", "find", "calls", "within", "the", "method", "call", "rels", "self", "extract", "calls", "node", "method", "id", "relationships", "extend", "call", "rels", "return", "entity", "relationships"], "metadata": {"kind": "method", "chunk_index": "1", "has_docstring": "true", "last_modified": "1768185812.9936173"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/python_parser.py::PythonParser._extract_calls::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/python_parser.py::PythonParser._extract_calls", "content": "def _extract_calls(self, node: ast.AST, caller_id: str) -> list[Relationship]\n\"\"\"Extract function/method calls from a node.\"\"\"\n    def _extract_calls(\n        self,\n        node: ast.AST,\n        caller_id: str,\n    ) -> list[Relationship]:\n        \"\"\"Extract function/method calls from a node.\"\"\"\n        relationships: list[Relationship] = []\n\n        for child in ast.walk(node):\n            if isinstance(child, ast.Call):\n                callee_name = self._get_call_name(child)\n                if callee_name:\n                    relationships.append(\n                        Relationship(\n                            source_id=caller_id,\n                            target_id=f\"ref::{callee_name}\",\n                            kind=RelationshipKind.CALLS,\n                        )\n                    )\n\n        return relationships", "tokens": ["def", "extract", "calls", "self", "node", "ast", "ast", "caller", "id", "str", "list", "relationship", "extract", "function", "method", "calls", "from", "node", "def", "extract", "calls", "self", "node", "ast", "ast", "caller", "id", "str", "list", "relationship", "extract", "function", "method", "calls", "from", "node", "relationships", "list", "relationship", "for", "child", "in", "ast", "walk", "node", "if", "isinstance", "child", "ast", "call", "callee", "name", "self", "get", "call", "name", "child", "if", "callee", "name", "relationships", "append", "relationship", "source", "id", "caller", "id", "target", "id", "ref", "callee", "name", "kind", "relationship", "kind", "calls", "return", "relationships"], "metadata": {"kind": "method", "has_docstring": "true", "last_modified": "1768185812.9936173"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/python_parser.py::PythonParser._get_call_name::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/python_parser.py::PythonParser._get_call_name", "content": "def _get_call_name(self, node: ast.Call) -> Optional[str]\n\"\"\"Get the name of a called function.\"\"\"\n    def _get_call_name(self, node: ast.Call) -> Optional[str]:\n        \"\"\"Get the name of a called function.\"\"\"\n        if isinstance(node.func, ast.Name):\n            return node.func.id\n        elif isinstance(node.func, ast.Attribute):\n            value_name = self._get_name(node.func.value)\n            if value_name:\n                return f\"{value_name}.{node.func.attr}\"\n            return node.func.attr\n        return None", "tokens": ["def", "get", "call", "name", "self", "node", "ast", "call", "optional", "str", "get", "the", "name", "of", "called", "function", "def", "get", "call", "name", "self", "node", "ast", "call", "optional", "str", "get", "the", "name", "of", "called", "function", "if", "isinstance", "node", "func", "ast", "name", "return", "node", "func", "id", "elif", "isinstance", "node", "func", "ast", "attribute", "value", "name", "self", "get", "name", "node", "func", "value", "if", "value", "name", "return", "value", "name", "node", "func", "attr", "return", "node", "func", "attr", "return", "none"], "metadata": {"kind": "method", "has_docstring": "true", "last_modified": "1768185812.9936173"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/python_parser.py::PythonParser._get_name::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/python_parser.py::PythonParser._get_name", "content": "def _get_name(self, node: ast.expr) -> Optional[str]\n\"\"\"Get name from an expression node.\"\"\"\n    def _get_name(self, node: ast.expr) -> Optional[str]:\n        \"\"\"Get name from an expression node.\"\"\"\n        if isinstance(node, ast.Name):\n            return node.id\n        elif isinstance(node, ast.Attribute):\n            value = self._get_name(node.value)\n            if value:\n                return f\"{value}.{node.attr}\"\n            return node.attr\n        return None", "tokens": ["def", "get", "name", "self", "node", "ast", "expr", "optional", "str", "get", "name", "from", "an", "expression", "node", "def", "get", "name", "self", "node", "ast", "expr", "optional", "str", "get", "name", "from", "an", "expression", "node", "if", "isinstance", "node", "ast", "name", "return", "node", "id", "elif", "isinstance", "node", "ast", "attribute", "value", "self", "get", "name", "node", "value", "if", "value", "return", "value", "node", "attr", "return", "node", "attr", "return", "none"], "metadata": {"kind": "method", "has_docstring": "true", "last_modified": "1768185812.9936173"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/python_parser.py::PythonParser._get_source::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/python_parser.py::PythonParser._get_source", "content": "def _get_source(self, node: ast.AST, source_lines: list[str]) -> str\n\"\"\"Get source code for a node.\"\"\"\n    def _get_source(self, node: ast.AST, source_lines: list[str]) -> str:\n        \"\"\"Get source code for a node.\"\"\"\n        if not hasattr(node, \"lineno\") or not hasattr(node, \"end_lineno\"):\n            return \"\"\n        start = node.lineno - 1\n        end = node.end_lineno if node.end_lineno else node.lineno\n        return \"\\n\".join(source_lines[start:end])", "tokens": ["def", "get", "source", "self", "node", "ast", "ast", "source", "lines", "list", "str", "str", "get", "source", "code", "for", "node", "def", "get", "source", "self", "node", "ast", "ast", "source", "lines", "list", "str", "str", "get", "source", "code", "for", "node", "if", "not", "hasattr", "node", "lineno", "or", "not", "hasattr", "node", "end", "lineno", "return", "start", "node", "lineno", "end", "node", "end", "lineno", "if", "node", "end", "lineno", "else", "node", "lineno", "return", "join", "source", "lines", "start", "end"], "metadata": {"kind": "method", "has_docstring": "true", "last_modified": "1768185812.9936173"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/python_parser.py::PythonParser._get_signature::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/python_parser.py::PythonParser._get_signature", "content": "def _get_signature(self, node: ast.FunctionDef | ast.AsyncFunctionDef) -> str\n\"\"\"Generate function signature string.\"\"\"\n    def _get_signature(\n        self, node: ast.FunctionDef | ast.AsyncFunctionDef\n    ) -> str:\n        \"\"\"Generate function signature string.\"\"\"\n        args = node.args\n        params: list[str] = []\n\n        # Positional args\n        for arg in args.args:\n            param = arg.arg\n            if arg.annotation:\n                param += f\": {ast.unparse(arg.annotation)}\"\n            params.append(param)\n\n        # *args\n        if args.vararg:\n            param = f\"*{args.vararg.arg}\"\n            if args.vararg.annotation:\n                param += f\": {ast.unparse(args.vararg.annotation)}\"\n            params.append(param)\n\n        # **kwargs\n        if args.kwarg:\n            param = f\"**{args.kwarg.arg}\"\n            if args.kwarg.annotation:\n                param += f\": {ast.unparse(args.kwarg.annotation)}\"\n            params.append(param)\n\n        # Return type", "tokens": ["def", "get", "signature", "self", "node", "ast", "function", "def", "ast", "async", "function", "def", "str", "generate", "function", "signature", "string", "def", "get", "signature", "self", "node", "ast", "function", "def", "ast", "async", "function", "def", "str", "generate", "function", "signature", "string", "args", "node", "args", "params", "list", "str", "positional", "args", "for", "arg", "in", "args", "args", "param", "arg", "arg", "if", "arg", "annotation", "param", "ast", "unparse", "arg", "annotation", "params", "append", "param", "args", "if", "args", "vararg", "param", "args", "vararg", "arg", "if", "args", "vararg", "annotation", "param", "ast", "unparse", "args", "vararg", "annotation", "params", "append", "param", "kwargs", "if", "args", "kwarg", "param", "args", "kwarg", "arg", "if", "args", "kwarg", "annotation", "param", "ast", "unparse", "args", "kwarg", "annotation", "params", "append", "param", "return", "type"], "metadata": {"kind": "method", "chunk_index": "0", "has_docstring": "true", "last_modified": "1768185812.9936173"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/python_parser.py::PythonParser._get_signature::1", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/python_parser.py::PythonParser._get_signature", "content": "+= f\": {ast.unparse(args.kwarg.annotation)}\"\n            params.append(param)\n\n        # Return type\n        returns = \"\"\n        if node.returns:\n            returns = f\" -> {ast.unparse(node.returns)}\"\n\n        async_prefix = \"async \" if isinstance(node, ast.AsyncFunctionDef) else \"\"\n        return f\"{async_prefix}def {node.name}({', '.join(params)}){returns}\"", "tokens": ["ast", "unparse", "args", "kwarg", "annotation", "params", "append", "param", "return", "type", "returns", "if", "node", "returns", "returns", "ast", "unparse", "node", "returns", "async", "prefix", "async", "if", "isinstance", "node", "ast", "async", "function", "def", "else", "return", "async", "prefix", "def", "node", "name", "join", "params", "returns"], "metadata": {"kind": "method", "chunk_index": "1", "has_docstring": "true", "last_modified": "1768185812.9936173"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/base.py::module::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/base.py::module", "content": "\"\"\"Base parser using Tree-sitter.\"\"\"", "tokens": ["base", "parser", "using", "tree", "sitter"], "metadata": {"type": "module_header"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/base.py::imports::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/base.py::module", "content": "from __future__ import annotations\nfrom pathlib import Path\nfrom typing import Any, Optional\nfrom tree_sitter import Parser\nimport tree_sitter_languages\nfrom knowcode.data_models import (", "tokens": ["from", "future", "import", "annotations", "from", "pathlib", "import", "path", "from", "typing", "import", "any", "optional", "from", "tree", "sitter", "import", "parser", "import", "tree", "sitter", "languages", "from", "knowcode", "data", "models", "import"], "metadata": {"type": "imports"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/base.py::TreeSitterParser::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/base.py::TreeSitterParser", "content": "\"\"\"Base class for parsers using Tree-sitter.\"\"\"\nclass TreeSitterParser:\n    \"\"\"Base class for parsers using Tree-sitter.\"\"\"\n\n    def __init__(self, language_name: str) -> None:\n        \"\"\"Initialize parser for a specific language.\n\n        Args:\n            language_name: Name of the language (e.g., 'python', 'javascript', 'java').\n        \"\"\"\n        self.language_name = language_name\n        self.language = tree_sitter_languages.get_language(language_name)\n        self.parser = Parser()\n        self.parser.set_language(self.language)\n\n    def parse_file(self, file_path: str | Path) -> ParseResult:\n        \"\"\"Parse a source file.\n\n        Args:\n            file_path: Path to the source file.\n\n        Returns:\n            ParseResult with entities and relationships.\n        \"\"\"\n        file_path = Path(file_path)\n        errors: list[str] = []\n\n        try:\n            source_code = file_path.read_text(encoding=\"utf-8\")\n        except Exception as e:\n            return ParseResult(\n   ", "tokens": ["base", "class", "for", "parsers", "using", "tree", "sitter", "class", "tree", "sitter", "parser", "base", "class", "for", "parsers", "using", "tree", "sitter", "def", "init", "self", "language", "name", "str", "none", "initialize", "parser", "for", "specific", "language", "args", "language", "name", "name", "of", "the", "language", "python", "javascript", "java", "self", "language", "name", "language", "name", "self", "language", "tree", "sitter", "languages", "get", "language", "language", "name", "self", "parser", "parser", "self", "parser", "set", "language", "self", "language", "def", "parse", "file", "self", "file", "path", "str", "path", "parse", "result", "parse", "source", "file", "args", "file", "path", "path", "to", "the", "source", "file", "returns", "parse", "result", "with", "entities", "and", "relationships", "file", "path", "path", "file", "path", "errors", "list", "str", "try", "source", "code", "file", "path", "read", "text", "encoding", "utf", "except", "exception", "as", "return", "parse", "result"], "metadata": {"kind": "class", "chunk_index": "0", "has_docstring": "true", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/base.py::TreeSitterParser::1", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/base.py::TreeSitterParser", "content": "_path.read_text(encoding=\"utf-8\")\n        except Exception as e:\n            return ParseResult(\n                file_path=str(file_path),\n                entities=[],\n                relationships=[],\n                errors=[f\"Failed to read file: {e}\"],\n            )\n\n        try:\n            tree = self.parser.parse(bytes(source_code, \"utf8\"))\n        except Exception as e:\n            return ParseResult(\n                file_path=str(file_path),\n                entities=[],\n                relationships=[],\n                errors=[f\"Parse error: {e}\"],\n            )\n\n        entities: list[Entity] = []\n        relationships: list[Relationship] = []\n        source_lines = source_code.splitlines()\n\n        # Create module entity\n        module_name = file_path.stem\n        module_id = f\"{file_path}::{module_name}\"\n        module_entity = Entity(\n            id=module_id,\n            kind=EntityKind.MODULE,\n            name=module_name,\n            qualified_name=module_name,\n        ", "tokens": ["path", "read", "text", "encoding", "utf", "except", "exception", "as", "return", "parse", "result", "file", "path", "str", "file", "path", "entities", "relationships", "errors", "failed", "to", "read", "file", "try", "tree", "self", "parser", "parse", "bytes", "source", "code", "utf8", "except", "exception", "as", "return", "parse", "result", "file", "path", "str", "file", "path", "entities", "relationships", "errors", "parse", "error", "entities", "list", "entity", "relationships", "list", "relationship", "source", "lines", "source", "code", "splitlines", "create", "module", "entity", "module", "name", "file", "path", "stem", "module", "id", "file", "path", "module", "name", "module", "entity", "entity", "id", "module", "id", "kind", "entity", "kind", "module", "name", "module", "name", "qualified", "name", "module", "name"], "metadata": {"kind": "class", "chunk_index": "1", "has_docstring": "true", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/base.py::TreeSitterParser::2", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/base.py::TreeSitterParser", "content": "nd=EntityKind.MODULE,\n            name=module_name,\n            qualified_name=module_name,\n            location=Location(\n                file_path=str(file_path),\n                line_start=1,\n                line_end=len(source_lines),\n            ),\n        )\n        entities.append(module_entity)\n\n        # Delegate to language-specific extraction\n        child_entities, child_rels = self._extract_entities(\n            tree.root_node, file_path, module_id, source_code, source_lines\n        )\n        entities.extend(child_entities)\n        relationships.extend(child_rels)\n\n        # Handle errors from tree-sitter\n        if tree.root_node.has_error:\n             # We might want to be more specific here, but for now just flag it\n             # Don't fail completely, as partial AST is often useful\n             errors.append(\"Tree-sitter reported syntax errors in file\")\n\n        return ParseResult(\n            file_path=str(file_path),\n            entities=entities,\n            relati", "tokens": ["nd", "entity", "kind", "module", "name", "module", "name", "qualified", "name", "module", "name", "location", "location", "file", "path", "str", "file", "path", "line", "start", "line", "end", "len", "source", "lines", "entities", "append", "module", "entity", "delegate", "to", "language", "specific", "extraction", "child", "entities", "child", "rels", "self", "extract", "entities", "tree", "root", "node", "file", "path", "module", "id", "source", "code", "source", "lines", "entities", "extend", "child", "entities", "relationships", "extend", "child", "rels", "handle", "errors", "from", "tree", "sitter", "if", "tree", "root", "node", "has", "error", "we", "might", "want", "to", "be", "more", "specific", "here", "but", "for", "now", "just", "flag", "it", "don", "fail", "completely", "as", "partial", "ast", "is", "often", "useful", "errors", "append", "tree", "sitter", "reported", "syntax", "errors", "in", "file", "return", "parse", "result", "file", "path", "str", "file", "path", "entities", "entities", "relati"], "metadata": {"kind": "class", "chunk_index": "2", "has_docstring": "true", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/base.py::TreeSitterParser::3", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/base.py::TreeSitterParser", "content": "ParseResult(\n            file_path=str(file_path),\n            entities=entities,\n            relationships=relationships,\n            errors=errors,\n        )\n\n    def _extract_entities(\n        self,\n        node: Any,\n        file_path: Path,\n        parent_id: str,\n        source_code: str,\n        source_lines: list[str],\n    ) -> tuple[list[Entity], list[Relationship]]:\n        \"\"\"Extract entities from the AST. Must be implemented by subclasses.\n        \n        Args:\n            node: Current AST node to process.\n            file_path: Path to the file being parsed.\n            parent_id: ID of the parent entity (for containment).\n            source_code: Full source code text.\n            source_lines: Source code split by lines.\n            \n        Returns:\n            Tuple of (entities list, relationships list).\n        \"\"\"\n        raise NotImplementedError\n\n\n    def _get_text(self, node: Any, source_bytes: bytes) -> str:\n        \"\"\"Get text content of a node.\"\"\"\n        re", "tokens": ["parse", "result", "file", "path", "str", "file", "path", "entities", "entities", "relationships", "relationships", "errors", "errors", "def", "extract", "entities", "self", "node", "any", "file", "path", "path", "parent", "id", "str", "source", "code", "str", "source", "lines", "list", "str", "tuple", "list", "entity", "list", "relationship", "extract", "entities", "from", "the", "ast", "must", "be", "implemented", "by", "subclasses", "args", "node", "current", "ast", "node", "to", "process", "file", "path", "path", "to", "the", "file", "being", "parsed", "parent", "id", "id", "of", "the", "parent", "entity", "for", "containment", "source", "code", "full", "source", "code", "text", "source", "lines", "source", "code", "split", "by", "lines", "returns", "tuple", "of", "entities", "list", "relationships", "list", "raise", "not", "implemented", "error", "def", "get", "text", "self", "node", "any", "source", "bytes", "bytes", "str", "get", "text", "content", "of", "node", "re"], "metadata": {"kind": "class", "chunk_index": "3", "has_docstring": "true", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/base.py::TreeSitterParser::4", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/base.py::TreeSitterParser", "content": "t(self, node: Any, source_bytes: bytes) -> str:\n        \"\"\"Get text content of a node.\"\"\"\n        return node.text.decode(\"utf8\")\n\n    def _get_location(self, node: Any, file_path: Path) -> Location:\n        \"\"\"Get location object for a node.\"\"\"\n        return Location(\n            file_path=str(file_path),\n            line_start=node.start_point[0] + 1,\n            line_end=node.end_point[0] + 1,\n            column_start=node.start_point[1],\n            column_end=node.end_point[1],\n        )\n\n    def _create_entity(\n        self,\n        node: Any,\n        kind: EntityKind,\n        name: str,\n        qualified_name: str,\n        file_path: Path,\n        source_lines: list[str],\n        docstring: Optional[str] = None,\n        signature: Optional[str] = None,\n    ) -> Entity:\n        \"\"\"Helper to create an entity.\"\"\"\n        # Extract source code for the node\n        start_line = node.start_point[0]\n        end_line = node.end_point[0] + 1\n        node_source = \"\\n\".join(source_lines[", "tokens": ["self", "node", "any", "source", "bytes", "bytes", "str", "get", "text", "content", "of", "node", "return", "node", "text", "decode", "utf8", "def", "get", "location", "self", "node", "any", "file", "path", "path", "location", "get", "location", "object", "for", "node", "return", "location", "file", "path", "str", "file", "path", "line", "start", "node", "start", "point", "line", "end", "node", "end", "point", "column", "start", "node", "start", "point", "column", "end", "node", "end", "point", "def", "create", "entity", "self", "node", "any", "kind", "entity", "kind", "name", "str", "qualified", "name", "str", "file", "path", "path", "source", "lines", "list", "str", "docstring", "optional", "str", "none", "signature", "optional", "str", "none", "entity", "helper", "to", "create", "an", "entity", "extract", "source", "code", "for", "the", "node", "start", "line", "node", "start", "point", "end", "line", "node", "end", "point", "node", "source", "join", "source", "lines"], "metadata": {"kind": "class", "chunk_index": "4", "has_docstring": "true", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/base.py::TreeSitterParser::5", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/base.py::TreeSitterParser", "content": "tart_point[0]\n        end_line = node.end_point[0] + 1\n        node_source = \"\\n\".join(source_lines[start_line:end_line])\n\n        return Entity(\n            id=f\"{file_path}::{qualified_name}\",\n            kind=kind,\n            name=name,\n            qualified_name=qualified_name,\n            location=self._get_location(node, file_path),\n            docstring=docstring,\n            signature=signature,\n            source_code=node_source,\n        )", "tokens": ["tart", "point", "end", "line", "node", "end", "point", "node", "source", "join", "source", "lines", "start", "line", "end", "line", "return", "entity", "id", "file", "path", "qualified", "name", "kind", "kind", "name", "name", "qualified", "name", "qualified", "name", "location", "self", "get", "location", "node", "file", "path", "docstring", "docstring", "signature", "signature", "source", "code", "node", "source"], "metadata": {"kind": "class", "chunk_index": "5", "has_docstring": "true", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/base.py::TreeSitterParser.__init__::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/base.py::TreeSitterParser.__init__", "content": "def __init__(self, language_name: str) -> None\n\"\"\"Initialize parser for a specific language.\n\nArgs:\n    language_name: Name of the language (e.g., 'python', 'javascript', 'java').\"\"\"\n    def __init__(self, language_name: str) -> None:\n        \"\"\"Initialize parser for a specific language.\n\n        Args:\n            language_name: Name of the language (e.g., 'python', 'javascript', 'java').\n        \"\"\"\n        self.language_name = language_name\n        self.language = tree_sitter_languages.get_language(language_name)\n        self.parser = Parser()\n        self.parser.set_language(self.language)", "tokens": ["def", "init", "self", "language", "name", "str", "none", "initialize", "parser", "for", "specific", "language", "args", "language", "name", "name", "of", "the", "language", "python", "javascript", "java", "def", "init", "self", "language", "name", "str", "none", "initialize", "parser", "for", "specific", "language", "args", "language", "name", "name", "of", "the", "language", "python", "javascript", "java", "self", "language", "name", "language", "name", "self", "language", "tree", "sitter", "languages", "get", "language", "language", "name", "self", "parser", "parser", "self", "parser", "set", "language", "self", "language"], "metadata": {"kind": "method", "has_docstring": "true", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/base.py::TreeSitterParser.parse_file::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/base.py::TreeSitterParser.parse_file", "content": "def parse_file(self, file_path: str | Path) -> ParseResult\n\"\"\"Parse a source file.\n\nArgs:\n    file_path: Path to the source file.\n\nReturns:\n    ParseResult with entities and relationships.\"\"\"\n    def parse_file(self, file_path: str | Path) -> ParseResult:\n        \"\"\"Parse a source file.\n\n        Args:\n            file_path: Path to the source file.\n\n        Returns:\n            ParseResult with entities and relationships.\n        \"\"\"\n        file_path = Path(file_path)\n        errors: list[str] = []\n\n        try:\n            source_code = file_path.read_text(encoding=\"utf-8\")\n        except Exception as e:\n            return ParseResult(\n                file_path=str(file_path),\n                entities=[],\n                relationships=[],\n                errors=[f\"Failed to read file: {e}\"],\n            )\n\n        try:\n            tree = self.parser.parse(bytes(source_code, \"utf8\"))\n        except Exception as e:\n            return ParseResult(\n                file_path=str(file_path", "tokens": ["def", "parse", "file", "self", "file", "path", "str", "path", "parse", "result", "parse", "source", "file", "args", "file", "path", "path", "to", "the", "source", "file", "returns", "parse", "result", "with", "entities", "and", "relationships", "def", "parse", "file", "self", "file", "path", "str", "path", "parse", "result", "parse", "source", "file", "args", "file", "path", "path", "to", "the", "source", "file", "returns", "parse", "result", "with", "entities", "and", "relationships", "file", "path", "path", "file", "path", "errors", "list", "str", "try", "source", "code", "file", "path", "read", "text", "encoding", "utf", "except", "exception", "as", "return", "parse", "result", "file", "path", "str", "file", "path", "entities", "relationships", "errors", "failed", "to", "read", "file", "try", "tree", "self", "parser", "parse", "bytes", "source", "code", "utf8", "except", "exception", "as", "return", "parse", "result", "file", "path", "str", "file", "path"], "metadata": {"kind": "method", "chunk_index": "0", "has_docstring": "true", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/base.py::TreeSitterParser.parse_file::1", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/base.py::TreeSitterParser.parse_file", "content": "      except Exception as e:\n            return ParseResult(\n                file_path=str(file_path),\n                entities=[],\n                relationships=[],\n                errors=[f\"Parse error: {e}\"],\n            )\n\n        entities: list[Entity] = []\n        relationships: list[Relationship] = []\n        source_lines = source_code.splitlines()\n\n        # Create module entity\n        module_name = file_path.stem\n        module_id = f\"{file_path}::{module_name}\"\n        module_entity = Entity(\n            id=module_id,\n            kind=EntityKind.MODULE,\n            name=module_name,\n            qualified_name=module_name,\n            location=Location(\n                file_path=str(file_path),\n                line_start=1,\n                line_end=len(source_lines),\n            ),\n        )\n        entities.append(module_entity)\n\n        # Delegate to language-specific extraction\n        child_entities, child_rels = self._extract_entities(\n            tree.root_node, file_pa", "tokens": ["except", "exception", "as", "return", "parse", "result", "file", "path", "str", "file", "path", "entities", "relationships", "errors", "parse", "error", "entities", "list", "entity", "relationships", "list", "relationship", "source", "lines", "source", "code", "splitlines", "create", "module", "entity", "module", "name", "file", "path", "stem", "module", "id", "file", "path", "module", "name", "module", "entity", "entity", "id", "module", "id", "kind", "entity", "kind", "module", "name", "module", "name", "qualified", "name", "module", "name", "location", "location", "file", "path", "str", "file", "path", "line", "start", "line", "end", "len", "source", "lines", "entities", "append", "module", "entity", "delegate", "to", "language", "specific", "extraction", "child", "entities", "child", "rels", "self", "extract", "entities", "tree", "root", "node", "file", "pa"], "metadata": {"kind": "method", "chunk_index": "1", "has_docstring": "true", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/base.py::TreeSitterParser.parse_file::2", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/base.py::TreeSitterParser.parse_file", "content": "ion\n        child_entities, child_rels = self._extract_entities(\n            tree.root_node, file_path, module_id, source_code, source_lines\n        )\n        entities.extend(child_entities)\n        relationships.extend(child_rels)\n\n        # Handle errors from tree-sitter\n        if tree.root_node.has_error:\n             # We might want to be more specific here, but for now just flag it\n             # Don't fail completely, as partial AST is often useful\n             errors.append(\"Tree-sitter reported syntax errors in file\")\n\n        return ParseResult(\n            file_path=str(file_path),\n            entities=entities,\n            relationships=relationships,\n            errors=errors,\n        )", "tokens": ["ion", "child", "entities", "child", "rels", "self", "extract", "entities", "tree", "root", "node", "file", "path", "module", "id", "source", "code", "source", "lines", "entities", "extend", "child", "entities", "relationships", "extend", "child", "rels", "handle", "errors", "from", "tree", "sitter", "if", "tree", "root", "node", "has", "error", "we", "might", "want", "to", "be", "more", "specific", "here", "but", "for", "now", "just", "flag", "it", "don", "fail", "completely", "as", "partial", "ast", "is", "often", "useful", "errors", "append", "tree", "sitter", "reported", "syntax", "errors", "in", "file", "return", "parse", "result", "file", "path", "str", "file", "path", "entities", "entities", "relationships", "relationships", "errors", "errors"], "metadata": {"kind": "method", "chunk_index": "2", "has_docstring": "true", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/base.py::TreeSitterParser._extract_entities::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/base.py::TreeSitterParser._extract_entities", "content": "def _extract_entities(self, node: Any, file_path: Path, parent_id: str, source_code: str, source_lines: list[str]) -> tuple[list[Entity], list[Relationship]]\n\"\"\"Extract entities from the AST. Must be implemented by subclasses.\n\nArgs:\n    node: Current AST node to process.\n    file_path: Path to the file being parsed.\n    parent_id: ID of the parent entity (for containment).\n    source_code: Full source code text.\n    source_lines: Source code split by lines.\n    \nReturns:\n    Tuple of (entities list, relationships list).\"\"\"\n    def _extract_entities(\n        self,\n        node: Any,\n        file_path: Path,\n        parent_id: str,\n        source_code: str,\n        source_lines: list[str],\n    ) -> tuple[list[Entity], list[Relationship]]:\n        \"\"\"Extract entities from the AST. Must be implemented by subclasses.\n        \n        Args:\n            node: Current AST node to process.\n            file_path: Path to the file being parsed.\n            parent_id: ID of the parent entity (for", "tokens": ["def", "extract", "entities", "self", "node", "any", "file", "path", "path", "parent", "id", "str", "source", "code", "str", "source", "lines", "list", "str", "tuple", "list", "entity", "list", "relationship", "extract", "entities", "from", "the", "ast", "must", "be", "implemented", "by", "subclasses", "args", "node", "current", "ast", "node", "to", "process", "file", "path", "path", "to", "the", "file", "being", "parsed", "parent", "id", "id", "of", "the", "parent", "entity", "for", "containment", "source", "code", "full", "source", "code", "text", "source", "lines", "source", "code", "split", "by", "lines", "returns", "tuple", "of", "entities", "list", "relationships", "list", "def", "extract", "entities", "self", "node", "any", "file", "path", "path", "parent", "id", "str", "source", "code", "str", "source", "lines", "list", "str", "tuple", "list", "entity", "list", "relationship", "extract", "entities", "from", "the", "ast", "must", "be", "implemented", "by", "subclasses", "args", "node", "current", "ast", "node", "to", "process", "file", "path", "path", "to", "the", "file", "being", "parsed", "parent", "id", "id", "of", "the", "parent", "entity", "for"], "metadata": {"kind": "method", "chunk_index": "0", "has_docstring": "true", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/base.py::TreeSitterParser._extract_entities::1", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/base.py::TreeSitterParser._extract_entities", "content": "       file_path: Path to the file being parsed.\n            parent_id: ID of the parent entity (for containment).\n            source_code: Full source code text.\n            source_lines: Source code split by lines.\n            \n        Returns:\n            Tuple of (entities list, relationships list).\n        \"\"\"\n        raise NotImplementedError", "tokens": ["file", "path", "path", "to", "the", "file", "being", "parsed", "parent", "id", "id", "of", "the", "parent", "entity", "for", "containment", "source", "code", "full", "source", "code", "text", "source", "lines", "source", "code", "split", "by", "lines", "returns", "tuple", "of", "entities", "list", "relationships", "list", "raise", "not", "implemented", "error"], "metadata": {"kind": "method", "chunk_index": "1", "has_docstring": "true", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/base.py::TreeSitterParser._get_text::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/base.py::TreeSitterParser._get_text", "content": "def _get_text(self, node: Any, source_bytes: bytes) -> str\n\"\"\"Get text content of a node.\"\"\"\n    def _get_text(self, node: Any, source_bytes: bytes) -> str:\n        \"\"\"Get text content of a node.\"\"\"\n        return node.text.decode(\"utf8\")", "tokens": ["def", "get", "text", "self", "node", "any", "source", "bytes", "bytes", "str", "get", "text", "content", "of", "node", "def", "get", "text", "self", "node", "any", "source", "bytes", "bytes", "str", "get", "text", "content", "of", "node", "return", "node", "text", "decode", "utf8"], "metadata": {"kind": "method", "has_docstring": "true", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/base.py::TreeSitterParser._get_location::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/base.py::TreeSitterParser._get_location", "content": "def _get_location(self, node: Any, file_path: Path) -> Location\n\"\"\"Get location object for a node.\"\"\"\n    def _get_location(self, node: Any, file_path: Path) -> Location:\n        \"\"\"Get location object for a node.\"\"\"\n        return Location(\n            file_path=str(file_path),\n            line_start=node.start_point[0] + 1,\n            line_end=node.end_point[0] + 1,\n            column_start=node.start_point[1],\n            column_end=node.end_point[1],\n        )", "tokens": ["def", "get", "location", "self", "node", "any", "file", "path", "path", "location", "get", "location", "object", "for", "node", "def", "get", "location", "self", "node", "any", "file", "path", "path", "location", "get", "location", "object", "for", "node", "return", "location", "file", "path", "str", "file", "path", "line", "start", "node", "start", "point", "line", "end", "node", "end", "point", "column", "start", "node", "start", "point", "column", "end", "node", "end", "point"], "metadata": {"kind": "method", "has_docstring": "true", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/base.py::TreeSitterParser._create_entity::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/base.py::TreeSitterParser._create_entity", "content": "def _create_entity(self, node: Any, kind: EntityKind, name: str, qualified_name: str, file_path: Path, source_lines: list[str], docstring: Optional[str], signature: Optional[str]) -> Entity\n\"\"\"Helper to create an entity.\"\"\"\n    def _create_entity(\n        self,\n        node: Any,\n        kind: EntityKind,\n        name: str,\n        qualified_name: str,\n        file_path: Path,\n        source_lines: list[str],\n        docstring: Optional[str] = None,\n        signature: Optional[str] = None,\n    ) -> Entity:\n        \"\"\"Helper to create an entity.\"\"\"\n        # Extract source code for the node\n        start_line = node.start_point[0]\n        end_line = node.end_point[0] + 1\n        node_source = \"\\n\".join(source_lines[start_line:end_line])\n\n        return Entity(\n            id=f\"{file_path}::{qualified_name}\",\n            kind=kind,\n            name=name,\n            qualified_name=qualified_name,\n            location=self._get_location(node, file_path),\n            docstring=docstring,\n ", "tokens": ["def", "create", "entity", "self", "node", "any", "kind", "entity", "kind", "name", "str", "qualified", "name", "str", "file", "path", "path", "source", "lines", "list", "str", "docstring", "optional", "str", "signature", "optional", "str", "entity", "helper", "to", "create", "an", "entity", "def", "create", "entity", "self", "node", "any", "kind", "entity", "kind", "name", "str", "qualified", "name", "str", "file", "path", "path", "source", "lines", "list", "str", "docstring", "optional", "str", "none", "signature", "optional", "str", "none", "entity", "helper", "to", "create", "an", "entity", "extract", "source", "code", "for", "the", "node", "start", "line", "node", "start", "point", "end", "line", "node", "end", "point", "node", "source", "join", "source", "lines", "start", "line", "end", "line", "return", "entity", "id", "file", "path", "qualified", "name", "kind", "kind", "name", "name", "qualified", "name", "qualified", "name", "location", "self", "get", "location", "node", "file", "path", "docstring", "docstring"], "metadata": {"kind": "method", "chunk_index": "0", "has_docstring": "true", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/base.py::TreeSitterParser._create_entity::1", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/base.py::TreeSitterParser._create_entity", "content": "d_name,\n            location=self._get_location(node, file_path),\n            docstring=docstring,\n            signature=signature,\n            source_code=node_source,\n        )", "tokens": ["name", "location", "self", "get", "location", "node", "file", "path", "docstring", "docstring", "signature", "signature", "source", "code", "node", "source"], "metadata": {"kind": "method", "chunk_index": "1", "has_docstring": "true", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/yaml_parser.py::module::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/yaml_parser.py::module", "content": "\"\"\"YAML configuration file parser.\"\"\"", "tokens": ["yaml", "configuration", "file", "parser"], "metadata": {"type": "module_header"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/yaml_parser.py::imports::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/yaml_parser.py::module", "content": "from __future__ import annotations\nfrom pathlib import Path\nfrom typing import Any\nimport yaml\nfrom knowcode.data_models import (", "tokens": ["from", "future", "import", "annotations", "from", "pathlib", "import", "path", "from", "typing", "import", "any", "import", "yaml", "from", "knowcode", "data", "models", "import"], "metadata": {"type": "imports"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/yaml_parser.py::YamlParser::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/yaml_parser.py::YamlParser", "content": "\"\"\"Parses YAML files into configuration key entities.\"\"\"\nclass YamlParser:\n    \"\"\"Parses YAML files into configuration key entities.\"\"\"\n\n    def parse_file(self, file_path: str | Path) -> ParseResult:\n        \"\"\"Parse a YAML file.\n\n        Args:\n            file_path: Path to the YAML file.\n\n        Returns:\n            ParseResult with config key entities.\n        \"\"\"\n        file_path = Path(file_path)\n        errors: list[str] = []\n\n        try:\n            content = file_path.read_text(encoding=\"utf-8\")\n        except Exception as e:\n            return ParseResult(\n                file_path=str(file_path),\n                entities=[],\n                relationships=[],\n                errors=[f\"Failed to read file: {e}\"],\n            )\n\n        try:\n            data = yaml.safe_load(content)\n        except yaml.YAMLError as e:\n            return ParseResult(\n                file_path=str(file_path),\n                entities=[],\n                relationships=[],\n                error", "tokens": ["parses", "yaml", "files", "into", "configuration", "key", "entities", "class", "yaml", "parser", "parses", "yaml", "files", "into", "configuration", "key", "entities", "def", "parse", "file", "self", "file", "path", "str", "path", "parse", "result", "parse", "yaml", "file", "args", "file", "path", "path", "to", "the", "yaml", "file", "returns", "parse", "result", "with", "config", "key", "entities", "file", "path", "path", "file", "path", "errors", "list", "str", "try", "content", "file", "path", "read", "text", "encoding", "utf", "except", "exception", "as", "return", "parse", "result", "file", "path", "str", "file", "path", "entities", "relationships", "errors", "failed", "to", "read", "file", "try", "data", "yaml", "safe", "load", "content", "except", "yaml", "yamlerror", "as", "return", "parse", "result", "file", "path", "str", "file", "path", "entities", "relationships", "error"], "metadata": {"kind": "class", "chunk_index": "0", "has_docstring": "true", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/yaml_parser.py::YamlParser::1", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/yaml_parser.py::YamlParser", "content": "str(file_path),\n                entities=[],\n                relationships=[],\n                errors=[f\"YAML parse error: {e}\"],\n            )\n\n        if data is None:\n            data = {}\n\n        entities: list[Entity] = []\n        relationships: list[Relationship] = []\n        lines = content.splitlines()\n\n        # Create document entity\n        doc_name = file_path.stem\n        doc_id = f\"{file_path}::{doc_name}\"\n\n        doc_entity = Entity(\n            id=doc_id,\n            kind=EntityKind.DOCUMENT,\n            name=doc_name,\n            qualified_name=doc_name,\n            location=Location(\n                file_path=str(file_path),\n                line_start=1,\n                line_end=len(lines),\n            ),\n        )\n        entities.append(doc_entity)\n\n        # Extract config keys recursively\n        if isinstance(data, dict):\n            self._extract_keys(\n                data=data,\n                file_path=file_path,\n                parent_id=doc_id,\n           ", "tokens": ["str", "file", "path", "entities", "relationships", "errors", "yaml", "parse", "error", "if", "data", "is", "none", "data", "entities", "list", "entity", "relationships", "list", "relationship", "lines", "content", "splitlines", "create", "document", "entity", "doc", "name", "file", "path", "stem", "doc", "id", "file", "path", "doc", "name", "doc", "entity", "entity", "id", "doc", "id", "kind", "entity", "kind", "document", "name", "doc", "name", "qualified", "name", "doc", "name", "location", "location", "file", "path", "str", "file", "path", "line", "start", "line", "end", "len", "lines", "entities", "append", "doc", "entity", "extract", "config", "keys", "recursively", "if", "isinstance", "data", "dict", "self", "extract", "keys", "data", "data", "file", "path", "file", "path", "parent", "id", "doc", "id"], "metadata": {"kind": "class", "chunk_index": "1", "has_docstring": "true", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/yaml_parser.py::YamlParser::2", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/yaml_parser.py::YamlParser", "content": "       data=data,\n                file_path=file_path,\n                parent_id=doc_id,\n                prefix=\"\",\n                entities=entities,\n                relationships=relationships,\n                lines=lines,\n            )\n\n        return ParseResult(\n            file_path=str(file_path),\n            entities=entities,\n            relationships=relationships,\n            errors=errors,\n        )\n\n    def _extract_keys(\n        self,\n        data: dict[str, Any],\n        file_path: Path,\n        parent_id: str,\n        prefix: str,\n        entities: list[Entity],\n        relationships: list[Relationship],\n        lines: list[str],\n    ) -> None:\n        \"\"\"Recursively extract configuration keys.\"\"\"\n        for key, value in data.items():\n            str_key = str(key)\n            qualified_name = f\"{prefix}{str_key}\" if prefix else str_key\n            key_id = f\"{file_path}::{qualified_name}\"\n\n            # Try to find line number for this key\n            line_num = self", "tokens": ["data", "data", "file", "path", "file", "path", "parent", "id", "doc", "id", "prefix", "entities", "entities", "relationships", "relationships", "lines", "lines", "return", "parse", "result", "file", "path", "str", "file", "path", "entities", "entities", "relationships", "relationships", "errors", "errors", "def", "extract", "keys", "self", "data", "dict", "str", "any", "file", "path", "path", "parent", "id", "str", "prefix", "str", "entities", "list", "entity", "relationships", "list", "relationship", "lines", "list", "str", "none", "recursively", "extract", "configuration", "keys", "for", "key", "value", "in", "data", "items", "str", "key", "str", "key", "qualified", "name", "prefix", "str", "key", "if", "prefix", "else", "str", "key", "key", "id", "file", "path", "qualified", "name", "try", "to", "find", "line", "number", "for", "this", "key", "line", "num", "self"], "metadata": {"kind": "class", "chunk_index": "2", "has_docstring": "true", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/yaml_parser.py::YamlParser::3", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/yaml_parser.py::YamlParser", "content": "}::{qualified_name}\"\n\n            # Try to find line number for this key\n            line_num = self._find_key_line(str_key, prefix, lines)\n\n            # Determine value representation\n            if isinstance(value, dict):\n                value_repr = \"{...}\"\n            elif isinstance(value, list):\n                value_repr = f\"[{len(value)} items]\"\n            else:\n                value_repr = str(value)[:100]\n\n            key_entity = Entity(\n                id=key_id,\n                kind=EntityKind.CONFIG_KEY,\n                name=str_key,\n                qualified_name=qualified_name,\n                location=Location(\n                    file_path=str(file_path),\n                    line_start=line_num,\n                    line_end=line_num,\n                ),\n                metadata={\n                    \"value_type\": type(value).__name__,\n                    \"value_preview\": value_repr,\n                },\n            )\n            entities.append(key_entity)\n\n          ", "tokens": ["qualified", "name", "try", "to", "find", "line", "number", "for", "this", "key", "line", "num", "self", "find", "key", "line", "str", "key", "prefix", "lines", "determine", "value", "representation", "if", "isinstance", "value", "dict", "value", "repr", "elif", "isinstance", "value", "list", "value", "repr", "len", "value", "items", "else", "value", "repr", "str", "value", "100", "key", "entity", "entity", "id", "key", "id", "kind", "entity", "kind", "config", "key", "name", "str", "key", "qualified", "name", "qualified", "name", "location", "location", "file", "path", "str", "file", "path", "line", "start", "line", "num", "line", "end", "line", "num", "metadata", "value", "type", "type", "value", "name", "value", "preview", "value", "repr", "entities", "append", "key", "entity"], "metadata": {"kind": "class", "chunk_index": "3", "has_docstring": "true", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/yaml_parser.py::YamlParser::4", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/yaml_parser.py::YamlParser", "content": "w\": value_repr,\n                },\n            )\n            entities.append(key_entity)\n\n            # Add contains relationship\n            relationships.append(\n                Relationship(\n                    source_id=parent_id,\n                    target_id=key_id,\n                    kind=RelationshipKind.CONTAINS,\n                )\n            )\n\n            # Recurse into nested dicts\n            if isinstance(value, dict):\n                self._extract_keys(\n                    data=value,\n                    file_path=file_path,\n                    parent_id=key_id,\n                    prefix=f\"{qualified_name}.\",\n                    entities=entities,\n                    relationships=relationships,\n                    lines=lines,\n                )\n\n    def _find_key_line(\n        self, key: str, prefix: str, lines: list[str]\n    ) -> int:\n        \"\"\"Try to find the line number for a key.\n        \n        Note: This is a simple heuristic that searches for \"key:\" matches.\n", "tokens": ["value", "repr", "entities", "append", "key", "entity", "add", "contains", "relationship", "relationships", "append", "relationship", "source", "id", "parent", "id", "target", "id", "key", "id", "kind", "relationship", "kind", "contains", "recurse", "into", "nested", "dicts", "if", "isinstance", "value", "dict", "self", "extract", "keys", "data", "value", "file", "path", "file", "path", "parent", "id", "key", "id", "prefix", "qualified", "name", "entities", "entities", "relationships", "relationships", "lines", "lines", "def", "find", "key", "line", "self", "key", "str", "prefix", "str", "lines", "list", "str", "int", "try", "to", "find", "the", "line", "number", "for", "key", "note", "this", "is", "simple", "heuristic", "that", "searches", "for", "key", "matches"], "metadata": {"kind": "class", "chunk_index": "4", "has_docstring": "true", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/yaml_parser.py::YamlParser::5", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/yaml_parser.py::YamlParser", "content": "mber for a key.\n        \n        Note: This is a simple heuristic that searches for \"key:\" matches.\n        It attempts to verify indentation depth but may fail on:\n        - Duplicate keys at similar indentation (valid in some contexts, or invalid YAML)\n        - Keys inside multiline strings\n        - Commented out keys that look like real keys\n        \"\"\"\n        # Simple heuristic: find first occurrence of \"key:\"\n        search_pattern = f\"{key}:\"\n\n        # Calculate expected indentation from prefix depth\n        depth = prefix.count(\".\") if prefix else 0\n\n        for i, line in enumerate(lines, start=1):\n            stripped = line.lstrip()\n            if stripped.startswith(search_pattern):\n                # Check approximate indentation level\n                indent = len(line) - len(stripped)\n                expected_indent = depth * 2  # Assuming 2-space indent\n                if abs(indent - expected_indent) <= 2:\n                    return i\n\n        return 1  # Default to l", "tokens": ["mber", "for", "key", "note", "this", "is", "simple", "heuristic", "that", "searches", "for", "key", "matches", "it", "attempts", "to", "verify", "indentation", "depth", "but", "may", "fail", "on", "duplicate", "keys", "at", "similar", "indentation", "valid", "in", "some", "contexts", "or", "invalid", "yaml", "keys", "inside", "multiline", "strings", "commented", "out", "keys", "that", "look", "like", "real", "keys", "simple", "heuristic", "find", "first", "occurrence", "of", "key", "search", "pattern", "key", "calculate", "expected", "indentation", "from", "prefix", "depth", "depth", "prefix", "count", "if", "prefix", "else", "for", "line", "in", "enumerate", "lines", "start", "stripped", "line", "lstrip", "if", "stripped", "startswith", "search", "pattern", "check", "approximate", "indentation", "level", "indent", "len", "line", "len", "stripped", "expected", "indent", "depth", "assuming", "space", "indent", "if", "abs", "indent", "expected", "indent", "return", "return", "default", "to"], "metadata": {"kind": "class", "chunk_index": "5", "has_docstring": "true", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/yaml_parser.py::YamlParser::6", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/yaml_parser.py::YamlParser", "content": "f abs(indent - expected_indent) <= 2:\n                    return i\n\n        return 1  # Default to line 1 if not found", "tokens": ["abs", "indent", "expected", "indent", "return", "return", "default", "to", "line", "if", "not", "found"], "metadata": {"kind": "class", "chunk_index": "6", "has_docstring": "true", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/yaml_parser.py::YamlParser.parse_file::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/yaml_parser.py::YamlParser.parse_file", "content": "def parse_file(self, file_path: str | Path) -> ParseResult\n\"\"\"Parse a YAML file.\n\nArgs:\n    file_path: Path to the YAML file.\n\nReturns:\n    ParseResult with config key entities.\"\"\"\n    def parse_file(self, file_path: str | Path) -> ParseResult:\n        \"\"\"Parse a YAML file.\n\n        Args:\n            file_path: Path to the YAML file.\n\n        Returns:\n            ParseResult with config key entities.\n        \"\"\"\n        file_path = Path(file_path)\n        errors: list[str] = []\n\n        try:\n            content = file_path.read_text(encoding=\"utf-8\")\n        except Exception as e:\n            return ParseResult(\n                file_path=str(file_path),\n                entities=[],\n                relationships=[],\n                errors=[f\"Failed to read file: {e}\"],\n            )\n\n        try:\n            data = yaml.safe_load(content)\n        except yaml.YAMLError as e:\n            return ParseResult(\n                file_path=str(file_path),\n                entities=[],\n           ", "tokens": ["def", "parse", "file", "self", "file", "path", "str", "path", "parse", "result", "parse", "yaml", "file", "args", "file", "path", "path", "to", "the", "yaml", "file", "returns", "parse", "result", "with", "config", "key", "entities", "def", "parse", "file", "self", "file", "path", "str", "path", "parse", "result", "parse", "yaml", "file", "args", "file", "path", "path", "to", "the", "yaml", "file", "returns", "parse", "result", "with", "config", "key", "entities", "file", "path", "path", "file", "path", "errors", "list", "str", "try", "content", "file", "path", "read", "text", "encoding", "utf", "except", "exception", "as", "return", "parse", "result", "file", "path", "str", "file", "path", "entities", "relationships", "errors", "failed", "to", "read", "file", "try", "data", "yaml", "safe", "load", "content", "except", "yaml", "yamlerror", "as", "return", "parse", "result", "file", "path", "str", "file", "path", "entities"], "metadata": {"kind": "method", "chunk_index": "0", "has_docstring": "true", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/yaml_parser.py::YamlParser.parse_file::1", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/yaml_parser.py::YamlParser.parse_file", "content": "turn ParseResult(\n                file_path=str(file_path),\n                entities=[],\n                relationships=[],\n                errors=[f\"YAML parse error: {e}\"],\n            )\n\n        if data is None:\n            data = {}\n\n        entities: list[Entity] = []\n        relationships: list[Relationship] = []\n        lines = content.splitlines()\n\n        # Create document entity\n        doc_name = file_path.stem\n        doc_id = f\"{file_path}::{doc_name}\"\n\n        doc_entity = Entity(\n            id=doc_id,\n            kind=EntityKind.DOCUMENT,\n            name=doc_name,\n            qualified_name=doc_name,\n            location=Location(\n                file_path=str(file_path),\n                line_start=1,\n                line_end=len(lines),\n            ),\n        )\n        entities.append(doc_entity)\n\n        # Extract config keys recursively\n        if isinstance(data, dict):\n            self._extract_keys(\n                data=data,\n                file_path=file_path,\n ", "tokens": ["turn", "parse", "result", "file", "path", "str", "file", "path", "entities", "relationships", "errors", "yaml", "parse", "error", "if", "data", "is", "none", "data", "entities", "list", "entity", "relationships", "list", "relationship", "lines", "content", "splitlines", "create", "document", "entity", "doc", "name", "file", "path", "stem", "doc", "id", "file", "path", "doc", "name", "doc", "entity", "entity", "id", "doc", "id", "kind", "entity", "kind", "document", "name", "doc", "name", "qualified", "name", "doc", "name", "location", "location", "file", "path", "str", "file", "path", "line", "start", "line", "end", "len", "lines", "entities", "append", "doc", "entity", "extract", "config", "keys", "recursively", "if", "isinstance", "data", "dict", "self", "extract", "keys", "data", "data", "file", "path", "file", "path"], "metadata": {"kind": "method", "chunk_index": "1", "has_docstring": "true", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/yaml_parser.py::YamlParser.parse_file::2", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/yaml_parser.py::YamlParser.parse_file", "content": "):\n            self._extract_keys(\n                data=data,\n                file_path=file_path,\n                parent_id=doc_id,\n                prefix=\"\",\n                entities=entities,\n                relationships=relationships,\n                lines=lines,\n            )\n\n        return ParseResult(\n            file_path=str(file_path),\n            entities=entities,\n            relationships=relationships,\n            errors=errors,\n        )", "tokens": ["self", "extract", "keys", "data", "data", "file", "path", "file", "path", "parent", "id", "doc", "id", "prefix", "entities", "entities", "relationships", "relationships", "lines", "lines", "return", "parse", "result", "file", "path", "str", "file", "path", "entities", "entities", "relationships", "relationships", "errors", "errors"], "metadata": {"kind": "method", "chunk_index": "2", "has_docstring": "true", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/yaml_parser.py::YamlParser._extract_keys::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/yaml_parser.py::YamlParser._extract_keys", "content": "def _extract_keys(self, data: dict[str, Any], file_path: Path, parent_id: str, prefix: str, entities: list[Entity], relationships: list[Relationship], lines: list[str]) -> None\n\"\"\"Recursively extract configuration keys.\"\"\"\n    def _extract_keys(\n        self,\n        data: dict[str, Any],\n        file_path: Path,\n        parent_id: str,\n        prefix: str,\n        entities: list[Entity],\n        relationships: list[Relationship],\n        lines: list[str],\n    ) -> None:\n        \"\"\"Recursively extract configuration keys.\"\"\"\n        for key, value in data.items():\n            str_key = str(key)\n            qualified_name = f\"{prefix}{str_key}\" if prefix else str_key\n            key_id = f\"{file_path}::{qualified_name}\"\n\n            # Try to find line number for this key\n            line_num = self._find_key_line(str_key, prefix, lines)\n\n            # Determine value representation\n            if isinstance(value, dict):\n                value_repr = \"{...}\"\n            elif isinstance(va", "tokens": ["def", "extract", "keys", "self", "data", "dict", "str", "any", "file", "path", "path", "parent", "id", "str", "prefix", "str", "entities", "list", "entity", "relationships", "list", "relationship", "lines", "list", "str", "none", "recursively", "extract", "configuration", "keys", "def", "extract", "keys", "self", "data", "dict", "str", "any", "file", "path", "path", "parent", "id", "str", "prefix", "str", "entities", "list", "entity", "relationships", "list", "relationship", "lines", "list", "str", "none", "recursively", "extract", "configuration", "keys", "for", "key", "value", "in", "data", "items", "str", "key", "str", "key", "qualified", "name", "prefix", "str", "key", "if", "prefix", "else", "str", "key", "key", "id", "file", "path", "qualified", "name", "try", "to", "find", "line", "number", "for", "this", "key", "line", "num", "self", "find", "key", "line", "str", "key", "prefix", "lines", "determine", "value", "representation", "if", "isinstance", "value", "dict", "value", "repr", "elif", "isinstance", "va"], "metadata": {"kind": "method", "chunk_index": "0", "has_docstring": "true", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/yaml_parser.py::YamlParser._extract_keys::1", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/yaml_parser.py::YamlParser._extract_keys", "content": "     if isinstance(value, dict):\n                value_repr = \"{...}\"\n            elif isinstance(value, list):\n                value_repr = f\"[{len(value)} items]\"\n            else:\n                value_repr = str(value)[:100]\n\n            key_entity = Entity(\n                id=key_id,\n                kind=EntityKind.CONFIG_KEY,\n                name=str_key,\n                qualified_name=qualified_name,\n                location=Location(\n                    file_path=str(file_path),\n                    line_start=line_num,\n                    line_end=line_num,\n                ),\n                metadata={\n                    \"value_type\": type(value).__name__,\n                    \"value_preview\": value_repr,\n                },\n            )\n            entities.append(key_entity)\n\n            # Add contains relationship\n            relationships.append(\n                Relationship(\n                    source_id=parent_id,\n                    target_id=key_id,\n                    ", "tokens": ["if", "isinstance", "value", "dict", "value", "repr", "elif", "isinstance", "value", "list", "value", "repr", "len", "value", "items", "else", "value", "repr", "str", "value", "100", "key", "entity", "entity", "id", "key", "id", "kind", "entity", "kind", "config", "key", "name", "str", "key", "qualified", "name", "qualified", "name", "location", "location", "file", "path", "str", "file", "path", "line", "start", "line", "num", "line", "end", "line", "num", "metadata", "value", "type", "type", "value", "name", "value", "preview", "value", "repr", "entities", "append", "key", "entity", "add", "contains", "relationship", "relationships", "append", "relationship", "source", "id", "parent", "id", "target", "id", "key", "id"], "metadata": {"kind": "method", "chunk_index": "1", "has_docstring": "true", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/yaml_parser.py::YamlParser._extract_keys::2", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/yaml_parser.py::YamlParser._extract_keys", "content": "\n                    source_id=parent_id,\n                    target_id=key_id,\n                    kind=RelationshipKind.CONTAINS,\n                )\n            )\n\n            # Recurse into nested dicts\n            if isinstance(value, dict):\n                self._extract_keys(\n                    data=value,\n                    file_path=file_path,\n                    parent_id=key_id,\n                    prefix=f\"{qualified_name}.\",\n                    entities=entities,\n                    relationships=relationships,\n                    lines=lines,\n                )", "tokens": ["source", "id", "parent", "id", "target", "id", "key", "id", "kind", "relationship", "kind", "contains", "recurse", "into", "nested", "dicts", "if", "isinstance", "value", "dict", "self", "extract", "keys", "data", "value", "file", "path", "file", "path", "parent", "id", "key", "id", "prefix", "qualified", "name", "entities", "entities", "relationships", "relationships", "lines", "lines"], "metadata": {"kind": "method", "chunk_index": "2", "has_docstring": "true", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/yaml_parser.py::YamlParser._find_key_line::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/yaml_parser.py::YamlParser._find_key_line", "content": "def _find_key_line(self, key: str, prefix: str, lines: list[str]) -> int\n\"\"\"Try to find the line number for a key.\n\nNote: This is a simple heuristic that searches for \"key:\" matches.\nIt attempts to verify indentation depth but may fail on:\n- Duplicate keys at similar indentation (valid in some contexts, or invalid YAML)\n- Keys inside multiline strings\n- Commented out keys that look like real keys\"\"\"\n    def _find_key_line(\n        self, key: str, prefix: str, lines: list[str]\n    ) -> int:\n        \"\"\"Try to find the line number for a key.\n        \n        Note: This is a simple heuristic that searches for \"key:\" matches.\n        It attempts to verify indentation depth but may fail on:\n        - Duplicate keys at similar indentation (valid in some contexts, or invalid YAML)\n        - Keys inside multiline strings\n        - Commented out keys that look like real keys\n        \"\"\"\n        # Simple heuristic: find first occurrence of \"key:\"\n        search_pattern = f\"{key}:\"\n\n        # Calc", "tokens": ["def", "find", "key", "line", "self", "key", "str", "prefix", "str", "lines", "list", "str", "int", "try", "to", "find", "the", "line", "number", "for", "key", "note", "this", "is", "simple", "heuristic", "that", "searches", "for", "key", "matches", "it", "attempts", "to", "verify", "indentation", "depth", "but", "may", "fail", "on", "duplicate", "keys", "at", "similar", "indentation", "valid", "in", "some", "contexts", "or", "invalid", "yaml", "keys", "inside", "multiline", "strings", "commented", "out", "keys", "that", "look", "like", "real", "keys", "def", "find", "key", "line", "self", "key", "str", "prefix", "str", "lines", "list", "str", "int", "try", "to", "find", "the", "line", "number", "for", "key", "note", "this", "is", "simple", "heuristic", "that", "searches", "for", "key", "matches", "it", "attempts", "to", "verify", "indentation", "depth", "but", "may", "fail", "on", "duplicate", "keys", "at", "similar", "indentation", "valid", "in", "some", "contexts", "or", "invalid", "yaml", "keys", "inside", "multiline", "strings", "commented", "out", "keys", "that", "look", "like", "real", "keys", "simple", "heuristic", "find", "first", "occurrence", "of", "key", "search", "pattern", "key", "calc"], "metadata": {"kind": "method", "chunk_index": "0", "has_docstring": "true", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/yaml_parser.py::YamlParser._find_key_line::1", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/yaml_parser.py::YamlParser._find_key_line", "content": "Simple heuristic: find first occurrence of \"key:\"\n        search_pattern = f\"{key}:\"\n\n        # Calculate expected indentation from prefix depth\n        depth = prefix.count(\".\") if prefix else 0\n\n        for i, line in enumerate(lines, start=1):\n            stripped = line.lstrip()\n            if stripped.startswith(search_pattern):\n                # Check approximate indentation level\n                indent = len(line) - len(stripped)\n                expected_indent = depth * 2  # Assuming 2-space indent\n                if abs(indent - expected_indent) <= 2:\n                    return i\n\n        return 1  # Default to line 1 if not found", "tokens": ["simple", "heuristic", "find", "first", "occurrence", "of", "key", "search", "pattern", "key", "calculate", "expected", "indentation", "from", "prefix", "depth", "depth", "prefix", "count", "if", "prefix", "else", "for", "line", "in", "enumerate", "lines", "start", "stripped", "line", "lstrip", "if", "stripped", "startswith", "search", "pattern", "check", "approximate", "indentation", "level", "indent", "len", "line", "len", "stripped", "expected", "indent", "depth", "assuming", "space", "indent", "if", "abs", "indent", "expected", "indent", "return", "return", "default", "to", "line", "if", "not", "found"], "metadata": {"kind": "method", "chunk_index": "1", "has_docstring": "true", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/__init__.py::module::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/__init__.py::module", "content": "\"\"\"Parsers package for different file types.\"\"\"", "tokens": ["parsers", "package", "for", "different", "file", "types"], "metadata": {"type": "module_header"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/__init__.py::imports::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/__init__.py::module", "content": "from knowcode.parsers.python_parser import PythonParser\nfrom knowcode.parsers.markdown_parser import MarkdownParser\nfrom knowcode.parsers.yaml_parser import YamlParser", "tokens": ["from", "knowcode", "parsers", "python", "parser", "import", "python", "parser", "from", "knowcode", "parsers", "markdown", "parser", "import", "markdown", "parser", "from", "knowcode", "parsers", "yaml", "parser", "import", "yaml", "parser"], "metadata": {"type": "imports"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/java_parser.py::module::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/java_parser.py::module", "content": "\"\"\"Java parser using Tree-sitter.\"\"\"", "tokens": ["java", "parser", "using", "tree", "sitter"], "metadata": {"type": "module_header"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/java_parser.py::imports::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/java_parser.py::module", "content": "from pathlib import Path\nfrom typing import Any\nfrom knowcode.data_models import Entity, EntityKind, Relationship, RelationshipKind\nfrom knowcode.parsers.base import TreeSitterParser", "tokens": ["from", "pathlib", "import", "path", "from", "typing", "import", "any", "from", "knowcode", "data", "models", "import", "entity", "entity", "kind", "relationship", "relationship", "kind", "from", "knowcode", "parsers", "base", "import", "tree", "sitter", "parser"], "metadata": {"type": "imports"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/java_parser.py::JavaParser::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/java_parser.py::JavaParser", "content": "\"\"\"Parses Java files.\"\"\"\nclass JavaParser(TreeSitterParser):\n    \"\"\"Parses Java files.\"\"\"\n\n    def __init__(self) -> None:\n        \"\"\"Initialize Java parser.\"\"\"\n        super().__init__(\"java\")\n\n    def _extract_entities(\n        self,\n        node: Any,\n        file_path: Path,\n        parent_id: str,\n        source_code: str,\n        source_lines: list[str],\n    ) -> tuple[list[Entity], list[Relationship]]:\n        \"\"\"Extract entities from Java AST.\"\"\"\n        entities: list[Entity] = []\n        relationships: list[Relationship] = []\n\n\n        \n        # In Java, file usually maps to a class, but we have a module entity for the file anyway.\n        # Package declaration defines the logic module/package.\n        \n        for child in node.children:\n            child_type = child.type\n            \n            if child_type == \"package_declaration\":\n                # package com.example;\n                # This informs the \"qualified name\" of subsequent classes\n                pass \n    ", "tokens": ["parses", "java", "files", "class", "java", "parser", "tree", "sitter", "parser", "parses", "java", "files", "def", "init", "self", "none", "initialize", "java", "parser", "super", "init", "java", "def", "extract", "entities", "self", "node", "any", "file", "path", "path", "parent", "id", "str", "source", "code", "str", "source", "lines", "list", "str", "tuple", "list", "entity", "list", "relationship", "extract", "entities", "from", "java", "ast", "entities", "list", "entity", "relationships", "list", "relationship", "in", "java", "file", "usually", "maps", "to", "class", "but", "we", "have", "module", "entity", "for", "the", "file", "anyway", "package", "declaration", "defines", "the", "logic", "module", "package", "for", "child", "in", "node", "children", "child", "type", "child", "type", "if", "child", "type", "package", "declaration", "package", "com", "example", "this", "informs", "the", "qualified", "name", "of", "subsequent", "classes", "pass"], "metadata": {"kind": "class", "chunk_index": "0", "has_docstring": "true", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/java_parser.py::JavaParser::1", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/java_parser.py::JavaParser", "content": "                # This informs the \"qualified name\" of subsequent classes\n                pass \n                \n            elif child_type == \"import_declaration\":\n                # import java.util.List;\n                # No field name 'name', just find the identifier or scoped_identifier\n                name_node = None\n                for c in child.children:\n                    if c.type in (\"scoped_identifier\", \"identifier\"):\n                        name_node = c\n                        break\n                \n                if name_node:\n                    imported_name = self._get_text(name_node, None)\n                    relationships.append(\n                        Relationship(\n                            source_id=parent_id,\n                            target_id=f\"external::{imported_name}\",\n                            kind=RelationshipKind.IMPORTS\n                        )\n                    )\n            \n            elif child_type == \"class_declaration\":\n            ", "tokens": ["this", "informs", "the", "qualified", "name", "of", "subsequent", "classes", "pass", "elif", "child", "type", "import", "declaration", "import", "java", "util", "list", "no", "field", "name", "name", "just", "find", "the", "identifier", "or", "scoped", "identifier", "name", "node", "none", "for", "in", "child", "children", "if", "type", "in", "scoped", "identifier", "identifier", "name", "node", "break", "if", "name", "node", "imported", "name", "self", "get", "text", "name", "node", "none", "relationships", "append", "relationship", "source", "id", "parent", "id", "target", "id", "external", "imported", "name", "kind", "relationship", "kind", "imports", "elif", "child", "type", "class", "declaration"], "metadata": {"kind": "class", "chunk_index": "1", "has_docstring": "true", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/java_parser.py::JavaParser::2", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/java_parser.py::JavaParser", "content": "\n                    )\n            \n            elif child_type == \"class_declaration\":\n                class_entities, class_rels = self._parse_class(\n                    child, file_path, parent_id, source_code, source_lines\n                )\n                entities.extend(class_entities)\n                relationships.extend(class_rels)\n                \n            elif child_type == \"interface_declaration\":\n                 # Treat interface as class for MVP\n                class_entities, class_rels = self._parse_class(\n                    child, file_path, parent_id, source_code, source_lines, kind=EntityKind.CLASS\n                )\n                entities.extend(class_entities)\n                relationships.extend(class_rels)\n\n        return entities, relationships\n\n    def _parse_class(\n        self,\n        node: Any,\n        file_path: Path,\n        parent_id: str,\n        source_code: str,\n        source_lines: list[str],\n        kind: EntityKind = EntityKind.CLASS\n    ) ->", "tokens": ["elif", "child", "type", "class", "declaration", "class", "entities", "class", "rels", "self", "parse", "class", "child", "file", "path", "parent", "id", "source", "code", "source", "lines", "entities", "extend", "class", "entities", "relationships", "extend", "class", "rels", "elif", "child", "type", "interface", "declaration", "treat", "interface", "as", "class", "for", "mvp", "class", "entities", "class", "rels", "self", "parse", "class", "child", "file", "path", "parent", "id", "source", "code", "source", "lines", "kind", "entity", "kind", "class", "entities", "extend", "class", "entities", "relationships", "extend", "class", "rels", "return", "entities", "relationships", "def", "parse", "class", "self", "node", "any", "file", "path", "path", "parent", "id", "str", "source", "code", "str", "source", "lines", "list", "str", "kind", "entity", "kind", "entity", "kind", "class"], "metadata": {"kind": "class", "chunk_index": "2", "has_docstring": "true", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/java_parser.py::JavaParser::3", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/java_parser.py::JavaParser", "content": "rce_code: str,\n        source_lines: list[str],\n        kind: EntityKind = EntityKind.CLASS\n    ) -> tuple[list[Entity], list[Relationship]]:\n        entities: list[Entity] = []\n        relationships: list[Relationship] = []\n\n        name_node = node.child_by_field_name(\"name\")\n        class_name = self._get_text(name_node, None)\n        qualified_name = class_name # Simplified\n        class_id = f\"{file_path}::{qualified_name}\"\n\n        # Inheritance\n        # superclass -> type_id\n        # interfaces -> type_list\n        superclass_node = node.child_by_field_name(\"superclass\")\n        if superclass_node:\n             # extends Foo\n             # superclass node contains type_identifier \"Foo\"\n             # Actually, superclass: (superclass (type_identifier))\n             # Just get text of the whole node for now\n             base_text = self._get_text(superclass_node, None).replace(\"extends \", \"\").strip()\n             relationships.append(\n                Relationship(\n             ", "tokens": ["rce", "code", "str", "source", "lines", "list", "str", "kind", "entity", "kind", "entity", "kind", "class", "tuple", "list", "entity", "list", "relationship", "entities", "list", "entity", "relationships", "list", "relationship", "name", "node", "node", "child", "by", "field", "name", "name", "class", "name", "self", "get", "text", "name", "node", "none", "qualified", "name", "class", "name", "simplified", "class", "id", "file", "path", "qualified", "name", "inheritance", "superclass", "type", "id", "interfaces", "type", "list", "superclass", "node", "node", "child", "by", "field", "name", "superclass", "if", "superclass", "node", "extends", "foo", "superclass", "node", "contains", "type", "identifier", "foo", "actually", "superclass", "superclass", "type", "identifier", "just", "get", "text", "of", "the", "whole", "node", "for", "now", "base", "text", "self", "get", "text", "superclass", "node", "none", "replace", "extends", "strip", "relationships", "append", "relationship"], "metadata": {"kind": "class", "chunk_index": "3", "has_docstring": "true", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/java_parser.py::JavaParser::4", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/java_parser.py::JavaParser", "content": "xtends \", \"\").strip()\n             relationships.append(\n                Relationship(\n                    source_id=class_id,\n                    target_id=f\"ref::{base_text}\",\n                    kind=RelationshipKind.INHERITS\n                )\n             )\n\n        entity = self._create_entity(\n            node, kind, class_name, qualified_name, file_path, source_lines\n        )\n        entities.append(entity)\n        \n        relationships.append(\n            Relationship(source_id=parent_id, target_id=class_id, kind=RelationshipKind.CONTAINS)\n        )\n\n        body_node = node.child_by_field_name(\"body\")\n        if body_node:\n            for child in body_node.children:\n                if child.type == \"method_declaration\":\n                    method_entities, method_rels = self._parse_method(\n                        child, file_path, class_id, source_code, source_lines, parent_name=class_name\n                    )\n                    entities.extend(method_entities)\n          ", "tokens": ["xtends", "strip", "relationships", "append", "relationship", "source", "id", "class", "id", "target", "id", "ref", "base", "text", "kind", "relationship", "kind", "inherits", "entity", "self", "create", "entity", "node", "kind", "class", "name", "qualified", "name", "file", "path", "source", "lines", "entities", "append", "entity", "relationships", "append", "relationship", "source", "id", "parent", "id", "target", "id", "class", "id", "kind", "relationship", "kind", "contains", "body", "node", "node", "child", "by", "field", "name", "body", "if", "body", "node", "for", "child", "in", "body", "node", "children", "if", "child", "type", "method", "declaration", "method", "entities", "method", "rels", "self", "parse", "method", "child", "file", "path", "class", "id", "source", "code", "source", "lines", "parent", "name", "class", "name", "entities", "extend", "method", "entities"], "metadata": {"kind": "class", "chunk_index": "4", "has_docstring": "true", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/java_parser.py::JavaParser::5", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/java_parser.py::JavaParser", "content": "ame=class_name\n                    )\n                    entities.extend(method_entities)\n                    relationships.extend(method_rels)\n                \n                elif child.type == \"constructor_declaration\":\n                     # Handle constructor as method\n                    method_entities, method_rels = self._parse_method(\n                        child, file_path, class_id, source_code, source_lines, parent_name=class_name\n                    )\n                    entities.extend(method_entities)\n                    relationships.extend(method_rels)\n\n        return entities, relationships\n\n    def _parse_method(\n        self,\n        node: Any,\n        file_path: Path,\n        parent_id: str,\n        source_code: str,\n        source_lines: list[str],\n        parent_name: str\n    ) -> tuple[list[Entity], list[Relationship]]:\n        entities = []\n        rels = []\n        \n        name_node = node.child_by_field_name(\"name\")\n        method_name = self._get_text(name", "tokens": ["ame", "class", "name", "entities", "extend", "method", "entities", "relationships", "extend", "method", "rels", "elif", "child", "type", "constructor", "declaration", "handle", "constructor", "as", "method", "method", "entities", "method", "rels", "self", "parse", "method", "child", "file", "path", "class", "id", "source", "code", "source", "lines", "parent", "name", "class", "name", "entities", "extend", "method", "entities", "relationships", "extend", "method", "rels", "return", "entities", "relationships", "def", "parse", "method", "self", "node", "any", "file", "path", "path", "parent", "id", "str", "source", "code", "str", "source", "lines", "list", "str", "parent", "name", "str", "tuple", "list", "entity", "list", "relationship", "entities", "rels", "name", "node", "node", "child", "by", "field", "name", "name", "method", "name", "self", "get", "text", "name"], "metadata": {"kind": "class", "chunk_index": "5", "has_docstring": "true", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/java_parser.py::JavaParser::6", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/java_parser.py::JavaParser", "content": "     \n        name_node = node.child_by_field_name(\"name\")\n        method_name = self._get_text(name_node, None)\n        qualified_name = f\"{parent_name}.{method_name}\"\n        method_id = f\"{file_path}::{qualified_name}\"\n        \n        entity = self._create_entity(\n            node, EntityKind.METHOD, method_name, qualified_name, file_path, source_lines\n        )\n        entities.append(entity)\n        \n        rels.append(\n            Relationship(source_id=parent_id, target_id=method_id, kind=RelationshipKind.CONTAINS)\n        )\n        \n        # Calls\n        body_node = node.child_by_field_name(\"body\")\n        if body_node:\n             calls = self._walk_for_calls(body_node, method_id)\n             rels.extend(calls)\n             \n        return entities, rels\n\n    def _walk_for_calls(self, node, source_id):\n        rels = []\n        cursor = node.walk()\n        visited_children = False\n        \n        while True:\n            if cursor.node.type == \"method_invocation\":\n      ", "tokens": ["name", "node", "node", "child", "by", "field", "name", "name", "method", "name", "self", "get", "text", "name", "node", "none", "qualified", "name", "parent", "name", "method", "name", "method", "id", "file", "path", "qualified", "name", "entity", "self", "create", "entity", "node", "entity", "kind", "method", "method", "name", "qualified", "name", "file", "path", "source", "lines", "entities", "append", "entity", "rels", "append", "relationship", "source", "id", "parent", "id", "target", "id", "method", "id", "kind", "relationship", "kind", "contains", "calls", "body", "node", "node", "child", "by", "field", "name", "body", "if", "body", "node", "calls", "self", "walk", "for", "calls", "body", "node", "method", "id", "rels", "extend", "calls", "return", "entities", "rels", "def", "walk", "for", "calls", "self", "node", "source", "id", "rels", "cursor", "node", "walk", "visited", "children", "false", "while", "true", "if", "cursor", "node", "type", "method", "invocation"], "metadata": {"kind": "class", "chunk_index": "6", "has_docstring": "true", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/java_parser.py::JavaParser::7", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/java_parser.py::JavaParser", "content": " = False\n        \n        while True:\n            if cursor.node.type == \"method_invocation\":\n                # foo.bar(args)\n                # object: (identifier), name: (identifier), arguments\n                # OR bar(args) -> name: (identifier), arguments\n                \n                name_node = cursor.node.child_by_field_name(\"name\")\n                object_node = cursor.node.child_by_field_name(\"object\")\n                \n                method_name = self._get_text(name_node, None)\n                if object_node:\n                    obj_name = self._get_text(object_node, None)\n                    callee = f\"{obj_name}.{method_name}\"\n                else:\n                    callee = method_name\n                \n                rels.append(\n                    Relationship(\n                        source_id=source_id,\n                        target_id=f\"ref::{callee}\",\n                        kind=RelationshipKind.CALLS\n                    )\n                )\n\n            elif ", "tokens": ["false", "while", "true", "if", "cursor", "node", "type", "method", "invocation", "foo", "bar", "args", "object", "identifier", "name", "identifier", "arguments", "or", "bar", "args", "name", "identifier", "arguments", "name", "node", "cursor", "node", "child", "by", "field", "name", "name", "object", "node", "cursor", "node", "child", "by", "field", "name", "object", "method", "name", "self", "get", "text", "name", "node", "none", "if", "object", "node", "obj", "name", "self", "get", "text", "object", "node", "none", "callee", "obj", "name", "method", "name", "else", "callee", "method", "name", "rels", "append", "relationship", "source", "id", "source", "id", "target", "id", "ref", "callee", "kind", "relationship", "kind", "calls", "elif"], "metadata": {"kind": "class", "chunk_index": "7", "has_docstring": "true", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/java_parser.py::JavaParser::8", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/java_parser.py::JavaParser", "content": "              kind=RelationshipKind.CALLS\n                    )\n                )\n\n            elif cursor.node.type == \"object_creation_expression\":\n                 # new Foo()\n                 type_node = cursor.node.child_by_field_name(\"type\")\n                 if type_node:\n                     type_name = self._get_text(type_node, None)\n                     rels.append(\n                         Relationship(\n                            source_id=source_id,\n                            target_id=f\"ref::{type_name}\",\n                            kind=RelationshipKind.CALLS # Constructor call\n                         )\n                     )\n\n            # Traverse\n            if not visited_children and cursor.goto_first_child():\n                visited_children = False\n                continue\n            \n            if cursor.goto_next_sibling():\n                visited_children = False\n                continue\n            \n            if cursor.goto_parent():\n                visit", "tokens": ["kind", "relationship", "kind", "calls", "elif", "cursor", "node", "type", "object", "creation", "expression", "new", "foo", "type", "node", "cursor", "node", "child", "by", "field", "name", "type", "if", "type", "node", "type", "name", "self", "get", "text", "type", "node", "none", "rels", "append", "relationship", "source", "id", "source", "id", "target", "id", "ref", "type", "name", "kind", "relationship", "kind", "calls", "constructor", "call", "traverse", "if", "not", "visited", "children", "and", "cursor", "goto", "first", "child", "visited", "children", "false", "continue", "if", "cursor", "goto", "next", "sibling", "visited", "children", "false", "continue", "if", "cursor", "goto", "parent", "visit"], "metadata": {"kind": "class", "chunk_index": "8", "has_docstring": "true", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/java_parser.py::JavaParser::9", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/java_parser.py::JavaParser", "content": "lse\n                continue\n            \n            if cursor.goto_parent():\n                visited_children = True\n                if cursor.node == node:\n                    break\n                continue\n            else:\n                break\n                \n        return rels", "tokens": ["lse", "continue", "if", "cursor", "goto", "parent", "visited", "children", "true", "if", "cursor", "node", "node", "break", "continue", "else", "break", "return", "rels"], "metadata": {"kind": "class", "chunk_index": "9", "has_docstring": "true", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/java_parser.py::JavaParser.__init__::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/java_parser.py::JavaParser.__init__", "content": "def __init__(self) -> None\n\"\"\"Initialize Java parser.\"\"\"\n    def __init__(self) -> None:\n        \"\"\"Initialize Java parser.\"\"\"\n        super().__init__(\"java\")", "tokens": ["def", "init", "self", "none", "initialize", "java", "parser", "def", "init", "self", "none", "initialize", "java", "parser", "super", "init", "java"], "metadata": {"kind": "method", "has_docstring": "true", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/java_parser.py::JavaParser._extract_entities::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/java_parser.py::JavaParser._extract_entities", "content": "def _extract_entities(self, node: Any, file_path: Path, parent_id: str, source_code: str, source_lines: list[str]) -> tuple[list[Entity], list[Relationship]]\n\"\"\"Extract entities from Java AST.\"\"\"\n    def _extract_entities(\n        self,\n        node: Any,\n        file_path: Path,\n        parent_id: str,\n        source_code: str,\n        source_lines: list[str],\n    ) -> tuple[list[Entity], list[Relationship]]:\n        \"\"\"Extract entities from Java AST.\"\"\"\n        entities: list[Entity] = []\n        relationships: list[Relationship] = []\n\n\n        \n        # In Java, file usually maps to a class, but we have a module entity for the file anyway.\n        # Package declaration defines the logic module/package.\n        \n        for child in node.children:\n            child_type = child.type\n            \n            if child_type == \"package_declaration\":\n                # package com.example;\n                # This informs the \"qualified name\" of subsequent classes\n                pass \n   ", "tokens": ["def", "extract", "entities", "self", "node", "any", "file", "path", "path", "parent", "id", "str", "source", "code", "str", "source", "lines", "list", "str", "tuple", "list", "entity", "list", "relationship", "extract", "entities", "from", "java", "ast", "def", "extract", "entities", "self", "node", "any", "file", "path", "path", "parent", "id", "str", "source", "code", "str", "source", "lines", "list", "str", "tuple", "list", "entity", "list", "relationship", "extract", "entities", "from", "java", "ast", "entities", "list", "entity", "relationships", "list", "relationship", "in", "java", "file", "usually", "maps", "to", "class", "but", "we", "have", "module", "entity", "for", "the", "file", "anyway", "package", "declaration", "defines", "the", "logic", "module", "package", "for", "child", "in", "node", "children", "child", "type", "child", "type", "if", "child", "type", "package", "declaration", "package", "com", "example", "this", "informs", "the", "qualified", "name", "of", "subsequent", "classes", "pass"], "metadata": {"kind": "method", "chunk_index": "0", "has_docstring": "true", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/java_parser.py::JavaParser._extract_entities::1", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/java_parser.py::JavaParser._extract_entities", "content": "\n                # This informs the \"qualified name\" of subsequent classes\n                pass \n                \n            elif child_type == \"import_declaration\":\n                # import java.util.List;\n                # No field name 'name', just find the identifier or scoped_identifier\n                name_node = None\n                for c in child.children:\n                    if c.type in (\"scoped_identifier\", \"identifier\"):\n                        name_node = c\n                        break\n                \n                if name_node:\n                    imported_name = self._get_text(name_node, None)\n                    relationships.append(\n                        Relationship(\n                            source_id=parent_id,\n                            target_id=f\"external::{imported_name}\",\n                            kind=RelationshipKind.IMPORTS\n                        )\n                    )\n            \n            elif child_type == \"class_declaration\":\n           ", "tokens": ["this", "informs", "the", "qualified", "name", "of", "subsequent", "classes", "pass", "elif", "child", "type", "import", "declaration", "import", "java", "util", "list", "no", "field", "name", "name", "just", "find", "the", "identifier", "or", "scoped", "identifier", "name", "node", "none", "for", "in", "child", "children", "if", "type", "in", "scoped", "identifier", "identifier", "name", "node", "break", "if", "name", "node", "imported", "name", "self", "get", "text", "name", "node", "none", "relationships", "append", "relationship", "source", "id", "parent", "id", "target", "id", "external", "imported", "name", "kind", "relationship", "kind", "imports", "elif", "child", "type", "class", "declaration"], "metadata": {"kind": "method", "chunk_index": "1", "has_docstring": "true", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/java_parser.py::JavaParser._extract_entities::2", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/java_parser.py::JavaParser._extract_entities", "content": ")\n                    )\n            \n            elif child_type == \"class_declaration\":\n                class_entities, class_rels = self._parse_class(\n                    child, file_path, parent_id, source_code, source_lines\n                )\n                entities.extend(class_entities)\n                relationships.extend(class_rels)\n                \n            elif child_type == \"interface_declaration\":\n                 # Treat interface as class for MVP\n                class_entities, class_rels = self._parse_class(\n                    child, file_path, parent_id, source_code, source_lines, kind=EntityKind.CLASS\n                )\n                entities.extend(class_entities)\n                relationships.extend(class_rels)\n\n        return entities, relationships", "tokens": ["elif", "child", "type", "class", "declaration", "class", "entities", "class", "rels", "self", "parse", "class", "child", "file", "path", "parent", "id", "source", "code", "source", "lines", "entities", "extend", "class", "entities", "relationships", "extend", "class", "rels", "elif", "child", "type", "interface", "declaration", "treat", "interface", "as", "class", "for", "mvp", "class", "entities", "class", "rels", "self", "parse", "class", "child", "file", "path", "parent", "id", "source", "code", "source", "lines", "kind", "entity", "kind", "class", "entities", "extend", "class", "entities", "relationships", "extend", "class", "rels", "return", "entities", "relationships"], "metadata": {"kind": "method", "chunk_index": "2", "has_docstring": "true", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/java_parser.py::JavaParser._parse_class::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/java_parser.py::JavaParser._parse_class", "content": "def _parse_class(self, node: Any, file_path: Path, parent_id: str, source_code: str, source_lines: list[str], kind: EntityKind) -> tuple[list[Entity], list[Relationship]]\n    def _parse_class(\n        self,\n        node: Any,\n        file_path: Path,\n        parent_id: str,\n        source_code: str,\n        source_lines: list[str],\n        kind: EntityKind = EntityKind.CLASS\n    ) -> tuple[list[Entity], list[Relationship]]:\n        entities: list[Entity] = []\n        relationships: list[Relationship] = []\n\n        name_node = node.child_by_field_name(\"name\")\n        class_name = self._get_text(name_node, None)\n        qualified_name = class_name # Simplified\n        class_id = f\"{file_path}::{qualified_name}\"\n\n        # Inheritance\n        # superclass -> type_id\n        # interfaces -> type_list\n        superclass_node = node.child_by_field_name(\"superclass\")\n        if superclass_node:\n             # extends Foo\n             # superclass node contains type_identifier \"Foo\"\n          ", "tokens": ["def", "parse", "class", "self", "node", "any", "file", "path", "path", "parent", "id", "str", "source", "code", "str", "source", "lines", "list", "str", "kind", "entity", "kind", "tuple", "list", "entity", "list", "relationship", "def", "parse", "class", "self", "node", "any", "file", "path", "path", "parent", "id", "str", "source", "code", "str", "source", "lines", "list", "str", "kind", "entity", "kind", "entity", "kind", "class", "tuple", "list", "entity", "list", "relationship", "entities", "list", "entity", "relationships", "list", "relationship", "name", "node", "node", "child", "by", "field", "name", "name", "class", "name", "self", "get", "text", "name", "node", "none", "qualified", "name", "class", "name", "simplified", "class", "id", "file", "path", "qualified", "name", "inheritance", "superclass", "type", "id", "interfaces", "type", "list", "superclass", "node", "node", "child", "by", "field", "name", "superclass", "if", "superclass", "node", "extends", "foo", "superclass", "node", "contains", "type", "identifier", "foo"], "metadata": {"kind": "method", "chunk_index": "0", "has_docstring": "false", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/java_parser.py::JavaParser._parse_class::1", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/java_parser.py::JavaParser._parse_class", "content": "\n             # extends Foo\n             # superclass node contains type_identifier \"Foo\"\n             # Actually, superclass: (superclass (type_identifier))\n             # Just get text of the whole node for now\n             base_text = self._get_text(superclass_node, None).replace(\"extends \", \"\").strip()\n             relationships.append(\n                Relationship(\n                    source_id=class_id,\n                    target_id=f\"ref::{base_text}\",\n                    kind=RelationshipKind.INHERITS\n                )\n             )\n\n        entity = self._create_entity(\n            node, kind, class_name, qualified_name, file_path, source_lines\n        )\n        entities.append(entity)\n        \n        relationships.append(\n            Relationship(source_id=parent_id, target_id=class_id, kind=RelationshipKind.CONTAINS)\n        )\n\n        body_node = node.child_by_field_name(\"body\")\n        if body_node:\n            for child in body_node.children:\n                if child.ty", "tokens": ["extends", "foo", "superclass", "node", "contains", "type", "identifier", "foo", "actually", "superclass", "superclass", "type", "identifier", "just", "get", "text", "of", "the", "whole", "node", "for", "now", "base", "text", "self", "get", "text", "superclass", "node", "none", "replace", "extends", "strip", "relationships", "append", "relationship", "source", "id", "class", "id", "target", "id", "ref", "base", "text", "kind", "relationship", "kind", "inherits", "entity", "self", "create", "entity", "node", "kind", "class", "name", "qualified", "name", "file", "path", "source", "lines", "entities", "append", "entity", "relationships", "append", "relationship", "source", "id", "parent", "id", "target", "id", "class", "id", "kind", "relationship", "kind", "contains", "body", "node", "node", "child", "by", "field", "name", "body", "if", "body", "node", "for", "child", "in", "body", "node", "children", "if", "child", "ty"], "metadata": {"kind": "method", "chunk_index": "1", "has_docstring": "false", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/java_parser.py::JavaParser._parse_class::2", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/java_parser.py::JavaParser._parse_class", "content": "ody\")\n        if body_node:\n            for child in body_node.children:\n                if child.type == \"method_declaration\":\n                    method_entities, method_rels = self._parse_method(\n                        child, file_path, class_id, source_code, source_lines, parent_name=class_name\n                    )\n                    entities.extend(method_entities)\n                    relationships.extend(method_rels)\n                \n                elif child.type == \"constructor_declaration\":\n                     # Handle constructor as method\n                    method_entities, method_rels = self._parse_method(\n                        child, file_path, class_id, source_code, source_lines, parent_name=class_name\n                    )\n                    entities.extend(method_entities)\n                    relationships.extend(method_rels)\n\n        return entities, relationships", "tokens": ["ody", "if", "body", "node", "for", "child", "in", "body", "node", "children", "if", "child", "type", "method", "declaration", "method", "entities", "method", "rels", "self", "parse", "method", "child", "file", "path", "class", "id", "source", "code", "source", "lines", "parent", "name", "class", "name", "entities", "extend", "method", "entities", "relationships", "extend", "method", "rels", "elif", "child", "type", "constructor", "declaration", "handle", "constructor", "as", "method", "method", "entities", "method", "rels", "self", "parse", "method", "child", "file", "path", "class", "id", "source", "code", "source", "lines", "parent", "name", "class", "name", "entities", "extend", "method", "entities", "relationships", "extend", "method", "rels", "return", "entities", "relationships"], "metadata": {"kind": "method", "chunk_index": "2", "has_docstring": "false", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/java_parser.py::JavaParser._parse_method::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/java_parser.py::JavaParser._parse_method", "content": "def _parse_method(self, node: Any, file_path: Path, parent_id: str, source_code: str, source_lines: list[str], parent_name: str) -> tuple[list[Entity], list[Relationship]]\n    def _parse_method(\n        self,\n        node: Any,\n        file_path: Path,\n        parent_id: str,\n        source_code: str,\n        source_lines: list[str],\n        parent_name: str\n    ) -> tuple[list[Entity], list[Relationship]]:\n        entities = []\n        rels = []\n        \n        name_node = node.child_by_field_name(\"name\")\n        method_name = self._get_text(name_node, None)\n        qualified_name = f\"{parent_name}.{method_name}\"\n        method_id = f\"{file_path}::{qualified_name}\"\n        \n        entity = self._create_entity(\n            node, EntityKind.METHOD, method_name, qualified_name, file_path, source_lines\n        )\n        entities.append(entity)\n        \n        rels.append(\n            Relationship(source_id=parent_id, target_id=method_id, kind=RelationshipKind.CONTAINS)\n        )\n      ", "tokens": ["def", "parse", "method", "self", "node", "any", "file", "path", "path", "parent", "id", "str", "source", "code", "str", "source", "lines", "list", "str", "parent", "name", "str", "tuple", "list", "entity", "list", "relationship", "def", "parse", "method", "self", "node", "any", "file", "path", "path", "parent", "id", "str", "source", "code", "str", "source", "lines", "list", "str", "parent", "name", "str", "tuple", "list", "entity", "list", "relationship", "entities", "rels", "name", "node", "node", "child", "by", "field", "name", "name", "method", "name", "self", "get", "text", "name", "node", "none", "qualified", "name", "parent", "name", "method", "name", "method", "id", "file", "path", "qualified", "name", "entity", "self", "create", "entity", "node", "entity", "kind", "method", "method", "name", "qualified", "name", "file", "path", "source", "lines", "entities", "append", "entity", "rels", "append", "relationship", "source", "id", "parent", "id", "target", "id", "method", "id", "kind", "relationship", "kind", "contains"], "metadata": {"kind": "method", "chunk_index": "0", "has_docstring": "false", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/java_parser.py::JavaParser._parse_method::1", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/java_parser.py::JavaParser._parse_method", "content": "ationship(source_id=parent_id, target_id=method_id, kind=RelationshipKind.CONTAINS)\n        )\n        \n        # Calls\n        body_node = node.child_by_field_name(\"body\")\n        if body_node:\n             calls = self._walk_for_calls(body_node, method_id)\n             rels.extend(calls)\n             \n        return entities, rels", "tokens": ["ationship", "source", "id", "parent", "id", "target", "id", "method", "id", "kind", "relationship", "kind", "contains", "calls", "body", "node", "node", "child", "by", "field", "name", "body", "if", "body", "node", "calls", "self", "walk", "for", "calls", "body", "node", "method", "id", "rels", "extend", "calls", "return", "entities", "rels"], "metadata": {"kind": "method", "chunk_index": "1", "has_docstring": "false", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/java_parser.py::JavaParser._walk_for_calls::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/java_parser.py::JavaParser._walk_for_calls", "content": "def _walk_for_calls(self, node, source_id)\n    def _walk_for_calls(self, node, source_id):\n        rels = []\n        cursor = node.walk()\n        visited_children = False\n        \n        while True:\n            if cursor.node.type == \"method_invocation\":\n                # foo.bar(args)\n                # object: (identifier), name: (identifier), arguments\n                # OR bar(args) -> name: (identifier), arguments\n                \n                name_node = cursor.node.child_by_field_name(\"name\")\n                object_node = cursor.node.child_by_field_name(\"object\")\n                \n                method_name = self._get_text(name_node, None)\n                if object_node:\n                    obj_name = self._get_text(object_node, None)\n                    callee = f\"{obj_name}.{method_name}\"\n                else:\n                    callee = method_name\n                \n                rels.append(\n                    Relationship(\n                        source_id=source_id,\n", "tokens": ["def", "walk", "for", "calls", "self", "node", "source", "id", "def", "walk", "for", "calls", "self", "node", "source", "id", "rels", "cursor", "node", "walk", "visited", "children", "false", "while", "true", "if", "cursor", "node", "type", "method", "invocation", "foo", "bar", "args", "object", "identifier", "name", "identifier", "arguments", "or", "bar", "args", "name", "identifier", "arguments", "name", "node", "cursor", "node", "child", "by", "field", "name", "name", "object", "node", "cursor", "node", "child", "by", "field", "name", "object", "method", "name", "self", "get", "text", "name", "node", "none", "if", "object", "node", "obj", "name", "self", "get", "text", "object", "node", "none", "callee", "obj", "name", "method", "name", "else", "callee", "method", "name", "rels", "append", "relationship", "source", "id", "source", "id"], "metadata": {"kind": "method", "chunk_index": "0", "has_docstring": "false", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/java_parser.py::JavaParser._walk_for_calls::1", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/java_parser.py::JavaParser._walk_for_calls", "content": "        rels.append(\n                    Relationship(\n                        source_id=source_id,\n                        target_id=f\"ref::{callee}\",\n                        kind=RelationshipKind.CALLS\n                    )\n                )\n\n            elif cursor.node.type == \"object_creation_expression\":\n                 # new Foo()\n                 type_node = cursor.node.child_by_field_name(\"type\")\n                 if type_node:\n                     type_name = self._get_text(type_node, None)\n                     rels.append(\n                         Relationship(\n                            source_id=source_id,\n                            target_id=f\"ref::{type_name}\",\n                            kind=RelationshipKind.CALLS # Constructor call\n                         )\n                     )\n\n            # Traverse\n            if not visited_children and cursor.goto_first_child():\n                visited_children = False\n                continue\n            \n            if cur", "tokens": ["rels", "append", "relationship", "source", "id", "source", "id", "target", "id", "ref", "callee", "kind", "relationship", "kind", "calls", "elif", "cursor", "node", "type", "object", "creation", "expression", "new", "foo", "type", "node", "cursor", "node", "child", "by", "field", "name", "type", "if", "type", "node", "type", "name", "self", "get", "text", "type", "node", "none", "rels", "append", "relationship", "source", "id", "source", "id", "target", "id", "ref", "type", "name", "kind", "relationship", "kind", "calls", "constructor", "call", "traverse", "if", "not", "visited", "children", "and", "cursor", "goto", "first", "child", "visited", "children", "false", "continue", "if", "cur"], "metadata": {"kind": "method", "chunk_index": "1", "has_docstring": "false", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/java_parser.py::JavaParser._walk_for_calls::2", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/java_parser.py::JavaParser._walk_for_calls", "content": "):\n                visited_children = False\n                continue\n            \n            if cursor.goto_next_sibling():\n                visited_children = False\n                continue\n            \n            if cursor.goto_parent():\n                visited_children = True\n                if cursor.node == node:\n                    break\n                continue\n            else:\n                break\n                \n        return rels", "tokens": ["visited", "children", "false", "continue", "if", "cursor", "goto", "next", "sibling", "visited", "children", "false", "continue", "if", "cursor", "goto", "parent", "visited", "children", "true", "if", "cursor", "node", "node", "break", "continue", "else", "break", "return", "rels"], "metadata": {"kind": "method", "chunk_index": "2", "has_docstring": "false", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/markdown_parser.py::module::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/markdown_parser.py::module", "content": "\"\"\"Markdown document parser.\"\"\"", "tokens": ["markdown", "document", "parser"], "metadata": {"type": "module_header"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/markdown_parser.py::imports::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/markdown_parser.py::module", "content": "from __future__ import annotations\nimport re\nfrom pathlib import Path\nfrom knowcode.data_models import (", "tokens": ["from", "future", "import", "annotations", "import", "re", "from", "pathlib", "import", "path", "from", "knowcode", "data", "models", "import"], "metadata": {"type": "imports"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/markdown_parser.py::MarkdownParser::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/markdown_parser.py::MarkdownParser", "content": "\"\"\"Parses Markdown files into entities based on heading structure.\"\"\"\nclass MarkdownParser:\n    \"\"\"Parses Markdown files into entities based on heading structure.\"\"\"\n\n    # Regex patterns\n    HEADING_PATTERN = re.compile(r\"^(#{1,6})\\s+(.+)$\", re.MULTILINE)\n    CODE_BLOCK_PATTERN = re.compile(r\"```[\\s\\S]*?```\", re.MULTILINE)\n\n    def parse_file(self, file_path: str | Path) -> ParseResult:\n        \"\"\"Parse a Markdown file.\n\n        Args:\n            file_path: Path to the Markdown file.\n\n        Returns:\n            ParseResult with document and section entities.\n        \"\"\"\n        file_path = Path(file_path)\n        errors: list[str] = []\n\n        try:\n            content = file_path.read_text(encoding=\"utf-8\")\n        except Exception as e:\n            return ParseResult(\n                file_path=str(file_path),\n                entities=[],\n                relationships=[],\n                errors=[f\"Failed to read file: {e}\"],\n            )\n\n        entities: list[Entity] = []\n      ", "tokens": ["parses", "markdown", "files", "into", "entities", "based", "on", "heading", "structure", "class", "markdown", "parser", "parses", "markdown", "files", "into", "entities", "based", "on", "heading", "structure", "regex", "patterns", "heading", "pattern", "re", "compile", "re", "multiline", "code", "block", "pattern", "re", "compile", "re", "multiline", "def", "parse", "file", "self", "file", "path", "str", "path", "parse", "result", "parse", "markdown", "file", "args", "file", "path", "path", "to", "the", "markdown", "file", "returns", "parse", "result", "with", "document", "and", "section", "entities", "file", "path", "path", "file", "path", "errors", "list", "str", "try", "content", "file", "path", "read", "text", "encoding", "utf", "except", "exception", "as", "return", "parse", "result", "file", "path", "str", "file", "path", "entities", "relationships", "errors", "failed", "to", "read", "file", "entities", "list", "entity"], "metadata": {"kind": "class", "chunk_index": "0", "has_docstring": "true", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/markdown_parser.py::MarkdownParser::1", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/markdown_parser.py::MarkdownParser", "content": "     errors=[f\"Failed to read file: {e}\"],\n            )\n\n        entities: list[Entity] = []\n        relationships: list[Relationship] = []\n        lines = content.splitlines()\n\n        # Create document entity\n        doc_name = file_path.stem\n        doc_id = f\"{file_path}::{doc_name}\"\n\n        # Extract first paragraph as description (skip headings)\n        description = self._extract_description(content)\n\n        doc_entity = Entity(\n            id=doc_id,\n            kind=EntityKind.DOCUMENT,\n            name=doc_name,\n            qualified_name=doc_name,\n            location=Location(\n                file_path=str(file_path),\n                line_start=1,\n                line_end=len(lines),\n            ),\n            docstring=description,\n        )\n        entities.append(doc_entity)\n\n        # Remove code blocks to avoid matching headings inside them\n        content_no_code = self.CODE_BLOCK_PATTERN.sub(\"\", content)\n\n        # Extract headings\n        headings = self._extract", "tokens": ["errors", "failed", "to", "read", "file", "entities", "list", "entity", "relationships", "list", "relationship", "lines", "content", "splitlines", "create", "document", "entity", "doc", "name", "file", "path", "stem", "doc", "id", "file", "path", "doc", "name", "extract", "first", "paragraph", "as", "description", "skip", "headings", "description", "self", "extract", "description", "content", "doc", "entity", "entity", "id", "doc", "id", "kind", "entity", "kind", "document", "name", "doc", "name", "qualified", "name", "doc", "name", "location", "location", "file", "path", "str", "file", "path", "line", "start", "line", "end", "len", "lines", "docstring", "description", "entities", "append", "doc", "entity", "remove", "code", "blocks", "to", "avoid", "matching", "headings", "inside", "them", "content", "no", "code", "self", "code", "block", "pattern", "sub", "content", "extract", "headings", "headings", "self", "extract"], "metadata": {"kind": "class", "chunk_index": "1", "has_docstring": "true", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/markdown_parser.py::MarkdownParser::2", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/markdown_parser.py::MarkdownParser", "content": "elf.CODE_BLOCK_PATTERN.sub(\"\", content)\n\n        # Extract headings\n        headings = self._extract_headings(content_no_code, lines)\n\n        # Build section hierarchy\n        section_stack: list[tuple[int, str]] = [(0, doc_id)]  # (level, entity_id)\n\n        for heading in headings:\n            level, title, line_num = heading\n            section_id = f\"{file_path}::{self._slugify(title)}\"\n\n            # Find line range for this section\n            line_end = self._find_section_end(line_num, headings, len(lines))\n\n            section_entity = Entity(\n                id=section_id,\n                kind=EntityKind.SECTION,\n                name=title,\n                qualified_name=title,\n                location=Location(\n                    file_path=str(file_path),\n                    line_start=line_num,\n                    line_end=line_end,\n                ),\n                metadata={\"level\": str(level)},\n            )\n            entities.append(section_entity)\n\n            # Fi", "tokens": ["elf", "code", "block", "pattern", "sub", "content", "extract", "headings", "headings", "self", "extract", "headings", "content", "no", "code", "lines", "build", "section", "hierarchy", "section", "stack", "list", "tuple", "int", "str", "doc", "id", "level", "entity", "id", "for", "heading", "in", "headings", "level", "title", "line", "num", "heading", "section", "id", "file", "path", "self", "slugify", "title", "find", "line", "range", "for", "this", "section", "line", "end", "self", "find", "section", "end", "line", "num", "headings", "len", "lines", "section", "entity", "entity", "id", "section", "id", "kind", "entity", "kind", "section", "name", "title", "qualified", "name", "title", "location", "location", "file", "path", "str", "file", "path", "line", "start", "line", "num", "line", "end", "line", "end", "metadata", "level", "str", "level", "entities", "append", "section", "entity", "fi"], "metadata": {"kind": "class", "chunk_index": "2", "has_docstring": "true", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/markdown_parser.py::MarkdownParser::3", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/markdown_parser.py::MarkdownParser", "content": "a={\"level\": str(level)},\n            )\n            entities.append(section_entity)\n\n            # Find parent (closest heading with lower level)\n            while section_stack and section_stack[-1][0] >= level:\n                section_stack.pop()\n\n            parent_id = section_stack[-1][1] if section_stack else doc_id\n\n            relationships.append(\n                Relationship(\n                    source_id=parent_id,\n                    target_id=section_id,\n                    kind=RelationshipKind.CONTAINS,\n                )\n            )\n\n            section_stack.append((level, section_id))\n\n        return ParseResult(\n            file_path=str(file_path),\n            entities=entities,\n            relationships=relationships,\n            errors=errors,\n        )\n\n    def _extract_headings(\n        self, content: str, lines: list[str]\n    ) -> list[tuple[int, str, int]]:\n        \"\"\"Extract headings with their levels and line numbers.\n\n        Returns:\n            List of (l", "tokens": ["level", "str", "level", "entities", "append", "section", "entity", "find", "parent", "closest", "heading", "with", "lower", "level", "while", "section", "stack", "and", "section", "stack", "level", "section", "stack", "pop", "parent", "id", "section", "stack", "if", "section", "stack", "else", "doc", "id", "relationships", "append", "relationship", "source", "id", "parent", "id", "target", "id", "section", "id", "kind", "relationship", "kind", "contains", "section", "stack", "append", "level", "section", "id", "return", "parse", "result", "file", "path", "str", "file", "path", "entities", "entities", "relationships", "relationships", "errors", "errors", "def", "extract", "headings", "self", "content", "str", "lines", "list", "str", "list", "tuple", "int", "str", "int", "extract", "headings", "with", "their", "levels", "and", "line", "numbers", "returns", "list", "of"], "metadata": {"kind": "class", "chunk_index": "3", "has_docstring": "true", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/markdown_parser.py::MarkdownParser::4", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/markdown_parser.py::MarkdownParser", "content": "    \"\"\"Extract headings with their levels and line numbers.\n\n        Returns:\n            List of (level, title, line_number) tuples.\n        \"\"\"\n        headings: list[tuple[int, str, int]] = []\n\n        for i, line in enumerate(lines, start=1):\n            match = self.HEADING_PATTERN.match(line)\n            if match:\n                level = len(match.group(1))\n                title = match.group(2).strip()\n                headings.append((level, title, i))\n\n        return headings\n\n    def _find_section_end(\n        self,\n        start_line: int,\n        headings: list[tuple[int, str, int]],\n        total_lines: int,\n    ) -> int:\n        \"\"\"Find the end line of a section.\"\"\"\n        current_level = None\n        for level, _, line_num in headings:\n            if line_num == start_line:\n                current_level = level\n            elif current_level is not None and line_num > start_line:\n                if level <= current_level:\n                    return line_num - 1\n\n        ", "tokens": ["extract", "headings", "with", "their", "levels", "and", "line", "numbers", "returns", "list", "of", "level", "title", "line", "number", "tuples", "headings", "list", "tuple", "int", "str", "int", "for", "line", "in", "enumerate", "lines", "start", "match", "self", "heading", "pattern", "match", "line", "if", "match", "level", "len", "match", "group", "title", "match", "group", "strip", "headings", "append", "level", "title", "return", "headings", "def", "find", "section", "end", "self", "start", "line", "int", "headings", "list", "tuple", "int", "str", "int", "total", "lines", "int", "int", "find", "the", "end", "line", "of", "section", "current", "level", "none", "for", "level", "line", "num", "in", "headings", "if", "line", "num", "start", "line", "current", "level", "level", "elif", "current", "level", "is", "not", "none", "and", "line", "num", "start", "line", "if", "level", "current", "level", "return", "line", "num"], "metadata": {"kind": "class", "chunk_index": "4", "has_docstring": "true", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/markdown_parser.py::MarkdownParser::5", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/markdown_parser.py::MarkdownParser", "content": "t_line:\n                if level <= current_level:\n                    return line_num - 1\n\n        return total_lines\n\n    def _extract_description(self, content: str) -> str:\n        \"\"\"Extract first paragraph as document description.\"\"\"\n        # Remove code blocks\n        content = self.CODE_BLOCK_PATTERN.sub(\"\", content)\n\n        # Split into paragraphs\n        paragraphs = re.split(r\"\\n\\s*\\n\", content)\n\n        for para in paragraphs:\n            para = para.strip()\n            # Skip headings and empty paragraphs\n            if para and not para.startswith(\"#\"):\n                # Take first 500 chars max\n                return para[:500]\n\n        return \"\"\n\n    def _slugify(self, text: str) -> str:\n        \"\"\"Convert text to a URL-friendly slug.\"\"\"\n        # Lowercase and replace spaces with hyphens\n        slug = text.lower().strip()\n        slug = re.sub(r\"[^\\w\\s-]\", \"\", slug)\n        slug = re.sub(r\"[\\s_]+\", \"-\", slug)\n        slug = re.sub(r\"-+\", \"-\", slug)\n        return sl", "tokens": ["line", "if", "level", "current", "level", "return", "line", "num", "return", "total", "lines", "def", "extract", "description", "self", "content", "str", "str", "extract", "first", "paragraph", "as", "document", "description", "remove", "code", "blocks", "content", "self", "code", "block", "pattern", "sub", "content", "split", "into", "paragraphs", "paragraphs", "re", "split", "content", "for", "para", "in", "paragraphs", "para", "para", "strip", "skip", "headings", "and", "empty", "paragraphs", "if", "para", "and", "not", "para", "startswith", "take", "first", "500", "chars", "max", "return", "para", "500", "return", "def", "slugify", "self", "text", "str", "str", "convert", "text", "to", "url", "friendly", "slug", "lowercase", "and", "replace", "spaces", "with", "hyphens", "slug", "text", "lower", "strip", "slug", "re", "sub", "slug", "slug", "re", "sub", "slug", "slug", "re", "sub", "slug", "return", "sl"], "metadata": {"kind": "class", "chunk_index": "5", "has_docstring": "true", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/markdown_parser.py::MarkdownParser::6", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/markdown_parser.py::MarkdownParser", "content": "       slug = re.sub(r\"[\\s_]+\", \"-\", slug)\n        slug = re.sub(r\"-+\", \"-\", slug)\n        return slug.strip(\"-\")", "tokens": ["slug", "re", "sub", "slug", "slug", "re", "sub", "slug", "return", "slug", "strip"], "metadata": {"kind": "class", "chunk_index": "6", "has_docstring": "true", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/markdown_parser.py::MarkdownParser.parse_file::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/markdown_parser.py::MarkdownParser.parse_file", "content": "def parse_file(self, file_path: str | Path) -> ParseResult\n\"\"\"Parse a Markdown file.\n\nArgs:\n    file_path: Path to the Markdown file.\n\nReturns:\n    ParseResult with document and section entities.\"\"\"\n    def parse_file(self, file_path: str | Path) -> ParseResult:\n        \"\"\"Parse a Markdown file.\n\n        Args:\n            file_path: Path to the Markdown file.\n\n        Returns:\n            ParseResult with document and section entities.\n        \"\"\"\n        file_path = Path(file_path)\n        errors: list[str] = []\n\n        try:\n            content = file_path.read_text(encoding=\"utf-8\")\n        except Exception as e:\n            return ParseResult(\n                file_path=str(file_path),\n                entities=[],\n                relationships=[],\n                errors=[f\"Failed to read file: {e}\"],\n            )\n\n        entities: list[Entity] = []\n        relationships: list[Relationship] = []\n        lines = content.splitlines()\n\n        # Create document entity\n        doc_name", "tokens": ["def", "parse", "file", "self", "file", "path", "str", "path", "parse", "result", "parse", "markdown", "file", "args", "file", "path", "path", "to", "the", "markdown", "file", "returns", "parse", "result", "with", "document", "and", "section", "entities", "def", "parse", "file", "self", "file", "path", "str", "path", "parse", "result", "parse", "markdown", "file", "args", "file", "path", "path", "to", "the", "markdown", "file", "returns", "parse", "result", "with", "document", "and", "section", "entities", "file", "path", "path", "file", "path", "errors", "list", "str", "try", "content", "file", "path", "read", "text", "encoding", "utf", "except", "exception", "as", "return", "parse", "result", "file", "path", "str", "file", "path", "entities", "relationships", "errors", "failed", "to", "read", "file", "entities", "list", "entity", "relationships", "list", "relationship", "lines", "content", "splitlines", "create", "document", "entity", "doc", "name"], "metadata": {"kind": "method", "chunk_index": "0", "has_docstring": "true", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/markdown_parser.py::MarkdownParser.parse_file::1", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/markdown_parser.py::MarkdownParser.parse_file", "content": "onship] = []\n        lines = content.splitlines()\n\n        # Create document entity\n        doc_name = file_path.stem\n        doc_id = f\"{file_path}::{doc_name}\"\n\n        # Extract first paragraph as description (skip headings)\n        description = self._extract_description(content)\n\n        doc_entity = Entity(\n            id=doc_id,\n            kind=EntityKind.DOCUMENT,\n            name=doc_name,\n            qualified_name=doc_name,\n            location=Location(\n                file_path=str(file_path),\n                line_start=1,\n                line_end=len(lines),\n            ),\n            docstring=description,\n        )\n        entities.append(doc_entity)\n\n        # Remove code blocks to avoid matching headings inside them\n        content_no_code = self.CODE_BLOCK_PATTERN.sub(\"\", content)\n\n        # Extract headings\n        headings = self._extract_headings(content_no_code, lines)\n\n        # Build section hierarchy\n        section_stack: list[tuple[int, str]] = [(0, doc_id)", "tokens": ["onship", "lines", "content", "splitlines", "create", "document", "entity", "doc", "name", "file", "path", "stem", "doc", "id", "file", "path", "doc", "name", "extract", "first", "paragraph", "as", "description", "skip", "headings", "description", "self", "extract", "description", "content", "doc", "entity", "entity", "id", "doc", "id", "kind", "entity", "kind", "document", "name", "doc", "name", "qualified", "name", "doc", "name", "location", "location", "file", "path", "str", "file", "path", "line", "start", "line", "end", "len", "lines", "docstring", "description", "entities", "append", "doc", "entity", "remove", "code", "blocks", "to", "avoid", "matching", "headings", "inside", "them", "content", "no", "code", "self", "code", "block", "pattern", "sub", "content", "extract", "headings", "headings", "self", "extract", "headings", "content", "no", "code", "lines", "build", "section", "hierarchy", "section", "stack", "list", "tuple", "int", "str", "doc", "id"], "metadata": {"kind": "method", "chunk_index": "1", "has_docstring": "true", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/markdown_parser.py::MarkdownParser.parse_file::2", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/markdown_parser.py::MarkdownParser.parse_file", "content": "ines)\n\n        # Build section hierarchy\n        section_stack: list[tuple[int, str]] = [(0, doc_id)]  # (level, entity_id)\n\n        for heading in headings:\n            level, title, line_num = heading\n            section_id = f\"{file_path}::{self._slugify(title)}\"\n\n            # Find line range for this section\n            line_end = self._find_section_end(line_num, headings, len(lines))\n\n            section_entity = Entity(\n                id=section_id,\n                kind=EntityKind.SECTION,\n                name=title,\n                qualified_name=title,\n                location=Location(\n                    file_path=str(file_path),\n                    line_start=line_num,\n                    line_end=line_end,\n                ),\n                metadata={\"level\": str(level)},\n            )\n            entities.append(section_entity)\n\n            # Find parent (closest heading with lower level)\n            while section_stack and section_stack[-1][0] >= level:\n                ", "tokens": ["ines", "build", "section", "hierarchy", "section", "stack", "list", "tuple", "int", "str", "doc", "id", "level", "entity", "id", "for", "heading", "in", "headings", "level", "title", "line", "num", "heading", "section", "id", "file", "path", "self", "slugify", "title", "find", "line", "range", "for", "this", "section", "line", "end", "self", "find", "section", "end", "line", "num", "headings", "len", "lines", "section", "entity", "entity", "id", "section", "id", "kind", "entity", "kind", "section", "name", "title", "qualified", "name", "title", "location", "location", "file", "path", "str", "file", "path", "line", "start", "line", "num", "line", "end", "line", "end", "metadata", "level", "str", "level", "entities", "append", "section", "entity", "find", "parent", "closest", "heading", "with", "lower", "level", "while", "section", "stack", "and", "section", "stack", "level"], "metadata": {"kind": "method", "chunk_index": "2", "has_docstring": "true", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/markdown_parser.py::MarkdownParser.parse_file::3", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/markdown_parser.py::MarkdownParser.parse_file", "content": "ith lower level)\n            while section_stack and section_stack[-1][0] >= level:\n                section_stack.pop()\n\n            parent_id = section_stack[-1][1] if section_stack else doc_id\n\n            relationships.append(\n                Relationship(\n                    source_id=parent_id,\n                    target_id=section_id,\n                    kind=RelationshipKind.CONTAINS,\n                )\n            )\n\n            section_stack.append((level, section_id))\n\n        return ParseResult(\n            file_path=str(file_path),\n            entities=entities,\n            relationships=relationships,\n            errors=errors,\n        )", "tokens": ["ith", "lower", "level", "while", "section", "stack", "and", "section", "stack", "level", "section", "stack", "pop", "parent", "id", "section", "stack", "if", "section", "stack", "else", "doc", "id", "relationships", "append", "relationship", "source", "id", "parent", "id", "target", "id", "section", "id", "kind", "relationship", "kind", "contains", "section", "stack", "append", "level", "section", "id", "return", "parse", "result", "file", "path", "str", "file", "path", "entities", "entities", "relationships", "relationships", "errors", "errors"], "metadata": {"kind": "method", "chunk_index": "3", "has_docstring": "true", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/markdown_parser.py::MarkdownParser._extract_headings::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/markdown_parser.py::MarkdownParser._extract_headings", "content": "def _extract_headings(self, content: str, lines: list[str]) -> list[tuple[int, str, int]]\n\"\"\"Extract headings with their levels and line numbers.\n\nReturns:\n    List of (level, title, line_number) tuples.\"\"\"\n    def _extract_headings(\n        self, content: str, lines: list[str]\n    ) -> list[tuple[int, str, int]]:\n        \"\"\"Extract headings with their levels and line numbers.\n\n        Returns:\n            List of (level, title, line_number) tuples.\n        \"\"\"\n        headings: list[tuple[int, str, int]] = []\n\n        for i, line in enumerate(lines, start=1):\n            match = self.HEADING_PATTERN.match(line)\n            if match:\n                level = len(match.group(1))\n                title = match.group(2).strip()\n                headings.append((level, title, i))\n\n        return headings", "tokens": ["def", "extract", "headings", "self", "content", "str", "lines", "list", "str", "list", "tuple", "int", "str", "int", "extract", "headings", "with", "their", "levels", "and", "line", "numbers", "returns", "list", "of", "level", "title", "line", "number", "tuples", "def", "extract", "headings", "self", "content", "str", "lines", "list", "str", "list", "tuple", "int", "str", "int", "extract", "headings", "with", "their", "levels", "and", "line", "numbers", "returns", "list", "of", "level", "title", "line", "number", "tuples", "headings", "list", "tuple", "int", "str", "int", "for", "line", "in", "enumerate", "lines", "start", "match", "self", "heading", "pattern", "match", "line", "if", "match", "level", "len", "match", "group", "title", "match", "group", "strip", "headings", "append", "level", "title", "return", "headings"], "metadata": {"kind": "method", "has_docstring": "true", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/markdown_parser.py::MarkdownParser._find_section_end::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/markdown_parser.py::MarkdownParser._find_section_end", "content": "def _find_section_end(self, start_line: int, headings: list[tuple[int, str, int]], total_lines: int) -> int\n\"\"\"Find the end line of a section.\"\"\"\n    def _find_section_end(\n        self,\n        start_line: int,\n        headings: list[tuple[int, str, int]],\n        total_lines: int,\n    ) -> int:\n        \"\"\"Find the end line of a section.\"\"\"\n        current_level = None\n        for level, _, line_num in headings:\n            if line_num == start_line:\n                current_level = level\n            elif current_level is not None and line_num > start_line:\n                if level <= current_level:\n                    return line_num - 1\n\n        return total_lines", "tokens": ["def", "find", "section", "end", "self", "start", "line", "int", "headings", "list", "tuple", "int", "str", "int", "total", "lines", "int", "int", "find", "the", "end", "line", "of", "section", "def", "find", "section", "end", "self", "start", "line", "int", "headings", "list", "tuple", "int", "str", "int", "total", "lines", "int", "int", "find", "the", "end", "line", "of", "section", "current", "level", "none", "for", "level", "line", "num", "in", "headings", "if", "line", "num", "start", "line", "current", "level", "level", "elif", "current", "level", "is", "not", "none", "and", "line", "num", "start", "line", "if", "level", "current", "level", "return", "line", "num", "return", "total", "lines"], "metadata": {"kind": "method", "has_docstring": "true", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/markdown_parser.py::MarkdownParser._extract_description::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/markdown_parser.py::MarkdownParser._extract_description", "content": "def _extract_description(self, content: str) -> str\n\"\"\"Extract first paragraph as document description.\"\"\"\n    def _extract_description(self, content: str) -> str:\n        \"\"\"Extract first paragraph as document description.\"\"\"\n        # Remove code blocks\n        content = self.CODE_BLOCK_PATTERN.sub(\"\", content)\n\n        # Split into paragraphs\n        paragraphs = re.split(r\"\\n\\s*\\n\", content)\n\n        for para in paragraphs:\n            para = para.strip()\n            # Skip headings and empty paragraphs\n            if para and not para.startswith(\"#\"):\n                # Take first 500 chars max\n                return para[:500]\n\n        return \"\"", "tokens": ["def", "extract", "description", "self", "content", "str", "str", "extract", "first", "paragraph", "as", "document", "description", "def", "extract", "description", "self", "content", "str", "str", "extract", "first", "paragraph", "as", "document", "description", "remove", "code", "blocks", "content", "self", "code", "block", "pattern", "sub", "content", "split", "into", "paragraphs", "paragraphs", "re", "split", "content", "for", "para", "in", "paragraphs", "para", "para", "strip", "skip", "headings", "and", "empty", "paragraphs", "if", "para", "and", "not", "para", "startswith", "take", "first", "500", "chars", "max", "return", "para", "500", "return"], "metadata": {"kind": "method", "has_docstring": "true", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/markdown_parser.py::MarkdownParser._slugify::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/parsers/markdown_parser.py::MarkdownParser._slugify", "content": "def _slugify(self, text: str) -> str\n\"\"\"Convert text to a URL-friendly slug.\"\"\"\n    def _slugify(self, text: str) -> str:\n        \"\"\"Convert text to a URL-friendly slug.\"\"\"\n        # Lowercase and replace spaces with hyphens\n        slug = text.lower().strip()\n        slug = re.sub(r\"[^\\w\\s-]\", \"\", slug)\n        slug = re.sub(r\"[\\s_]+\", \"-\", slug)\n        slug = re.sub(r\"-+\", \"-\", slug)\n        return slug.strip(\"-\")", "tokens": ["def", "slugify", "self", "text", "str", "str", "convert", "text", "to", "url", "friendly", "slug", "def", "slugify", "self", "text", "str", "str", "convert", "text", "to", "url", "friendly", "slug", "lowercase", "and", "replace", "spaces", "with", "hyphens", "slug", "text", "lower", "strip", "slug", "re", "sub", "slug", "slug", "re", "sub", "slug", "slug", "re", "sub", "slug", "return", "slug", "strip"], "metadata": {"kind": "method", "has_docstring": "true", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/analysis/temporal.py::module::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/analysis/temporal.py::module", "content": "\"\"\"Temporal analysis of git history.\"\"\"", "tokens": ["temporal", "analysis", "of", "git", "history"], "metadata": {"type": "module_header"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/analysis/temporal.py::imports::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/analysis/temporal.py::module", "content": "from __future__ import annotations\nfrom datetime import datetime, timezone\nfrom pathlib import Path\nfrom git import Repo\nfrom knowcode.data_models import (", "tokens": ["from", "future", "import", "annotations", "from", "datetime", "import", "datetime", "timezone", "from", "pathlib", "import", "path", "from", "git", "import", "repo", "from", "knowcode", "data", "models", "import"], "metadata": {"type": "imports"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/analysis/temporal.py::TemporalAnalyzer::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/analysis/temporal.py::TemporalAnalyzer", "content": "\"\"\"Analyzes git history to build temporal graph.\"\"\"\nclass TemporalAnalyzer:\n    \"\"\"Analyzes git history to build temporal graph.\"\"\"\n\n    def __init__(self, root_dir: str | Path) -> None:\n        \"\"\"Initialize temporal analyzer.\n        \n        Args:\n            root_dir: Root directory of the git repo.\n        \"\"\"\n        self.root_dir = Path(root_dir).resolve()\n        try:\n            self.repo = Repo(self.root_dir)\n        except Exception:\n            # Not a git repo or git not installed\n            self.repo = None\n\n    def analyze_history(self, limit: int = 100) -> ParseResult:\n        \"\"\"Analyze git commit history.\n\n        Args:\n            limit: Maximum number of commits to analyze.\n\n        Returns:\n            ParseResult containing COMMIT and AUTHOR entities and relationships.\n        \"\"\"\n        if not self.repo:\n            return ParseResult(\n                file_path=\"git-history\",\n                entities=[],\n                relationships=[],\n                errors=", "tokens": ["analyzes", "git", "history", "to", "build", "temporal", "graph", "class", "temporal", "analyzer", "analyzes", "git", "history", "to", "build", "temporal", "graph", "def", "init", "self", "root", "dir", "str", "path", "none", "initialize", "temporal", "analyzer", "args", "root", "dir", "root", "directory", "of", "the", "git", "repo", "self", "root", "dir", "path", "root", "dir", "resolve", "try", "self", "repo", "repo", "self", "root", "dir", "except", "exception", "not", "git", "repo", "or", "git", "not", "installed", "self", "repo", "none", "def", "analyze", "history", "self", "limit", "int", "100", "parse", "result", "analyze", "git", "commit", "history", "args", "limit", "maximum", "number", "of", "commits", "to", "analyze", "returns", "parse", "result", "containing", "commit", "and", "author", "entities", "and", "relationships", "if", "not", "self", "repo", "return", "parse", "result", "file", "path", "git", "history", "entities", "relationships", "errors"], "metadata": {"kind": "class", "chunk_index": "0", "has_docstring": "true", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/analysis/temporal.py::TemporalAnalyzer::1", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/analysis/temporal.py::TemporalAnalyzer", "content": "git-history\",\n                entities=[],\n                relationships=[],\n                errors=[\"Not a valid git repository\"],\n            )\n\n        entities: list[Entity] = []\n        relationships: list[Relationship] = []\n        errors: list[str] = []\n\n        try:\n            # Iterating commits from HEAD\n            commits = list(self.repo.iter_commits(\"HEAD\", max_count=limit))\n            \n            for commit in commits:\n                commit_hash = commit.hexsha\n                short_hash = commit_hash[:7]\n                commit_id = f\"commit::{commit_hash}\"\n                \n                # Author Entity\n                author_name = commit.author.name\n                author_email = commit.author.email\n                author_id = f\"author::{author_email}\"\n                \n                # Create Author entity if not exists (we rely on graph builder to dedupe)\n                author_entity = Entity(\n                    id=author_id,\n                    kind=EntityKi", "tokens": ["git", "history", "entities", "relationships", "errors", "not", "valid", "git", "repository", "entities", "list", "entity", "relationships", "list", "relationship", "errors", "list", "str", "try", "iterating", "commits", "from", "head", "commits", "list", "self", "repo", "iter", "commits", "head", "max", "count", "limit", "for", "commit", "in", "commits", "commit", "hash", "commit", "hexsha", "short", "hash", "commit", "hash", "commit", "id", "commit", "commit", "hash", "author", "entity", "author", "name", "commit", "author", "name", "author", "email", "commit", "author", "email", "author", "id", "author", "author", "email", "create", "author", "entity", "if", "not", "exists", "we", "rely", "on", "graph", "builder", "to", "dedupe", "author", "entity", "entity", "id", "author", "id", "kind", "entity", "ki"], "metadata": {"kind": "class", "chunk_index": "1", "has_docstring": "true", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/analysis/temporal.py::TemporalAnalyzer::2", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/analysis/temporal.py::TemporalAnalyzer", "content": "         author_entity = Entity(\n                    id=author_id,\n                    kind=EntityKind.AUTHOR,\n                    name=author_name,\n                    qualified_name=author_email,\n                    location=Location(\"git\", 0, 0),\n                    metadata={\"email\": author_email}\n                )\n                entities.append(author_entity)\n\n                # Create Commit Entity\n                # Use commit message as description/docstring\n                committed_date = datetime.fromtimestamp(commit.committed_date, tz=timezone.utc)\n                commit_entity = Entity(\n                    id=commit_id,\n                    kind=EntityKind.COMMIT,\n                    name=short_hash,\n                    qualified_name=commit_hash,\n                    location=Location(\"git\", 0, 0),\n                    docstring=commit.message.strip(),\n                    metadata={\n                        \"date\": committed_date.isoformat(),\n                        \"timestamp", "tokens": ["author", "entity", "entity", "id", "author", "id", "kind", "entity", "kind", "author", "name", "author", "name", "qualified", "name", "author", "email", "location", "location", "git", "metadata", "email", "author", "email", "entities", "append", "author", "entity", "create", "commit", "entity", "use", "commit", "message", "as", "description", "docstring", "committed", "date", "datetime", "fromtimestamp", "commit", "committed", "date", "tz", "timezone", "utc", "commit", "entity", "entity", "id", "commit", "id", "kind", "entity", "kind", "commit", "name", "short", "hash", "qualified", "name", "commit", "hash", "location", "location", "git", "docstring", "commit", "message", "strip", "metadata", "date", "committed", "date", "isoformat", "timestamp"], "metadata": {"kind": "class", "chunk_index": "2", "has_docstring": "true", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/analysis/temporal.py::TemporalAnalyzer::3", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/analysis/temporal.py::TemporalAnalyzer", "content": "ata={\n                        \"date\": committed_date.isoformat(),\n                        \"timestamp\": str(commit.committed_date)\n                    }\n                )\n                entities.append(commit_entity)\n\n                # Relationship: AUTHOR -> AUTHORED -> COMMIT\n                relationships.append(\n                    Relationship(\n                        source_id=author_id,\n                        target_id=commit_id,\n                        kind=RelationshipKind.AUTHORED\n                    )\n                )\n\n                # Relationship: COMMIT -> MODIFIED -> FILE (Module)\n                # We need to find what files changed.\n                # commit.stats.files gives us list of changed files\n                for file_path, stats in commit.stats.files.items():\n                    # stats is dict like {'insertions': 1, 'deletions': 0, 'lines': 1}\n                    # file_path is relative to repo root\n                    \n                    # Construct module I", "tokens": ["ata", "date", "committed", "date", "isoformat", "timestamp", "str", "commit", "committed", "date", "entities", "append", "commit", "entity", "relationship", "author", "authored", "commit", "relationships", "append", "relationship", "source", "id", "author", "id", "target", "id", "commit", "id", "kind", "relationship", "kind", "authored", "relationship", "commit", "modified", "file", "module", "we", "need", "to", "find", "what", "files", "changed", "commit", "stats", "files", "gives", "us", "list", "of", "changed", "files", "for", "file", "path", "stats", "in", "commit", "stats", "files", "items", "stats", "is", "dict", "like", "insertions", "deletions", "lines", "file", "path", "is", "relative", "to", "repo", "root", "construct", "module"], "metadata": {"kind": "class", "chunk_index": "3", "has_docstring": "true", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/analysis/temporal.py::TemporalAnalyzer::4", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/analysis/temporal.py::TemporalAnalyzer", "content": "  # file_path is relative to repo root\n                    \n                    # Construct module ID for the file\n                    # We assume standard module ID format: /abs/path/to/file::filename\n                    # But we only have relative path here.\n                    # We need to reconstruct the absolute path ID used by other parsers.\n                    abs_path = self.root_dir / file_path\n                    module_name = Path(file_path).stem\n                    target_module_id = f\"{abs_path}::{module_name}\"\n                    \n                    relationships.append(\n                        Relationship(\n                            source_id=commit_id,\n                            target_id=target_module_id,\n                            kind=RelationshipKind.MODIFIED,\n                            metadata={\n                                \"insertions\": str(stats.get(\"insertions\", 0)),\n                                \"deletions\": str(stats.get(\"deletions\", 0))\n          ", "tokens": ["file", "path", "is", "relative", "to", "repo", "root", "construct", "module", "id", "for", "the", "file", "we", "assume", "standard", "module", "id", "format", "abs", "path", "to", "file", "filename", "but", "we", "only", "have", "relative", "path", "here", "we", "need", "to", "reconstruct", "the", "absolute", "path", "id", "used", "by", "other", "parsers", "abs", "path", "self", "root", "dir", "file", "path", "module", "name", "path", "file", "path", "stem", "target", "module", "id", "abs", "path", "module", "name", "relationships", "append", "relationship", "source", "id", "commit", "id", "target", "id", "target", "module", "id", "kind", "relationship", "kind", "modified", "metadata", "insertions", "str", "stats", "get", "insertions", "deletions", "str", "stats", "get", "deletions"], "metadata": {"kind": "class", "chunk_index": "4", "has_docstring": "true", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/analysis/temporal.py::TemporalAnalyzer::5", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/analysis/temporal.py::TemporalAnalyzer", "content": "rtions\", 0)),\n                                \"deletions\": str(stats.get(\"deletions\", 0))\n                            }\n                        )\n                    )\n                    \n                    # Also Relationship: MODULE -> CHANGED_BY -> COMMIT\n                    relationships.append(\n                        Relationship(\n                            source_id=target_module_id,\n                            target_id=commit_id,\n                            kind=RelationshipKind.CHANGED_BY\n                        )\n                    )\n\n        except Exception as e:\n            errors.append(f\"Error analyzing git history: {e}\")\n\n        return ParseResult(\n            file_path=\"git-history\",\n            entities=entities,\n            relationships=relationships,\n            errors=errors,\n        )", "tokens": ["rtions", "deletions", "str", "stats", "get", "deletions", "also", "relationship", "module", "changed", "by", "commit", "relationships", "append", "relationship", "source", "id", "target", "module", "id", "target", "id", "commit", "id", "kind", "relationship", "kind", "changed", "by", "except", "exception", "as", "errors", "append", "error", "analyzing", "git", "history", "return", "parse", "result", "file", "path", "git", "history", "entities", "entities", "relationships", "relationships", "errors", "errors"], "metadata": {"kind": "class", "chunk_index": "5", "has_docstring": "true", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/analysis/temporal.py::TemporalAnalyzer.__init__::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/analysis/temporal.py::TemporalAnalyzer.__init__", "content": "def __init__(self, root_dir: str | Path) -> None\n\"\"\"Initialize temporal analyzer.\n\nArgs:\n    root_dir: Root directory of the git repo.\"\"\"\n    def __init__(self, root_dir: str | Path) -> None:\n        \"\"\"Initialize temporal analyzer.\n        \n        Args:\n            root_dir: Root directory of the git repo.\n        \"\"\"\n        self.root_dir = Path(root_dir).resolve()\n        try:\n            self.repo = Repo(self.root_dir)\n        except Exception:\n            # Not a git repo or git not installed\n            self.repo = None", "tokens": ["def", "init", "self", "root", "dir", "str", "path", "none", "initialize", "temporal", "analyzer", "args", "root", "dir", "root", "directory", "of", "the", "git", "repo", "def", "init", "self", "root", "dir", "str", "path", "none", "initialize", "temporal", "analyzer", "args", "root", "dir", "root", "directory", "of", "the", "git", "repo", "self", "root", "dir", "path", "root", "dir", "resolve", "try", "self", "repo", "repo", "self", "root", "dir", "except", "exception", "not", "git", "repo", "or", "git", "not", "installed", "self", "repo", "none"], "metadata": {"kind": "method", "has_docstring": "true", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/analysis/temporal.py::TemporalAnalyzer.analyze_history::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/analysis/temporal.py::TemporalAnalyzer.analyze_history", "content": "def analyze_history(self, limit: int) -> ParseResult\n\"\"\"Analyze git commit history.\n\nArgs:\n    limit: Maximum number of commits to analyze.\n\nReturns:\n    ParseResult containing COMMIT and AUTHOR entities and relationships.\"\"\"\n    def analyze_history(self, limit: int = 100) -> ParseResult:\n        \"\"\"Analyze git commit history.\n\n        Args:\n            limit: Maximum number of commits to analyze.\n\n        Returns:\n            ParseResult containing COMMIT and AUTHOR entities and relationships.\n        \"\"\"\n        if not self.repo:\n            return ParseResult(\n                file_path=\"git-history\",\n                entities=[],\n                relationships=[],\n                errors=[\"Not a valid git repository\"],\n            )\n\n        entities: list[Entity] = []\n        relationships: list[Relationship] = []\n        errors: list[str] = []\n\n        try:\n            # Iterating commits from HEAD\n            commits = list(self.repo.iter_commits(\"HEAD\", max_count=limit))\n          ", "tokens": ["def", "analyze", "history", "self", "limit", "int", "parse", "result", "analyze", "git", "commit", "history", "args", "limit", "maximum", "number", "of", "commits", "to", "analyze", "returns", "parse", "result", "containing", "commit", "and", "author", "entities", "and", "relationships", "def", "analyze", "history", "self", "limit", "int", "100", "parse", "result", "analyze", "git", "commit", "history", "args", "limit", "maximum", "number", "of", "commits", "to", "analyze", "returns", "parse", "result", "containing", "commit", "and", "author", "entities", "and", "relationships", "if", "not", "self", "repo", "return", "parse", "result", "file", "path", "git", "history", "entities", "relationships", "errors", "not", "valid", "git", "repository", "entities", "list", "entity", "relationships", "list", "relationship", "errors", "list", "str", "try", "iterating", "commits", "from", "head", "commits", "list", "self", "repo", "iter", "commits", "head", "max", "count", "limit"], "metadata": {"kind": "method", "chunk_index": "0", "has_docstring": "true", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/analysis/temporal.py::TemporalAnalyzer.analyze_history::1", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/analysis/temporal.py::TemporalAnalyzer.analyze_history", "content": "its from HEAD\n            commits = list(self.repo.iter_commits(\"HEAD\", max_count=limit))\n            \n            for commit in commits:\n                commit_hash = commit.hexsha\n                short_hash = commit_hash[:7]\n                commit_id = f\"commit::{commit_hash}\"\n                \n                # Author Entity\n                author_name = commit.author.name\n                author_email = commit.author.email\n                author_id = f\"author::{author_email}\"\n                \n                # Create Author entity if not exists (we rely on graph builder to dedupe)\n                author_entity = Entity(\n                    id=author_id,\n                    kind=EntityKind.AUTHOR,\n                    name=author_name,\n                    qualified_name=author_email,\n                    location=Location(\"git\", 0, 0),\n                    metadata={\"email\": author_email}\n                )\n                entities.append(author_entity)\n\n                # Create Commit En", "tokens": ["its", "from", "head", "commits", "list", "self", "repo", "iter", "commits", "head", "max", "count", "limit", "for", "commit", "in", "commits", "commit", "hash", "commit", "hexsha", "short", "hash", "commit", "hash", "commit", "id", "commit", "commit", "hash", "author", "entity", "author", "name", "commit", "author", "name", "author", "email", "commit", "author", "email", "author", "id", "author", "author", "email", "create", "author", "entity", "if", "not", "exists", "we", "rely", "on", "graph", "builder", "to", "dedupe", "author", "entity", "entity", "id", "author", "id", "kind", "entity", "kind", "author", "name", "author", "name", "qualified", "name", "author", "email", "location", "location", "git", "metadata", "email", "author", "email", "entities", "append", "author", "entity", "create", "commit", "en"], "metadata": {"kind": "method", "chunk_index": "1", "has_docstring": "true", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/analysis/temporal.py::TemporalAnalyzer.analyze_history::2", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/analysis/temporal.py::TemporalAnalyzer.analyze_history", "content": "                )\n                entities.append(author_entity)\n\n                # Create Commit Entity\n                # Use commit message as description/docstring\n                committed_date = datetime.fromtimestamp(commit.committed_date, tz=timezone.utc)\n                commit_entity = Entity(\n                    id=commit_id,\n                    kind=EntityKind.COMMIT,\n                    name=short_hash,\n                    qualified_name=commit_hash,\n                    location=Location(\"git\", 0, 0),\n                    docstring=commit.message.strip(),\n                    metadata={\n                        \"date\": committed_date.isoformat(),\n                        \"timestamp\": str(commit.committed_date)\n                    }\n                )\n                entities.append(commit_entity)\n\n                # Relationship: AUTHOR -> AUTHORED -> COMMIT\n                relationships.append(\n                    Relationship(\n                        source_id=author_id,\n       ", "tokens": ["entities", "append", "author", "entity", "create", "commit", "entity", "use", "commit", "message", "as", "description", "docstring", "committed", "date", "datetime", "fromtimestamp", "commit", "committed", "date", "tz", "timezone", "utc", "commit", "entity", "entity", "id", "commit", "id", "kind", "entity", "kind", "commit", "name", "short", "hash", "qualified", "name", "commit", "hash", "location", "location", "git", "docstring", "commit", "message", "strip", "metadata", "date", "committed", "date", "isoformat", "timestamp", "str", "commit", "committed", "date", "entities", "append", "commit", "entity", "relationship", "author", "authored", "commit", "relationships", "append", "relationship", "source", "id", "author", "id"], "metadata": {"kind": "method", "chunk_index": "2", "has_docstring": "true", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/analysis/temporal.py::TemporalAnalyzer.analyze_history::3", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/analysis/temporal.py::TemporalAnalyzer.analyze_history", "content": "ships.append(\n                    Relationship(\n                        source_id=author_id,\n                        target_id=commit_id,\n                        kind=RelationshipKind.AUTHORED\n                    )\n                )\n\n                # Relationship: COMMIT -> MODIFIED -> FILE (Module)\n                # We need to find what files changed.\n                # commit.stats.files gives us list of changed files\n                for file_path, stats in commit.stats.files.items():\n                    # stats is dict like {'insertions': 1, 'deletions': 0, 'lines': 1}\n                    # file_path is relative to repo root\n                    \n                    # Construct module ID for the file\n                    # We assume standard module ID format: /abs/path/to/file::filename\n                    # But we only have relative path here.\n                    # We need to reconstruct the absolute path ID used by other parsers.\n                    abs_path = self.root_dir / file_p", "tokens": ["ships", "append", "relationship", "source", "id", "author", "id", "target", "id", "commit", "id", "kind", "relationship", "kind", "authored", "relationship", "commit", "modified", "file", "module", "we", "need", "to", "find", "what", "files", "changed", "commit", "stats", "files", "gives", "us", "list", "of", "changed", "files", "for", "file", "path", "stats", "in", "commit", "stats", "files", "items", "stats", "is", "dict", "like", "insertions", "deletions", "lines", "file", "path", "is", "relative", "to", "repo", "root", "construct", "module", "id", "for", "the", "file", "we", "assume", "standard", "module", "id", "format", "abs", "path", "to", "file", "filename", "but", "we", "only", "have", "relative", "path", "here", "we", "need", "to", "reconstruct", "the", "absolute", "path", "id", "used", "by", "other", "parsers", "abs", "path", "self", "root", "dir", "file"], "metadata": {"kind": "method", "chunk_index": "3", "has_docstring": "true", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/analysis/temporal.py::TemporalAnalyzer.analyze_history::4", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/analysis/temporal.py::TemporalAnalyzer.analyze_history", "content": "ct the absolute path ID used by other parsers.\n                    abs_path = self.root_dir / file_path\n                    module_name = Path(file_path).stem\n                    target_module_id = f\"{abs_path}::{module_name}\"\n                    \n                    relationships.append(\n                        Relationship(\n                            source_id=commit_id,\n                            target_id=target_module_id,\n                            kind=RelationshipKind.MODIFIED,\n                            metadata={\n                                \"insertions\": str(stats.get(\"insertions\", 0)),\n                                \"deletions\": str(stats.get(\"deletions\", 0))\n                            }\n                        )\n                    )\n                    \n                    # Also Relationship: MODULE -> CHANGED_BY -> COMMIT\n                    relationships.append(\n                        Relationship(\n                            source_id=target_module_id,\n      ", "tokens": ["ct", "the", "absolute", "path", "id", "used", "by", "other", "parsers", "abs", "path", "self", "root", "dir", "file", "path", "module", "name", "path", "file", "path", "stem", "target", "module", "id", "abs", "path", "module", "name", "relationships", "append", "relationship", "source", "id", "commit", "id", "target", "id", "target", "module", "id", "kind", "relationship", "kind", "modified", "metadata", "insertions", "str", "stats", "get", "insertions", "deletions", "str", "stats", "get", "deletions", "also", "relationship", "module", "changed", "by", "commit", "relationships", "append", "relationship", "source", "id", "target", "module", "id"], "metadata": {"kind": "method", "chunk_index": "4", "has_docstring": "true", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/analysis/temporal.py::TemporalAnalyzer.analyze_history::5", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/analysis/temporal.py::TemporalAnalyzer.analyze_history", "content": "                        Relationship(\n                            source_id=target_module_id,\n                            target_id=commit_id,\n                            kind=RelationshipKind.CHANGED_BY\n                        )\n                    )\n\n        except Exception as e:\n            errors.append(f\"Error analyzing git history: {e}\")\n\n        return ParseResult(\n            file_path=\"git-history\",\n            entities=entities,\n            relationships=relationships,\n            errors=errors,\n        )", "tokens": ["relationship", "source", "id", "target", "module", "id", "target", "id", "commit", "id", "kind", "relationship", "kind", "changed", "by", "except", "exception", "as", "errors", "append", "error", "analyzing", "git", "history", "return", "parse", "result", "file", "path", "git", "history", "entities", "entities", "relationships", "relationships", "errors", "errors"], "metadata": {"kind": "method", "chunk_index": "5", "has_docstring": "true", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/analysis/context_synthesizer.py::module::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/analysis/context_synthesizer.py::module", "content": "\"\"\"Context synthesizer for generating AI-ready context bundles.\"\"\"", "tokens": ["context", "synthesizer", "for", "generating", "ai", "ready", "context", "bundles"], "metadata": {"type": "module_header"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/analysis/context_synthesizer.py::imports::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/analysis/context_synthesizer.py::module", "content": "from dataclasses import dataclass\nfrom typing import Optional\nfrom knowcode.storage.knowledge_store import KnowledgeStore\nfrom knowcode.data_models import Entity, EntityKind, TaskType\nfrom knowcode.utils.token_counter import TokenCounter", "tokens": ["from", "dataclasses", "import", "dataclass", "from", "typing", "import", "optional", "from", "knowcode", "storage", "knowledge", "store", "import", "knowledge", "store", "from", "knowcode", "data", "models", "import", "entity", "entity", "kind", "task", "type", "from", "knowcode", "utils", "token", "counter", "import", "token", "counter"], "metadata": {"type": "imports"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/analysis/context_synthesizer.py::ContextBundle::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/analysis/context_synthesizer.py::ContextBundle", "content": "\"\"\"A bundle of context for an entity.\"\"\"\nclass ContextBundle:\n    \"\"\"A bundle of context for an entity.\"\"\"\n\n    target_entity: Entity\n    context_text: str\n    included_entities: list[str]\n    total_chars: int\n    total_tokens: int\n    truncated: bool\n    task_type: TaskType = TaskType.GENERAL\n    sufficiency_score: float = 0.0  # 0.0-1.0 confidence in context adequacy", "tokens": ["bundle", "of", "context", "for", "an", "entity", "class", "context", "bundle", "bundle", "of", "context", "for", "an", "entity", "target", "entity", "entity", "context", "text", "str", "included", "entities", "list", "str", "total", "chars", "int", "total", "tokens", "int", "truncated", "bool", "task", "type", "task", "type", "task", "type", "general", "sufficiency", "score", "float", "confidence", "in", "context", "adequacy"], "metadata": {"kind": "class", "has_docstring": "true", "last_modified": "1768185812.9925995"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/analysis/context_synthesizer.py::ContextSynthesizer::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/analysis/context_synthesizer.py::ContextSynthesizer", "content": "\"\"\"Synthesizes context bundles for entities.\"\"\"\nclass ContextSynthesizer:\n    \"\"\"Synthesizes context bundles for entities.\"\"\"\n\n    DEFAULT_MAX_TOKENS = 2000\n\n    def __init__(\n        self,\n        store: KnowledgeStore,\n        max_tokens: int = DEFAULT_MAX_TOKENS,\n        model: str = \"gpt-4\",\n    ) -> None:\n        \"\"\"Initialize context synthesizer.\n\n        Args:\n            store: Knowledge store to query.\n            max_tokens: Maximum tokens in context bundle.\n            model: Model name for token counting.\n        \"\"\"\n        self.store = store\n        self.max_tokens = max_tokens\n        self.tokenizer = TokenCounter(model)\n\n    def synthesize(self, entity_id: str) -> Optional[ContextBundle]:\n        \"\"\"Synthesize context bundle for an entity.\n\n        Args:\n            entity_id: ID of the target entity.\n\n        Returns:\n            ContextBundle or None if entity not found.\n        \"\"\"\n        entity = self.store.get_entity(entity_id)\n        if not entity:\n            r", "tokens": ["synthesizes", "context", "bundles", "for", "entities", "class", "context", "synthesizer", "synthesizes", "context", "bundles", "for", "entities", "default", "max", "tokens", "2000", "def", "init", "self", "store", "knowledge", "store", "max", "tokens", "int", "default", "max", "tokens", "model", "str", "gpt", "none", "initialize", "context", "synthesizer", "args", "store", "knowledge", "store", "to", "query", "max", "tokens", "maximum", "tokens", "in", "context", "bundle", "model", "model", "name", "for", "token", "counting", "self", "store", "store", "self", "max", "tokens", "max", "tokens", "self", "tokenizer", "token", "counter", "model", "def", "synthesize", "self", "entity", "id", "str", "optional", "context", "bundle", "synthesize", "context", "bundle", "for", "an", "entity", "args", "entity", "id", "id", "of", "the", "target", "entity", "returns", "context", "bundle", "or", "none", "if", "entity", "not", "found", "entity", "self", "store", "get", "entity", "entity", "id", "if", "not", "entity"], "metadata": {"kind": "class", "chunk_index": "0", "has_docstring": "true", "last_modified": "1768185812.9925995"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/analysis/context_synthesizer.py::ContextSynthesizer::1", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/analysis/context_synthesizer.py::ContextSynthesizer", "content": ".\n        \"\"\"\n        entity = self.store.get_entity(entity_id)\n        if not entity:\n            return None\n\n        sections: list[str] = []\n        included: list[str] = [entity_id]\n        \n        # STRATEGY: \n        # We construct the context bundle by adding sections in order of \"Semantic Priority\".\n        # 1. Core Identity (Header, Signature, Docstring) - Essential\n        # 2. Source Code - High value, but expensive. Truncated if necessary.\n        # 3. Parent Context - Helps LLM understand where this fits.\n        # 4. Incoming/Outgoing Relationships - Additional context, added greedily until budget fills.\n        \n        # We build sections in priority order but display them in logical order usually.\n        # However, for simplicity, we'll append and check budget.\n        \n        # Priority 1: Entity Core (Header, Signature, Description)\n        header = self._format_entity_header(entity)\n        current_tokens = self.tokenizer.count_tokens(header)\n        sections.a", "tokens": ["entity", "self", "store", "get", "entity", "entity", "id", "if", "not", "entity", "return", "none", "sections", "list", "str", "included", "list", "str", "entity", "id", "strategy", "we", "construct", "the", "context", "bundle", "by", "adding", "sections", "in", "order", "of", "semantic", "priority", "core", "identity", "header", "signature", "docstring", "essential", "source", "code", "high", "value", "but", "expensive", "truncated", "if", "necessary", "parent", "context", "helps", "llm", "understand", "where", "this", "fits", "incoming", "outgoing", "relationships", "additional", "context", "added", "greedily", "until", "budget", "fills", "we", "build", "sections", "in", "priority", "order", "but", "display", "them", "in", "logical", "order", "usually", "however", "for", "simplicity", "we", "ll", "append", "and", "check", "budget", "priority", "entity", "core", "header", "signature", "description", "header", "self", "format", "entity", "header", "entity", "current", "tokens", "self", "tokenizer", "count", "tokens", "header", "sections"], "metadata": {"kind": "class", "chunk_index": "1", "has_docstring": "true", "last_modified": "1768185812.9925995"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/analysis/context_synthesizer.py::ContextSynthesizer::2", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/analysis/context_synthesizer.py::ContextSynthesizer", "content": "ntity_header(entity)\n        current_tokens = self.tokenizer.count_tokens(header)\n        sections.append(header)\n        \n        desc = \"\"\n        if entity.docstring:\n            desc = f\"## Description\\n\\n{entity.docstring}\"\n            \n        sig = \"\"\n        if entity.signature:\n            sig = f\"## Signature\\n\\n```python\\n{entity.signature}\\n```\"\n            \n        # Add high priority sections if they fit\n        if desc:\n            t = self.tokenizer.count_tokens(desc)\n            if current_tokens + t < self.max_tokens:\n                sections.append(desc)\n                current_tokens += t\n        \n        if sig:\n            t = self.tokenizer.count_tokens(sig)\n            if current_tokens + t < self.max_tokens:\n                sections.append(sig)\n                current_tokens += t\n\n        # Priority 2: Source Code (Huge consumer, often truncated)\n        if entity.source_code:\n            code_header = \"## Source Code\\n\\n```python\\n\"\n            code_footer = \"", "tokens": ["ntity", "header", "entity", "current", "tokens", "self", "tokenizer", "count", "tokens", "header", "sections", "append", "header", "desc", "if", "entity", "docstring", "desc", "description", "entity", "docstring", "sig", "if", "entity", "signature", "sig", "signature", "python", "entity", "signature", "add", "high", "priority", "sections", "if", "they", "fit", "if", "desc", "self", "tokenizer", "count", "tokens", "desc", "if", "current", "tokens", "self", "max", "tokens", "sections", "append", "desc", "current", "tokens", "if", "sig", "self", "tokenizer", "count", "tokens", "sig", "if", "current", "tokens", "self", "max", "tokens", "sections", "append", "sig", "current", "tokens", "priority", "source", "code", "huge", "consumer", "often", "truncated", "if", "entity", "source", "code", "code", "header", "source", "code", "python", "code", "footer"], "metadata": {"kind": "class", "chunk_index": "2", "has_docstring": "true", "last_modified": "1768185812.9925995"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/analysis/context_synthesizer.py::ContextSynthesizer::3", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/analysis/context_synthesizer.py::ContextSynthesizer", "content": "y.source_code:\n            code_header = \"## Source Code\\n\\n```python\\n\"\n            code_footer = \"\\n```\"\n            overhead = self.tokenizer.count_tokens(code_header + code_footer)\n            remaining = self.max_tokens - current_tokens - overhead\n            \n            if remaining > 100: # Only add if we have decent space\n                code_body = entity.source_code\n                code_tokens = self.tokenizer.count_tokens(code_body)\n                \n                if code_tokens > remaining:\n                    code_body = self.tokenizer.truncate(code_body, remaining) + \"\\n# ... (truncated)\"\n                    # We technically truncated the content\n                    # But we will rely on full budget exhaustion check often\n                \n                sections.append(f\"{code_header}{code_body}{code_footer}\")\n                current_tokens += self.tokenizer.count_tokens(sections[-1])\n            else:\n                 # Skipped source code due to budget\n              ", "tokens": ["source", "code", "code", "header", "source", "code", "python", "code", "footer", "overhead", "self", "tokenizer", "count", "tokens", "code", "header", "code", "footer", "remaining", "self", "max", "tokens", "current", "tokens", "overhead", "if", "remaining", "100", "only", "add", "if", "we", "have", "decent", "space", "code", "body", "entity", "source", "code", "code", "tokens", "self", "tokenizer", "count", "tokens", "code", "body", "if", "code", "tokens", "remaining", "code", "body", "self", "tokenizer", "truncate", "code", "body", "remaining", "truncated", "we", "technically", "truncated", "the", "content", "but", "we", "will", "rely", "on", "full", "budget", "exhaustion", "check", "often", "sections", "append", "code", "header", "code", "body", "code", "footer", "current", "tokens", "self", "tokenizer", "count", "tokens", "sections", "else", "skipped", "source", "code", "due", "to", "budget"], "metadata": {"kind": "class", "chunk_index": "3", "has_docstring": "true", "last_modified": "1768185812.9925995"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/analysis/context_synthesizer.py::ContextSynthesizer::4", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/analysis/context_synthesizer.py::ContextSynthesizer", "content": "(sections[-1])\n            else:\n                 # Skipped source code due to budget\n                 # We consider this truncation/loss of info\n                 pass \n\n        # Priority 3: Parent Context\n        parent = self.store.get_parent(entity_id)\n        if parent:\n            parent_section = self._format_parent_context(parent)\n            t = self.tokenizer.count_tokens(parent_section)\n            if current_tokens + t < self.max_tokens:\n                sections.append(parent_section)\n                included.append(parent.id)\n                current_tokens += t\n\n        # Priority 4: Relationships (Callers, Callees, Children)\n        # We add them greedily until budget exhaust\n        \n        # Unified list of potential sections\n        rel_sections = []\n        \n        callers = self.store.get_callers(entity_id)\n        if callers:\n            rel_sections.append((self._format_callers(callers), [c.id for c in callers]))\n\n        callees = self.store.get_callees(entity_i", "tokens": ["sections", "else", "skipped", "source", "code", "due", "to", "budget", "we", "consider", "this", "truncation", "loss", "of", "info", "pass", "priority", "parent", "context", "parent", "self", "store", "get", "parent", "entity", "id", "if", "parent", "parent", "section", "self", "format", "parent", "context", "parent", "self", "tokenizer", "count", "tokens", "parent", "section", "if", "current", "tokens", "self", "max", "tokens", "sections", "append", "parent", "section", "included", "append", "parent", "id", "current", "tokens", "priority", "relationships", "callers", "callees", "children", "we", "add", "them", "greedily", "until", "budget", "exhaust", "unified", "list", "of", "potential", "sections", "rel", "sections", "callers", "self", "store", "get", "callers", "entity", "id", "if", "callers", "rel", "sections", "append", "self", "format", "callers", "callers", "id", "for", "in", "callers", "callees", "self", "store", "get", "callees", "entity"], "metadata": {"kind": "class", "chunk_index": "4", "has_docstring": "true", "last_modified": "1768185812.9925995"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/analysis/context_synthesizer.py::ContextSynthesizer::5", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/analysis/context_synthesizer.py::ContextSynthesizer", "content": "ormat_callers(callers), [c.id for c in callers]))\n\n        callees = self.store.get_callees(entity_id)\n        if callees:\n             rel_sections.append((self._format_callees(callees), [c.id for c in callees]))\n             \n        if entity.kind in {EntityKind.CLASS, EntityKind.MODULE, EntityKind.DOCUMENT}:\n            children = self.store.get_children(entity_id)\n            if children:\n                rel_sections.append((self._format_children(children), [c.id for c in children]))\n\n        is_truncated = False\n        \n        for text, ids in rel_sections:\n            t = self.tokenizer.count_tokens(text)\n            if current_tokens + t < self.max_tokens:\n                sections.append(text)\n                included.extend(ids)\n                current_tokens += t\n            else:\n                is_truncated = True\n\n        context_text = \"\\n\\n---\\n\\n\".join(sections)\n        \n        # Check if we skipped source code but had it\n        if entity.source_code and \"## Source ", "tokens": ["ormat", "callers", "callers", "id", "for", "in", "callers", "callees", "self", "store", "get", "callees", "entity", "id", "if", "callees", "rel", "sections", "append", "self", "format", "callees", "callees", "id", "for", "in", "callees", "if", "entity", "kind", "in", "entity", "kind", "class", "entity", "kind", "module", "entity", "kind", "document", "children", "self", "store", "get", "children", "entity", "id", "if", "children", "rel", "sections", "append", "self", "format", "children", "children", "id", "for", "in", "children", "is", "truncated", "false", "for", "text", "ids", "in", "rel", "sections", "self", "tokenizer", "count", "tokens", "text", "if", "current", "tokens", "self", "max", "tokens", "sections", "append", "text", "included", "extend", "ids", "current", "tokens", "else", "is", "truncated", "true", "context", "text", "join", "sections", "check", "if", "we", "skipped", "source", "code", "but", "had", "it", "if", "entity", "source", "code", "and", "source"], "metadata": {"kind": "class", "chunk_index": "5", "has_docstring": "true", "last_modified": "1768185812.9925995"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/analysis/context_synthesizer.py::ContextSynthesizer::6", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/analysis/context_synthesizer.py::ContextSynthesizer", "content": " \n        # Check if we skipped source code but had it\n        if entity.source_code and \"## Source Code\" not in context_text:\n             is_truncated = True\n\n        return ContextBundle(\n            target_entity=entity,\n            context_text=context_text,\n            included_entities=included,\n            total_chars=len(context_text),\n            total_tokens=current_tokens,\n            truncated=is_truncated or (current_tokens >= self.max_tokens),\n        )\n\n    def _format_entity_header(self, entity: Entity) -> str:\n        \"\"\"Format entity header.\"\"\"\n        lines = [\n            f\"# {entity.kind.value.title()}: `{entity.qualified_name}`\",\n            \"\",\n            f\"**File**: `{entity.location.file_path}`\",\n            f\"**Lines**: {entity.location.line_start}-{entity.location.line_end}\",\n        ]\n        return \"\\n\".join(lines)\n\n    def _format_parent_context(self, parent: Entity) -> str:\n        \"\"\"Format parent context section.\"\"\"\n        lines = [\n            \"## P", "tokens": ["check", "if", "we", "skipped", "source", "code", "but", "had", "it", "if", "entity", "source", "code", "and", "source", "code", "not", "in", "context", "text", "is", "truncated", "true", "return", "context", "bundle", "target", "entity", "entity", "context", "text", "context", "text", "included", "entities", "included", "total", "chars", "len", "context", "text", "total", "tokens", "current", "tokens", "truncated", "is", "truncated", "or", "current", "tokens", "self", "max", "tokens", "def", "format", "entity", "header", "self", "entity", "entity", "str", "format", "entity", "header", "lines", "entity", "kind", "value", "title", "entity", "qualified", "name", "file", "entity", "location", "file", "path", "lines", "entity", "location", "line", "start", "entity", "location", "line", "end", "return", "join", "lines", "def", "format", "parent", "context", "self", "parent", "entity", "str", "format", "parent", "context", "section", "lines"], "metadata": {"kind": "class", "chunk_index": "6", "has_docstring": "true", "last_modified": "1768185812.9925995"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/analysis/context_synthesizer.py::ContextSynthesizer::7", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/analysis/context_synthesizer.py::ContextSynthesizer", "content": "nt: Entity) -> str:\n        \"\"\"Format parent context section.\"\"\"\n        lines = [\n            \"## Parent Context\",\n            \"\",\n            f\"**{parent.kind.value.title()}**: `{parent.qualified_name}`\",\n        ]\n        if parent.docstring:\n            # Include first line of docstring\n            first_line = parent.docstring.split(\"\\n\")[0]\n            lines.append(f\"> {first_line}\")\n        return \"\\n\".join(lines)\n\n    def _format_callers(self, callers: list[Entity]) -> str:\n        \"\"\"Format callers section.\"\"\"\n        lines = [\"## Called By\", \"\"]\n        for caller in callers[:10]:  # Limit to 10\n            sig = f\" - `{caller.signature.split('(')[0]}(...)`\" if caller.signature else \"\"\n            lines.append(f\"- `{caller.qualified_name}`{sig}\")\n        if len(callers) > 10:\n            lines.append(f\"- ... and {len(callers) - 10} more\")\n        return \"\\n\".join(lines)\n\n    def _format_callees(self, callees: list[Entity]) -> str:\n        \"\"\"Format callees section.\"\"\"\n       ", "tokens": ["nt", "entity", "str", "format", "parent", "context", "section", "lines", "parent", "context", "parent", "kind", "value", "title", "parent", "qualified", "name", "if", "parent", "docstring", "include", "first", "line", "of", "docstring", "first", "line", "parent", "docstring", "split", "lines", "append", "first", "line", "return", "join", "lines", "def", "format", "callers", "self", "callers", "list", "entity", "str", "format", "callers", "section", "lines", "called", "by", "for", "caller", "in", "callers", "10", "limit", "to", "10", "sig", "caller", "signature", "split", "if", "caller", "signature", "else", "lines", "append", "caller", "qualified", "name", "sig", "if", "len", "callers", "10", "lines", "append", "and", "len", "callers", "10", "more", "return", "join", "lines", "def", "format", "callees", "self", "callees", "list", "entity", "str", "format", "callees", "section"], "metadata": {"kind": "class", "chunk_index": "7", "has_docstring": "true", "last_modified": "1768185812.9925995"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/analysis/context_synthesizer.py::ContextSynthesizer::8", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/analysis/context_synthesizer.py::ContextSynthesizer", "content": "f _format_callees(self, callees: list[Entity]) -> str:\n        \"\"\"Format callees section.\"\"\"\n        lines = [\"## Calls\", \"\"]\n        for callee in callees[:10]:  # Limit to 10\n            lines.append(f\"- `{callee.qualified_name}`\")\n        if len(callees) > 10:\n            lines.append(f\"- ... and {len(callees) - 10} more\")\n        return \"\\n\".join(lines)\n\n    def _format_children(self, children: list[Entity]) -> str:\n        \"\"\"Format children section.\"\"\"\n        lines = [\"## Contains\", \"\"]\n        for child in children[:15]:  # Limit to 15\n            kind = child.kind.value\n            lines.append(f\"- [{kind}] `{child.name}`\")\n        if len(children) > 15:\n            lines.append(f\"- ... and {len(children) - 15} more\")\n        return \"\\n\".join(lines)\n\n    def synthesize_for_search(\n        self,\n        query: str,\n        max_results: int = 5,\n    ) -> str:\n        \"\"\"Synthesize context for a search query.\n\n        Args:\n            query: Search pattern.\n            max_resul", "tokens": ["format", "callees", "self", "callees", "list", "entity", "str", "format", "callees", "section", "lines", "calls", "for", "callee", "in", "callees", "10", "limit", "to", "10", "lines", "append", "callee", "qualified", "name", "if", "len", "callees", "10", "lines", "append", "and", "len", "callees", "10", "more", "return", "join", "lines", "def", "format", "children", "self", "children", "list", "entity", "str", "format", "children", "section", "lines", "contains", "for", "child", "in", "children", "15", "limit", "to", "15", "kind", "child", "kind", "value", "lines", "append", "kind", "child", "name", "if", "len", "children", "15", "lines", "append", "and", "len", "children", "15", "more", "return", "join", "lines", "def", "synthesize", "for", "search", "self", "query", "str", "max", "results", "int", "str", "synthesize", "context", "for", "search", "query", "args", "query", "search", "pattern", "max", "resul"], "metadata": {"kind": "class", "chunk_index": "8", "has_docstring": "true", "last_modified": "1768185812.9925995"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/analysis/context_synthesizer.py::ContextSynthesizer::9", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/analysis/context_synthesizer.py::ContextSynthesizer", "content": " context for a search query.\n\n        Args:\n            query: Search pattern.\n            max_results: Maximum entities to include.\n\n        Returns:\n            Combined context string for matching entities.\n        \"\"\"\n        matches = self.store.search(query)[:max_results]\n\n        if not matches:\n            return f\"No entities found matching '{query}'\"\n\n        sections = [f\"# Search Results for '{query}'\", \"\"]\n\n        for entity in matches:\n            sections.append(f\"## {entity.kind.value.title()}: `{entity.qualified_name}`\")\n            sections.append(f\"File: `{entity.location.file_path}:{entity.location.line_start}`\")\n            if entity.docstring:\n                # First 200 chars of docstring\n                doc_preview = entity.docstring[:200]\n                if len(entity.docstring) > 200:\n                    doc_preview += \"...\"\n                sections.append(f\"> {doc_preview}\")\n            sections.append(\"\")\n\n        return \"\\n\".join(sections)\n\n    def synthes", "tokens": ["context", "for", "search", "query", "args", "query", "search", "pattern", "max", "results", "maximum", "entities", "to", "include", "returns", "combined", "context", "string", "for", "matching", "entities", "matches", "self", "store", "search", "query", "max", "results", "if", "not", "matches", "return", "no", "entities", "found", "matching", "query", "sections", "search", "results", "for", "query", "for", "entity", "in", "matches", "sections", "append", "entity", "kind", "value", "title", "entity", "qualified", "name", "sections", "append", "file", "entity", "location", "file", "path", "entity", "location", "line", "start", "if", "entity", "docstring", "first", "200", "chars", "of", "docstring", "doc", "preview", "entity", "docstring", "200", "if", "len", "entity", "docstring", "200", "doc", "preview", "sections", "append", "doc", "preview", "sections", "append", "return", "join", "sections", "def", "synthes"], "metadata": {"kind": "class", "chunk_index": "9", "has_docstring": "true", "last_modified": "1768185812.9925995"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/analysis/context_synthesizer.py::ContextSynthesizer::10", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/analysis/context_synthesizer.py::ContextSynthesizer", "content": "{doc_preview}\")\n            sections.append(\"\")\n\n        return \"\\n\".join(sections)\n\n    def synthesize_with_task(\n        self,\n        entity_id: str,\n        task_type: TaskType = TaskType.GENERAL,\n    ) -> Optional[ContextBundle]:\n        \"\"\"Synthesize context bundle with task-specific prioritization.\n\n        Uses task templates from KnowCode.md Layer 9 to prioritize content\n        based on the type of task (debug, extend, review, explain, locate).\n\n        Args:\n            entity_id: ID of the target entity.\n            task_type: Type of task for context prioritization.\n\n        Returns:\n            ContextBundle with task_type and sufficiency_score, or None if not found.\n        \"\"\"\n        entity = self.store.get_entity(entity_id)\n        if not entity:\n            return None\n\n        template = TASK_TEMPLATES.get(task_type, TASK_TEMPLATES[TaskType.GENERAL])\n        priority_order = template[\"priority\"]\n        boosts = template.get(\"boost\", {})\n\n        sections: list[str]", "tokens": ["doc", "preview", "sections", "append", "return", "join", "sections", "def", "synthesize", "with", "task", "self", "entity", "id", "str", "task", "type", "task", "type", "task", "type", "general", "optional", "context", "bundle", "synthesize", "context", "bundle", "with", "task", "specific", "prioritization", "uses", "task", "templates", "from", "know", "code", "md", "layer", "to", "prioritize", "content", "based", "on", "the", "type", "of", "task", "debug", "extend", "review", "explain", "locate", "args", "entity", "id", "id", "of", "the", "target", "entity", "task", "type", "type", "of", "task", "for", "context", "prioritization", "returns", "context", "bundle", "with", "task", "type", "and", "sufficiency", "score", "or", "none", "if", "not", "found", "entity", "self", "store", "get", "entity", "entity", "id", "if", "not", "entity", "return", "none", "template", "task", "templates", "get", "task", "type", "task", "templates", "task", "type", "general", "priority", "order", "template", "priority", "boosts", "template", "get", "boost", "sections", "list", "str"], "metadata": {"kind": "class", "chunk_index": "10", "has_docstring": "true", "last_modified": "1768185812.9925995"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/analysis/context_synthesizer.py::ContextSynthesizer::11", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/analysis/context_synthesizer.py::ContextSynthesizer", "content": "order = template[\"priority\"]\n        boosts = template.get(\"boost\", {})\n\n        sections: list[str] = []\n        included: list[str] = [entity_id]\n        \n        # Track what we've included for sufficiency scoring\n        content_included = {\n            \"signature\": False,\n            \"docstring\": False,\n            \"source_code\": False,\n            \"parent\": False,\n            \"callers\": False,\n            \"callees\": False,\n            \"children\": False,\n        }\n        \n        # Always include header\n        header = self._format_entity_header(entity)\n        current_tokens = self.tokenizer.count_tokens(header)\n        sections.append(header)\n        \n        # Build content sections based on priority order\n        content_sections = {}\n        \n        if entity.signature:\n            content_sections[\"signature\"] = f\"## Signature\\n\\n```python\\n{entity.signature}\\n```\"\n            \n        if entity.docstring:\n            content_sections[\"docstring\"] = f\"## Description\\n\\n{e", "tokens": ["order", "template", "priority", "boosts", "template", "get", "boost", "sections", "list", "str", "included", "list", "str", "entity", "id", "track", "what", "we", "ve", "included", "for", "sufficiency", "scoring", "content", "included", "signature", "false", "docstring", "false", "source", "code", "false", "parent", "false", "callers", "false", "callees", "false", "children", "false", "always", "include", "header", "header", "self", "format", "entity", "header", "entity", "current", "tokens", "self", "tokenizer", "count", "tokens", "header", "sections", "append", "header", "build", "content", "sections", "based", "on", "priority", "order", "content", "sections", "if", "entity", "signature", "content", "sections", "signature", "signature", "python", "entity", "signature", "if", "entity", "docstring", "content", "sections", "docstring", "description"], "metadata": {"kind": "class", "chunk_index": "11", "has_docstring": "true", "last_modified": "1768185812.9925995"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/analysis/context_synthesizer.py::ContextSynthesizer::12", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/analysis/context_synthesizer.py::ContextSynthesizer", "content": "    \n        if entity.docstring:\n            content_sections[\"docstring\"] = f\"## Description\\n\\n{entity.docstring}\"\n            \n        if entity.source_code:\n            code_header = \"## Source Code\\n\\n```python\\n\"\n            code_footer = \"\\n```\"\n            code_body = entity.source_code\n            # Pre-truncate if too long\n            max_code_tokens = int(self.max_tokens * 0.5)  # Reserve half for code max\n            code_tokens = self.tokenizer.count_tokens(code_body)\n            if code_tokens > max_code_tokens:\n                code_body = self.tokenizer.truncate(code_body, max_code_tokens) + \"\\n# ... (truncated)\"\n            content_sections[\"source_code\"] = f\"{code_header}{code_body}{code_footer}\"\n            \n        parent = self.store.get_parent(entity_id)\n        if parent:\n            content_sections[\"parent\"] = self._format_parent_context(parent)\n            \n        callers = self.store.get_callers(entity_id)\n        if callers:\n            content_sections[\"ca", "tokens": ["if", "entity", "docstring", "content", "sections", "docstring", "description", "entity", "docstring", "if", "entity", "source", "code", "code", "header", "source", "code", "python", "code", "footer", "code", "body", "entity", "source", "code", "pre", "truncate", "if", "too", "long", "max", "code", "tokens", "int", "self", "max", "tokens", "reserve", "half", "for", "code", "max", "code", "tokens", "self", "tokenizer", "count", "tokens", "code", "body", "if", "code", "tokens", "max", "code", "tokens", "code", "body", "self", "tokenizer", "truncate", "code", "body", "max", "code", "tokens", "truncated", "content", "sections", "source", "code", "code", "header", "code", "body", "code", "footer", "parent", "self", "store", "get", "parent", "entity", "id", "if", "parent", "content", "sections", "parent", "self", "format", "parent", "context", "parent", "callers", "self", "store", "get", "callers", "entity", "id", "if", "callers", "content", "sections", "ca"], "metadata": {"kind": "class", "chunk_index": "12", "has_docstring": "true", "last_modified": "1768185812.9925995"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/analysis/context_synthesizer.py::ContextSynthesizer::13", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/analysis/context_synthesizer.py::ContextSynthesizer", "content": "    callers = self.store.get_callers(entity_id)\n        if callers:\n            content_sections[\"callers\"] = self._format_callers(callers)\n            \n        callees = self.store.get_callees(entity_id)\n        if callees:\n            content_sections[\"callees\"] = self._format_callees(callees)\n            \n        if entity.kind in {EntityKind.CLASS, EntityKind.MODULE, EntityKind.DOCUMENT}:\n            children = self.store.get_children(entity_id)\n            if children:\n                content_sections[\"children\"] = self._format_children(children)\n        \n        # Add sections in priority order until budget exhausted\n        is_truncated = False\n        \n        for section_name in priority_order:\n            if section_name not in content_sections:\n                continue\n                \n            section_text = content_sections[section_name]\n            t = self.tokenizer.count_tokens(section_text)\n            \n            # Apply boost: if boosted, allocate more budget\n   ", "tokens": ["callers", "self", "store", "get", "callers", "entity", "id", "if", "callers", "content", "sections", "callers", "self", "format", "callers", "callers", "callees", "self", "store", "get", "callees", "entity", "id", "if", "callees", "content", "sections", "callees", "self", "format", "callees", "callees", "if", "entity", "kind", "in", "entity", "kind", "class", "entity", "kind", "module", "entity", "kind", "document", "children", "self", "store", "get", "children", "entity", "id", "if", "children", "content", "sections", "children", "self", "format", "children", "children", "add", "sections", "in", "priority", "order", "until", "budget", "exhausted", "is", "truncated", "false", "for", "section", "name", "in", "priority", "order", "if", "section", "name", "not", "in", "content", "sections", "continue", "section", "text", "content", "sections", "section", "name", "self", "tokenizer", "count", "tokens", "section", "text", "apply", "boost", "if", "boosted", "allocate", "more", "budget"], "metadata": {"kind": "class", "chunk_index": "13", "has_docstring": "true", "last_modified": "1768185812.9925995"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/analysis/context_synthesizer.py::ContextSynthesizer::14", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/analysis/context_synthesizer.py::ContextSynthesizer", "content": "nt_tokens(section_text)\n            \n            # Apply boost: if boosted, allocate more budget\n            boost = boosts.get(section_name, 1.0)\n            effective_budget = self.max_tokens * boost\n            \n            if current_tokens + t < min(effective_budget, self.max_tokens):\n                sections.append(section_text)\n                current_tokens += t\n                content_included[section_name] = True\n                \n                # Track included entity IDs\n                if section_name == \"parent\" and parent:\n                    included.append(parent.id)\n                elif section_name == \"callers\" and callers:\n                    included.extend(c.id for c in callers[:10])\n                elif section_name == \"callees\" and callees:\n                    included.extend(c.id for c in callees[:10])\n                elif section_name == \"children\":\n                    children_list = self.store.get_children(entity_id)\n                    if children_list:\n   ", "tokens": ["nt", "tokens", "section", "text", "apply", "boost", "if", "boosted", "allocate", "more", "budget", "boost", "boosts", "get", "section", "name", "effective", "budget", "self", "max", "tokens", "boost", "if", "current", "tokens", "min", "effective", "budget", "self", "max", "tokens", "sections", "append", "section", "text", "current", "tokens", "content", "included", "section", "name", "true", "track", "included", "entity", "ids", "if", "section", "name", "parent", "and", "parent", "included", "append", "parent", "id", "elif", "section", "name", "callers", "and", "callers", "included", "extend", "id", "for", "in", "callers", "10", "elif", "section", "name", "callees", "and", "callees", "included", "extend", "id", "for", "in", "callees", "10", "elif", "section", "name", "children", "children", "list", "self", "store", "get", "children", "entity", "id", "if", "children", "list"], "metadata": {"kind": "class", "chunk_index": "14", "has_docstring": "true", "last_modified": "1768185812.9925995"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/analysis/context_synthesizer.py::ContextSynthesizer::15", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/analysis/context_synthesizer.py::ContextSynthesizer", "content": "        children_list = self.store.get_children(entity_id)\n                    if children_list:\n                        included.extend(c.id for c in children_list[:15])\n            else:\n                is_truncated = True\n        \n        context_text = \"\\n\\n---\\n\\n\".join(sections)\n        \n        # Calculate sufficiency score based on task requirements\n        sufficiency = self._calculate_sufficiency(\n            task_type, content_included, entity, context_text\n        )\n        \n        return ContextBundle(\n            target_entity=entity,\n            context_text=context_text,\n            included_entities=included,\n            total_chars=len(context_text),\n            total_tokens=current_tokens,\n            truncated=is_truncated,\n            task_type=task_type,\n            sufficiency_score=sufficiency,\n        )\n\n    def _calculate_sufficiency(\n        self,\n        task_type: TaskType,\n        content_included: dict[str, bool],\n        entity: Entity,\n        context_", "tokens": ["children", "list", "self", "store", "get", "children", "entity", "id", "if", "children", "list", "included", "extend", "id", "for", "in", "children", "list", "15", "else", "is", "truncated", "true", "context", "text", "join", "sections", "calculate", "sufficiency", "score", "based", "on", "task", "requirements", "sufficiency", "self", "calculate", "sufficiency", "task", "type", "content", "included", "entity", "context", "text", "return", "context", "bundle", "target", "entity", "entity", "context", "text", "context", "text", "included", "entities", "included", "total", "chars", "len", "context", "text", "total", "tokens", "current", "tokens", "truncated", "is", "truncated", "task", "type", "task", "type", "sufficiency", "score", "sufficiency", "def", "calculate", "sufficiency", "self", "task", "type", "task", "type", "content", "included", "dict", "str", "bool", "entity", "entity", "context"], "metadata": {"kind": "class", "chunk_index": "15", "has_docstring": "true", "last_modified": "1768185812.9925995"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/analysis/context_synthesizer.py::ContextSynthesizer::16", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/analysis/context_synthesizer.py::ContextSynthesizer", "content": "_type: TaskType,\n        content_included: dict[str, bool],\n        entity: Entity,\n        context_text: str,\n    ) -> float:\n        \"\"\"Calculate sufficiency score (0.0-1.0) for local-first answering.\n        \n        Higher scores indicate the context is likely sufficient to answer\n        without needing an external LLM.\n        \n        Args:\n            task_type: The type of task being performed.\n            content_included: Dict tracking what content was included.\n            entity: The target entity.\n            context_text: The synthesized context.\n            \n        Returns:\n            Sufficiency score from 0.0 to 1.0.\n        \"\"\"\n        template = TASK_TEMPLATES.get(task_type, TASK_TEMPLATES[TaskType.GENERAL])\n        priority_order = template[\"priority\"]\n        \n        score = 0.0\n        max_score = 0.0\n        \n        # Weight each priority item by its position (higher priority = more weight)\n        for i, section_name in enumerate(priority_order):\n          ", "tokens": ["type", "task", "type", "content", "included", "dict", "str", "bool", "entity", "entity", "context", "text", "str", "float", "calculate", "sufficiency", "score", "for", "local", "first", "answering", "higher", "scores", "indicate", "the", "context", "is", "likely", "sufficient", "to", "answer", "without", "needing", "an", "external", "llm", "args", "task", "type", "the", "type", "of", "task", "being", "performed", "content", "included", "dict", "tracking", "what", "content", "was", "included", "entity", "the", "target", "entity", "context", "text", "the", "synthesized", "context", "returns", "sufficiency", "score", "from", "to", "template", "task", "templates", "get", "task", "type", "task", "templates", "task", "type", "general", "priority", "order", "template", "priority", "score", "max", "score", "weight", "each", "priority", "item", "by", "its", "position", "higher", "priority", "more", "weight", "for", "section", "name", "in", "enumerate", "priority", "order"], "metadata": {"kind": "class", "chunk_index": "16", "has_docstring": "true", "last_modified": "1768185812.9925995"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/analysis/context_synthesizer.py::ContextSynthesizer::17", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/analysis/context_synthesizer.py::ContextSynthesizer", "content": "(higher priority = more weight)\n        for i, section_name in enumerate(priority_order):\n            weight = 1.0 / (i + 1)  # Decreasing weight by position\n            max_score += weight\n            \n            if content_included.get(section_name, False):\n                score += weight\n        \n        # Bonus for having source code (always valuable)\n        if entity.source_code and \"## Source Code\" in context_text:\n            score += 0.2\n            max_score += 0.2\n            \n        # Bonus for having docstring (helps LLM understand intent)\n        if entity.docstring and len(entity.docstring) > 50:\n            score += 0.1\n            max_score += 0.1\n            \n        # Penalize if context is very short\n        min_useful_tokens = 100\n        if len(context_text) < min_useful_tokens:\n            score *= 0.5\n            \n        return min(1.0, round(score / max_score, 2)) if max_score > 0 else 0.0", "tokens": ["higher", "priority", "more", "weight", "for", "section", "name", "in", "enumerate", "priority", "order", "weight", "decreasing", "weight", "by", "position", "max", "score", "weight", "if", "content", "included", "get", "section", "name", "false", "score", "weight", "bonus", "for", "having", "source", "code", "always", "valuable", "if", "entity", "source", "code", "and", "source", "code", "in", "context", "text", "score", "max", "score", "bonus", "for", "having", "docstring", "helps", "llm", "understand", "intent", "if", "entity", "docstring", "and", "len", "entity", "docstring", "50", "score", "max", "score", "penalize", "if", "context", "is", "very", "short", "min", "useful", "tokens", "100", "if", "len", "context", "text", "min", "useful", "tokens", "score", "return", "min", "round", "score", "max", "score", "if", "max", "score", "else"], "metadata": {"kind": "class", "chunk_index": "17", "has_docstring": "true", "last_modified": "1768185812.9925995"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/analysis/context_synthesizer.py::ContextSynthesizer.__init__::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/analysis/context_synthesizer.py::ContextSynthesizer.__init__", "content": "def __init__(self, store: KnowledgeStore, max_tokens: int, model: str) -> None\n\"\"\"Initialize context synthesizer.\n\nArgs:\n    store: Knowledge store to query.\n    max_tokens: Maximum tokens in context bundle.\n    model: Model name for token counting.\"\"\"\n    def __init__(\n        self,\n        store: KnowledgeStore,\n        max_tokens: int = DEFAULT_MAX_TOKENS,\n        model: str = \"gpt-4\",\n    ) -> None:\n        \"\"\"Initialize context synthesizer.\n\n        Args:\n            store: Knowledge store to query.\n            max_tokens: Maximum tokens in context bundle.\n            model: Model name for token counting.\n        \"\"\"\n        self.store = store\n        self.max_tokens = max_tokens\n        self.tokenizer = TokenCounter(model)", "tokens": ["def", "init", "self", "store", "knowledge", "store", "max", "tokens", "int", "model", "str", "none", "initialize", "context", "synthesizer", "args", "store", "knowledge", "store", "to", "query", "max", "tokens", "maximum", "tokens", "in", "context", "bundle", "model", "model", "name", "for", "token", "counting", "def", "init", "self", "store", "knowledge", "store", "max", "tokens", "int", "default", "max", "tokens", "model", "str", "gpt", "none", "initialize", "context", "synthesizer", "args", "store", "knowledge", "store", "to", "query", "max", "tokens", "maximum", "tokens", "in", "context", "bundle", "model", "model", "name", "for", "token", "counting", "self", "store", "store", "self", "max", "tokens", "max", "tokens", "self", "tokenizer", "token", "counter", "model"], "metadata": {"kind": "method", "has_docstring": "true", "last_modified": "1768185812.9925995"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/analysis/context_synthesizer.py::ContextSynthesizer.synthesize::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/analysis/context_synthesizer.py::ContextSynthesizer.synthesize", "content": "def synthesize(self, entity_id: str) -> Optional[ContextBundle]\n\"\"\"Synthesize context bundle for an entity.\n\nArgs:\n    entity_id: ID of the target entity.\n\nReturns:\n    ContextBundle or None if entity not found.\"\"\"\n    def synthesize(self, entity_id: str) -> Optional[ContextBundle]:\n        \"\"\"Synthesize context bundle for an entity.\n\n        Args:\n            entity_id: ID of the target entity.\n\n        Returns:\n            ContextBundle or None if entity not found.\n        \"\"\"\n        entity = self.store.get_entity(entity_id)\n        if not entity:\n            return None\n\n        sections: list[str] = []\n        included: list[str] = [entity_id]\n        \n        # STRATEGY: \n        # We construct the context bundle by adding sections in order of \"Semantic Priority\".\n        # 1. Core Identity (Header, Signature, Docstring) - Essential\n        # 2. Source Code - High value, but expensive. Truncated if necessary.\n        # 3. Parent Context - Helps LLM understand where this fits.\n   ", "tokens": ["def", "synthesize", "self", "entity", "id", "str", "optional", "context", "bundle", "synthesize", "context", "bundle", "for", "an", "entity", "args", "entity", "id", "id", "of", "the", "target", "entity", "returns", "context", "bundle", "or", "none", "if", "entity", "not", "found", "def", "synthesize", "self", "entity", "id", "str", "optional", "context", "bundle", "synthesize", "context", "bundle", "for", "an", "entity", "args", "entity", "id", "id", "of", "the", "target", "entity", "returns", "context", "bundle", "or", "none", "if", "entity", "not", "found", "entity", "self", "store", "get", "entity", "entity", "id", "if", "not", "entity", "return", "none", "sections", "list", "str", "included", "list", "str", "entity", "id", "strategy", "we", "construct", "the", "context", "bundle", "by", "adding", "sections", "in", "order", "of", "semantic", "priority", "core", "identity", "header", "signature", "docstring", "essential", "source", "code", "high", "value", "but", "expensive", "truncated", "if", "necessary", "parent", "context", "helps", "llm", "understand", "where", "this", "fits"], "metadata": {"kind": "method", "chunk_index": "0", "has_docstring": "true", "last_modified": "1768185812.9925995"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/analysis/context_synthesizer.py::ContextSynthesizer.synthesize::1", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/analysis/context_synthesizer.py::ContextSynthesizer.synthesize", "content": "ive. Truncated if necessary.\n        # 3. Parent Context - Helps LLM understand where this fits.\n        # 4. Incoming/Outgoing Relationships - Additional context, added greedily until budget fills.\n        \n        # We build sections in priority order but display them in logical order usually.\n        # However, for simplicity, we'll append and check budget.\n        \n        # Priority 1: Entity Core (Header, Signature, Description)\n        header = self._format_entity_header(entity)\n        current_tokens = self.tokenizer.count_tokens(header)\n        sections.append(header)\n        \n        desc = \"\"\n        if entity.docstring:\n            desc = f\"## Description\\n\\n{entity.docstring}\"\n            \n        sig = \"\"\n        if entity.signature:\n            sig = f\"## Signature\\n\\n```python\\n{entity.signature}\\n```\"\n            \n        # Add high priority sections if they fit\n        if desc:\n            t = self.tokenizer.count_tokens(desc)\n            if current_tokens + t < self.", "tokens": ["ive", "truncated", "if", "necessary", "parent", "context", "helps", "llm", "understand", "where", "this", "fits", "incoming", "outgoing", "relationships", "additional", "context", "added", "greedily", "until", "budget", "fills", "we", "build", "sections", "in", "priority", "order", "but", "display", "them", "in", "logical", "order", "usually", "however", "for", "simplicity", "we", "ll", "append", "and", "check", "budget", "priority", "entity", "core", "header", "signature", "description", "header", "self", "format", "entity", "header", "entity", "current", "tokens", "self", "tokenizer", "count", "tokens", "header", "sections", "append", "header", "desc", "if", "entity", "docstring", "desc", "description", "entity", "docstring", "sig", "if", "entity", "signature", "sig", "signature", "python", "entity", "signature", "add", "high", "priority", "sections", "if", "they", "fit", "if", "desc", "self", "tokenizer", "count", "tokens", "desc", "if", "current", "tokens", "self"], "metadata": {"kind": "method", "chunk_index": "1", "has_docstring": "true", "last_modified": "1768185812.9925995"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/analysis/context_synthesizer.py::ContextSynthesizer.synthesize::2", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/analysis/context_synthesizer.py::ContextSynthesizer.synthesize", "content": "if desc:\n            t = self.tokenizer.count_tokens(desc)\n            if current_tokens + t < self.max_tokens:\n                sections.append(desc)\n                current_tokens += t\n        \n        if sig:\n            t = self.tokenizer.count_tokens(sig)\n            if current_tokens + t < self.max_tokens:\n                sections.append(sig)\n                current_tokens += t\n\n        # Priority 2: Source Code (Huge consumer, often truncated)\n        if entity.source_code:\n            code_header = \"## Source Code\\n\\n```python\\n\"\n            code_footer = \"\\n```\"\n            overhead = self.tokenizer.count_tokens(code_header + code_footer)\n            remaining = self.max_tokens - current_tokens - overhead\n            \n            if remaining > 100: # Only add if we have decent space\n                code_body = entity.source_code\n                code_tokens = self.tokenizer.count_tokens(code_body)\n                \n                if code_tokens > remaining:\n                    ", "tokens": ["if", "desc", "self", "tokenizer", "count", "tokens", "desc", "if", "current", "tokens", "self", "max", "tokens", "sections", "append", "desc", "current", "tokens", "if", "sig", "self", "tokenizer", "count", "tokens", "sig", "if", "current", "tokens", "self", "max", "tokens", "sections", "append", "sig", "current", "tokens", "priority", "source", "code", "huge", "consumer", "often", "truncated", "if", "entity", "source", "code", "code", "header", "source", "code", "python", "code", "footer", "overhead", "self", "tokenizer", "count", "tokens", "code", "header", "code", "footer", "remaining", "self", "max", "tokens", "current", "tokens", "overhead", "if", "remaining", "100", "only", "add", "if", "we", "have", "decent", "space", "code", "body", "entity", "source", "code", "code", "tokens", "self", "tokenizer", "count", "tokens", "code", "body", "if", "code", "tokens", "remaining"], "metadata": {"kind": "method", "chunk_index": "2", "has_docstring": "true", "last_modified": "1768185812.9925995"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/analysis/context_synthesizer.py::ContextSynthesizer.synthesize::3", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/analysis/context_synthesizer.py::ContextSynthesizer.synthesize", "content": "_tokens(code_body)\n                \n                if code_tokens > remaining:\n                    code_body = self.tokenizer.truncate(code_body, remaining) + \"\\n# ... (truncated)\"\n                    # We technically truncated the content\n                    # But we will rely on full budget exhaustion check often\n                \n                sections.append(f\"{code_header}{code_body}{code_footer}\")\n                current_tokens += self.tokenizer.count_tokens(sections[-1])\n            else:\n                 # Skipped source code due to budget\n                 # We consider this truncation/loss of info\n                 pass \n\n        # Priority 3: Parent Context\n        parent = self.store.get_parent(entity_id)\n        if parent:\n            parent_section = self._format_parent_context(parent)\n            t = self.tokenizer.count_tokens(parent_section)\n            if current_tokens + t < self.max_tokens:\n                sections.append(parent_section)\n                included.app", "tokens": ["tokens", "code", "body", "if", "code", "tokens", "remaining", "code", "body", "self", "tokenizer", "truncate", "code", "body", "remaining", "truncated", "we", "technically", "truncated", "the", "content", "but", "we", "will", "rely", "on", "full", "budget", "exhaustion", "check", "often", "sections", "append", "code", "header", "code", "body", "code", "footer", "current", "tokens", "self", "tokenizer", "count", "tokens", "sections", "else", "skipped", "source", "code", "due", "to", "budget", "we", "consider", "this", "truncation", "loss", "of", "info", "pass", "priority", "parent", "context", "parent", "self", "store", "get", "parent", "entity", "id", "if", "parent", "parent", "section", "self", "format", "parent", "context", "parent", "self", "tokenizer", "count", "tokens", "parent", "section", "if", "current", "tokens", "self", "max", "tokens", "sections", "append", "parent", "section", "included", "app"], "metadata": {"kind": "method", "chunk_index": "3", "has_docstring": "true", "last_modified": "1768185812.9925995"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/analysis/context_synthesizer.py::ContextSynthesizer.synthesize::4", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/analysis/context_synthesizer.py::ContextSynthesizer.synthesize", "content": " + t < self.max_tokens:\n                sections.append(parent_section)\n                included.append(parent.id)\n                current_tokens += t\n\n        # Priority 4: Relationships (Callers, Callees, Children)\n        # We add them greedily until budget exhaust\n        \n        # Unified list of potential sections\n        rel_sections = []\n        \n        callers = self.store.get_callers(entity_id)\n        if callers:\n            rel_sections.append((self._format_callers(callers), [c.id for c in callers]))\n\n        callees = self.store.get_callees(entity_id)\n        if callees:\n             rel_sections.append((self._format_callees(callees), [c.id for c in callees]))\n             \n        if entity.kind in {EntityKind.CLASS, EntityKind.MODULE, EntityKind.DOCUMENT}:\n            children = self.store.get_children(entity_id)\n            if children:\n                rel_sections.append((self._format_children(children), [c.id for c in children]))\n\n        is_truncated = False\n      ", "tokens": ["self", "max", "tokens", "sections", "append", "parent", "section", "included", "append", "parent", "id", "current", "tokens", "priority", "relationships", "callers", "callees", "children", "we", "add", "them", "greedily", "until", "budget", "exhaust", "unified", "list", "of", "potential", "sections", "rel", "sections", "callers", "self", "store", "get", "callers", "entity", "id", "if", "callers", "rel", "sections", "append", "self", "format", "callers", "callers", "id", "for", "in", "callers", "callees", "self", "store", "get", "callees", "entity", "id", "if", "callees", "rel", "sections", "append", "self", "format", "callees", "callees", "id", "for", "in", "callees", "if", "entity", "kind", "in", "entity", "kind", "class", "entity", "kind", "module", "entity", "kind", "document", "children", "self", "store", "get", "children", "entity", "id", "if", "children", "rel", "sections", "append", "self", "format", "children", "children", "id", "for", "in", "children", "is", "truncated", "false"], "metadata": {"kind": "method", "chunk_index": "4", "has_docstring": "true", "last_modified": "1768185812.9925995"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/analysis/context_synthesizer.py::ContextSynthesizer.synthesize::5", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/analysis/context_synthesizer.py::ContextSynthesizer.synthesize", "content": "nd((self._format_children(children), [c.id for c in children]))\n\n        is_truncated = False\n        \n        for text, ids in rel_sections:\n            t = self.tokenizer.count_tokens(text)\n            if current_tokens + t < self.max_tokens:\n                sections.append(text)\n                included.extend(ids)\n                current_tokens += t\n            else:\n                is_truncated = True\n\n        context_text = \"\\n\\n---\\n\\n\".join(sections)\n        \n        # Check if we skipped source code but had it\n        if entity.source_code and \"## Source Code\" not in context_text:\n             is_truncated = True\n\n        return ContextBundle(\n            target_entity=entity,\n            context_text=context_text,\n            included_entities=included,\n            total_chars=len(context_text),\n            total_tokens=current_tokens,\n            truncated=is_truncated or (current_tokens >= self.max_tokens),\n        )", "tokens": ["nd", "self", "format", "children", "children", "id", "for", "in", "children", "is", "truncated", "false", "for", "text", "ids", "in", "rel", "sections", "self", "tokenizer", "count", "tokens", "text", "if", "current", "tokens", "self", "max", "tokens", "sections", "append", "text", "included", "extend", "ids", "current", "tokens", "else", "is", "truncated", "true", "context", "text", "join", "sections", "check", "if", "we", "skipped", "source", "code", "but", "had", "it", "if", "entity", "source", "code", "and", "source", "code", "not", "in", "context", "text", "is", "truncated", "true", "return", "context", "bundle", "target", "entity", "entity", "context", "text", "context", "text", "included", "entities", "included", "total", "chars", "len", "context", "text", "total", "tokens", "current", "tokens", "truncated", "is", "truncated", "or", "current", "tokens", "self", "max", "tokens"], "metadata": {"kind": "method", "chunk_index": "5", "has_docstring": "true", "last_modified": "1768185812.9925995"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/analysis/context_synthesizer.py::ContextSynthesizer._format_entity_header::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/analysis/context_synthesizer.py::ContextSynthesizer._format_entity_header", "content": "def _format_entity_header(self, entity: Entity) -> str\n\"\"\"Format entity header.\"\"\"\n    def _format_entity_header(self, entity: Entity) -> str:\n        \"\"\"Format entity header.\"\"\"\n        lines = [\n            f\"# {entity.kind.value.title()}: `{entity.qualified_name}`\",\n            \"\",\n            f\"**File**: `{entity.location.file_path}`\",\n            f\"**Lines**: {entity.location.line_start}-{entity.location.line_end}\",\n        ]\n        return \"\\n\".join(lines)", "tokens": ["def", "format", "entity", "header", "self", "entity", "entity", "str", "format", "entity", "header", "def", "format", "entity", "header", "self", "entity", "entity", "str", "format", "entity", "header", "lines", "entity", "kind", "value", "title", "entity", "qualified", "name", "file", "entity", "location", "file", "path", "lines", "entity", "location", "line", "start", "entity", "location", "line", "end", "return", "join", "lines"], "metadata": {"kind": "method", "has_docstring": "true", "last_modified": "1768185812.9925995"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/analysis/context_synthesizer.py::ContextSynthesizer._format_parent_context::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/analysis/context_synthesizer.py::ContextSynthesizer._format_parent_context", "content": "def _format_parent_context(self, parent: Entity) -> str\n\"\"\"Format parent context section.\"\"\"\n    def _format_parent_context(self, parent: Entity) -> str:\n        \"\"\"Format parent context section.\"\"\"\n        lines = [\n            \"## Parent Context\",\n            \"\",\n            f\"**{parent.kind.value.title()}**: `{parent.qualified_name}`\",\n        ]\n        if parent.docstring:\n            # Include first line of docstring\n            first_line = parent.docstring.split(\"\\n\")[0]\n            lines.append(f\"> {first_line}\")\n        return \"\\n\".join(lines)", "tokens": ["def", "format", "parent", "context", "self", "parent", "entity", "str", "format", "parent", "context", "section", "def", "format", "parent", "context", "self", "parent", "entity", "str", "format", "parent", "context", "section", "lines", "parent", "context", "parent", "kind", "value", "title", "parent", "qualified", "name", "if", "parent", "docstring", "include", "first", "line", "of", "docstring", "first", "line", "parent", "docstring", "split", "lines", "append", "first", "line", "return", "join", "lines"], "metadata": {"kind": "method", "has_docstring": "true", "last_modified": "1768185812.9925995"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/analysis/context_synthesizer.py::ContextSynthesizer._format_callers::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/analysis/context_synthesizer.py::ContextSynthesizer._format_callers", "content": "def _format_callers(self, callers: list[Entity]) -> str\n\"\"\"Format callers section.\"\"\"\n    def _format_callers(self, callers: list[Entity]) -> str:\n        \"\"\"Format callers section.\"\"\"\n        lines = [\"## Called By\", \"\"]\n        for caller in callers[:10]:  # Limit to 10\n            sig = f\" - `{caller.signature.split('(')[0]}(...)`\" if caller.signature else \"\"\n            lines.append(f\"- `{caller.qualified_name}`{sig}\")\n        if len(callers) > 10:\n            lines.append(f\"- ... and {len(callers) - 10} more\")\n        return \"\\n\".join(lines)", "tokens": ["def", "format", "callers", "self", "callers", "list", "entity", "str", "format", "callers", "section", "def", "format", "callers", "self", "callers", "list", "entity", "str", "format", "callers", "section", "lines", "called", "by", "for", "caller", "in", "callers", "10", "limit", "to", "10", "sig", "caller", "signature", "split", "if", "caller", "signature", "else", "lines", "append", "caller", "qualified", "name", "sig", "if", "len", "callers", "10", "lines", "append", "and", "len", "callers", "10", "more", "return", "join", "lines"], "metadata": {"kind": "method", "has_docstring": "true", "last_modified": "1768185812.9925995"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/analysis/context_synthesizer.py::ContextSynthesizer._format_callees::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/analysis/context_synthesizer.py::ContextSynthesizer._format_callees", "content": "def _format_callees(self, callees: list[Entity]) -> str\n\"\"\"Format callees section.\"\"\"\n    def _format_callees(self, callees: list[Entity]) -> str:\n        \"\"\"Format callees section.\"\"\"\n        lines = [\"## Calls\", \"\"]\n        for callee in callees[:10]:  # Limit to 10\n            lines.append(f\"- `{callee.qualified_name}`\")\n        if len(callees) > 10:\n            lines.append(f\"- ... and {len(callees) - 10} more\")\n        return \"\\n\".join(lines)", "tokens": ["def", "format", "callees", "self", "callees", "list", "entity", "str", "format", "callees", "section", "def", "format", "callees", "self", "callees", "list", "entity", "str", "format", "callees", "section", "lines", "calls", "for", "callee", "in", "callees", "10", "limit", "to", "10", "lines", "append", "callee", "qualified", "name", "if", "len", "callees", "10", "lines", "append", "and", "len", "callees", "10", "more", "return", "join", "lines"], "metadata": {"kind": "method", "has_docstring": "true", "last_modified": "1768185812.9925995"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/analysis/context_synthesizer.py::ContextSynthesizer._format_children::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/analysis/context_synthesizer.py::ContextSynthesizer._format_children", "content": "def _format_children(self, children: list[Entity]) -> str\n\"\"\"Format children section.\"\"\"\n    def _format_children(self, children: list[Entity]) -> str:\n        \"\"\"Format children section.\"\"\"\n        lines = [\"## Contains\", \"\"]\n        for child in children[:15]:  # Limit to 15\n            kind = child.kind.value\n            lines.append(f\"- [{kind}] `{child.name}`\")\n        if len(children) > 15:\n            lines.append(f\"- ... and {len(children) - 15} more\")\n        return \"\\n\".join(lines)", "tokens": ["def", "format", "children", "self", "children", "list", "entity", "str", "format", "children", "section", "def", "format", "children", "self", "children", "list", "entity", "str", "format", "children", "section", "lines", "contains", "for", "child", "in", "children", "15", "limit", "to", "15", "kind", "child", "kind", "value", "lines", "append", "kind", "child", "name", "if", "len", "children", "15", "lines", "append", "and", "len", "children", "15", "more", "return", "join", "lines"], "metadata": {"kind": "method", "has_docstring": "true", "last_modified": "1768185812.9925995"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/analysis/context_synthesizer.py::ContextSynthesizer.synthesize_for_search::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/analysis/context_synthesizer.py::ContextSynthesizer.synthesize_for_search", "content": "def synthesize_for_search(self, query: str, max_results: int) -> str\n\"\"\"Synthesize context for a search query.\n\nArgs:\n    query: Search pattern.\n    max_results: Maximum entities to include.\n\nReturns:\n    Combined context string for matching entities.\"\"\"\n    def synthesize_for_search(\n        self,\n        query: str,\n        max_results: int = 5,\n    ) -> str:\n        \"\"\"Synthesize context for a search query.\n\n        Args:\n            query: Search pattern.\n            max_results: Maximum entities to include.\n\n        Returns:\n            Combined context string for matching entities.\n        \"\"\"\n        matches = self.store.search(query)[:max_results]\n\n        if not matches:\n            return f\"No entities found matching '{query}'\"\n\n        sections = [f\"# Search Results for '{query}'\", \"\"]\n\n        for entity in matches:\n            sections.append(f\"## {entity.kind.value.title()}: `{entity.qualified_name}`\")\n            sections.append(f\"File: `{entity.location.file_path}:{enti", "tokens": ["def", "synthesize", "for", "search", "self", "query", "str", "max", "results", "int", "str", "synthesize", "context", "for", "search", "query", "args", "query", "search", "pattern", "max", "results", "maximum", "entities", "to", "include", "returns", "combined", "context", "string", "for", "matching", "entities", "def", "synthesize", "for", "search", "self", "query", "str", "max", "results", "int", "str", "synthesize", "context", "for", "search", "query", "args", "query", "search", "pattern", "max", "results", "maximum", "entities", "to", "include", "returns", "combined", "context", "string", "for", "matching", "entities", "matches", "self", "store", "search", "query", "max", "results", "if", "not", "matches", "return", "no", "entities", "found", "matching", "query", "sections", "search", "results", "for", "query", "for", "entity", "in", "matches", "sections", "append", "entity", "kind", "value", "title", "entity", "qualified", "name", "sections", "append", "file", "entity", "location", "file", "path", "enti"], "metadata": {"kind": "method", "chunk_index": "0", "has_docstring": "true", "last_modified": "1768185812.9925995"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/analysis/context_synthesizer.py::ContextSynthesizer.synthesize_for_search::1", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/analysis/context_synthesizer.py::ContextSynthesizer.synthesize_for_search", "content": ": `{entity.qualified_name}`\")\n            sections.append(f\"File: `{entity.location.file_path}:{entity.location.line_start}`\")\n            if entity.docstring:\n                # First 200 chars of docstring\n                doc_preview = entity.docstring[:200]\n                if len(entity.docstring) > 200:\n                    doc_preview += \"...\"\n                sections.append(f\"> {doc_preview}\")\n            sections.append(\"\")\n\n        return \"\\n\".join(sections)", "tokens": ["entity", "qualified", "name", "sections", "append", "file", "entity", "location", "file", "path", "entity", "location", "line", "start", "if", "entity", "docstring", "first", "200", "chars", "of", "docstring", "doc", "preview", "entity", "docstring", "200", "if", "len", "entity", "docstring", "200", "doc", "preview", "sections", "append", "doc", "preview", "sections", "append", "return", "join", "sections"], "metadata": {"kind": "method", "chunk_index": "1", "has_docstring": "true", "last_modified": "1768185812.9925995"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/analysis/context_synthesizer.py::ContextSynthesizer.synthesize_with_task::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/analysis/context_synthesizer.py::ContextSynthesizer.synthesize_with_task", "content": "def synthesize_with_task(self, entity_id: str, task_type: TaskType) -> Optional[ContextBundle]\n\"\"\"Synthesize context bundle with task-specific prioritization.\n\nUses task templates from KnowCode.md Layer 9 to prioritize content\nbased on the type of task (debug, extend, review, explain, locate).\n\nArgs:\n    entity_id: ID of the target entity.\n    task_type: Type of task for context prioritization.\n\nReturns:\n    ContextBundle with task_type and sufficiency_score, or None if not found.\"\"\"\n    def synthesize_with_task(\n        self,\n        entity_id: str,\n        task_type: TaskType = TaskType.GENERAL,\n    ) -> Optional[ContextBundle]:\n        \"\"\"Synthesize context bundle with task-specific prioritization.\n\n        Uses task templates from KnowCode.md Layer 9 to prioritize content\n        based on the type of task (debug, extend, review, explain, locate).\n\n        Args:\n            entity_id: ID of the target entity.\n            task_type: Type of task for context prioritization.\n\n        R", "tokens": ["def", "synthesize", "with", "task", "self", "entity", "id", "str", "task", "type", "task", "type", "optional", "context", "bundle", "synthesize", "context", "bundle", "with", "task", "specific", "prioritization", "uses", "task", "templates", "from", "know", "code", "md", "layer", "to", "prioritize", "content", "based", "on", "the", "type", "of", "task", "debug", "extend", "review", "explain", "locate", "args", "entity", "id", "id", "of", "the", "target", "entity", "task", "type", "type", "of", "task", "for", "context", "prioritization", "returns", "context", "bundle", "with", "task", "type", "and", "sufficiency", "score", "or", "none", "if", "not", "found", "def", "synthesize", "with", "task", "self", "entity", "id", "str", "task", "type", "task", "type", "task", "type", "general", "optional", "context", "bundle", "synthesize", "context", "bundle", "with", "task", "specific", "prioritization", "uses", "task", "templates", "from", "know", "code", "md", "layer", "to", "prioritize", "content", "based", "on", "the", "type", "of", "task", "debug", "extend", "review", "explain", "locate", "args", "entity", "id", "id", "of", "the", "target", "entity", "task", "type", "type", "of", "task", "for", "context", "prioritization"], "metadata": {"kind": "method", "chunk_index": "0", "has_docstring": "true", "last_modified": "1768185812.9925995"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/analysis/context_synthesizer.py::ContextSynthesizer.synthesize_with_task::1", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/analysis/context_synthesizer.py::ContextSynthesizer.synthesize_with_task", "content": " ID of the target entity.\n            task_type: Type of task for context prioritization.\n\n        Returns:\n            ContextBundle with task_type and sufficiency_score, or None if not found.\n        \"\"\"\n        entity = self.store.get_entity(entity_id)\n        if not entity:\n            return None\n\n        template = TASK_TEMPLATES.get(task_type, TASK_TEMPLATES[TaskType.GENERAL])\n        priority_order = template[\"priority\"]\n        boosts = template.get(\"boost\", {})\n\n        sections: list[str] = []\n        included: list[str] = [entity_id]\n        \n        # Track what we've included for sufficiency scoring\n        content_included = {\n            \"signature\": False,\n            \"docstring\": False,\n            \"source_code\": False,\n            \"parent\": False,\n            \"callers\": False,\n            \"callees\": False,\n            \"children\": False,\n        }\n        \n        # Always include header\n        header = self._format_entity_header(entity)\n        current_tokens = self", "tokens": ["id", "of", "the", "target", "entity", "task", "type", "type", "of", "task", "for", "context", "prioritization", "returns", "context", "bundle", "with", "task", "type", "and", "sufficiency", "score", "or", "none", "if", "not", "found", "entity", "self", "store", "get", "entity", "entity", "id", "if", "not", "entity", "return", "none", "template", "task", "templates", "get", "task", "type", "task", "templates", "task", "type", "general", "priority", "order", "template", "priority", "boosts", "template", "get", "boost", "sections", "list", "str", "included", "list", "str", "entity", "id", "track", "what", "we", "ve", "included", "for", "sufficiency", "scoring", "content", "included", "signature", "false", "docstring", "false", "source", "code", "false", "parent", "false", "callers", "false", "callees", "false", "children", "false", "always", "include", "header", "header", "self", "format", "entity", "header", "entity", "current", "tokens", "self"], "metadata": {"kind": "method", "chunk_index": "1", "has_docstring": "true", "last_modified": "1768185812.9925995"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/analysis/context_synthesizer.py::ContextSynthesizer.synthesize_with_task::2", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/analysis/context_synthesizer.py::ContextSynthesizer.synthesize_with_task", "content": "ays include header\n        header = self._format_entity_header(entity)\n        current_tokens = self.tokenizer.count_tokens(header)\n        sections.append(header)\n        \n        # Build content sections based on priority order\n        content_sections = {}\n        \n        if entity.signature:\n            content_sections[\"signature\"] = f\"## Signature\\n\\n```python\\n{entity.signature}\\n```\"\n            \n        if entity.docstring:\n            content_sections[\"docstring\"] = f\"## Description\\n\\n{entity.docstring}\"\n            \n        if entity.source_code:\n            code_header = \"## Source Code\\n\\n```python\\n\"\n            code_footer = \"\\n```\"\n            code_body = entity.source_code\n            # Pre-truncate if too long\n            max_code_tokens = int(self.max_tokens * 0.5)  # Reserve half for code max\n            code_tokens = self.tokenizer.count_tokens(code_body)\n            if code_tokens > max_code_tokens:\n                code_body = self.tokenizer.truncate(code_body, ", "tokens": ["ays", "include", "header", "header", "self", "format", "entity", "header", "entity", "current", "tokens", "self", "tokenizer", "count", "tokens", "header", "sections", "append", "header", "build", "content", "sections", "based", "on", "priority", "order", "content", "sections", "if", "entity", "signature", "content", "sections", "signature", "signature", "python", "entity", "signature", "if", "entity", "docstring", "content", "sections", "docstring", "description", "entity", "docstring", "if", "entity", "source", "code", "code", "header", "source", "code", "python", "code", "footer", "code", "body", "entity", "source", "code", "pre", "truncate", "if", "too", "long", "max", "code", "tokens", "int", "self", "max", "tokens", "reserve", "half", "for", "code", "max", "code", "tokens", "self", "tokenizer", "count", "tokens", "code", "body", "if", "code", "tokens", "max", "code", "tokens", "code", "body", "self", "tokenizer", "truncate", "code", "body"], "metadata": {"kind": "method", "chunk_index": "2", "has_docstring": "true", "last_modified": "1768185812.9925995"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/analysis/context_synthesizer.py::ContextSynthesizer.synthesize_with_task::3", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/analysis/context_synthesizer.py::ContextSynthesizer.synthesize_with_task", "content": "   if code_tokens > max_code_tokens:\n                code_body = self.tokenizer.truncate(code_body, max_code_tokens) + \"\\n# ... (truncated)\"\n            content_sections[\"source_code\"] = f\"{code_header}{code_body}{code_footer}\"\n            \n        parent = self.store.get_parent(entity_id)\n        if parent:\n            content_sections[\"parent\"] = self._format_parent_context(parent)\n            \n        callers = self.store.get_callers(entity_id)\n        if callers:\n            content_sections[\"callers\"] = self._format_callers(callers)\n            \n        callees = self.store.get_callees(entity_id)\n        if callees:\n            content_sections[\"callees\"] = self._format_callees(callees)\n            \n        if entity.kind in {EntityKind.CLASS, EntityKind.MODULE, EntityKind.DOCUMENT}:\n            children = self.store.get_children(entity_id)\n            if children:\n                content_sections[\"children\"] = self._format_children(children)\n        \n        # Add sections in pri", "tokens": ["if", "code", "tokens", "max", "code", "tokens", "code", "body", "self", "tokenizer", "truncate", "code", "body", "max", "code", "tokens", "truncated", "content", "sections", "source", "code", "code", "header", "code", "body", "code", "footer", "parent", "self", "store", "get", "parent", "entity", "id", "if", "parent", "content", "sections", "parent", "self", "format", "parent", "context", "parent", "callers", "self", "store", "get", "callers", "entity", "id", "if", "callers", "content", "sections", "callers", "self", "format", "callers", "callers", "callees", "self", "store", "get", "callees", "entity", "id", "if", "callees", "content", "sections", "callees", "self", "format", "callees", "callees", "if", "entity", "kind", "in", "entity", "kind", "class", "entity", "kind", "module", "entity", "kind", "document", "children", "self", "store", "get", "children", "entity", "id", "if", "children", "content", "sections", "children", "self", "format", "children", "children", "add", "sections", "in", "pri"], "metadata": {"kind": "method", "chunk_index": "3", "has_docstring": "true", "last_modified": "1768185812.9925995"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/analysis/context_synthesizer.py::ContextSynthesizer.synthesize_with_task::4", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/analysis/context_synthesizer.py::ContextSynthesizer.synthesize_with_task", "content": "ontent_sections[\"children\"] = self._format_children(children)\n        \n        # Add sections in priority order until budget exhausted\n        is_truncated = False\n        \n        for section_name in priority_order:\n            if section_name not in content_sections:\n                continue\n                \n            section_text = content_sections[section_name]\n            t = self.tokenizer.count_tokens(section_text)\n            \n            # Apply boost: if boosted, allocate more budget\n            boost = boosts.get(section_name, 1.0)\n            effective_budget = self.max_tokens * boost\n            \n            if current_tokens + t < min(effective_budget, self.max_tokens):\n                sections.append(section_text)\n                current_tokens += t\n                content_included[section_name] = True\n                \n                # Track included entity IDs\n                if section_name == \"parent\" and parent:\n                    included.append(parent.id)\n     ", "tokens": ["ontent", "sections", "children", "self", "format", "children", "children", "add", "sections", "in", "priority", "order", "until", "budget", "exhausted", "is", "truncated", "false", "for", "section", "name", "in", "priority", "order", "if", "section", "name", "not", "in", "content", "sections", "continue", "section", "text", "content", "sections", "section", "name", "self", "tokenizer", "count", "tokens", "section", "text", "apply", "boost", "if", "boosted", "allocate", "more", "budget", "boost", "boosts", "get", "section", "name", "effective", "budget", "self", "max", "tokens", "boost", "if", "current", "tokens", "min", "effective", "budget", "self", "max", "tokens", "sections", "append", "section", "text", "current", "tokens", "content", "included", "section", "name", "true", "track", "included", "entity", "ids", "if", "section", "name", "parent", "and", "parent", "included", "append", "parent", "id"], "metadata": {"kind": "method", "chunk_index": "4", "has_docstring": "true", "last_modified": "1768185812.9925995"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/analysis/context_synthesizer.py::ContextSynthesizer.synthesize_with_task::5", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/analysis/context_synthesizer.py::ContextSynthesizer.synthesize_with_task", "content": "        if section_name == \"parent\" and parent:\n                    included.append(parent.id)\n                elif section_name == \"callers\" and callers:\n                    included.extend(c.id for c in callers[:10])\n                elif section_name == \"callees\" and callees:\n                    included.extend(c.id for c in callees[:10])\n                elif section_name == \"children\":\n                    children_list = self.store.get_children(entity_id)\n                    if children_list:\n                        included.extend(c.id for c in children_list[:15])\n            else:\n                is_truncated = True\n        \n        context_text = \"\\n\\n---\\n\\n\".join(sections)\n        \n        # Calculate sufficiency score based on task requirements\n        sufficiency = self._calculate_sufficiency(\n            task_type, content_included, entity, context_text\n        )\n        \n        return ContextBundle(\n            target_entity=entity,\n            context_text=context_text,\n ", "tokens": ["if", "section", "name", "parent", "and", "parent", "included", "append", "parent", "id", "elif", "section", "name", "callers", "and", "callers", "included", "extend", "id", "for", "in", "callers", "10", "elif", "section", "name", "callees", "and", "callees", "included", "extend", "id", "for", "in", "callees", "10", "elif", "section", "name", "children", "children", "list", "self", "store", "get", "children", "entity", "id", "if", "children", "list", "included", "extend", "id", "for", "in", "children", "list", "15", "else", "is", "truncated", "true", "context", "text", "join", "sections", "calculate", "sufficiency", "score", "based", "on", "task", "requirements", "sufficiency", "self", "calculate", "sufficiency", "task", "type", "content", "included", "entity", "context", "text", "return", "context", "bundle", "target", "entity", "entity", "context", "text", "context", "text"], "metadata": {"kind": "method", "chunk_index": "5", "has_docstring": "true", "last_modified": "1768185812.9925995"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/analysis/context_synthesizer.py::ContextSynthesizer.synthesize_with_task::6", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/analysis/context_synthesizer.py::ContextSynthesizer.synthesize_with_task", "content": "    return ContextBundle(\n            target_entity=entity,\n            context_text=context_text,\n            included_entities=included,\n            total_chars=len(context_text),\n            total_tokens=current_tokens,\n            truncated=is_truncated,\n            task_type=task_type,\n            sufficiency_score=sufficiency,\n        )", "tokens": ["return", "context", "bundle", "target", "entity", "entity", "context", "text", "context", "text", "included", "entities", "included", "total", "chars", "len", "context", "text", "total", "tokens", "current", "tokens", "truncated", "is", "truncated", "task", "type", "task", "type", "sufficiency", "score", "sufficiency"], "metadata": {"kind": "method", "chunk_index": "6", "has_docstring": "true", "last_modified": "1768185812.9925995"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/analysis/context_synthesizer.py::ContextSynthesizer._calculate_sufficiency::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/analysis/context_synthesizer.py::ContextSynthesizer._calculate_sufficiency", "content": "def _calculate_sufficiency(self, task_type: TaskType, content_included: dict[str, bool], entity: Entity, context_text: str) -> float\n\"\"\"Calculate sufficiency score (0.0-1.0) for local-first answering.\n\nHigher scores indicate the context is likely sufficient to answer\nwithout needing an external LLM.\n\nArgs:\n    task_type: The type of task being performed.\n    content_included: Dict tracking what content was included.\n    entity: The target entity.\n    context_text: The synthesized context.\n    \nReturns:\n    Sufficiency score from 0.0 to 1.0.\"\"\"\n    def _calculate_sufficiency(\n        self,\n        task_type: TaskType,\n        content_included: dict[str, bool],\n        entity: Entity,\n        context_text: str,\n    ) -> float:\n        \"\"\"Calculate sufficiency score (0.0-1.0) for local-first answering.\n        \n        Higher scores indicate the context is likely sufficient to answer\n        without needing an external LLM.\n        \n        Args:\n            task_type: The type of task be", "tokens": ["def", "calculate", "sufficiency", "self", "task", "type", "task", "type", "content", "included", "dict", "str", "bool", "entity", "entity", "context", "text", "str", "float", "calculate", "sufficiency", "score", "for", "local", "first", "answering", "higher", "scores", "indicate", "the", "context", "is", "likely", "sufficient", "to", "answer", "without", "needing", "an", "external", "llm", "args", "task", "type", "the", "type", "of", "task", "being", "performed", "content", "included", "dict", "tracking", "what", "content", "was", "included", "entity", "the", "target", "entity", "context", "text", "the", "synthesized", "context", "returns", "sufficiency", "score", "from", "to", "def", "calculate", "sufficiency", "self", "task", "type", "task", "type", "content", "included", "dict", "str", "bool", "entity", "entity", "context", "text", "str", "float", "calculate", "sufficiency", "score", "for", "local", "first", "answering", "higher", "scores", "indicate", "the", "context", "is", "likely", "sufficient", "to", "answer", "without", "needing", "an", "external", "llm", "args", "task", "type", "the", "type", "of", "task", "be"], "metadata": {"kind": "method", "chunk_index": "0", "has_docstring": "true", "last_modified": "1768185812.9925995"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/analysis/context_synthesizer.py::ContextSynthesizer._calculate_sufficiency::1", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/analysis/context_synthesizer.py::ContextSynthesizer._calculate_sufficiency", "content": "  without needing an external LLM.\n        \n        Args:\n            task_type: The type of task being performed.\n            content_included: Dict tracking what content was included.\n            entity: The target entity.\n            context_text: The synthesized context.\n            \n        Returns:\n            Sufficiency score from 0.0 to 1.0.\n        \"\"\"\n        template = TASK_TEMPLATES.get(task_type, TASK_TEMPLATES[TaskType.GENERAL])\n        priority_order = template[\"priority\"]\n        \n        score = 0.0\n        max_score = 0.0\n        \n        # Weight each priority item by its position (higher priority = more weight)\n        for i, section_name in enumerate(priority_order):\n            weight = 1.0 / (i + 1)  # Decreasing weight by position\n            max_score += weight\n            \n            if content_included.get(section_name, False):\n                score += weight\n        \n        # Bonus for having source code (always valuable)\n        if entity.source_code and", "tokens": ["without", "needing", "an", "external", "llm", "args", "task", "type", "the", "type", "of", "task", "being", "performed", "content", "included", "dict", "tracking", "what", "content", "was", "included", "entity", "the", "target", "entity", "context", "text", "the", "synthesized", "context", "returns", "sufficiency", "score", "from", "to", "template", "task", "templates", "get", "task", "type", "task", "templates", "task", "type", "general", "priority", "order", "template", "priority", "score", "max", "score", "weight", "each", "priority", "item", "by", "its", "position", "higher", "priority", "more", "weight", "for", "section", "name", "in", "enumerate", "priority", "order", "weight", "decreasing", "weight", "by", "position", "max", "score", "weight", "if", "content", "included", "get", "section", "name", "false", "score", "weight", "bonus", "for", "having", "source", "code", "always", "valuable", "if", "entity", "source", "code", "and"], "metadata": {"kind": "method", "chunk_index": "1", "has_docstring": "true", "last_modified": "1768185812.9925995"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/analysis/context_synthesizer.py::ContextSynthesizer._calculate_sufficiency::2", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/analysis/context_synthesizer.py::ContextSynthesizer._calculate_sufficiency", "content": "\n        \n        # Bonus for having source code (always valuable)\n        if entity.source_code and \"## Source Code\" in context_text:\n            score += 0.2\n            max_score += 0.2\n            \n        # Bonus for having docstring (helps LLM understand intent)\n        if entity.docstring and len(entity.docstring) > 50:\n            score += 0.1\n            max_score += 0.1\n            \n        # Penalize if context is very short\n        min_useful_tokens = 100\n        if len(context_text) < min_useful_tokens:\n            score *= 0.5\n            \n        return min(1.0, round(score / max_score, 2)) if max_score > 0 else 0.0", "tokens": ["bonus", "for", "having", "source", "code", "always", "valuable", "if", "entity", "source", "code", "and", "source", "code", "in", "context", "text", "score", "max", "score", "bonus", "for", "having", "docstring", "helps", "llm", "understand", "intent", "if", "entity", "docstring", "and", "len", "entity", "docstring", "50", "score", "max", "score", "penalize", "if", "context", "is", "very", "short", "min", "useful", "tokens", "100", "if", "len", "context", "text", "min", "useful", "tokens", "score", "return", "min", "round", "score", "max", "score", "if", "max", "score", "else"], "metadata": {"kind": "method", "chunk_index": "2", "has_docstring": "true", "last_modified": "1768185812.9925995"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/analysis/signals.py::module::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/analysis/signals.py::module", "content": "\"\"\"Runtime signal processing (e.g., coverage, traces).\"\"\"", "tokens": ["runtime", "signal", "processing", "coverage", "traces"], "metadata": {"type": "module_header"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/analysis/signals.py::imports::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/analysis/signals.py::module", "content": "from __future__ import annotations\nimport xml.etree.ElementTree as ET\nfrom pathlib import Path\nfrom knowcode.data_models import (", "tokens": ["from", "future", "import", "annotations", "import", "xml", "etree", "element", "tree", "as", "et", "from", "pathlib", "import", "path", "from", "knowcode", "data", "models", "import"], "metadata": {"type": "imports"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/analysis/signals.py::CoverageProcessor::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/analysis/signals.py::CoverageProcessor", "content": "\"\"\"Process coverage reports.\"\"\"\nclass CoverageProcessor:\n    \"\"\"Process coverage reports.\"\"\"\n\n    def __init__(self, root_dir: str | Path) -> None:\n        \"\"\"Initialize coverage processor.\n\n        Args:\n            root_dir: Root directory of the codebase (for relative path resolution).\n        \"\"\"\n        self.root_dir = Path(root_dir).resolve()\n\n    def process_cobertura(self, xml_path: str | Path) -> ParseResult:\n        \"\"\"Process a Cobertura XML coverage report.\n\n        Args:\n            xml_path: Path to coverage.xml.\n\n        Returns:\n            ParseResult containing COVERAGE_REPORT entity and COVERS relationships.\n        \"\"\"\n        xml_path = Path(xml_path)\n        if not xml_path.exists():\n            return ParseResult(\n                file_path=str(xml_path),\n                entities=[],\n                relationships=[],\n                errors=[f\"Coverage file not found: {xml_path}\"],\n            )\n\n        entities: list[Entity] = []\n        relationships: list[Relat", "tokens": ["process", "coverage", "reports", "class", "coverage", "processor", "process", "coverage", "reports", "def", "init", "self", "root", "dir", "str", "path", "none", "initialize", "coverage", "processor", "args", "root", "dir", "root", "directory", "of", "the", "codebase", "for", "relative", "path", "resolution", "self", "root", "dir", "path", "root", "dir", "resolve", "def", "process", "cobertura", "self", "xml", "path", "str", "path", "parse", "result", "process", "cobertura", "xml", "coverage", "report", "args", "xml", "path", "path", "to", "coverage", "xml", "returns", "parse", "result", "containing", "coverage", "report", "entity", "and", "covers", "relationships", "xml", "path", "path", "xml", "path", "if", "not", "xml", "path", "exists", "return", "parse", "result", "file", "path", "str", "xml", "path", "entities", "relationships", "errors", "coverage", "file", "not", "found", "xml", "path", "entities", "list", "entity", "relationships", "list", "relat"], "metadata": {"kind": "class", "chunk_index": "0", "has_docstring": "true", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/analysis/signals.py::CoverageProcessor::1", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/analysis/signals.py::CoverageProcessor", "content": ": {xml_path}\"],\n            )\n\n        entities: list[Entity] = []\n        relationships: list[Relationship] = []\n        errors: list[str] = []\n\n        try:\n            tree = ET.parse(xml_path)\n            root = tree.getroot()\n\n            # Create Report Entity\n            report_id = f\"coverage::{xml_path.name}\"\n            # Extract timestamp if available available in root attributes usually 'timestamp'\n            timestamp = root.get(\"timestamp\", str(xml_path.stat().st_mtime))\n            \n            report_entity = Entity(\n                id=report_id,\n                kind=EntityKind.COVERAGE_REPORT,\n                name=f\"Coverage Report ({xml_path.name})\",\n                qualified_name=xml_path.name,\n                location=Location(str(xml_path), 0, 0),\n                metadata={\n                    \"timestamp\": timestamp,\n                    \"line-rate\": root.get(\"line-rate\", \"0\"),\n                    \"branch-rate\": root.get(\"branch-rate\", \"0\"),\n                },\n    ", "tokens": ["xml", "path", "entities", "list", "entity", "relationships", "list", "relationship", "errors", "list", "str", "try", "tree", "et", "parse", "xml", "path", "root", "tree", "getroot", "create", "report", "entity", "report", "id", "coverage", "xml", "path", "name", "extract", "timestamp", "if", "available", "available", "in", "root", "attributes", "usually", "timestamp", "timestamp", "root", "get", "timestamp", "str", "xml", "path", "stat", "st", "mtime", "report", "entity", "entity", "id", "report", "id", "kind", "entity", "kind", "coverage", "report", "name", "coverage", "report", "xml", "path", "name", "qualified", "name", "xml", "path", "name", "location", "location", "str", "xml", "path", "metadata", "timestamp", "timestamp", "line", "rate", "root", "get", "line", "rate", "branch", "rate", "root", "get", "branch", "rate"], "metadata": {"kind": "class", "chunk_index": "1", "has_docstring": "true", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/analysis/signals.py::CoverageProcessor::2", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/analysis/signals.py::CoverageProcessor", "content": "ate\", \"0\"),\n                    \"branch-rate\": root.get(\"branch-rate\", \"0\"),\n                },\n            )\n            entities.append(report_entity)\n\n            # Traverse packages -> classes -> lines\n            # Structure: coverage -> packages -> package -> classes -> class -> lines -> line\n            \n            # We want to map files/classes to the report.\n            # <class name=\"knowcode.models\" filename=\"src/knowcode/models.py\" line-rate=\"1.0\" ...>\n            \n            for cls in root.findall(\".//class\"):\n                filename = cls.get(\"filename\")\n                if not filename:\n                    continue\n                \n                # Resolve file path to simple module ID\n                # We assume standard module ID: /abs/path/to/file::filename_stem\n                # filename in coverage.xml is usually relative to root\n                abs_file_path = (self.root_dir / filename).resolve()\n                module_name = abs_file_path.stem\n                ", "tokens": ["ate", "branch", "rate", "root", "get", "branch", "rate", "entities", "append", "report", "entity", "traverse", "packages", "classes", "lines", "structure", "coverage", "packages", "package", "classes", "class", "lines", "line", "we", "want", "to", "map", "files", "classes", "to", "the", "report", "class", "name", "knowcode", "models", "filename", "src", "knowcode", "models", "py", "line", "rate", "for", "cls", "in", "root", "findall", "class", "filename", "cls", "get", "filename", "if", "not", "filename", "continue", "resolve", "file", "path", "to", "simple", "module", "id", "we", "assume", "standard", "module", "id", "abs", "path", "to", "file", "filename", "stem", "filename", "in", "coverage", "xml", "is", "usually", "relative", "to", "root", "abs", "file", "path", "self", "root", "dir", "filename", "resolve", "module", "name", "abs", "file", "path", "stem"], "metadata": {"kind": "class", "chunk_index": "2", "has_docstring": "true", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/analysis/signals.py::CoverageProcessor::3", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/analysis/signals.py::CoverageProcessor", "content": "elf.root_dir / filename).resolve()\n                module_name = abs_file_path.stem\n                module_id = f\"{abs_file_path}::{module_name}\"\n                \n                line_rate = cls.get(\"line-rate\", \"0\")\n                \n                # Relationship: REPORT -> COVERS -> MODULE\n                relationships.append(\n                    Relationship(\n                        source_id=report_id,\n                        target_id=module_id,\n                        kind=RelationshipKind.COVERS,\n                        metadata={\n                            \"line-rate\": line_rate,\n                            \"hits\": cls.get(\"lines-covered\", \"0\") + \"/\" + cls.get(\"lines-valid\", \"0\")\n                        }\n                    )\n                )\n                \n                # We could map specific lines to entities if we had line ranges of entities loaded.\n                # Since CoverageProcessor runs independently or after graph build, \n                # we usually just l", "tokens": ["elf", "root", "dir", "filename", "resolve", "module", "name", "abs", "file", "path", "stem", "module", "id", "abs", "file", "path", "module", "name", "line", "rate", "cls", "get", "line", "rate", "relationship", "report", "covers", "module", "relationships", "append", "relationship", "source", "id", "report", "id", "target", "id", "module", "id", "kind", "relationship", "kind", "covers", "metadata", "line", "rate", "line", "rate", "hits", "cls", "get", "lines", "covered", "cls", "get", "lines", "valid", "we", "could", "map", "specific", "lines", "to", "entities", "if", "we", "had", "line", "ranges", "of", "entities", "loaded", "since", "coverage", "processor", "runs", "independently", "or", "after", "graph", "build", "we", "usually", "just"], "metadata": {"kind": "class", "chunk_index": "3", "has_docstring": "true", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/analysis/signals.py::CoverageProcessor::4", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/analysis/signals.py::CoverageProcessor", "content": "ince CoverageProcessor runs independently or after graph build, \n                # we usually just link to the File/Module level for MVP.\n                # Detailed line mapping requires access to the full graph to find which entity covers line X.\n                # For v1.4 MVP, linking to Module is sufficient.\n                \n                # Note: We can also add \"EXECUTED_BY\" from Module to Report\n                relationships.append(\n                    Relationship(\n                        source_id=module_id,\n                        target_id=report_id,\n                        kind=RelationshipKind.EXECUTED_BY\n                    )\n                )\n\n        except ET.ParseError as e:\n            errors.append(f\"Invalid XML format: {e}\")\n        except Exception as e:\n            errors.append(f\"Error processing coverage: {e}\")\n\n        return ParseResult(\n            file_path=str(xml_path),\n            entities=entities,\n            relationships=relationships,\n            er", "tokens": ["ince", "coverage", "processor", "runs", "independently", "or", "after", "graph", "build", "we", "usually", "just", "link", "to", "the", "file", "module", "level", "for", "mvp", "detailed", "line", "mapping", "requires", "access", "to", "the", "full", "graph", "to", "find", "which", "entity", "covers", "line", "for", "v1", "mvp", "linking", "to", "module", "is", "sufficient", "note", "we", "can", "also", "add", "executed", "by", "from", "module", "to", "report", "relationships", "append", "relationship", "source", "id", "module", "id", "target", "id", "report", "id", "kind", "relationship", "kind", "executed", "by", "except", "et", "parse", "error", "as", "errors", "append", "invalid", "xml", "format", "except", "exception", "as", "errors", "append", "error", "processing", "coverage", "return", "parse", "result", "file", "path", "str", "xml", "path", "entities", "entities", "relationships", "relationships", "er"], "metadata": {"kind": "class", "chunk_index": "4", "has_docstring": "true", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/analysis/signals.py::CoverageProcessor::5", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/analysis/signals.py::CoverageProcessor", "content": "tr(xml_path),\n            entities=entities,\n            relationships=relationships,\n            errors=errors,\n        )", "tokens": ["tr", "xml", "path", "entities", "entities", "relationships", "relationships", "errors", "errors"], "metadata": {"kind": "class", "chunk_index": "5", "has_docstring": "true", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/analysis/signals.py::CoverageProcessor.__init__::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/analysis/signals.py::CoverageProcessor.__init__", "content": "def __init__(self, root_dir: str | Path) -> None\n\"\"\"Initialize coverage processor.\n\nArgs:\n    root_dir: Root directory of the codebase (for relative path resolution).\"\"\"\n    def __init__(self, root_dir: str | Path) -> None:\n        \"\"\"Initialize coverage processor.\n\n        Args:\n            root_dir: Root directory of the codebase (for relative path resolution).\n        \"\"\"\n        self.root_dir = Path(root_dir).resolve()", "tokens": ["def", "init", "self", "root", "dir", "str", "path", "none", "initialize", "coverage", "processor", "args", "root", "dir", "root", "directory", "of", "the", "codebase", "for", "relative", "path", "resolution", "def", "init", "self", "root", "dir", "str", "path", "none", "initialize", "coverage", "processor", "args", "root", "dir", "root", "directory", "of", "the", "codebase", "for", "relative", "path", "resolution", "self", "root", "dir", "path", "root", "dir", "resolve"], "metadata": {"kind": "method", "has_docstring": "true", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/analysis/signals.py::CoverageProcessor.process_cobertura::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/analysis/signals.py::CoverageProcessor.process_cobertura", "content": "def process_cobertura(self, xml_path: str | Path) -> ParseResult\n\"\"\"Process a Cobertura XML coverage report.\n\nArgs:\n    xml_path: Path to coverage.xml.\n\nReturns:\n    ParseResult containing COVERAGE_REPORT entity and COVERS relationships.\"\"\"\n    def process_cobertura(self, xml_path: str | Path) -> ParseResult:\n        \"\"\"Process a Cobertura XML coverage report.\n\n        Args:\n            xml_path: Path to coverage.xml.\n\n        Returns:\n            ParseResult containing COVERAGE_REPORT entity and COVERS relationships.\n        \"\"\"\n        xml_path = Path(xml_path)\n        if not xml_path.exists():\n            return ParseResult(\n                file_path=str(xml_path),\n                entities=[],\n                relationships=[],\n                errors=[f\"Coverage file not found: {xml_path}\"],\n            )\n\n        entities: list[Entity] = []\n        relationships: list[Relationship] = []\n        errors: list[str] = []\n\n        try:\n            tree = ET.parse(xml_path)\n            ro", "tokens": ["def", "process", "cobertura", "self", "xml", "path", "str", "path", "parse", "result", "process", "cobertura", "xml", "coverage", "report", "args", "xml", "path", "path", "to", "coverage", "xml", "returns", "parse", "result", "containing", "coverage", "report", "entity", "and", "covers", "relationships", "def", "process", "cobertura", "self", "xml", "path", "str", "path", "parse", "result", "process", "cobertura", "xml", "coverage", "report", "args", "xml", "path", "path", "to", "coverage", "xml", "returns", "parse", "result", "containing", "coverage", "report", "entity", "and", "covers", "relationships", "xml", "path", "path", "xml", "path", "if", "not", "xml", "path", "exists", "return", "parse", "result", "file", "path", "str", "xml", "path", "entities", "relationships", "errors", "coverage", "file", "not", "found", "xml", "path", "entities", "list", "entity", "relationships", "list", "relationship", "errors", "list", "str", "try", "tree", "et", "parse", "xml", "path", "ro"], "metadata": {"kind": "method", "chunk_index": "0", "has_docstring": "true", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/analysis/signals.py::CoverageProcessor.process_cobertura::1", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/analysis/signals.py::CoverageProcessor.process_cobertura", "content": "[]\n        errors: list[str] = []\n\n        try:\n            tree = ET.parse(xml_path)\n            root = tree.getroot()\n\n            # Create Report Entity\n            report_id = f\"coverage::{xml_path.name}\"\n            # Extract timestamp if available available in root attributes usually 'timestamp'\n            timestamp = root.get(\"timestamp\", str(xml_path.stat().st_mtime))\n            \n            report_entity = Entity(\n                id=report_id,\n                kind=EntityKind.COVERAGE_REPORT,\n                name=f\"Coverage Report ({xml_path.name})\",\n                qualified_name=xml_path.name,\n                location=Location(str(xml_path), 0, 0),\n                metadata={\n                    \"timestamp\": timestamp,\n                    \"line-rate\": root.get(\"line-rate\", \"0\"),\n                    \"branch-rate\": root.get(\"branch-rate\", \"0\"),\n                },\n            )\n            entities.append(report_entity)\n\n            # Traverse packages -> classes -> lines\n     ", "tokens": ["errors", "list", "str", "try", "tree", "et", "parse", "xml", "path", "root", "tree", "getroot", "create", "report", "entity", "report", "id", "coverage", "xml", "path", "name", "extract", "timestamp", "if", "available", "available", "in", "root", "attributes", "usually", "timestamp", "timestamp", "root", "get", "timestamp", "str", "xml", "path", "stat", "st", "mtime", "report", "entity", "entity", "id", "report", "id", "kind", "entity", "kind", "coverage", "report", "name", "coverage", "report", "xml", "path", "name", "qualified", "name", "xml", "path", "name", "location", "location", "str", "xml", "path", "metadata", "timestamp", "timestamp", "line", "rate", "root", "get", "line", "rate", "branch", "rate", "root", "get", "branch", "rate", "entities", "append", "report", "entity", "traverse", "packages", "classes", "lines"], "metadata": {"kind": "method", "chunk_index": "1", "has_docstring": "true", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/analysis/signals.py::CoverageProcessor.process_cobertura::2", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/analysis/signals.py::CoverageProcessor.process_cobertura", "content": "           entities.append(report_entity)\n\n            # Traverse packages -> classes -> lines\n            # Structure: coverage -> packages -> package -> classes -> class -> lines -> line\n            \n            # We want to map files/classes to the report.\n            # <class name=\"knowcode.models\" filename=\"src/knowcode/models.py\" line-rate=\"1.0\" ...>\n            \n            for cls in root.findall(\".//class\"):\n                filename = cls.get(\"filename\")\n                if not filename:\n                    continue\n                \n                # Resolve file path to simple module ID\n                # We assume standard module ID: /abs/path/to/file::filename_stem\n                # filename in coverage.xml is usually relative to root\n                abs_file_path = (self.root_dir / filename).resolve()\n                module_name = abs_file_path.stem\n                module_id = f\"{abs_file_path}::{module_name}\"\n                \n                line_rate = cls.get(\"line-rate\",", "tokens": ["entities", "append", "report", "entity", "traverse", "packages", "classes", "lines", "structure", "coverage", "packages", "package", "classes", "class", "lines", "line", "we", "want", "to", "map", "files", "classes", "to", "the", "report", "class", "name", "knowcode", "models", "filename", "src", "knowcode", "models", "py", "line", "rate", "for", "cls", "in", "root", "findall", "class", "filename", "cls", "get", "filename", "if", "not", "filename", "continue", "resolve", "file", "path", "to", "simple", "module", "id", "we", "assume", "standard", "module", "id", "abs", "path", "to", "file", "filename", "stem", "filename", "in", "coverage", "xml", "is", "usually", "relative", "to", "root", "abs", "file", "path", "self", "root", "dir", "filename", "resolve", "module", "name", "abs", "file", "path", "stem", "module", "id", "abs", "file", "path", "module", "name", "line", "rate", "cls", "get", "line", "rate"], "metadata": {"kind": "method", "chunk_index": "2", "has_docstring": "true", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/analysis/signals.py::CoverageProcessor.process_cobertura::3", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/analysis/signals.py::CoverageProcessor.process_cobertura", "content": " f\"{abs_file_path}::{module_name}\"\n                \n                line_rate = cls.get(\"line-rate\", \"0\")\n                \n                # Relationship: REPORT -> COVERS -> MODULE\n                relationships.append(\n                    Relationship(\n                        source_id=report_id,\n                        target_id=module_id,\n                        kind=RelationshipKind.COVERS,\n                        metadata={\n                            \"line-rate\": line_rate,\n                            \"hits\": cls.get(\"lines-covered\", \"0\") + \"/\" + cls.get(\"lines-valid\", \"0\")\n                        }\n                    )\n                )\n                \n                # We could map specific lines to entities if we had line ranges of entities loaded.\n                # Since CoverageProcessor runs independently or after graph build, \n                # we usually just link to the File/Module level for MVP.\n                # Detailed line mapping requires access to the full graph", "tokens": ["abs", "file", "path", "module", "name", "line", "rate", "cls", "get", "line", "rate", "relationship", "report", "covers", "module", "relationships", "append", "relationship", "source", "id", "report", "id", "target", "id", "module", "id", "kind", "relationship", "kind", "covers", "metadata", "line", "rate", "line", "rate", "hits", "cls", "get", "lines", "covered", "cls", "get", "lines", "valid", "we", "could", "map", "specific", "lines", "to", "entities", "if", "we", "had", "line", "ranges", "of", "entities", "loaded", "since", "coverage", "processor", "runs", "independently", "or", "after", "graph", "build", "we", "usually", "just", "link", "to", "the", "file", "module", "level", "for", "mvp", "detailed", "line", "mapping", "requires", "access", "to", "the", "full", "graph"], "metadata": {"kind": "method", "chunk_index": "3", "has_docstring": "true", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/analysis/signals.py::CoverageProcessor.process_cobertura::4", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/analysis/signals.py::CoverageProcessor.process_cobertura", "content": "File/Module level for MVP.\n                # Detailed line mapping requires access to the full graph to find which entity covers line X.\n                # For v1.4 MVP, linking to Module is sufficient.\n                \n                # Note: We can also add \"EXECUTED_BY\" from Module to Report\n                relationships.append(\n                    Relationship(\n                        source_id=module_id,\n                        target_id=report_id,\n                        kind=RelationshipKind.EXECUTED_BY\n                    )\n                )\n\n        except ET.ParseError as e:\n            errors.append(f\"Invalid XML format: {e}\")\n        except Exception as e:\n            errors.append(f\"Error processing coverage: {e}\")\n\n        return ParseResult(\n            file_path=str(xml_path),\n            entities=entities,\n            relationships=relationships,\n            errors=errors,\n        )", "tokens": ["file", "module", "level", "for", "mvp", "detailed", "line", "mapping", "requires", "access", "to", "the", "full", "graph", "to", "find", "which", "entity", "covers", "line", "for", "v1", "mvp", "linking", "to", "module", "is", "sufficient", "note", "we", "can", "also", "add", "executed", "by", "from", "module", "to", "report", "relationships", "append", "relationship", "source", "id", "module", "id", "target", "id", "report", "id", "kind", "relationship", "kind", "executed", "by", "except", "et", "parse", "error", "as", "errors", "append", "invalid", "xml", "format", "except", "exception", "as", "errors", "append", "error", "processing", "coverage", "return", "parse", "result", "file", "path", "str", "xml", "path", "entities", "entities", "relationships", "relationships", "errors", "errors"], "metadata": {"kind": "method", "chunk_index": "4", "has_docstring": "true", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/mcp/server.py::module::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/mcp/server.py::module", "content": "\"\"\"MCP Server implementation for KnowCode.\n\nProvides an MCP server that exposes KnowCode's codebase intelligence\nto LLM applications via the Model Context Protocol.\n\"\"\"", "tokens": ["mcp", "server", "implementation", "for", "know", "code", "provides", "an", "mcp", "server", "that", "exposes", "know", "code", "codebase", "intelligence", "to", "llm", "applications", "via", "the", "model", "context", "protocol"], "metadata": {"type": "module_header"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/mcp/server.py::imports::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/mcp/server.py::module", "content": "from __future__ import annotations\nimport asyncio\nimport json\nfrom pathlib import Path\nfrom typing import Any, Optional\n    from mcp.server import Server\n    from mcp.server.stdio import stdio_server\n    from mcp.types import (\nfrom knowcode.service import KnowCodeService\nfrom knowcode.storage.knowledge_store import KnowledgeStore\nfrom knowcode.data_models import TaskType", "tokens": ["from", "future", "import", "annotations", "import", "asyncio", "import", "json", "from", "pathlib", "import", "path", "from", "typing", "import", "any", "optional", "from", "mcp", "server", "import", "server", "from", "mcp", "server", "stdio", "import", "stdio", "server", "from", "mcp", "types", "import", "from", "knowcode", "service", "import", "know", "code", "service", "from", "knowcode", "storage", "knowledge", "store", "import", "knowledge", "store", "from", "knowcode", "data", "models", "import", "task", "type"], "metadata": {"type": "imports"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/mcp/server.py::KnowCodeMCPServer::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/mcp/server.py::KnowCodeMCPServer", "content": "\"\"\"MCP Server wrapper for KnowCode.\"\"\"\nclass KnowCodeMCPServer:\n    \"\"\"MCP Server wrapper for KnowCode.\"\"\"\n    \n    def __init__(self, store_path: str | Path, config_path: Optional[str] = None) -> None:\n        \"\"\"Initialize MCP server with knowledge store.\n        \n        Args:\n            store_path: Path to knowcode_knowledge.json\n            config_path: Optional path to aimodels.yaml for model priorities.\n        \"\"\"\n        self.store_path = Path(store_path)\n        self.config_path = config_path\n        self._service: Optional[KnowCodeService] = None\n        \n    def _ensure_service(self, allow_missing_store: bool = False) -> KnowCodeService:\n        \"\"\"Create the shared service (loads store/index lazily).\"\"\"\n        if self._service is None:\n            store_file = self.store_path\n            if store_file.is_dir():\n                store_file = store_file / KnowledgeStore.DEFAULT_FILENAME\n\n            if not allow_missing_store and not store_file.exists():\n                rai", "tokens": ["mcp", "server", "wrapper", "for", "know", "code", "class", "know", "code", "mcpserver", "mcp", "server", "wrapper", "for", "know", "code", "def", "init", "self", "store", "path", "str", "path", "config", "path", "optional", "str", "none", "none", "initialize", "mcp", "server", "with", "knowledge", "store", "args", "store", "path", "path", "to", "knowcode", "knowledge", "json", "config", "path", "optional", "path", "to", "aimodels", "yaml", "for", "model", "priorities", "self", "store", "path", "path", "store", "path", "self", "config", "path", "config", "path", "self", "service", "optional", "know", "code", "service", "none", "def", "ensure", "service", "self", "allow", "missing", "store", "bool", "false", "know", "code", "service", "create", "the", "shared", "service", "loads", "store", "index", "lazily", "if", "self", "service", "is", "none", "store", "file", "self", "store", "path", "if", "store", "file", "is", "dir", "store", "file", "store", "file", "knowledge", "store", "default", "filename", "if", "not", "allow", "missing", "store", "and", "not", "store", "file", "exists", "rai"], "metadata": {"kind": "class", "chunk_index": "0", "has_docstring": "true", "last_modified": "1768240645.0479665"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/mcp/server.py::KnowCodeMCPServer::1", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/mcp/server.py::KnowCodeMCPServer", "content": "LT_FILENAME\n\n            if not allow_missing_store and not store_file.exists():\n                raise FileNotFoundError(\n                    f\"Knowledge store not found: {store_file}\\n\"\n                    \"Run 'knowcode analyze' first to build the knowledge graph.\"\n                )\n\n            self._service = KnowCodeService(\n                store_path=self.store_path,\n                config_path=self.config_path,\n            )\n        return self._service\n\n    def _ensure_store_ready(self, service: KnowCodeService) -> None:\n        \"\"\"Ensure the knowledge store exists by running analyze if needed.\"\"\"\n        store_root = service.store_path if service.store_path.is_dir() else service.store_path.parent\n        store_file = store_root / KnowledgeStore.DEFAULT_FILENAME\n        if store_file.exists():\n            return\n        service.analyze(directory=store_root, output=store_root)\n    \n    def search_codebase(self, query: str, limit: int = 10) -> list[dict[str, Any]]:\n        \"\"\"Sea", "tokens": ["lt", "filename", "if", "not", "allow", "missing", "store", "and", "not", "store", "file", "exists", "raise", "file", "not", "found", "error", "knowledge", "store", "not", "found", "store", "file", "run", "knowcode", "analyze", "first", "to", "build", "the", "knowledge", "graph", "self", "service", "know", "code", "service", "store", "path", "self", "store", "path", "config", "path", "self", "config", "path", "return", "self", "service", "def", "ensure", "store", "ready", "self", "service", "know", "code", "service", "none", "ensure", "the", "knowledge", "store", "exists", "by", "running", "analyze", "if", "needed", "store", "root", "service", "store", "path", "if", "service", "store", "path", "is", "dir", "else", "service", "store", "path", "parent", "store", "file", "store", "root", "knowledge", "store", "default", "filename", "if", "store", "file", "exists", "return", "service", "analyze", "directory", "store", "root", "output", "store", "root", "def", "search", "codebase", "self", "query", "str", "limit", "int", "10", "list", "dict", "str", "any", "sea"], "metadata": {"kind": "class", "chunk_index": "1", "has_docstring": "true", "last_modified": "1768240645.0479665"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/mcp/server.py::KnowCodeMCPServer::2", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/mcp/server.py::KnowCodeMCPServer", "content": " \n    def search_codebase(self, query: str, limit: int = 10) -> list[dict[str, Any]]:\n        \"\"\"Search for entities by name pattern.\n        \n        Args:\n            query: Search pattern.\n            limit: Maximum results.\n            \n        Returns:\n            List of matching entity summaries.\n        \"\"\"\n        service = self._ensure_service(allow_missing_store=True)\n        self._ensure_store_ready(service)\n        entities = service.store.search(query)[:limit]\n        \n        return [\n            {\n                \"id\": e.id,\n                \"name\": e.name,\n                \"qualified_name\": e.qualified_name,\n                \"kind\": e.kind.value,\n                \"file\": e.location.file_path,\n                \"line\": e.location.line_start,\n            }\n            for e in entities\n        ]\n    \n    def get_entity_context(\n        self,\n        entity_id: str,\n        task_type: str = \"general\",\n        max_tokens: int = 2000,\n    ) -> dict[str, Any]:\n        \"\"\"Get synth", "tokens": ["def", "search", "codebase", "self", "query", "str", "limit", "int", "10", "list", "dict", "str", "any", "search", "for", "entities", "by", "name", "pattern", "args", "query", "search", "pattern", "limit", "maximum", "results", "returns", "list", "of", "matching", "entity", "summaries", "service", "self", "ensure", "service", "allow", "missing", "store", "true", "self", "ensure", "store", "ready", "service", "entities", "service", "store", "search", "query", "limit", "return", "id", "id", "name", "name", "qualified", "name", "qualified", "name", "kind", "kind", "value", "file", "location", "file", "path", "line", "location", "line", "start", "for", "in", "entities", "def", "get", "entity", "context", "self", "entity", "id", "str", "task", "type", "str", "general", "max", "tokens", "int", "2000", "dict", "str", "any", "get", "synth"], "metadata": {"kind": "class", "chunk_index": "2", "has_docstring": "true", "last_modified": "1768240645.0479665"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/mcp/server.py::KnowCodeMCPServer::3", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/mcp/server.py::KnowCodeMCPServer", "content": "type: str = \"general\",\n        max_tokens: int = 2000,\n    ) -> dict[str, Any]:\n        \"\"\"Get synthesized context for an entity.\n        \n        Args:\n            entity_id: Entity ID or search pattern.\n            task_type: Task type for prioritization.\n            max_tokens: Token budget.\n            \n        Returns:\n            Context bundle with sufficiency score.\n        \"\"\"\n        service = self._ensure_service(allow_missing_store=True)\n        self._ensure_store_ready(service)\n        try:\n            task = TaskType(task_type)\n        except ValueError:\n            task = TaskType.GENERAL\n\n        try:\n            bundle = service.get_context(entity_id, max_tokens=max_tokens, task_type=task)\n        except ValueError:\n            return {\n                \"error\": f\"Entity not found: {entity_id}\",\n                \"context_text\": \"\",\n                \"sufficiency_score\": 0.0,\n                \"task_type\": task.value,\n            }\n\n        entity = service.store.get_entity(b", "tokens": ["type", "str", "general", "max", "tokens", "int", "2000", "dict", "str", "any", "get", "synthesized", "context", "for", "an", "entity", "args", "entity", "id", "entity", "id", "or", "search", "pattern", "task", "type", "task", "type", "for", "prioritization", "max", "tokens", "token", "budget", "returns", "context", "bundle", "with", "sufficiency", "score", "service", "self", "ensure", "service", "allow", "missing", "store", "true", "self", "ensure", "store", "ready", "service", "try", "task", "task", "type", "task", "type", "except", "value", "error", "task", "task", "type", "general", "try", "bundle", "service", "get", "context", "entity", "id", "max", "tokens", "max", "tokens", "task", "type", "task", "except", "value", "error", "return", "error", "entity", "not", "found", "entity", "id", "context", "text", "sufficiency", "score", "task", "type", "task", "value", "entity", "service", "store", "get", "entity"], "metadata": {"kind": "class", "chunk_index": "3", "has_docstring": "true", "last_modified": "1768240645.0479665"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/mcp/server.py::KnowCodeMCPServer::4", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/mcp/server.py::KnowCodeMCPServer", "content": "\n                \"task_type\": task.value,\n            }\n\n        entity = service.store.get_entity(bundle.get(\"entity_id\", entity_id))\n        qualified_name = entity.qualified_name if entity else \"\"\n\n        return {\n            \"entity_id\": bundle.get(\"entity_id\", entity_id),\n            \"qualified_name\": qualified_name,\n            \"context_text\": bundle.get(\"context_text\", \"\"),\n            \"total_tokens\": bundle.get(\"total_tokens\", 0),\n            \"sufficiency_score\": bundle.get(\"sufficiency_score\", 0.0),\n            \"task_type\": bundle.get(\"task_type\", task.value),\n        }\n    \n    def trace_calls(\n        self,\n        entity_id: str,\n        direction: str = \"callees\",\n        depth: int = 1,\n    ) -> list[dict[str, Any]]:\n        \"\"\"Trace call graph from an entity.\n        \n        Args:\n            entity_id: Starting entity.\n            direction: \"callers\" or \"callees\".\n            depth: Max hops.\n            \n        Returns:\n            List of entities with call_depth.", "tokens": ["task", "type", "task", "value", "entity", "service", "store", "get", "entity", "bundle", "get", "entity", "id", "entity", "id", "qualified", "name", "entity", "qualified", "name", "if", "entity", "else", "return", "entity", "id", "bundle", "get", "entity", "id", "entity", "id", "qualified", "name", "qualified", "name", "context", "text", "bundle", "get", "context", "text", "total", "tokens", "bundle", "get", "total", "tokens", "sufficiency", "score", "bundle", "get", "sufficiency", "score", "task", "type", "bundle", "get", "task", "type", "task", "value", "def", "trace", "calls", "self", "entity", "id", "str", "direction", "str", "callees", "depth", "int", "list", "dict", "str", "any", "trace", "call", "graph", "from", "an", "entity", "args", "entity", "id", "starting", "entity", "direction", "callers", "or", "callees", "depth", "max", "hops", "returns", "list", "of", "entities", "with", "call", "depth"], "metadata": {"kind": "class", "chunk_index": "4", "has_docstring": "true", "last_modified": "1768240645.0479665"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/mcp/server.py::KnowCodeMCPServer::5", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/mcp/server.py::KnowCodeMCPServer", "content": "        depth: Max hops.\n            \n        Returns:\n            List of entities with call_depth.\n        \"\"\"\n        service = self._ensure_service(allow_missing_store=True)\n        self._ensure_store_ready(service)\n        return service.store.trace_calls(\n            entity_id,\n            direction=direction,\n            depth=min(depth, 5),\n            max_results=50,\n        )\n\n    def retrieve_context_for_query(\n        self,\n        query: str,\n        task_type: str = \"auto\",\n        max_tokens: int = 6000,\n        limit_entities: int = 3,\n        expand_deps: bool = True,\n    ) -> dict[str, Any]:\n        \"\"\"Retrieve a task-aware context bundle for a query.\"\"\"\n        service = self._ensure_service(allow_missing_store=True)\n        task_override: Optional[TaskType] = None\n        if task_type != \"auto\":\n            try:\n                task_override = TaskType(task_type)\n            except ValueError:\n                task_override = TaskType.GENERAL\n\n        return service.", "tokens": ["depth", "max", "hops", "returns", "list", "of", "entities", "with", "call", "depth", "service", "self", "ensure", "service", "allow", "missing", "store", "true", "self", "ensure", "store", "ready", "service", "return", "service", "store", "trace", "calls", "entity", "id", "direction", "direction", "depth", "min", "depth", "max", "results", "50", "def", "retrieve", "context", "for", "query", "self", "query", "str", "task", "type", "str", "auto", "max", "tokens", "int", "6000", "limit", "entities", "int", "expand", "deps", "bool", "true", "dict", "str", "any", "retrieve", "task", "aware", "context", "bundle", "for", "query", "service", "self", "ensure", "service", "allow", "missing", "store", "true", "task", "override", "optional", "task", "type", "none", "if", "task", "type", "auto", "try", "task", "override", "task", "type", "task", "type", "except", "value", "error", "task", "override", "task", "type", "general", "return", "service"], "metadata": {"kind": "class", "chunk_index": "5", "has_docstring": "true", "last_modified": "1768240645.0479665"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/mcp/server.py::KnowCodeMCPServer::6", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/mcp/server.py::KnowCodeMCPServer", "content": "        except ValueError:\n                task_override = TaskType.GENERAL\n\n        return service.retrieve_context_for_query(\n            query=query,\n            max_tokens=max_tokens,\n            task_type=task_override,\n            limit_entities=limit_entities,\n            expand_deps=expand_deps,\n        )\n    \n    def handle_tool_call(self, name: str, arguments: dict[str, Any]) -> str:\n        \"\"\"Handle an MCP tool call.\n        \n        Args:\n            name: Tool name.\n            arguments: Tool arguments.\n            \n        Returns:\n            JSON string result.\n        \"\"\"\n        try:\n            if name == \"search_codebase\":\n                result = self.search_codebase(\n                    query=arguments[\"query\"],\n                    limit=arguments.get(\"limit\", 10),\n                )\n            elif name == \"get_entity_context\":\n                result = self.get_entity_context(\n                    entity_id=arguments[\"entity_id\"],\n                    task_type=a", "tokens": ["except", "value", "error", "task", "override", "task", "type", "general", "return", "service", "retrieve", "context", "for", "query", "query", "query", "max", "tokens", "max", "tokens", "task", "type", "task", "override", "limit", "entities", "limit", "entities", "expand", "deps", "expand", "deps", "def", "handle", "tool", "call", "self", "name", "str", "arguments", "dict", "str", "any", "str", "handle", "an", "mcp", "tool", "call", "args", "name", "tool", "name", "arguments", "tool", "arguments", "returns", "json", "string", "result", "try", "if", "name", "search", "codebase", "result", "self", "search", "codebase", "query", "arguments", "query", "limit", "arguments", "get", "limit", "10", "elif", "name", "get", "entity", "context", "result", "self", "get", "entity", "context", "entity", "id", "arguments", "entity", "id", "task", "type"], "metadata": {"kind": "class", "chunk_index": "6", "has_docstring": "true", "last_modified": "1768240645.0479665"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/mcp/server.py::KnowCodeMCPServer::7", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/mcp/server.py::KnowCodeMCPServer", "content": "ntity_context(\n                    entity_id=arguments[\"entity_id\"],\n                    task_type=arguments.get(\"task_type\", \"general\"),\n                    max_tokens=arguments.get(\"max_tokens\", 2000),\n                )\n            elif name == \"trace_calls\":\n                result = self.trace_calls(\n                    entity_id=arguments[\"entity_id\"],\n                    direction=arguments.get(\"direction\", \"callees\"),\n                    depth=arguments.get(\"depth\", 1),\n                )\n            elif name == \"retrieve_context_for_query\":\n                result = self.retrieve_context_for_query(\n                    query=arguments[\"query\"],\n                    task_type=arguments.get(\"task_type\", \"auto\"),\n                    max_tokens=arguments.get(\"max_tokens\", 6000),\n                    limit_entities=arguments.get(\"limit_entities\", 3),\n                    expand_deps=arguments.get(\"expand_deps\", True),\n                )\n            else:\n                result = {\"error\": ", "tokens": ["ntity", "context", "entity", "id", "arguments", "entity", "id", "task", "type", "arguments", "get", "task", "type", "general", "max", "tokens", "arguments", "get", "max", "tokens", "2000", "elif", "name", "trace", "calls", "result", "self", "trace", "calls", "entity", "id", "arguments", "entity", "id", "direction", "arguments", "get", "direction", "callees", "depth", "arguments", "get", "depth", "elif", "name", "retrieve", "context", "for", "query", "result", "self", "retrieve", "context", "for", "query", "query", "arguments", "query", "task", "type", "arguments", "get", "task", "type", "auto", "max", "tokens", "arguments", "get", "max", "tokens", "6000", "limit", "entities", "arguments", "get", "limit", "entities", "expand", "deps", "arguments", "get", "expand", "deps", "true", "else", "result", "error"], "metadata": {"kind": "class", "chunk_index": "7", "has_docstring": "true", "last_modified": "1768240645.0479665"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/mcp/server.py::KnowCodeMCPServer::8", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/mcp/server.py::KnowCodeMCPServer", "content": "ts.get(\"expand_deps\", True),\n                )\n            else:\n                result = {\"error\": f\"Unknown tool: {name}\"}\n                \n            return json.dumps(result, indent=2)\n        except Exception as e:\n            return json.dumps({\"error\": str(e)})", "tokens": ["ts", "get", "expand", "deps", "true", "else", "result", "error", "unknown", "tool", "name", "return", "json", "dumps", "result", "indent", "except", "exception", "as", "return", "json", "dumps", "error", "str"], "metadata": {"kind": "class", "chunk_index": "8", "has_docstring": "true", "last_modified": "1768240645.0479665"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/mcp/server.py::KnowCodeMCPServer.__init__::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/mcp/server.py::KnowCodeMCPServer.__init__", "content": "def __init__(self, store_path: str | Path, config_path: Optional[str]) -> None\n\"\"\"Initialize MCP server with knowledge store.\n\nArgs:\n    store_path: Path to knowcode_knowledge.json\n    config_path: Optional path to aimodels.yaml for model priorities.\"\"\"\n    def __init__(self, store_path: str | Path, config_path: Optional[str] = None) -> None:\n        \"\"\"Initialize MCP server with knowledge store.\n        \n        Args:\n            store_path: Path to knowcode_knowledge.json\n            config_path: Optional path to aimodels.yaml for model priorities.\n        \"\"\"\n        self.store_path = Path(store_path)\n        self.config_path = config_path\n        self._service: Optional[KnowCodeService] = None", "tokens": ["def", "init", "self", "store", "path", "str", "path", "config", "path", "optional", "str", "none", "initialize", "mcp", "server", "with", "knowledge", "store", "args", "store", "path", "path", "to", "knowcode", "knowledge", "json", "config", "path", "optional", "path", "to", "aimodels", "yaml", "for", "model", "priorities", "def", "init", "self", "store", "path", "str", "path", "config", "path", "optional", "str", "none", "none", "initialize", "mcp", "server", "with", "knowledge", "store", "args", "store", "path", "path", "to", "knowcode", "knowledge", "json", "config", "path", "optional", "path", "to", "aimodels", "yaml", "for", "model", "priorities", "self", "store", "path", "path", "store", "path", "self", "config", "path", "config", "path", "self", "service", "optional", "know", "code", "service", "none"], "metadata": {"kind": "method", "has_docstring": "true", "last_modified": "1768240645.0479665"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/mcp/server.py::KnowCodeMCPServer._ensure_service::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/mcp/server.py::KnowCodeMCPServer._ensure_service", "content": "def _ensure_service(self, allow_missing_store: bool) -> KnowCodeService\n\"\"\"Create the shared service (loads store/index lazily).\"\"\"\n    def _ensure_service(self, allow_missing_store: bool = False) -> KnowCodeService:\n        \"\"\"Create the shared service (loads store/index lazily).\"\"\"\n        if self._service is None:\n            store_file = self.store_path\n            if store_file.is_dir():\n                store_file = store_file / KnowledgeStore.DEFAULT_FILENAME\n\n            if not allow_missing_store and not store_file.exists():\n                raise FileNotFoundError(\n                    f\"Knowledge store not found: {store_file}\\n\"\n                    \"Run 'knowcode analyze' first to build the knowledge graph.\"\n                )\n\n            self._service = KnowCodeService(\n                store_path=self.store_path,\n                config_path=self.config_path,\n            )\n        return self._service", "tokens": ["def", "ensure", "service", "self", "allow", "missing", "store", "bool", "know", "code", "service", "create", "the", "shared", "service", "loads", "store", "index", "lazily", "def", "ensure", "service", "self", "allow", "missing", "store", "bool", "false", "know", "code", "service", "create", "the", "shared", "service", "loads", "store", "index", "lazily", "if", "self", "service", "is", "none", "store", "file", "self", "store", "path", "if", "store", "file", "is", "dir", "store", "file", "store", "file", "knowledge", "store", "default", "filename", "if", "not", "allow", "missing", "store", "and", "not", "store", "file", "exists", "raise", "file", "not", "found", "error", "knowledge", "store", "not", "found", "store", "file", "run", "knowcode", "analyze", "first", "to", "build", "the", "knowledge", "graph", "self", "service", "know", "code", "service", "store", "path", "self", "store", "path", "config", "path", "self", "config", "path", "return", "self", "service"], "metadata": {"kind": "method", "has_docstring": "true", "last_modified": "1768240645.0479665"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/mcp/server.py::KnowCodeMCPServer._ensure_store_ready::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/mcp/server.py::KnowCodeMCPServer._ensure_store_ready", "content": "def _ensure_store_ready(self, service: KnowCodeService) -> None\n\"\"\"Ensure the knowledge store exists by running analyze if needed.\"\"\"\n    def _ensure_store_ready(self, service: KnowCodeService) -> None:\n        \"\"\"Ensure the knowledge store exists by running analyze if needed.\"\"\"\n        store_root = service.store_path if service.store_path.is_dir() else service.store_path.parent\n        store_file = store_root / KnowledgeStore.DEFAULT_FILENAME\n        if store_file.exists():\n            return\n        service.analyze(directory=store_root, output=store_root)", "tokens": ["def", "ensure", "store", "ready", "self", "service", "know", "code", "service", "none", "ensure", "the", "knowledge", "store", "exists", "by", "running", "analyze", "if", "needed", "def", "ensure", "store", "ready", "self", "service", "know", "code", "service", "none", "ensure", "the", "knowledge", "store", "exists", "by", "running", "analyze", "if", "needed", "store", "root", "service", "store", "path", "if", "service", "store", "path", "is", "dir", "else", "service", "store", "path", "parent", "store", "file", "store", "root", "knowledge", "store", "default", "filename", "if", "store", "file", "exists", "return", "service", "analyze", "directory", "store", "root", "output", "store", "root"], "metadata": {"kind": "method", "has_docstring": "true", "last_modified": "1768240645.0479665"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/mcp/server.py::KnowCodeMCPServer.search_codebase::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/mcp/server.py::KnowCodeMCPServer.search_codebase", "content": "def search_codebase(self, query: str, limit: int) -> list[dict[str, Any]]\n\"\"\"Search for entities by name pattern.\n\nArgs:\n    query: Search pattern.\n    limit: Maximum results.\n    \nReturns:\n    List of matching entity summaries.\"\"\"\n    def search_codebase(self, query: str, limit: int = 10) -> list[dict[str, Any]]:\n        \"\"\"Search for entities by name pattern.\n        \n        Args:\n            query: Search pattern.\n            limit: Maximum results.\n            \n        Returns:\n            List of matching entity summaries.\n        \"\"\"\n        service = self._ensure_service(allow_missing_store=True)\n        self._ensure_store_ready(service)\n        entities = service.store.search(query)[:limit]\n        \n        return [\n            {\n                \"id\": e.id,\n                \"name\": e.name,\n                \"qualified_name\": e.qualified_name,\n                \"kind\": e.kind.value,\n                \"file\": e.location.file_path,\n                \"line\": e.location.line_start,\n        ", "tokens": ["def", "search", "codebase", "self", "query", "str", "limit", "int", "list", "dict", "str", "any", "search", "for", "entities", "by", "name", "pattern", "args", "query", "search", "pattern", "limit", "maximum", "results", "returns", "list", "of", "matching", "entity", "summaries", "def", "search", "codebase", "self", "query", "str", "limit", "int", "10", "list", "dict", "str", "any", "search", "for", "entities", "by", "name", "pattern", "args", "query", "search", "pattern", "limit", "maximum", "results", "returns", "list", "of", "matching", "entity", "summaries", "service", "self", "ensure", "service", "allow", "missing", "store", "true", "self", "ensure", "store", "ready", "service", "entities", "service", "store", "search", "query", "limit", "return", "id", "id", "name", "name", "qualified", "name", "qualified", "name", "kind", "kind", "value", "file", "location", "file", "path", "line", "location", "line", "start"], "metadata": {"kind": "method", "chunk_index": "0", "has_docstring": "true", "last_modified": "1768240645.0479665"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/mcp/server.py::KnowCodeMCPServer.search_codebase::1", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/mcp/server.py::KnowCodeMCPServer.search_codebase", "content": "               \"file\": e.location.file_path,\n                \"line\": e.location.line_start,\n            }\n            for e in entities\n        ]", "tokens": ["file", "location", "file", "path", "line", "location", "line", "start", "for", "in", "entities"], "metadata": {"kind": "method", "chunk_index": "1", "has_docstring": "true", "last_modified": "1768240645.0479665"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/mcp/server.py::KnowCodeMCPServer.get_entity_context::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/mcp/server.py::KnowCodeMCPServer.get_entity_context", "content": "def get_entity_context(self, entity_id: str, task_type: str, max_tokens: int) -> dict[str, Any]\n\"\"\"Get synthesized context for an entity.\n\nArgs:\n    entity_id: Entity ID or search pattern.\n    task_type: Task type for prioritization.\n    max_tokens: Token budget.\n    \nReturns:\n    Context bundle with sufficiency score.\"\"\"\n    def get_entity_context(\n        self,\n        entity_id: str,\n        task_type: str = \"general\",\n        max_tokens: int = 2000,\n    ) -> dict[str, Any]:\n        \"\"\"Get synthesized context for an entity.\n        \n        Args:\n            entity_id: Entity ID or search pattern.\n            task_type: Task type for prioritization.\n            max_tokens: Token budget.\n            \n        Returns:\n            Context bundle with sufficiency score.\n        \"\"\"\n        service = self._ensure_service(allow_missing_store=True)\n        self._ensure_store_ready(service)\n        try:\n            task = TaskType(task_type)\n        except ValueError:\n            task = Tas", "tokens": ["def", "get", "entity", "context", "self", "entity", "id", "str", "task", "type", "str", "max", "tokens", "int", "dict", "str", "any", "get", "synthesized", "context", "for", "an", "entity", "args", "entity", "id", "entity", "id", "or", "search", "pattern", "task", "type", "task", "type", "for", "prioritization", "max", "tokens", "token", "budget", "returns", "context", "bundle", "with", "sufficiency", "score", "def", "get", "entity", "context", "self", "entity", "id", "str", "task", "type", "str", "general", "max", "tokens", "int", "2000", "dict", "str", "any", "get", "synthesized", "context", "for", "an", "entity", "args", "entity", "id", "entity", "id", "or", "search", "pattern", "task", "type", "task", "type", "for", "prioritization", "max", "tokens", "token", "budget", "returns", "context", "bundle", "with", "sufficiency", "score", "service", "self", "ensure", "service", "allow", "missing", "store", "true", "self", "ensure", "store", "ready", "service", "try", "task", "task", "type", "task", "type", "except", "value", "error", "task", "tas"], "metadata": {"kind": "method", "chunk_index": "0", "has_docstring": "true", "last_modified": "1768240645.0479665"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/mcp/server.py::KnowCodeMCPServer.get_entity_context::1", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/mcp/server.py::KnowCodeMCPServer.get_entity_context", "content": "       try:\n            task = TaskType(task_type)\n        except ValueError:\n            task = TaskType.GENERAL\n\n        try:\n            bundle = service.get_context(entity_id, max_tokens=max_tokens, task_type=task)\n        except ValueError:\n            return {\n                \"error\": f\"Entity not found: {entity_id}\",\n                \"context_text\": \"\",\n                \"sufficiency_score\": 0.0,\n                \"task_type\": task.value,\n            }\n\n        entity = service.store.get_entity(bundle.get(\"entity_id\", entity_id))\n        qualified_name = entity.qualified_name if entity else \"\"\n\n        return {\n            \"entity_id\": bundle.get(\"entity_id\", entity_id),\n            \"qualified_name\": qualified_name,\n            \"context_text\": bundle.get(\"context_text\", \"\"),\n            \"total_tokens\": bundle.get(\"total_tokens\", 0),\n            \"sufficiency_score\": bundle.get(\"sufficiency_score\", 0.0),\n            \"task_type\": bundle.get(\"task_type\", task.value),\n        }", "tokens": ["try", "task", "task", "type", "task", "type", "except", "value", "error", "task", "task", "type", "general", "try", "bundle", "service", "get", "context", "entity", "id", "max", "tokens", "max", "tokens", "task", "type", "task", "except", "value", "error", "return", "error", "entity", "not", "found", "entity", "id", "context", "text", "sufficiency", "score", "task", "type", "task", "value", "entity", "service", "store", "get", "entity", "bundle", "get", "entity", "id", "entity", "id", "qualified", "name", "entity", "qualified", "name", "if", "entity", "else", "return", "entity", "id", "bundle", "get", "entity", "id", "entity", "id", "qualified", "name", "qualified", "name", "context", "text", "bundle", "get", "context", "text", "total", "tokens", "bundle", "get", "total", "tokens", "sufficiency", "score", "bundle", "get", "sufficiency", "score", "task", "type", "bundle", "get", "task", "type", "task", "value"], "metadata": {"kind": "method", "chunk_index": "1", "has_docstring": "true", "last_modified": "1768240645.0479665"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/mcp/server.py::KnowCodeMCPServer.trace_calls::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/mcp/server.py::KnowCodeMCPServer.trace_calls", "content": "def trace_calls(self, entity_id: str, direction: str, depth: int) -> list[dict[str, Any]]\n\"\"\"Trace call graph from an entity.\n\nArgs:\n    entity_id: Starting entity.\n    direction: \"callers\" or \"callees\".\n    depth: Max hops.\n    \nReturns:\n    List of entities with call_depth.\"\"\"\n    def trace_calls(\n        self,\n        entity_id: str,\n        direction: str = \"callees\",\n        depth: int = 1,\n    ) -> list[dict[str, Any]]:\n        \"\"\"Trace call graph from an entity.\n        \n        Args:\n            entity_id: Starting entity.\n            direction: \"callers\" or \"callees\".\n            depth: Max hops.\n            \n        Returns:\n            List of entities with call_depth.\n        \"\"\"\n        service = self._ensure_service(allow_missing_store=True)\n        self._ensure_store_ready(service)\n        return service.store.trace_calls(\n            entity_id,\n            direction=direction,\n            depth=min(depth, 5),\n            max_results=50,\n        )", "tokens": ["def", "trace", "calls", "self", "entity", "id", "str", "direction", "str", "depth", "int", "list", "dict", "str", "any", "trace", "call", "graph", "from", "an", "entity", "args", "entity", "id", "starting", "entity", "direction", "callers", "or", "callees", "depth", "max", "hops", "returns", "list", "of", "entities", "with", "call", "depth", "def", "trace", "calls", "self", "entity", "id", "str", "direction", "str", "callees", "depth", "int", "list", "dict", "str", "any", "trace", "call", "graph", "from", "an", "entity", "args", "entity", "id", "starting", "entity", "direction", "callers", "or", "callees", "depth", "max", "hops", "returns", "list", "of", "entities", "with", "call", "depth", "service", "self", "ensure", "service", "allow", "missing", "store", "true", "self", "ensure", "store", "ready", "service", "return", "service", "store", "trace", "calls", "entity", "id", "direction", "direction", "depth", "min", "depth", "max", "results", "50"], "metadata": {"kind": "method", "has_docstring": "true", "last_modified": "1768240645.0479665"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/mcp/server.py::KnowCodeMCPServer.retrieve_context_for_query::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/mcp/server.py::KnowCodeMCPServer.retrieve_context_for_query", "content": "def retrieve_context_for_query(self, query: str, task_type: str, max_tokens: int, limit_entities: int, expand_deps: bool) -> dict[str, Any]\n\"\"\"Retrieve a task-aware context bundle for a query.\"\"\"\n    def retrieve_context_for_query(\n        self,\n        query: str,\n        task_type: str = \"auto\",\n        max_tokens: int = 6000,\n        limit_entities: int = 3,\n        expand_deps: bool = True,\n    ) -> dict[str, Any]:\n        \"\"\"Retrieve a task-aware context bundle for a query.\"\"\"\n        service = self._ensure_service(allow_missing_store=True)\n        task_override: Optional[TaskType] = None\n        if task_type != \"auto\":\n            try:\n                task_override = TaskType(task_type)\n            except ValueError:\n                task_override = TaskType.GENERAL\n\n        return service.retrieve_context_for_query(\n            query=query,\n            max_tokens=max_tokens,\n            task_type=task_override,\n            limit_entities=limit_entities,\n            expand_deps=ex", "tokens": ["def", "retrieve", "context", "for", "query", "self", "query", "str", "task", "type", "str", "max", "tokens", "int", "limit", "entities", "int", "expand", "deps", "bool", "dict", "str", "any", "retrieve", "task", "aware", "context", "bundle", "for", "query", "def", "retrieve", "context", "for", "query", "self", "query", "str", "task", "type", "str", "auto", "max", "tokens", "int", "6000", "limit", "entities", "int", "expand", "deps", "bool", "true", "dict", "str", "any", "retrieve", "task", "aware", "context", "bundle", "for", "query", "service", "self", "ensure", "service", "allow", "missing", "store", "true", "task", "override", "optional", "task", "type", "none", "if", "task", "type", "auto", "try", "task", "override", "task", "type", "task", "type", "except", "value", "error", "task", "override", "task", "type", "general", "return", "service", "retrieve", "context", "for", "query", "query", "query", "max", "tokens", "max", "tokens", "task", "type", "task", "override", "limit", "entities", "limit", "entities", "expand", "deps", "ex"], "metadata": {"kind": "method", "chunk_index": "0", "has_docstring": "true", "last_modified": "1768240645.0479665"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/mcp/server.py::KnowCodeMCPServer.retrieve_context_for_query::1", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/mcp/server.py::KnowCodeMCPServer.retrieve_context_for_query", "content": "      task_type=task_override,\n            limit_entities=limit_entities,\n            expand_deps=expand_deps,\n        )", "tokens": ["task", "type", "task", "override", "limit", "entities", "limit", "entities", "expand", "deps", "expand", "deps"], "metadata": {"kind": "method", "chunk_index": "1", "has_docstring": "true", "last_modified": "1768240645.0479665"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/mcp/server.py::KnowCodeMCPServer.handle_tool_call::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/mcp/server.py::KnowCodeMCPServer.handle_tool_call", "content": "def handle_tool_call(self, name: str, arguments: dict[str, Any]) -> str\n\"\"\"Handle an MCP tool call.\n\nArgs:\n    name: Tool name.\n    arguments: Tool arguments.\n    \nReturns:\n    JSON string result.\"\"\"\n    def handle_tool_call(self, name: str, arguments: dict[str, Any]) -> str:\n        \"\"\"Handle an MCP tool call.\n        \n        Args:\n            name: Tool name.\n            arguments: Tool arguments.\n            \n        Returns:\n            JSON string result.\n        \"\"\"\n        try:\n            if name == \"search_codebase\":\n                result = self.search_codebase(\n                    query=arguments[\"query\"],\n                    limit=arguments.get(\"limit\", 10),\n                )\n            elif name == \"get_entity_context\":\n                result = self.get_entity_context(\n                    entity_id=arguments[\"entity_id\"],\n                    task_type=arguments.get(\"task_type\", \"general\"),\n                    max_tokens=arguments.get(\"max_tokens\", 2000),\n                ", "tokens": ["def", "handle", "tool", "call", "self", "name", "str", "arguments", "dict", "str", "any", "str", "handle", "an", "mcp", "tool", "call", "args", "name", "tool", "name", "arguments", "tool", "arguments", "returns", "json", "string", "result", "def", "handle", "tool", "call", "self", "name", "str", "arguments", "dict", "str", "any", "str", "handle", "an", "mcp", "tool", "call", "args", "name", "tool", "name", "arguments", "tool", "arguments", "returns", "json", "string", "result", "try", "if", "name", "search", "codebase", "result", "self", "search", "codebase", "query", "arguments", "query", "limit", "arguments", "get", "limit", "10", "elif", "name", "get", "entity", "context", "result", "self", "get", "entity", "context", "entity", "id", "arguments", "entity", "id", "task", "type", "arguments", "get", "task", "type", "general", "max", "tokens", "arguments", "get", "max", "tokens", "2000"], "metadata": {"kind": "method", "chunk_index": "0", "has_docstring": "true", "last_modified": "1768240645.0479665"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/mcp/server.py::KnowCodeMCPServer.handle_tool_call::1", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/mcp/server.py::KnowCodeMCPServer.handle_tool_call", "content": "ype\", \"general\"),\n                    max_tokens=arguments.get(\"max_tokens\", 2000),\n                )\n            elif name == \"trace_calls\":\n                result = self.trace_calls(\n                    entity_id=arguments[\"entity_id\"],\n                    direction=arguments.get(\"direction\", \"callees\"),\n                    depth=arguments.get(\"depth\", 1),\n                )\n            elif name == \"retrieve_context_for_query\":\n                result = self.retrieve_context_for_query(\n                    query=arguments[\"query\"],\n                    task_type=arguments.get(\"task_type\", \"auto\"),\n                    max_tokens=arguments.get(\"max_tokens\", 6000),\n                    limit_entities=arguments.get(\"limit_entities\", 3),\n                    expand_deps=arguments.get(\"expand_deps\", True),\n                )\n            else:\n                result = {\"error\": f\"Unknown tool: {name}\"}\n                \n            return json.dumps(result, indent=2)\n        except Exception as e:", "tokens": ["ype", "general", "max", "tokens", "arguments", "get", "max", "tokens", "2000", "elif", "name", "trace", "calls", "result", "self", "trace", "calls", "entity", "id", "arguments", "entity", "id", "direction", "arguments", "get", "direction", "callees", "depth", "arguments", "get", "depth", "elif", "name", "retrieve", "context", "for", "query", "result", "self", "retrieve", "context", "for", "query", "query", "arguments", "query", "task", "type", "arguments", "get", "task", "type", "auto", "max", "tokens", "arguments", "get", "max", "tokens", "6000", "limit", "entities", "arguments", "get", "limit", "entities", "expand", "deps", "arguments", "get", "expand", "deps", "true", "else", "result", "error", "unknown", "tool", "name", "return", "json", "dumps", "result", "indent", "except", "exception", "as"], "metadata": {"kind": "method", "chunk_index": "1", "has_docstring": "true", "last_modified": "1768240645.0479665"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/mcp/server.py::KnowCodeMCPServer.handle_tool_call::2", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/mcp/server.py::KnowCodeMCPServer.handle_tool_call", "content": "e}\"}\n                \n            return json.dumps(result, indent=2)\n        except Exception as e:\n            return json.dumps({\"error\": str(e)})", "tokens": ["return", "json", "dumps", "result", "indent", "except", "exception", "as", "return", "json", "dumps", "error", "str"], "metadata": {"kind": "method", "chunk_index": "2", "has_docstring": "true", "last_modified": "1768240645.0479665"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/mcp/server.py::create_server::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/mcp/server.py::create_server", "content": "def create_server(store_path: str | Path, config_path: Optional[str]) -> 'Server'\n\"\"\"Create an MCP server instance.\n\nArgs:\n    store_path: Path to knowledge store.\n    config_path: Optional configuration file path for model priorities.\n    \nReturns:\n    Configured MCP Server.\"\"\"\ndef create_server(store_path: str | Path, config_path: Optional[str] = None) -> \"Server\":\n    \"\"\"Create an MCP server instance.\n    \n    Args:\n        store_path: Path to knowledge store.\n        config_path: Optional configuration file path for model priorities.\n        \n    Returns:\n        Configured MCP Server.\n    \"\"\"\n    if not MCP_AVAILABLE:\n        raise ImportError(\n            \"MCP package not installed. Install with: pip install mcp\"\n        )\n    \n    server = Server(\"knowcode\")\n    knowcode = KnowCodeMCPServer(store_path, config_path=config_path)\n    \n    @server.list_tools()\n    async def list_tools() -> list[Tool]:\n        \"\"\"List available KnowCode tools.\"\"\"\n        return [\n            Tool(\n  ", "tokens": ["def", "create", "server", "store", "path", "str", "path", "config", "path", "optional", "str", "server", "create", "an", "mcp", "server", "instance", "args", "store", "path", "path", "to", "knowledge", "store", "config", "path", "optional", "configuration", "file", "path", "for", "model", "priorities", "returns", "configured", "mcp", "server", "def", "create", "server", "store", "path", "str", "path", "config", "path", "optional", "str", "none", "server", "create", "an", "mcp", "server", "instance", "args", "store", "path", "path", "to", "knowledge", "store", "config", "path", "optional", "configuration", "file", "path", "for", "model", "priorities", "returns", "configured", "mcp", "server", "if", "not", "mcp", "available", "raise", "import", "error", "mcp", "package", "not", "installed", "install", "with", "pip", "install", "mcp", "server", "server", "knowcode", "knowcode", "know", "code", "mcpserver", "store", "path", "config", "path", "config", "path", "server", "list", "tools", "async", "def", "list", "tools", "list", "tool", "list", "available", "know", "code", "tools", "return", "tool"], "metadata": {"kind": "function", "chunk_index": "0", "has_docstring": "true", "last_modified": "1768240645.0479665"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/mcp/server.py::create_server::1", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/mcp/server.py::create_server", "content": "() -> list[Tool]:\n        \"\"\"List available KnowCode tools.\"\"\"\n        return [\n            Tool(\n                name=t[\"name\"],\n                description=t[\"description\"],\n                inputSchema=t[\"inputSchema\"],\n            )\n            for t in TOOL_DEFINITIONS\n        ]\n    \n    @server.call_tool()\n    async def call_tool(name: str, arguments: dict[str, Any]) -> CallToolResult:\n        \"\"\"Execute a KnowCode tool.\"\"\"\n        result_text = knowcode.handle_tool_call(name, arguments)\n        return CallToolResult(\n            content=[TextContent(type=\"text\", text=result_text)]\n        )\n    \n    return server", "tokens": ["list", "tool", "list", "available", "know", "code", "tools", "return", "tool", "name", "name", "description", "description", "input", "schema", "input", "schema", "for", "in", "tool", "definitions", "server", "call", "tool", "async", "def", "call", "tool", "name", "str", "arguments", "dict", "str", "any", "call", "tool", "result", "execute", "know", "code", "tool", "result", "text", "knowcode", "handle", "tool", "call", "name", "arguments", "return", "call", "tool", "result", "content", "text", "content", "type", "text", "text", "result", "text", "return", "server"], "metadata": {"kind": "function", "chunk_index": "1", "has_docstring": "true", "last_modified": "1768240645.0479665"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/mcp/server.py::run_server_async::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/mcp/server.py::run_server_async", "content": "async def run_server_async(store_path: str | Path, config_path: Optional[str]) -> None\n\"\"\"Run the MCP server with STDIO transport.\n\nArgs:\n    store_path: Path to knowledge store.\n    config_path: Optional configuration file path for model priorities.\"\"\"\nasync def run_server_async(store_path: str | Path, config_path: Optional[str] = None) -> None:\n    \"\"\"Run the MCP server with STDIO transport.\n    \n    Args:\n        store_path: Path to knowledge store.\n        config_path: Optional configuration file path for model priorities.\n    \"\"\"\n    if not MCP_AVAILABLE:\n        raise ImportError(\n            \"MCP package not installed. Install with: pip install mcp\"\n        )\n    \n    server = create_server(store_path, config_path=config_path)\n    \n    async with stdio_server() as (read_stream, write_stream):\n        await server.run(\n            read_stream,\n            write_stream,\n            server.create_initialization_options(),\n        )", "tokens": ["async", "def", "run", "server", "async", "store", "path", "str", "path", "config", "path", "optional", "str", "none", "run", "the", "mcp", "server", "with", "stdio", "transport", "args", "store", "path", "path", "to", "knowledge", "store", "config", "path", "optional", "configuration", "file", "path", "for", "model", "priorities", "async", "def", "run", "server", "async", "store", "path", "str", "path", "config", "path", "optional", "str", "none", "none", "run", "the", "mcp", "server", "with", "stdio", "transport", "args", "store", "path", "path", "to", "knowledge", "store", "config", "path", "optional", "configuration", "file", "path", "for", "model", "priorities", "if", "not", "mcp", "available", "raise", "import", "error", "mcp", "package", "not", "installed", "install", "with", "pip", "install", "mcp", "server", "create", "server", "store", "path", "config", "path", "config", "path", "async", "with", "stdio", "server", "as", "read", "stream", "write", "stream", "await", "server", "run", "read", "stream", "write", "stream", "server", "create", "initialization", "options"], "metadata": {"kind": "function", "has_docstring": "true", "last_modified": "1768240645.0479665"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/mcp/server.py::run_server::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/mcp/server.py::run_server", "content": "def run_server(store_path: str | Path, config_path: Optional[str]) -> None\n\"\"\"Run the MCP server (blocking).\n\nArgs:\n    store_path: Path to knowledge store.\n    config_path: Optional configuration file path for model priorities.\"\"\"\ndef run_server(store_path: str | Path, config_path: Optional[str] = None) -> None:\n    \"\"\"Run the MCP server (blocking).\n    \n    Args:\n        store_path: Path to knowledge store.\n        config_path: Optional configuration file path for model priorities.\n    \"\"\"\n    asyncio.run(run_server_async(store_path, config_path=config_path))", "tokens": ["def", "run", "server", "store", "path", "str", "path", "config", "path", "optional", "str", "none", "run", "the", "mcp", "server", "blocking", "args", "store", "path", "path", "to", "knowledge", "store", "config", "path", "optional", "configuration", "file", "path", "for", "model", "priorities", "def", "run", "server", "store", "path", "str", "path", "config", "path", "optional", "str", "none", "none", "run", "the", "mcp", "server", "blocking", "args", "store", "path", "path", "to", "knowledge", "store", "config", "path", "optional", "configuration", "file", "path", "for", "model", "priorities", "asyncio", "run", "run", "server", "async", "store", "path", "config", "path", "config", "path"], "metadata": {"kind": "function", "has_docstring": "true", "last_modified": "1768240645.0479665"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/mcp/__init__.py::module::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/mcp/__init__.py::module", "content": "\"\"\"MCP Server subpackage for KnowCode.\n\nExposes KnowCode tools to LLM applications via the Model Context Protocol (MCP).\nUses STDIO transport for local IDE integration.\n\"\"\"", "tokens": ["mcp", "server", "subpackage", "for", "know", "code", "exposes", "know", "code", "tools", "to", "llm", "applications", "via", "the", "model", "context", "protocol", "mcp", "uses", "stdio", "transport", "for", "local", "ide", "integration"], "metadata": {"type": "module_header"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/mcp/__init__.py::imports::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/mcp/__init__.py::module", "content": "from knowcode.mcp.server import create_server, run_server", "tokens": ["from", "knowcode", "mcp", "server", "import", "create", "server", "run", "server"], "metadata": {"type": "imports"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/utils/tokenizer.py::module::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/utils/tokenizer.py::module", "content": "\"\"\"Tokenize code for BM25 indexing.\"\"\"", "tokens": ["tokenize", "code", "for", "bm25", "indexing"], "metadata": {"type": "module_header"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/utils/tokenizer.py::imports::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/utils/tokenizer.py::module", "content": "import re", "tokens": ["import", "re"], "metadata": {"type": "imports"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/utils/tokenizer.py::tokenize_code::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/utils/tokenizer.py::tokenize_code", "content": "def tokenize_code(text: str) -> list[str]\n\"\"\"Tokenize code for BM25 indexing.\n\nHandles:\n- CamelCase splitting\n- snake_case splitting  \n- Punctuation removal\n- Lowercasing\n\nArgs:\n    text: Raw code or text to tokenize.\n\nReturns:\n    List of normalized tokens suitable for BM25 matching.\"\"\"\ndef tokenize_code(text: str) -> list[str]:\n    \"\"\"Tokenize code for BM25 indexing.\n    \n    Handles:\n    - CamelCase splitting\n    - snake_case splitting  \n    - Punctuation removal\n    - Lowercasing\n\n    Args:\n        text: Raw code or text to tokenize.\n\n    Returns:\n        List of normalized tokens suitable for BM25 matching.\n    \"\"\"\n    # Split camelCase\n    text = re.sub(r'([a-z])([A-Z])', r'\\1 \\2', text)\n    # Split snake_case\n    text = text.replace('_', ' ')\n    # Remove punctuation except spaces\n    text = re.sub(r'[^\\w\\s]', ' ', text)\n    # Lowercase and split\n    tokens = text.lower().split()\n    # Filter short tokens\n    return [t for t in tokens if len(t) > 1]", "tokens": ["def", "tokenize", "code", "text", "str", "list", "str", "tokenize", "code", "for", "bm25", "indexing", "handles", "camel", "case", "splitting", "snake", "case", "splitting", "punctuation", "removal", "lowercasing", "args", "text", "raw", "code", "or", "text", "to", "tokenize", "returns", "list", "of", "normalized", "tokens", "suitable", "for", "bm25", "matching", "def", "tokenize", "code", "text", "str", "list", "str", "tokenize", "code", "for", "bm25", "indexing", "handles", "camel", "case", "splitting", "snake", "case", "splitting", "punctuation", "removal", "lowercasing", "args", "text", "raw", "code", "or", "text", "to", "tokenize", "returns", "list", "of", "normalized", "tokens", "suitable", "for", "bm25", "matching", "split", "camel", "case", "text", "re", "sub", "text", "split", "snake", "case", "text", "text", "replace", "remove", "punctuation", "except", "spaces", "text", "re", "sub", "text", "lowercase", "and", "split", "tokens", "text", "lower", "split", "filter", "short", "tokens", "return", "for", "in", "tokens", "if", "len"], "metadata": {"kind": "function", "has_docstring": "true", "last_modified": "1766231204.571593"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/utils/token_counter.py::module::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/utils/token_counter.py::module", "content": "\"\"\"Token counting utility using tiktoken.\"\"\"", "tokens": ["token", "counting", "utility", "using", "tiktoken"], "metadata": {"type": "module_header"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/utils/token_counter.py::imports::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/utils/token_counter.py::module", "content": "import tiktoken", "tokens": ["import", "tiktoken"], "metadata": {"type": "imports"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/utils/token_counter.py::TokenCounter::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/utils/token_counter.py::TokenCounter", "content": "\"\"\"Token counter utility.\"\"\"\nclass TokenCounter:\n    \"\"\"Token counter utility.\"\"\"\n\n    DEFAULT_MODEL = \"gpt-4\"\n\n    def __init__(self, model: str = DEFAULT_MODEL) -> None:\n        \"\"\"Initialize token counter.\n\n        Args:\n            model: Model name to use for encoding.\n        \"\"\"\n        self.model = model\n        try:\n            self.encoding = tiktoken.encoding_for_model(model)\n        except KeyError:\n            # Fallback to cl100k_base (used by gpt-4, gpt-3.5-turbo)\n            self.encoding = tiktoken.get_encoding(\"cl100k_base\")\n\n    def count_tokens(self, text: str) -> int:\n        \"\"\"Count tokens in text.\n\n        Args:\n            text: Text to count tokens for.\n\n        Returns:\n            Number of tokens.\n        \"\"\"\n        if not text:\n            return 0\n        return len(self.encoding.encode(text))\n\n    def truncate(self, text: str, max_tokens: int) -> str:\n        \"\"\"Truncate text to max_tokens.\n\n        Args:\n            text: Text to truncate.\n            ", "tokens": ["token", "counter", "utility", "class", "token", "counter", "token", "counter", "utility", "default", "model", "gpt", "def", "init", "self", "model", "str", "default", "model", "none", "initialize", "token", "counter", "args", "model", "model", "name", "to", "use", "for", "encoding", "self", "model", "model", "try", "self", "encoding", "tiktoken", "encoding", "for", "model", "model", "except", "key", "error", "fallback", "to", "cl100k", "base", "used", "by", "gpt", "gpt", "turbo", "self", "encoding", "tiktoken", "get", "encoding", "cl100k", "base", "def", "count", "tokens", "self", "text", "str", "int", "count", "tokens", "in", "text", "args", "text", "text", "to", "count", "tokens", "for", "returns", "number", "of", "tokens", "if", "not", "text", "return", "return", "len", "self", "encoding", "encode", "text", "def", "truncate", "self", "text", "str", "max", "tokens", "int", "str", "truncate", "text", "to", "max", "tokens", "args", "text", "text", "to", "truncate"], "metadata": {"kind": "class", "chunk_index": "0", "has_docstring": "true", "last_modified": "1766231204.571593"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/utils/token_counter.py::TokenCounter::1", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/utils/token_counter.py::TokenCounter", "content": "     \"\"\"Truncate text to max_tokens.\n\n        Args:\n            text: Text to truncate.\n            max_tokens: Maximum tokens allowed.\n\n        Returns:\n            Truncated text.\n        \"\"\"\n        if not text:\n            return \"\"\n            \n        tokens = self.encoding.encode(text)\n        if len(tokens) <= max_tokens:\n            return text\n            \n        truncated_tokens = tokens[:max_tokens]\n        return self.encoding.decode(truncated_tokens)", "tokens": ["truncate", "text", "to", "max", "tokens", "args", "text", "text", "to", "truncate", "max", "tokens", "maximum", "tokens", "allowed", "returns", "truncated", "text", "if", "not", "text", "return", "tokens", "self", "encoding", "encode", "text", "if", "len", "tokens", "max", "tokens", "return", "text", "truncated", "tokens", "tokens", "max", "tokens", "return", "self", "encoding", "decode", "truncated", "tokens"], "metadata": {"kind": "class", "chunk_index": "1", "has_docstring": "true", "last_modified": "1766231204.571593"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/utils/token_counter.py::TokenCounter.__init__::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/utils/token_counter.py::TokenCounter.__init__", "content": "def __init__(self, model: str) -> None\n\"\"\"Initialize token counter.\n\nArgs:\n    model: Model name to use for encoding.\"\"\"\n    def __init__(self, model: str = DEFAULT_MODEL) -> None:\n        \"\"\"Initialize token counter.\n\n        Args:\n            model: Model name to use for encoding.\n        \"\"\"\n        self.model = model\n        try:\n            self.encoding = tiktoken.encoding_for_model(model)\n        except KeyError:\n            # Fallback to cl100k_base (used by gpt-4, gpt-3.5-turbo)\n            self.encoding = tiktoken.get_encoding(\"cl100k_base\")", "tokens": ["def", "init", "self", "model", "str", "none", "initialize", "token", "counter", "args", "model", "model", "name", "to", "use", "for", "encoding", "def", "init", "self", "model", "str", "default", "model", "none", "initialize", "token", "counter", "args", "model", "model", "name", "to", "use", "for", "encoding", "self", "model", "model", "try", "self", "encoding", "tiktoken", "encoding", "for", "model", "model", "except", "key", "error", "fallback", "to", "cl100k", "base", "used", "by", "gpt", "gpt", "turbo", "self", "encoding", "tiktoken", "get", "encoding", "cl100k", "base"], "metadata": {"kind": "method", "has_docstring": "true", "last_modified": "1766231204.571593"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/utils/token_counter.py::TokenCounter.count_tokens::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/utils/token_counter.py::TokenCounter.count_tokens", "content": "def count_tokens(self, text: str) -> int\n\"\"\"Count tokens in text.\n\nArgs:\n    text: Text to count tokens for.\n\nReturns:\n    Number of tokens.\"\"\"\n    def count_tokens(self, text: str) -> int:\n        \"\"\"Count tokens in text.\n\n        Args:\n            text: Text to count tokens for.\n\n        Returns:\n            Number of tokens.\n        \"\"\"\n        if not text:\n            return 0\n        return len(self.encoding.encode(text))", "tokens": ["def", "count", "tokens", "self", "text", "str", "int", "count", "tokens", "in", "text", "args", "text", "text", "to", "count", "tokens", "for", "returns", "number", "of", "tokens", "def", "count", "tokens", "self", "text", "str", "int", "count", "tokens", "in", "text", "args", "text", "text", "to", "count", "tokens", "for", "returns", "number", "of", "tokens", "if", "not", "text", "return", "return", "len", "self", "encoding", "encode", "text"], "metadata": {"kind": "method", "has_docstring": "true", "last_modified": "1766231204.571593"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/utils/token_counter.py::TokenCounter.truncate::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/utils/token_counter.py::TokenCounter.truncate", "content": "def truncate(self, text: str, max_tokens: int) -> str\n\"\"\"Truncate text to max_tokens.\n\nArgs:\n    text: Text to truncate.\n    max_tokens: Maximum tokens allowed.\n\nReturns:\n    Truncated text.\"\"\"\n    def truncate(self, text: str, max_tokens: int) -> str:\n        \"\"\"Truncate text to max_tokens.\n\n        Args:\n            text: Text to truncate.\n            max_tokens: Maximum tokens allowed.\n\n        Returns:\n            Truncated text.\n        \"\"\"\n        if not text:\n            return \"\"\n            \n        tokens = self.encoding.encode(text)\n        if len(tokens) <= max_tokens:\n            return text\n            \n        truncated_tokens = tokens[:max_tokens]\n        return self.encoding.decode(truncated_tokens)", "tokens": ["def", "truncate", "self", "text", "str", "max", "tokens", "int", "str", "truncate", "text", "to", "max", "tokens", "args", "text", "text", "to", "truncate", "max", "tokens", "maximum", "tokens", "allowed", "returns", "truncated", "text", "def", "truncate", "self", "text", "str", "max", "tokens", "int", "str", "truncate", "text", "to", "max", "tokens", "args", "text", "text", "to", "truncate", "max", "tokens", "maximum", "tokens", "allowed", "returns", "truncated", "text", "if", "not", "text", "return", "tokens", "self", "encoding", "encode", "text", "if", "len", "tokens", "max", "tokens", "return", "text", "truncated", "tokens", "tokens", "max", "tokens", "return", "self", "encoding", "decode", "truncated", "tokens"], "metadata": {"kind": "method", "has_docstring": "true", "last_modified": "1766231204.571593"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/utils/logger.py::module::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/utils/logger.py::module", "content": "\"\"\"Standard logging configuration for KnowCode.\"\"\"", "tokens": ["standard", "logging", "configuration", "for", "know", "code"], "metadata": {"type": "module_header"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/utils/logger.py::imports::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/utils/logger.py::module", "content": "import logging\nimport sys", "tokens": ["import", "logging", "import", "sys"], "metadata": {"type": "imports"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/utils/logger.py::get_logger::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/utils/logger.py::get_logger", "content": "def get_logger(name: str) -> logging.Logger\n\"\"\"Get a standardized logger configured for console output.\n\nArgs:\n    name: Logger name to retrieve.\n\nReturns:\n    A logger configured with a stream handler if none exists.\"\"\"\ndef get_logger(name: str) -> logging.Logger:\n    \"\"\"Get a standardized logger configured for console output.\n\n    Args:\n        name: Logger name to retrieve.\n\n    Returns:\n        A logger configured with a stream handler if none exists.\n    \"\"\"\n    logger = logging.getLogger(name)\n    \n    if not logger.handlers:\n        handler = logging.StreamHandler(sys.stdout)\n        formatter = logging.Formatter(\n            \"%(asctime)s - %(name)s - %(levelname)s - %(message)s\"\n        )\n        handler.setFormatter(formatter)\n        logger.addHandler(handler)\n        logger.setLevel(logging.INFO)\n        \n    return logger", "tokens": ["def", "get", "logger", "name", "str", "logging", "logger", "get", "standardized", "logger", "configured", "for", "console", "output", "args", "name", "logger", "name", "to", "retrieve", "returns", "logger", "configured", "with", "stream", "handler", "if", "none", "exists", "def", "get", "logger", "name", "str", "logging", "logger", "get", "standardized", "logger", "configured", "for", "console", "output", "args", "name", "logger", "name", "to", "retrieve", "returns", "logger", "configured", "with", "stream", "handler", "if", "none", "exists", "logger", "logging", "get", "logger", "name", "if", "not", "logger", "handlers", "handler", "logging", "stream", "handler", "sys", "stdout", "formatter", "logging", "formatter", "asctime", "name", "levelname", "message", "handler", "set", "formatter", "formatter", "logger", "add", "handler", "handler", "logger", "set", "level", "logging", "info", "return", "logger"], "metadata": {"kind": "function", "has_docstring": "true", "last_modified": "1766231204.571593"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/cli/__init__.py::module::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/cli/__init__.py::module", "content": "\"\"\"CLI package for KnowCode.\"\"\"", "tokens": ["cli", "package", "for", "know", "code"], "metadata": {"type": "module_header"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/cli/__init__.py::imports::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/cli/__init__.py::module", "content": "from .cli import cli", "tokens": ["from", "cli", "import", "cli"], "metadata": {"type": "imports"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/cli/cli.py::module::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/cli/cli.py::module", "content": "\"\"\"CLI interface for KnowCode.\"\"\"", "tokens": ["cli", "interface", "for", "know", "code"], "metadata": {"type": "module_header"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/cli/cli.py::imports::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/cli/cli.py::module", "content": "import json\nimport sys\nfrom pathlib import Path\nfrom typing import Any, Optional\nimport click\nfrom knowcode import __version__\nfrom knowcode.data_models import EntityKind, RelationshipKind\nfrom knowcode.service import KnowCodeService\nfrom knowcode.storage.knowledge_store import KnowledgeStore\n    from knowcode.config import AppConfig\n    from knowcode.llm.embedding import create_embedding_provider\n    from knowcode.indexing.indexer import Indexer\n    from knowcode.config import AppConfig\n    from knowcode.api.main import start_server\n    from knowcode.llm.agent import Agent\n    from knowcode.config import AppConfig\n        from knowcode.mcp.server import run_server", "tokens": ["import", "json", "import", "sys", "from", "pathlib", "import", "path", "from", "typing", "import", "any", "optional", "import", "click", "from", "knowcode", "import", "version", "from", "knowcode", "data", "models", "import", "entity", "kind", "relationship", "kind", "from", "knowcode", "service", "import", "know", "code", "service", "from", "knowcode", "storage", "knowledge", "store", "import", "knowledge", "store", "from", "knowcode", "config", "import", "app", "config", "from", "knowcode", "llm", "embedding", "import", "create", "embedding", "provider", "from", "knowcode", "indexing", "indexer", "import", "indexer", "from", "knowcode", "config", "import", "app", "config", "from", "knowcode", "api", "main", "import", "start", "server", "from", "knowcode", "llm", "agent", "import", "agent", "from", "knowcode", "config", "import", "app", "config", "from", "knowcode", "mcp", "server", "import", "run", "server"], "metadata": {"type": "imports"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/cli/cli.py::cli::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/cli/cli.py::cli", "content": "def cli() -> None\n\"\"\"KnowCode - Transform your codebase into an effective knowledge base.\"\"\"\ndef cli() -> None:\n    \"\"\"KnowCode - Transform your codebase into an effective knowledge base.\"\"\"\n    pass", "tokens": ["def", "cli", "none", "know", "code", "transform", "your", "codebase", "into", "an", "effective", "knowledge", "base", "def", "cli", "none", "know", "code", "transform", "your", "codebase", "into", "an", "effective", "knowledge", "base", "pass"], "metadata": {"kind": "function", "has_docstring": "true", "last_modified": "1768240645.0479665"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/cli/cli.py::analyze::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/cli/cli.py::analyze", "content": "def analyze(directory: str, output: str, ignore: tuple[str, ...], temporal: bool, coverage: Optional[str]) -> None\n\"\"\"Scan and analyze a codebase.\n\nDIRECTORY: Path to the codebase to analyze.\"\"\"\ndef analyze(directory: str, output: str, ignore: tuple[str, ...], temporal: bool, coverage: Optional[str]) -> None:\n    \"\"\"Scan and analyze a codebase.\n\n    DIRECTORY: Path to the codebase to analyze.\n    \"\"\"\n    click.echo(f\"Analyzing: {directory}\")\n    click.echo(f\"Temporal analysis: {'Enabled' if temporal else 'Disabled'}\")\n    if coverage:\n        click.echo(f\"Coverage report: {coverage}\")\n\n    service = KnowCodeService()\n    stats = service.analyze(\n        directory=directory,\n        output=output,\n        ignore=list(ignore),\n        temporal=temporal,\n        coverage=coverage,\n    )\n\n    click.echo(\"\\n\u2713 Analysis complete!\")\n    click.echo(f\"  Entities: {stats['total_entities']}\")\n    click.echo(f\"  Relationships: {stats['total_relationships']}\")\n    if stats.get('total_errors', 0) > 0", "tokens": ["def", "analyze", "directory", "str", "output", "str", "ignore", "tuple", "str", "temporal", "bool", "coverage", "optional", "str", "none", "scan", "and", "analyze", "codebase", "directory", "path", "to", "the", "codebase", "to", "analyze", "def", "analyze", "directory", "str", "output", "str", "ignore", "tuple", "str", "temporal", "bool", "coverage", "optional", "str", "none", "scan", "and", "analyze", "codebase", "directory", "path", "to", "the", "codebase", "to", "analyze", "click", "echo", "analyzing", "directory", "click", "echo", "temporal", "analysis", "enabled", "if", "temporal", "else", "disabled", "if", "coverage", "click", "echo", "coverage", "report", "coverage", "service", "know", "code", "service", "stats", "service", "analyze", "directory", "directory", "output", "output", "ignore", "list", "ignore", "temporal", "temporal", "coverage", "coverage", "click", "echo", "analysis", "complete", "click", "echo", "entities", "stats", "total", "entities", "click", "echo", "relationships", "stats", "total", "relationships", "if", "stats", "get", "total", "errors"], "metadata": {"kind": "function", "chunk_index": "0", "has_docstring": "true", "last_modified": "1768240645.0479665"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/cli/cli.py::analyze::1", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/cli/cli.py::analyze", "content": "ick.echo(f\"  Relationships: {stats['total_relationships']}\")\n    if stats.get('total_errors', 0) > 0:\n        click.echo(f\"  Errors: {stats['total_errors']}\")\n    if stats.get(\"indexed_chunks\") is not None:\n        click.echo(f\"  Indexed chunks: {stats['indexed_chunks']}\")\n\n    output_path = Path(output)\n    save_path = output_path / KnowledgeStore.DEFAULT_FILENAME if output_path.is_dir() else output_path\n    click.echo(f\"\\n  Saved to: {save_path}\")\n    if stats.get(\"index_path\"):\n        click.echo(f\"  Index saved to: {stats['index_path']}\")", "tokens": ["ick", "echo", "relationships", "stats", "total", "relationships", "if", "stats", "get", "total", "errors", "click", "echo", "errors", "stats", "total", "errors", "if", "stats", "get", "indexed", "chunks", "is", "not", "none", "click", "echo", "indexed", "chunks", "stats", "indexed", "chunks", "output", "path", "path", "output", "save", "path", "output", "path", "knowledge", "store", "default", "filename", "if", "output", "path", "is", "dir", "else", "output", "path", "click", "echo", "saved", "to", "save", "path", "if", "stats", "get", "index", "path", "click", "echo", "index", "saved", "to", "stats", "index", "path"], "metadata": {"kind": "function", "chunk_index": "1", "has_docstring": "true", "last_modified": "1768240645.0479665"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/cli/cli.py::index::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/cli/cli.py::index", "content": "def index(directory: str, output: str, config: Optional[str]) -> None\n\"\"\"Build semantic search index for a codebase.\n\nDIRECTORY: Path to the codebase to index.\"\"\"\ndef index(directory: str, output: str, config: Optional[str]) -> None:\n    \"\"\"Build semantic search index for a codebase.\n\n    DIRECTORY: Path to the codebase to index.\n    \"\"\"\n    from knowcode.config import AppConfig\n    from knowcode.llm.embedding import create_embedding_provider\n    from knowcode.indexing.indexer import Indexer\n\n    click.echo(f\"Indexing: {directory}\")\n\n    try:\n        app_config = AppConfig.load(config)\n        provider = create_embedding_provider(app_config=app_config)\n        indexer = Indexer(provider)\n\n        count = indexer.index_directory(directory)\n        indexer.save(output)\n\n        click.echo(f\"\u2713 Indexing complete! Created {count} chunks.\")\n        click.echo(f\"  Saved to: {output}\")\n    except Exception as e:\n        click.echo(f\"Error: {e}\", err=True)\n        sys.exit(1)", "tokens": ["def", "index", "directory", "str", "output", "str", "config", "optional", "str", "none", "build", "semantic", "search", "index", "for", "codebase", "directory", "path", "to", "the", "codebase", "to", "index", "def", "index", "directory", "str", "output", "str", "config", "optional", "str", "none", "build", "semantic", "search", "index", "for", "codebase", "directory", "path", "to", "the", "codebase", "to", "index", "from", "knowcode", "config", "import", "app", "config", "from", "knowcode", "llm", "embedding", "import", "create", "embedding", "provider", "from", "knowcode", "indexing", "indexer", "import", "indexer", "click", "echo", "indexing", "directory", "try", "app", "config", "app", "config", "load", "config", "provider", "create", "embedding", "provider", "app", "config", "app", "config", "indexer", "indexer", "provider", "count", "indexer", "index", "directory", "directory", "indexer", "save", "output", "click", "echo", "indexing", "complete", "created", "count", "chunks", "click", "echo", "saved", "to", "output", "except", "exception", "as", "click", "echo", "error", "err", "true", "sys", "exit"], "metadata": {"kind": "function", "has_docstring": "true", "last_modified": "1768240645.0479665"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/cli/cli.py::query::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/cli/cli.py::query", "content": "def query(query_type: str, target: str, store: str, as_json: bool) -> None\n\"\"\"Query the knowledge store.\n\nQUERY_TYPE: Type of query (callers, callees, deps, search)\nTARGET: Entity ID or search pattern\"\"\"\ndef query(query_type: str, target: str, store: str, as_json: bool) -> None:\n    \"\"\"Query the knowledge store.\n\n    QUERY_TYPE: Type of query (callers, callees, deps, search)\n    TARGET: Entity ID or search pattern\n    \"\"\"\n    try:\n        service = KnowCodeService(store_path=store)\n    except FileNotFoundError:\n        click.echo(\"Error: Knowledge store not found. Run 'knowcode analyze' first.\", err=True)\n        sys.exit(1)\n\n    results: list[dict[str, Any]] = []\n\n    if query_type == \"search\":\n        results = service.search(target)\n\n    elif query_type == \"callers\":\n        results = service.get_callers(target)\n\n    elif query_type == \"callees\":\n        results = service.get_callees(target)\n\n    elif query_type == \"deps\":\n        entity = service.store.get_entity(target) or next(it", "tokens": ["def", "query", "query", "type", "str", "target", "str", "store", "str", "as", "json", "bool", "none", "query", "the", "knowledge", "store", "query", "type", "type", "of", "query", "callers", "callees", "deps", "search", "target", "entity", "id", "or", "search", "pattern", "def", "query", "query", "type", "str", "target", "str", "store", "str", "as", "json", "bool", "none", "query", "the", "knowledge", "store", "query", "type", "type", "of", "query", "callers", "callees", "deps", "search", "target", "entity", "id", "or", "search", "pattern", "try", "service", "know", "code", "service", "store", "path", "store", "except", "file", "not", "found", "error", "click", "echo", "error", "knowledge", "store", "not", "found", "run", "knowcode", "analyze", "first", "err", "true", "sys", "exit", "results", "list", "dict", "str", "any", "if", "query", "type", "search", "results", "service", "search", "target", "elif", "query", "type", "callers", "results", "service", "get", "callers", "target", "elif", "query", "type", "callees", "results", "service", "get", "callees", "target", "elif", "query", "type", "deps", "entity", "service", "store", "get", "entity", "target", "or", "next", "it"], "metadata": {"kind": "function", "chunk_index": "0", "has_docstring": "true", "last_modified": "1768240645.0479665"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/cli/cli.py::query::1", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/cli/cli.py::query", "content": "target)\n\n    elif query_type == \"deps\":\n        entity = service.store.get_entity(target) or next(iter(service.store.search(target)), None)\n        if entity:\n            deps = service.store.get_dependencies(entity.id)\n            for d in deps:\n                results.append({\n                    \"id\": d.id,\n                    \"kind\": d.kind.value,\n                    \"name\": d.qualified_name,\n                })\n\n    # Output results\n    if as_json:\n        click.echo(json.dumps(results, indent=2))\n    else:\n        if not results:\n            click.echo(\"No results found.\")\n        else:\n            for r in results:\n                name = r.get(\"name\", r.get(\"id\", \"unknown\"))\n                if \"qualified_name\" in r:\n                    name = r[\"qualified_name\"]\n                extra = \"\"\n                if \"file\" in r:\n                    extra = f\" ({r['file']}:{r.get('line', '')})\"\n                elif \"kind\" in r:\n                    extra = f\" [{r['kind']}]\"\n                ", "tokens": ["target", "elif", "query", "type", "deps", "entity", "service", "store", "get", "entity", "target", "or", "next", "iter", "service", "store", "search", "target", "none", "if", "entity", "deps", "service", "store", "get", "dependencies", "entity", "id", "for", "in", "deps", "results", "append", "id", "id", "kind", "kind", "value", "name", "qualified", "name", "output", "results", "if", "as", "json", "click", "echo", "json", "dumps", "results", "indent", "else", "if", "not", "results", "click", "echo", "no", "results", "found", "else", "for", "in", "results", "name", "get", "name", "get", "id", "unknown", "if", "qualified", "name", "in", "name", "qualified", "name", "extra", "if", "file", "in", "extra", "file", "get", "line", "elif", "kind", "in", "extra", "kind"], "metadata": {"kind": "function", "chunk_index": "1", "has_docstring": "true", "last_modified": "1768240645.0479665"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/cli/cli.py::query::2", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/cli/cli.py::query", "content": "})\"\n                elif \"kind\" in r:\n                    extra = f\" [{r['kind']}]\"\n                click.echo(f\"  \u2022 {name}{extra}\")", "tokens": ["elif", "kind", "in", "extra", "kind", "click", "echo", "name", "extra"], "metadata": {"kind": "function", "chunk_index": "2", "has_docstring": "true", "last_modified": "1768240645.0479665"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/cli/cli.py::semantic_search::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/cli/cli.py::semantic_search", "content": "def semantic_search(query_text: tuple[str], index: str, store: str, config: Optional[str], limit: int) -> None\n\"\"\"Search codebase using semantic similarity.\n\nQUERY_TEXT: The search query.\"\"\"\ndef semantic_search(\n    query_text: tuple[str],\n    index: str,\n    store: str,\n    config: Optional[str],\n    limit: int,\n) -> None:\n    \"\"\"Search codebase using semantic similarity.\n\n    QUERY_TEXT: The search query.\n    \"\"\"\n    from knowcode.config import AppConfig\n\n    question = \" \".join(query_text)\n    click.echo(f\"Searching for: '{question}'...\")\n\n    try:\n        app_config = AppConfig.load(config)\n        service = KnowCodeService(store_path=store, app_config=app_config)\n        engine = service.get_search_engine(index_path=index)\n\n        results = engine.search(question, limit=limit)\n\n        if not results:\n            click.echo(\"No relevant code found.\")\n        else:\n            for i, chunk in enumerate(results):\n                click.echo(f\"\\n[{i+1}] {chunk.entity_id}\")\n          ", "tokens": ["def", "semantic", "search", "query", "text", "tuple", "str", "index", "str", "store", "str", "config", "optional", "str", "limit", "int", "none", "search", "codebase", "using", "semantic", "similarity", "query", "text", "the", "search", "query", "def", "semantic", "search", "query", "text", "tuple", "str", "index", "str", "store", "str", "config", "optional", "str", "limit", "int", "none", "search", "codebase", "using", "semantic", "similarity", "query", "text", "the", "search", "query", "from", "knowcode", "config", "import", "app", "config", "question", "join", "query", "text", "click", "echo", "searching", "for", "question", "try", "app", "config", "app", "config", "load", "config", "service", "know", "code", "service", "store", "path", "store", "app", "config", "app", "config", "engine", "service", "get", "search", "engine", "index", "path", "index", "results", "engine", "search", "question", "limit", "limit", "if", "not", "results", "click", "echo", "no", "relevant", "code", "found", "else", "for", "chunk", "in", "enumerate", "results", "click", "echo", "chunk", "entity", "id"], "metadata": {"kind": "function", "chunk_index": "0", "has_docstring": "true", "last_modified": "1768240645.0479665"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/cli/cli.py::semantic_search::1", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/cli/cli.py::semantic_search", "content": ", chunk in enumerate(results):\n                click.echo(f\"\\n[{i+1}] {chunk.entity_id}\")\n                content = chunk.content\n                if len(content) > 300:\n                    content = content[:300] + \"...\"\n                click.echo(\"-\" * 40)\n                click.echo(content)\n                click.echo(\"-\" * 40)\n\n    except Exception as e:\n        click.echo(f\"Error: {e}\", err=True)\n        sys.exit(1)", "tokens": ["chunk", "in", "enumerate", "results", "click", "echo", "chunk", "entity", "id", "content", "chunk", "content", "if", "len", "content", "300", "content", "content", "300", "click", "echo", "40", "click", "echo", "content", "click", "echo", "40", "except", "exception", "as", "click", "echo", "error", "err", "true", "sys", "exit"], "metadata": {"kind": "function", "chunk_index": "1", "has_docstring": "true", "last_modified": "1768240645.0479665"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/cli/cli.py::context::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/cli/cli.py::context", "content": "def context(target: str, store: str, max_tokens: int) -> None\n\"\"\"Generate context bundle for an entity.\n\nTARGET: Entity ID or search pattern\"\"\"\ndef context(target: str, store: str, max_tokens: int) -> None:\n    \"\"\"Generate context bundle for an entity.\n\n    TARGET: Entity ID or search pattern\n    \"\"\"\n    try:\n        service = KnowCodeService(store_path=store)\n    except FileNotFoundError:\n        click.echo(\"Error: Knowledge store not found. Run 'knowcode analyze' first.\", err=True)\n        sys.exit(1)\n\n    try:\n        bundle_dict = service.get_context(target, max_tokens=max_tokens)\n        click.echo(bundle_dict[\"context_text\"])\n        click.echo(f\"\\n--- {len(bundle_dict['context_text'])} chars, {bundle_dict['total_tokens']} tokens, {len(bundle_dict['included_entities'])} entities ---\", err=True)\n        if bundle_dict[\"truncated\"]:\n            click.echo(\"(truncated)\", err=True)\n    except ValueError as e:\n        click.echo(f\"Error: {e}\", err=True)\n        sys.exit(1)", "tokens": ["def", "context", "target", "str", "store", "str", "max", "tokens", "int", "none", "generate", "context", "bundle", "for", "an", "entity", "target", "entity", "id", "or", "search", "pattern", "def", "context", "target", "str", "store", "str", "max", "tokens", "int", "none", "generate", "context", "bundle", "for", "an", "entity", "target", "entity", "id", "or", "search", "pattern", "try", "service", "know", "code", "service", "store", "path", "store", "except", "file", "not", "found", "error", "click", "echo", "error", "knowledge", "store", "not", "found", "run", "knowcode", "analyze", "first", "err", "true", "sys", "exit", "try", "bundle", "dict", "service", "get", "context", "target", "max", "tokens", "max", "tokens", "click", "echo", "bundle", "dict", "context", "text", "click", "echo", "len", "bundle", "dict", "context", "text", "chars", "bundle", "dict", "total", "tokens", "tokens", "len", "bundle", "dict", "included", "entities", "entities", "err", "true", "if", "bundle", "dict", "truncated", "click", "echo", "truncated", "err", "true", "except", "value", "error", "as", "click", "echo", "error", "err", "true", "sys", "exit"], "metadata": {"kind": "function", "has_docstring": "true", "last_modified": "1768240645.0479665"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/cli/cli.py::export::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/cli/cli.py::export", "content": "def export(store: str, output: str) -> None\n\"\"\"Export knowledge store as Markdown documentation.\"\"\"\ndef export(store: str, output: str) -> None:\n    \"\"\"Export knowledge store as Markdown documentation.\"\"\"\n    try:\n        service = KnowCodeService(store_path=store)\n    except FileNotFoundError:\n        click.echo(\"Error: Knowledge store not found. Run 'knowcode analyze' first.\", err=True)\n        sys.exit(1)\n\n    knowledge = service.store\n    output_dir = Path(output)\n    output_dir.mkdir(parents=True, exist_ok=True)\n\n    # Export index\n    index_lines = [\"# Codebase Documentation\", \"\", \"Generated by KnowCode\", \"\", \"## Contents\", \"\"]\n\n    # Group entities by file\n    by_file: dict[str, list] = {}\n    for entity in knowledge.entities.values():\n        file_path = entity.location.file_path\n        if file_path not in by_file:\n            by_file[file_path] = []\n        by_file[file_path].append(entity)\n\n    for file_path, entities in sorted(by_file.items()):\n        index_lines.append(f\"", "tokens": ["def", "export", "store", "str", "output", "str", "none", "export", "knowledge", "store", "as", "markdown", "documentation", "def", "export", "store", "str", "output", "str", "none", "export", "knowledge", "store", "as", "markdown", "documentation", "try", "service", "know", "code", "service", "store", "path", "store", "except", "file", "not", "found", "error", "click", "echo", "error", "knowledge", "store", "not", "found", "run", "knowcode", "analyze", "first", "err", "true", "sys", "exit", "knowledge", "service", "store", "output", "dir", "path", "output", "output", "dir", "mkdir", "parents", "true", "exist", "ok", "true", "export", "index", "index", "lines", "codebase", "documentation", "generated", "by", "know", "code", "contents", "group", "entities", "by", "file", "by", "file", "dict", "str", "list", "for", "entity", "in", "knowledge", "entities", "values", "file", "path", "entity", "location", "file", "path", "if", "file", "path", "not", "in", "by", "file", "by", "file", "file", "path", "by", "file", "file", "path", "append", "entity", "for", "file", "path", "entities", "in", "sorted", "by", "file", "items", "index", "lines", "append"], "metadata": {"kind": "function", "chunk_index": "0", "has_docstring": "true", "last_modified": "1768240645.0479665"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/cli/cli.py::export::1", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/cli/cli.py::export", "content": "ppend(entity)\n\n    for file_path, entities in sorted(by_file.items()):\n        index_lines.append(f\"### `{Path(file_path).name}`\")\n        for e in sorted(entities, key=lambda x: x.location.line_start):\n            if e.kind in {EntityKind.FUNCTION, EntityKind.CLASS, EntityKind.METHOD}:\n                index_lines.append(f\"- [{e.kind.value}] `{e.qualified_name}`\")\n                if e.docstring:\n                    first_line = e.docstring.split(\"\\n\")[0][:80]\n                    index_lines.append(f\"  > {first_line}\")\n        index_lines.append(\"\")\n\n    # Write index\n    index_path = output_dir / \"index.md\"\n    index_path.write_text(\"\\n\".join(index_lines))\n\n    click.echo(f\"\u2713 Exported documentation to: {output_dir}\")\n    click.echo(f\"  Index: {index_path}\")", "tokens": ["ppend", "entity", "for", "file", "path", "entities", "in", "sorted", "by", "file", "items", "index", "lines", "append", "path", "file", "path", "name", "for", "in", "sorted", "entities", "key", "lambda", "location", "line", "start", "if", "kind", "in", "entity", "kind", "function", "entity", "kind", "class", "entity", "kind", "method", "index", "lines", "append", "kind", "value", "qualified", "name", "if", "docstring", "first", "line", "docstring", "split", "80", "index", "lines", "append", "first", "line", "index", "lines", "append", "write", "index", "index", "path", "output", "dir", "index", "md", "index", "path", "write", "text", "join", "index", "lines", "click", "echo", "exported", "documentation", "to", "output", "dir", "click", "echo", "index", "index", "path"], "metadata": {"kind": "function", "chunk_index": "1", "has_docstring": "true", "last_modified": "1768240645.0479665"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/cli/cli.py::stats::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/cli/cli.py::stats", "content": "def stats(store: str) -> None\n\"\"\"Show statistics about the knowledge store.\"\"\"\ndef stats(store: str) -> None:\n    \"\"\"Show statistics about the knowledge store.\"\"\"\n    try:\n        service = KnowCodeService(store_path=store)\n    except FileNotFoundError:\n        click.echo(\"Error: Knowledge store not found. Run 'knowcode analyze' first.\", err=True)\n        sys.exit(1)\n\n    s = service.get_stats()\n    click.echo(\"Knowledge Store Statistics\")\n    click.echo(\"-\" * 30)\n\n    click.echo(f\"\\nTotal Entities: {s['total_entities']}\")\n    for kind, count in sorted(s['entities_by_kind'].items()):\n        click.echo(f\"  {kind}: {count}\")\n\n    click.echo(f\"\\nTotal Relationships: {s['total_relationships']}\")\n    for kind, count in sorted(s['relationships_by_type'].items()):\n        click.echo(f\"  {kind}: {count}\")", "tokens": ["def", "stats", "store", "str", "none", "show", "statistics", "about", "the", "knowledge", "store", "def", "stats", "store", "str", "none", "show", "statistics", "about", "the", "knowledge", "store", "try", "service", "know", "code", "service", "store", "path", "store", "except", "file", "not", "found", "error", "click", "echo", "error", "knowledge", "store", "not", "found", "run", "knowcode", "analyze", "first", "err", "true", "sys", "exit", "service", "get", "stats", "click", "echo", "knowledge", "store", "statistics", "click", "echo", "30", "click", "echo", "total", "entities", "total", "entities", "for", "kind", "count", "in", "sorted", "entities", "by", "kind", "items", "click", "echo", "kind", "count", "click", "echo", "total", "relationships", "total", "relationships", "for", "kind", "count", "in", "sorted", "relationships", "by", "type", "items", "click", "echo", "kind", "count"], "metadata": {"kind": "function", "has_docstring": "true", "last_modified": "1768240645.0479665"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/cli/cli.py::server::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/cli/cli.py::server", "content": "def server(store: str, host: str, port: int, watch: bool) -> None\n\"\"\"Start the KnowCode intelligence server.\"\"\"\ndef server(store: str, host: str, port: int, watch: bool) -> None:\n    \"\"\"Start the KnowCode intelligence server.\"\"\"\n    from knowcode.api.main import start_server\n    \n    click.echo(f\"Starting KnowCode server on {host}:{port}\")\n    click.echo(f\"Using knowledge store: {store}\")\n    if watch:\n        click.echo(\"Watch mode enabled.\")\n    \n    start_server(host=host, port=port, store_path=store, watch=watch)", "tokens": ["def", "server", "store", "str", "host", "str", "port", "int", "watch", "bool", "none", "start", "the", "know", "code", "intelligence", "server", "def", "server", "store", "str", "host", "str", "port", "int", "watch", "bool", "none", "start", "the", "know", "code", "intelligence", "server", "from", "knowcode", "api", "main", "import", "start", "server", "click", "echo", "starting", "know", "code", "server", "on", "host", "port", "click", "echo", "using", "knowledge", "store", "store", "if", "watch", "click", "echo", "watch", "mode", "enabled", "start", "server", "host", "host", "port", "port", "store", "path", "store", "watch", "watch"], "metadata": {"kind": "function", "has_docstring": "true", "last_modified": "1768240645.0479665"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/cli/cli.py::history::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/cli/cli.py::history", "content": "def history(target: Optional[str], store: str, limit: int) -> None\n\"\"\"Show history of the codebase or a specific entity.\n\nTARGET: Optional entity ID or search pattern. If omitted, shows commit log.\"\"\"\ndef history(target: Optional[str], store: str, limit: int) -> None:\n    \"\"\"Show history of the codebase or a specific entity.\n    \n    TARGET: Optional entity ID or search pattern. If omitted, shows commit log.\n    \"\"\"\n    try:\n        service = KnowCodeService(store_path=store)\n    except FileNotFoundError:\n        click.echo(\"Error: Knowledge store not found. Run 'knowcode analyze' first.\", err=True)\n        sys.exit(1)\n        \n    knowledge = service.store\n    \n    if not target:\n        # Show recent commits\n        commits = knowledge.get_entities_by_kind(\"commit\")\n        # Sort by timestamp (metadata)\n        commits.sort(key=lambda x: x.metadata.get(\"timestamp\", \"0\"), reverse=True)\n        \n        click.echo(f\"Recent History (showing {min(limit, len(commits))} of {len(commits)})", "tokens": ["def", "history", "target", "optional", "str", "store", "str", "limit", "int", "none", "show", "history", "of", "the", "codebase", "or", "specific", "entity", "target", "optional", "entity", "id", "or", "search", "pattern", "if", "omitted", "shows", "commit", "log", "def", "history", "target", "optional", "str", "store", "str", "limit", "int", "none", "show", "history", "of", "the", "codebase", "or", "specific", "entity", "target", "optional", "entity", "id", "or", "search", "pattern", "if", "omitted", "shows", "commit", "log", "try", "service", "know", "code", "service", "store", "path", "store", "except", "file", "not", "found", "error", "click", "echo", "error", "knowledge", "store", "not", "found", "run", "knowcode", "analyze", "first", "err", "true", "sys", "exit", "knowledge", "service", "store", "if", "not", "target", "show", "recent", "commits", "commits", "knowledge", "get", "entities", "by", "kind", "commit", "sort", "by", "timestamp", "metadata", "commits", "sort", "key", "lambda", "metadata", "get", "timestamp", "reverse", "true", "click", "echo", "recent", "history", "showing", "min", "limit", "len", "commits", "of", "len", "commits"], "metadata": {"kind": "function", "chunk_index": "0", "has_docstring": "true", "last_modified": "1768240645.0479665"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/cli/cli.py::history::1", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/cli/cli.py::history", "content": "\n        \n        click.echo(f\"Recent History (showing {min(limit, len(commits))} of {len(commits)}):\")\n        for commit in commits[:limit]:\n            date = commit.metadata.get(\"date\", \"Unknown date\")\n            author_rels = knowledge.get_incoming_relationships(commit.id)\n            author = \"Unknown\"\n            for rel in author_rels:\n                if rel.kind == RelationshipKind.AUTHORED:\n                    # rel.source_id is author\n                    a_ent = knowledge.get_entity(rel.source_id)\n                    if a_ent:\n                         author = a_ent.name\n            \n            click.echo(f\"[{date}] {commit.name} - {author}\")\n            click.echo(f\"  {commit.docstring.splitlines()[0] if commit.docstring else ''}\")\n            \n    else:\n        # Show history for specific entity\n        entity = knowledge.get_entity(target)\n        if not entity:\n             matches = knowledge.search(target)\n             if matches:\n                 entity = matches[0]", "tokens": ["click", "echo", "recent", "history", "showing", "min", "limit", "len", "commits", "of", "len", "commits", "for", "commit", "in", "commits", "limit", "date", "commit", "metadata", "get", "date", "unknown", "date", "author", "rels", "knowledge", "get", "incoming", "relationships", "commit", "id", "author", "unknown", "for", "rel", "in", "author", "rels", "if", "rel", "kind", "relationship", "kind", "authored", "rel", "source", "id", "is", "author", "ent", "knowledge", "get", "entity", "rel", "source", "id", "if", "ent", "author", "ent", "name", "click", "echo", "date", "commit", "name", "author", "click", "echo", "commit", "docstring", "splitlines", "if", "commit", "docstring", "else", "else", "show", "history", "for", "specific", "entity", "entity", "knowledge", "get", "entity", "target", "if", "not", "entity", "matches", "knowledge", "search", "target", "if", "matches", "entity", "matches"], "metadata": {"kind": "function", "chunk_index": "1", "has_docstring": "true", "last_modified": "1768240645.0479665"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/cli/cli.py::history::2", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/cli/cli.py::history", "content": "    matches = knowledge.search(target)\n             if matches:\n                 entity = matches[0]\n                 click.echo(f\"Using: {entity.id}\\n\")\n        \n        if not entity:\n             click.echo(f\"Entity not found: {target}\")\n             return\n\n        click.echo(f\"History for {entity.qualified_name} ({entity.kind.value}):\")\n        \n        # Build history from relationships\n        # Entity -> CHANGED_BY -> Commit\n        rels = knowledge.get_outgoing_relationships(entity.id)\n        changes = []\n        for rel in rels:\n            if rel.kind == RelationshipKind.CHANGED_BY:\n                commit = knowledge.get_entity(rel.target_id)\n                if commit:\n                    # Get modification stats from edge metadata\n                    stats = f\"(+{rel.metadata.get('insertions', 0)}/-{rel.metadata.get('deletions', 0)})\"\n                    timestamp = commit.metadata.get(\"timestamp\", \"0\")\n                    changes.append((timestamp, commit, stats))\n       ", "tokens": ["matches", "knowledge", "search", "target", "if", "matches", "entity", "matches", "click", "echo", "using", "entity", "id", "if", "not", "entity", "click", "echo", "entity", "not", "found", "target", "return", "click", "echo", "history", "for", "entity", "qualified", "name", "entity", "kind", "value", "build", "history", "from", "relationships", "entity", "changed", "by", "commit", "rels", "knowledge", "get", "outgoing", "relationships", "entity", "id", "changes", "for", "rel", "in", "rels", "if", "rel", "kind", "relationship", "kind", "changed", "by", "commit", "knowledge", "get", "entity", "rel", "target", "id", "if", "commit", "get", "modification", "stats", "from", "edge", "metadata", "stats", "rel", "metadata", "get", "insertions", "rel", "metadata", "get", "deletions", "timestamp", "commit", "metadata", "get", "timestamp", "changes", "append", "timestamp", "commit", "stats"], "metadata": {"kind": "function", "chunk_index": "2", "has_docstring": "true", "last_modified": "1768240645.0479665"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/cli/cli.py::history::3", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/cli/cli.py::history", "content": "etadata.get(\"timestamp\", \"0\")\n                    changes.append((timestamp, commit, stats))\n        \n        changes.sort(key=lambda x: x[0], reverse=True)\n        \n        if not changes:\n            click.echo(\"  No recorded history (scan with --temporal).\")\n            return\n            \n        for _, commit, stats in changes[:limit]:\n            date = commit.metadata.get(\"date\", \"\")\n            click.echo(f\"  {date} {commit.name} {stats}: {commit.docstring.splitlines()[0]}\")", "tokens": ["etadata", "get", "timestamp", "changes", "append", "timestamp", "commit", "stats", "changes", "sort", "key", "lambda", "reverse", "true", "if", "not", "changes", "click", "echo", "no", "recorded", "history", "scan", "with", "temporal", "return", "for", "commit", "stats", "in", "changes", "limit", "date", "commit", "metadata", "get", "date", "click", "echo", "date", "commit", "name", "stats", "commit", "docstring", "splitlines"], "metadata": {"kind": "function", "chunk_index": "3", "has_docstring": "true", "last_modified": "1768240645.0479665"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/cli/cli.py::ask::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/cli/cli.py::ask", "content": "def ask(query_text: tuple[str], store: str, config: Optional[str]) -> None\n\"\"\"Ask a question about the codebase using AI.\n\nQUERY_TEXT: The question to ask.\"\"\"\ndef ask(query_text: tuple[str], store: str, config: Optional[str]) -> None:\n    \"\"\"Ask a question about the codebase using AI.\n    \n    QUERY_TEXT: The question to ask.\n    \"\"\"\n    from knowcode.llm.agent import Agent\n    from knowcode.config import AppConfig\n    \n    question = \" \".join(query_text)\n    \n    try:\n        app_config = AppConfig.load(config)\n        service = KnowCodeService(store_path=store, app_config=app_config)\n        agent = Agent(service, config=app_config)\n        \n        click.echo(f\"\ud83e\udd14 Asking KnowCode: '{question}'...\")\n        answer = agent.answer(question)\n        click.echo(\"\\n\" + answer)\n    except ValueError as e:\n        click.echo(f\"Error: {e}\", err=True)\n        sys.exit(1)\n    except Exception as e:\n        click.echo(f\"Error: {e}\", err=True)\n        sys.exit(1)", "tokens": ["def", "ask", "query", "text", "tuple", "str", "store", "str", "config", "optional", "str", "none", "ask", "question", "about", "the", "codebase", "using", "ai", "query", "text", "the", "question", "to", "ask", "def", "ask", "query", "text", "tuple", "str", "store", "str", "config", "optional", "str", "none", "ask", "question", "about", "the", "codebase", "using", "ai", "query", "text", "the", "question", "to", "ask", "from", "knowcode", "llm", "agent", "import", "agent", "from", "knowcode", "config", "import", "app", "config", "question", "join", "query", "text", "try", "app", "config", "app", "config", "load", "config", "service", "know", "code", "service", "store", "path", "store", "app", "config", "app", "config", "agent", "agent", "service", "config", "app", "config", "click", "echo", "asking", "know", "code", "question", "answer", "agent", "answer", "question", "click", "echo", "answer", "except", "value", "error", "as", "click", "echo", "error", "err", "true", "sys", "exit", "except", "exception", "as", "click", "echo", "error", "err", "true", "sys", "exit"], "metadata": {"kind": "function", "has_docstring": "true", "last_modified": "1768240645.0479665"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/cli/cli.py::mcp_server::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/cli/cli.py::mcp_server", "content": "def mcp_server(store: str, config: Optional[str]) -> None\n\"\"\"Start MCP server for IDE integration.\n\nExposes KnowCode tools via the Model Context Protocol (MCP) using\nSTDIO transport. Three tools are available:\n\n\b\n- search_codebase: Search for code entities by name\n- get_entity_context: Get detailed context for an entity  \n- trace_calls: Trace call graph (callers/callees) with depth\n\nExample usage with Claude Desktop or other MCP clients:\n\n\b\n    # In your MCP client config, add:\n    {\n        \"knowcode\": {\n            \"command\": \"knowcode\",\n            \"args\": [\"mcp-server\", \"--store\", \"/path/to/project\"]\n        }\n    }\"\"\"\ndef mcp_server(store: str, config: Optional[str]) -> None:\n    \"\"\"Start MCP server for IDE integration.\n    \n    Exposes KnowCode tools via the Model Context Protocol (MCP) using\n    STDIO transport. Three tools are available:\n    \n    \\b\n    - search_codebase: Search for code entities by name\n    - get_entity_context: Get detailed context for an entity  \n    - trace", "tokens": ["def", "mcp", "server", "store", "str", "config", "optional", "str", "none", "start", "mcp", "server", "for", "ide", "integration", "exposes", "know", "code", "tools", "via", "the", "model", "context", "protocol", "mcp", "using", "stdio", "transport", "three", "tools", "are", "available", "search", "codebase", "search", "for", "code", "entities", "by", "name", "get", "entity", "context", "get", "detailed", "context", "for", "an", "entity", "trace", "calls", "trace", "call", "graph", "callers", "callees", "with", "depth", "example", "usage", "with", "claude", "desktop", "or", "other", "mcp", "clients", "in", "your", "mcp", "client", "config", "add", "knowcode", "command", "knowcode", "args", "mcp", "server", "store", "path", "to", "project", "def", "mcp", "server", "store", "str", "config", "optional", "str", "none", "start", "mcp", "server", "for", "ide", "integration", "exposes", "know", "code", "tools", "via", "the", "model", "context", "protocol", "mcp", "using", "stdio", "transport", "three", "tools", "are", "available", "search", "codebase", "search", "for", "code", "entities", "by", "name", "get", "entity", "context", "get", "detailed", "context", "for", "an", "entity", "trace"], "metadata": {"kind": "function", "chunk_index": "0", "has_docstring": "true", "last_modified": "1768240645.0479665"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/cli/cli.py::mcp_server::1", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/cli/cli.py::mcp_server", "content": "for code entities by name\n    - get_entity_context: Get detailed context for an entity  \n    - trace_calls: Trace call graph (callers/callees) with depth\n    \n    Example usage with Claude Desktop or other MCP clients:\n    \n    \\b\n        # In your MCP client config, add:\n        {\n            \"knowcode\": {\n                \"command\": \"knowcode\",\n                \"args\": [\"mcp-server\", \"--store\", \"/path/to/project\"]\n            }\n        }\n    \"\"\"\n    store_path = Path(store)\n    store_file = store_path / KnowledgeStore.DEFAULT_FILENAME if store_path.is_dir() else store_path\n    if not store_file.exists():\n        click.echo(\n            \"\u26a0\ufe0f Knowledge store not found. It will be built on first query.\",\n            err=True,\n        )\n    \n    try:\n        from knowcode.mcp.server import run_server\n        \n        click.echo(\"\ud83d\udd0c Starting MCP server...\", err=True)\n        click.echo(f\"   Store: {store_path}\", err=True)\n        click.echo(\"   Transport: STDIO\", err=True)\n        click.echo(", "tokens": ["for", "code", "entities", "by", "name", "get", "entity", "context", "get", "detailed", "context", "for", "an", "entity", "trace", "calls", "trace", "call", "graph", "callers", "callees", "with", "depth", "example", "usage", "with", "claude", "desktop", "or", "other", "mcp", "clients", "in", "your", "mcp", "client", "config", "add", "knowcode", "command", "knowcode", "args", "mcp", "server", "store", "path", "to", "project", "store", "path", "path", "store", "store", "file", "store", "path", "knowledge", "store", "default", "filename", "if", "store", "path", "is", "dir", "else", "store", "path", "if", "not", "store", "file", "exists", "click", "echo", "knowledge", "store", "not", "found", "it", "will", "be", "built", "on", "first", "query", "err", "true", "try", "from", "knowcode", "mcp", "server", "import", "run", "server", "click", "echo", "starting", "mcp", "server", "err", "true", "click", "echo", "store", "store", "path", "err", "true", "click", "echo", "transport", "stdio", "err", "true", "click", "echo"], "metadata": {"kind": "function", "chunk_index": "1", "has_docstring": "true", "last_modified": "1768240645.0479665"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/cli/cli.py::mcp_server::2", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/cli/cli.py::mcp_server", "content": "re: {store_path}\", err=True)\n        click.echo(\"   Transport: STDIO\", err=True)\n        click.echo(\n            \"   Tools: search_codebase, get_entity_context, trace_calls, retrieve_context_for_query\",\n            err=True,\n        )\n        \n        # Run the server (blocking)\n        run_server(store_path, config_path=config)\n        \n    except ImportError as e:\n        click.echo(\n            f\"Error: MCP package not installed. Install with: pip install mcp\\n{e}\",\n            err=True\n        )\n        sys.exit(1)\n    except Exception as e:\n        click.echo(f\"Error: {e}\", err=True)\n        sys.exit(1)", "tokens": ["re", "store", "path", "err", "true", "click", "echo", "transport", "stdio", "err", "true", "click", "echo", "tools", "search", "codebase", "get", "entity", "context", "trace", "calls", "retrieve", "context", "for", "query", "err", "true", "run", "the", "server", "blocking", "run", "server", "store", "path", "config", "path", "config", "except", "import", "error", "as", "click", "echo", "error", "mcp", "package", "not", "installed", "install", "with", "pip", "install", "mcp", "err", "true", "sys", "exit", "except", "exception", "as", "click", "echo", "error", "err", "true", "sys", "exit"], "metadata": {"kind": "function", "chunk_index": "2", "has_docstring": "true", "last_modified": "1768240645.0479665"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/scanner.py::module::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/scanner.py::module", "content": "\"\"\"File scanner with gitignore support.\"\"\"", "tokens": ["file", "scanner", "with", "gitignore", "support"], "metadata": {"type": "module_header"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/scanner.py::imports::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/scanner.py::module", "content": "from __future__ import annotations\nimport os\nfrom dataclasses import dataclass\nfrom pathlib import Path\nfrom typing import Iterator, Optional\nimport pathspec", "tokens": ["from", "future", "import", "annotations", "import", "os", "from", "dataclasses", "import", "dataclass", "from", "pathlib", "import", "path", "from", "typing", "import", "iterator", "optional", "import", "pathspec"], "metadata": {"type": "imports"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/scanner.py::FileInfo::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/scanner.py::FileInfo", "content": "\"\"\"Information about a discovered file.\"\"\"\nclass FileInfo:\n    \"\"\"Information about a discovered file.\"\"\"\n\n    path: Path\n    relative_path: str\n    extension: str\n    size_bytes: int", "tokens": ["information", "about", "discovered", "file", "class", "file", "info", "information", "about", "discovered", "file", "path", "path", "relative", "path", "str", "extension", "str", "size", "bytes", "int"], "metadata": {"kind": "class", "has_docstring": "true", "last_modified": "1766231204.5712247"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/scanner.py::Scanner::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/scanner.py::Scanner", "content": "\"\"\"Scans directories for source files with gitignore support.\"\"\"\nclass Scanner:\n    \"\"\"Scans directories for source files with gitignore support.\"\"\"\n\n    SUPPORTED_EXTENSIONS = {\".py\", \".md\", \".yaml\", \".yml\", \".js\", \".ts\", \".java\"}\n\n    def __init__(\n        self,\n        root_dir: str | Path,\n        respect_gitignore: bool = True,\n        additional_ignores: Optional[list[str]] = None,\n    ) -> None:\n        \"\"\"Initialize scanner.\n\n        Args:\n            root_dir: Root directory to scan.\n            respect_gitignore: Whether to respect .gitignore files.\n            additional_ignores: Additional patterns to ignore.\n        \"\"\"\n        self.root_dir = Path(root_dir).resolve()\n        self.respect_gitignore = respect_gitignore\n        self.additional_ignores = additional_ignores or []\n        self._gitignore_spec: Optional[pathspec.PathSpec] = None\n\n    def _load_gitignore(self) -> Optional[pathspec.PathSpec]:\n        \"\"\"Load .gitignore patterns from root directory.\"\"\"\n        giti", "tokens": ["scans", "directories", "for", "source", "files", "with", "gitignore", "support", "class", "scanner", "scans", "directories", "for", "source", "files", "with", "gitignore", "support", "supported", "extensions", "py", "md", "yaml", "yml", "js", "ts", "java", "def", "init", "self", "root", "dir", "str", "path", "respect", "gitignore", "bool", "true", "additional", "ignores", "optional", "list", "str", "none", "none", "initialize", "scanner", "args", "root", "dir", "root", "directory", "to", "scan", "respect", "gitignore", "whether", "to", "respect", "gitignore", "files", "additional", "ignores", "additional", "patterns", "to", "ignore", "self", "root", "dir", "path", "root", "dir", "resolve", "self", "respect", "gitignore", "respect", "gitignore", "self", "additional", "ignores", "additional", "ignores", "or", "self", "gitignore", "spec", "optional", "pathspec", "path", "spec", "none", "def", "load", "gitignore", "self", "optional", "pathspec", "path", "spec", "load", "gitignore", "patterns", "from", "root", "directory", "giti"], "metadata": {"kind": "class", "chunk_index": "0", "has_docstring": "true", "last_modified": "1766231204.5712247"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/scanner.py::Scanner::1", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/scanner.py::Scanner", "content": "ptional[pathspec.PathSpec]:\n        \"\"\"Load .gitignore patterns from root directory.\"\"\"\n        gitignore_path = self.root_dir / \".gitignore\"\n        patterns: list[str] = []\n\n        # Always ignore common directories\n        patterns.extend([\n            \".git/\",\n            \"__pycache__/\",\n            \"*.pyc\",\n            \".venv/\",\n            \"venv/\",\n            \"node_modules/\",\n            \".eggs/\",\n            \"*.egg-info/\",\n        ])\n\n        # Add additional ignores\n        patterns.extend(self.additional_ignores)\n\n        # Load .gitignore if it exists\n        if gitignore_path.exists():\n            with open(gitignore_path, \"r\", encoding=\"utf-8\") as f:\n                for line in f:\n                    line = line.strip()\n                    if line and not line.startswith(\"#\"):\n                        patterns.append(line)\n\n        return pathspec.PathSpec.from_lines(\"gitwildmatch\", patterns)\n\n    def _should_ignore(self, relative_path: str) -> bool:\n        \"\"\"Check if a ", "tokens": ["ptional", "pathspec", "path", "spec", "load", "gitignore", "patterns", "from", "root", "directory", "gitignore", "path", "self", "root", "dir", "gitignore", "patterns", "list", "str", "always", "ignore", "common", "directories", "patterns", "extend", "git", "pycache", "pyc", "venv", "venv", "node", "modules", "eggs", "egg", "info", "add", "additional", "ignores", "patterns", "extend", "self", "additional", "ignores", "load", "gitignore", "if", "it", "exists", "if", "gitignore", "path", "exists", "with", "open", "gitignore", "path", "encoding", "utf", "as", "for", "line", "in", "line", "line", "strip", "if", "line", "and", "not", "line", "startswith", "patterns", "append", "line", "return", "pathspec", "path", "spec", "from", "lines", "gitwildmatch", "patterns", "def", "should", "ignore", "self", "relative", "path", "str", "bool", "check", "if"], "metadata": {"kind": "class", "chunk_index": "1", "has_docstring": "true", "last_modified": "1766231204.5712247"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/scanner.py::Scanner::2", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/scanner.py::Scanner", "content": "dmatch\", patterns)\n\n    def _should_ignore(self, relative_path: str) -> bool:\n        \"\"\"Check if a path should be ignored.\"\"\"\n        if self._gitignore_spec is None:\n            self._gitignore_spec = self._load_gitignore()\n\n        if self._gitignore_spec:\n            return self._gitignore_spec.match_file(relative_path)\n        return False\n\n    def scan(self) -> Iterator[FileInfo]:\n        \"\"\"Scan directory and yield file information.\n\n        Yields:\n            FileInfo for each discovered source file.\n        \"\"\"\n        if not self.root_dir.exists():\n            raise FileNotFoundError(f\"Directory not found: {self.root_dir}\")\n\n        if not self.root_dir.is_dir():\n            raise NotADirectoryError(f\"Not a directory: {self.root_dir}\")\n\n        for root, dirs, files in os.walk(self.root_dir):\n            root_path = Path(root)\n\n            # Filter directories in-place to skip ignored ones\n            dirs[:] = [\n                d for d in dirs\n                if not self._s", "tokens": ["dmatch", "patterns", "def", "should", "ignore", "self", "relative", "path", "str", "bool", "check", "if", "path", "should", "be", "ignored", "if", "self", "gitignore", "spec", "is", "none", "self", "gitignore", "spec", "self", "load", "gitignore", "if", "self", "gitignore", "spec", "return", "self", "gitignore", "spec", "match", "file", "relative", "path", "return", "false", "def", "scan", "self", "iterator", "file", "info", "scan", "directory", "and", "yield", "file", "information", "yields", "file", "info", "for", "each", "discovered", "source", "file", "if", "not", "self", "root", "dir", "exists", "raise", "file", "not", "found", "error", "directory", "not", "found", "self", "root", "dir", "if", "not", "self", "root", "dir", "is", "dir", "raise", "not", "adirectory", "error", "not", "directory", "self", "root", "dir", "for", "root", "dirs", "files", "in", "os", "walk", "self", "root", "dir", "root", "path", "path", "root", "filter", "directories", "in", "place", "to", "skip", "ignored", "ones", "dirs", "for", "in", "dirs", "if", "not", "self"], "metadata": {"kind": "class", "chunk_index": "2", "has_docstring": "true", "last_modified": "1766231204.5712247"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/scanner.py::Scanner::3", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/scanner.py::Scanner", "content": " ignored ones\n            dirs[:] = [\n                d for d in dirs\n                if not self._should_ignore(\n                    str((root_path / d).relative_to(self.root_dir)) + \"/\"\n                )\n            ]\n\n            for filename in files:\n                file_path = root_path / filename\n                relative_path = str(file_path.relative_to(self.root_dir))\n\n                # Check if ignored\n                # We check relative_path to ensure ignore patterns match correctly \n                # against the project root (e.g., \"src/\" vs \"/abs/path/to/src/\")\n                if self._should_ignore(relative_path):\n                    continue\n\n                # Check extension\n                extension = file_path.suffix.lower()\n                if extension not in self.SUPPORTED_EXTENSIONS:\n                    continue\n\n                try:\n                    size_bytes = file_path.stat().st_size\n                except OSError:\n                    continue\n\n              ", "tokens": ["ignored", "ones", "dirs", "for", "in", "dirs", "if", "not", "self", "should", "ignore", "str", "root", "path", "relative", "to", "self", "root", "dir", "for", "filename", "in", "files", "file", "path", "root", "path", "filename", "relative", "path", "str", "file", "path", "relative", "to", "self", "root", "dir", "check", "if", "ignored", "we", "check", "relative", "path", "to", "ensure", "ignore", "patterns", "match", "correctly", "against", "the", "project", "root", "src", "vs", "abs", "path", "to", "src", "if", "self", "should", "ignore", "relative", "path", "continue", "check", "extension", "extension", "file", "path", "suffix", "lower", "if", "extension", "not", "in", "self", "supported", "extensions", "continue", "try", "size", "bytes", "file", "path", "stat", "st", "size", "except", "oserror", "continue"], "metadata": {"kind": "class", "chunk_index": "3", "has_docstring": "true", "last_modified": "1766231204.5712247"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/scanner.py::Scanner::4", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/scanner.py::Scanner", "content": "ile_path.stat().st_size\n                except OSError:\n                    continue\n\n                yield FileInfo(\n                    path=file_path,\n                    relative_path=relative_path,\n                    extension=extension,\n                    size_bytes=size_bytes,\n                )\n\n    def scan_all(self) -> list[FileInfo]:\n        \"\"\"Scan and return all files as a list.\"\"\"\n        return list(self.scan())", "tokens": ["ile", "path", "stat", "st", "size", "except", "oserror", "continue", "yield", "file", "info", "path", "file", "path", "relative", "path", "relative", "path", "extension", "extension", "size", "bytes", "size", "bytes", "def", "scan", "all", "self", "list", "file", "info", "scan", "and", "return", "all", "files", "as", "list", "return", "list", "self", "scan"], "metadata": {"kind": "class", "chunk_index": "4", "has_docstring": "true", "last_modified": "1766231204.5712247"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/scanner.py::Scanner.__init__::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/scanner.py::Scanner.__init__", "content": "def __init__(self, root_dir: str | Path, respect_gitignore: bool, additional_ignores: Optional[list[str]]) -> None\n\"\"\"Initialize scanner.\n\nArgs:\n    root_dir: Root directory to scan.\n    respect_gitignore: Whether to respect .gitignore files.\n    additional_ignores: Additional patterns to ignore.\"\"\"\n    def __init__(\n        self,\n        root_dir: str | Path,\n        respect_gitignore: bool = True,\n        additional_ignores: Optional[list[str]] = None,\n    ) -> None:\n        \"\"\"Initialize scanner.\n\n        Args:\n            root_dir: Root directory to scan.\n            respect_gitignore: Whether to respect .gitignore files.\n            additional_ignores: Additional patterns to ignore.\n        \"\"\"\n        self.root_dir = Path(root_dir).resolve()\n        self.respect_gitignore = respect_gitignore\n        self.additional_ignores = additional_ignores or []\n        self._gitignore_spec: Optional[pathspec.PathSpec] = None", "tokens": ["def", "init", "self", "root", "dir", "str", "path", "respect", "gitignore", "bool", "additional", "ignores", "optional", "list", "str", "none", "initialize", "scanner", "args", "root", "dir", "root", "directory", "to", "scan", "respect", "gitignore", "whether", "to", "respect", "gitignore", "files", "additional", "ignores", "additional", "patterns", "to", "ignore", "def", "init", "self", "root", "dir", "str", "path", "respect", "gitignore", "bool", "true", "additional", "ignores", "optional", "list", "str", "none", "none", "initialize", "scanner", "args", "root", "dir", "root", "directory", "to", "scan", "respect", "gitignore", "whether", "to", "respect", "gitignore", "files", "additional", "ignores", "additional", "patterns", "to", "ignore", "self", "root", "dir", "path", "root", "dir", "resolve", "self", "respect", "gitignore", "respect", "gitignore", "self", "additional", "ignores", "additional", "ignores", "or", "self", "gitignore", "spec", "optional", "pathspec", "path", "spec", "none"], "metadata": {"kind": "method", "has_docstring": "true", "last_modified": "1766231204.5712247"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/scanner.py::Scanner._load_gitignore::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/scanner.py::Scanner._load_gitignore", "content": "def _load_gitignore(self) -> Optional[pathspec.PathSpec]\n\"\"\"Load .gitignore patterns from root directory.\"\"\"\n    def _load_gitignore(self) -> Optional[pathspec.PathSpec]:\n        \"\"\"Load .gitignore patterns from root directory.\"\"\"\n        gitignore_path = self.root_dir / \".gitignore\"\n        patterns: list[str] = []\n\n        # Always ignore common directories\n        patterns.extend([\n            \".git/\",\n            \"__pycache__/\",\n            \"*.pyc\",\n            \".venv/\",\n            \"venv/\",\n            \"node_modules/\",\n            \".eggs/\",\n            \"*.egg-info/\",\n        ])\n\n        # Add additional ignores\n        patterns.extend(self.additional_ignores)\n\n        # Load .gitignore if it exists\n        if gitignore_path.exists():\n            with open(gitignore_path, \"r\", encoding=\"utf-8\") as f:\n                for line in f:\n                    line = line.strip()\n                    if line and not line.startswith(\"#\"):\n                        patterns.append(line)\n\n        ", "tokens": ["def", "load", "gitignore", "self", "optional", "pathspec", "path", "spec", "load", "gitignore", "patterns", "from", "root", "directory", "def", "load", "gitignore", "self", "optional", "pathspec", "path", "spec", "load", "gitignore", "patterns", "from", "root", "directory", "gitignore", "path", "self", "root", "dir", "gitignore", "patterns", "list", "str", "always", "ignore", "common", "directories", "patterns", "extend", "git", "pycache", "pyc", "venv", "venv", "node", "modules", "eggs", "egg", "info", "add", "additional", "ignores", "patterns", "extend", "self", "additional", "ignores", "load", "gitignore", "if", "it", "exists", "if", "gitignore", "path", "exists", "with", "open", "gitignore", "path", "encoding", "utf", "as", "for", "line", "in", "line", "line", "strip", "if", "line", "and", "not", "line", "startswith", "patterns", "append", "line"], "metadata": {"kind": "method", "chunk_index": "0", "has_docstring": "true", "last_modified": "1766231204.5712247"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/scanner.py::Scanner._load_gitignore::1", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/scanner.py::Scanner._load_gitignore", "content": "       if line and not line.startswith(\"#\"):\n                        patterns.append(line)\n\n        return pathspec.PathSpec.from_lines(\"gitwildmatch\", patterns)", "tokens": ["if", "line", "and", "not", "line", "startswith", "patterns", "append", "line", "return", "pathspec", "path", "spec", "from", "lines", "gitwildmatch", "patterns"], "metadata": {"kind": "method", "chunk_index": "1", "has_docstring": "true", "last_modified": "1766231204.5712247"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/scanner.py::Scanner._should_ignore::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/scanner.py::Scanner._should_ignore", "content": "def _should_ignore(self, relative_path: str) -> bool\n\"\"\"Check if a path should be ignored.\"\"\"\n    def _should_ignore(self, relative_path: str) -> bool:\n        \"\"\"Check if a path should be ignored.\"\"\"\n        if self._gitignore_spec is None:\n            self._gitignore_spec = self._load_gitignore()\n\n        if self._gitignore_spec:\n            return self._gitignore_spec.match_file(relative_path)\n        return False", "tokens": ["def", "should", "ignore", "self", "relative", "path", "str", "bool", "check", "if", "path", "should", "be", "ignored", "def", "should", "ignore", "self", "relative", "path", "str", "bool", "check", "if", "path", "should", "be", "ignored", "if", "self", "gitignore", "spec", "is", "none", "self", "gitignore", "spec", "self", "load", "gitignore", "if", "self", "gitignore", "spec", "return", "self", "gitignore", "spec", "match", "file", "relative", "path", "return", "false"], "metadata": {"kind": "method", "has_docstring": "true", "last_modified": "1766231204.5712247"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/scanner.py::Scanner.scan::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/scanner.py::Scanner.scan", "content": "def scan(self) -> Iterator[FileInfo]\n\"\"\"Scan directory and yield file information.\n\nYields:\n    FileInfo for each discovered source file.\"\"\"\n    def scan(self) -> Iterator[FileInfo]:\n        \"\"\"Scan directory and yield file information.\n\n        Yields:\n            FileInfo for each discovered source file.\n        \"\"\"\n        if not self.root_dir.exists():\n            raise FileNotFoundError(f\"Directory not found: {self.root_dir}\")\n\n        if not self.root_dir.is_dir():\n            raise NotADirectoryError(f\"Not a directory: {self.root_dir}\")\n\n        for root, dirs, files in os.walk(self.root_dir):\n            root_path = Path(root)\n\n            # Filter directories in-place to skip ignored ones\n            dirs[:] = [\n                d for d in dirs\n                if not self._should_ignore(\n                    str((root_path / d).relative_to(self.root_dir)) + \"/\"\n                )\n            ]\n\n            for filename in files:\n                file_path = root_path / filename\n  ", "tokens": ["def", "scan", "self", "iterator", "file", "info", "scan", "directory", "and", "yield", "file", "information", "yields", "file", "info", "for", "each", "discovered", "source", "file", "def", "scan", "self", "iterator", "file", "info", "scan", "directory", "and", "yield", "file", "information", "yields", "file", "info", "for", "each", "discovered", "source", "file", "if", "not", "self", "root", "dir", "exists", "raise", "file", "not", "found", "error", "directory", "not", "found", "self", "root", "dir", "if", "not", "self", "root", "dir", "is", "dir", "raise", "not", "adirectory", "error", "not", "directory", "self", "root", "dir", "for", "root", "dirs", "files", "in", "os", "walk", "self", "root", "dir", "root", "path", "path", "root", "filter", "directories", "in", "place", "to", "skip", "ignored", "ones", "dirs", "for", "in", "dirs", "if", "not", "self", "should", "ignore", "str", "root", "path", "relative", "to", "self", "root", "dir", "for", "filename", "in", "files", "file", "path", "root", "path", "filename"], "metadata": {"kind": "method", "chunk_index": "0", "has_docstring": "true", "last_modified": "1766231204.5712247"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/scanner.py::Scanner.scan::1", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/scanner.py::Scanner.scan", "content": "           ]\n\n            for filename in files:\n                file_path = root_path / filename\n                relative_path = str(file_path.relative_to(self.root_dir))\n\n                # Check if ignored\n                # We check relative_path to ensure ignore patterns match correctly \n                # against the project root (e.g., \"src/\" vs \"/abs/path/to/src/\")\n                if self._should_ignore(relative_path):\n                    continue\n\n                # Check extension\n                extension = file_path.suffix.lower()\n                if extension not in self.SUPPORTED_EXTENSIONS:\n                    continue\n\n                try:\n                    size_bytes = file_path.stat().st_size\n                except OSError:\n                    continue\n\n                yield FileInfo(\n                    path=file_path,\n                    relative_path=relative_path,\n                    extension=extension,\n                    size_bytes=size_bytes,\n                )", "tokens": ["for", "filename", "in", "files", "file", "path", "root", "path", "filename", "relative", "path", "str", "file", "path", "relative", "to", "self", "root", "dir", "check", "if", "ignored", "we", "check", "relative", "path", "to", "ensure", "ignore", "patterns", "match", "correctly", "against", "the", "project", "root", "src", "vs", "abs", "path", "to", "src", "if", "self", "should", "ignore", "relative", "path", "continue", "check", "extension", "extension", "file", "path", "suffix", "lower", "if", "extension", "not", "in", "self", "supported", "extensions", "continue", "try", "size", "bytes", "file", "path", "stat", "st", "size", "except", "oserror", "continue", "yield", "file", "info", "path", "file", "path", "relative", "path", "relative", "path", "extension", "extension", "size", "bytes", "size", "bytes"], "metadata": {"kind": "method", "chunk_index": "1", "has_docstring": "true", "last_modified": "1766231204.5712247"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/scanner.py::Scanner.scan_all::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/scanner.py::Scanner.scan_all", "content": "def scan_all(self) -> list[FileInfo]\n\"\"\"Scan and return all files as a list.\"\"\"\n    def scan_all(self) -> list[FileInfo]:\n        \"\"\"Scan and return all files as a list.\"\"\"\n        return list(self.scan())", "tokens": ["def", "scan", "all", "self", "list", "file", "info", "scan", "and", "return", "all", "files", "as", "list", "def", "scan", "all", "self", "list", "file", "info", "scan", "and", "return", "all", "files", "as", "list", "return", "list", "self", "scan"], "metadata": {"kind": "method", "has_docstring": "true", "last_modified": "1766231204.5712247"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/background_indexer.py::module::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/background_indexer.py::module", "content": "\"\"\"Background indexing service.\"\"\"", "tokens": ["background", "indexing", "service"], "metadata": {"type": "module_header"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/background_indexer.py::imports::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/background_indexer.py::module", "content": "import queue\nimport threading\nfrom pathlib import Path\nfrom typing import Optional\nfrom knowcode.indexing.indexer import Indexer\n                import logging", "tokens": ["import", "queue", "import", "threading", "from", "pathlib", "import", "path", "from", "typing", "import", "optional", "from", "knowcode", "indexing", "indexer", "import", "indexer", "import", "logging"], "metadata": {"type": "imports"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/background_indexer.py::BackgroundIndexer::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/background_indexer.py::BackgroundIndexer", "content": "\"\"\"Runs indexing in background thread.\"\"\"\nclass BackgroundIndexer:\n    \"\"\"Runs indexing in background thread.\"\"\"\n\n    def __init__(self, indexer: Indexer) -> None:\n        \"\"\"Initialize the background worker with an Indexer instance.\n\n        Args:\n            indexer: Indexer used to process queued files.\n        \"\"\"\n        self.indexer = indexer\n        self._queue: queue.Queue = queue.Queue()\n        self._thread: Optional[threading.Thread] = None\n        self._running = False\n\n    def start(self) -> None:\n        \"\"\"Start background indexing thread.\"\"\"\n        self._running = True\n        self._thread = threading.Thread(target=self._worker, daemon=True)\n        self._thread.start()\n\n    def stop(self) -> None:\n        \"\"\"Stop background indexing.\"\"\"\n        self._running = False\n        self._queue.put(None)  # Sentinel to unblock\n        if self._thread:\n            self._thread.join(timeout=5.0)\n\n    def queue_file(self, path: Path) -> None:\n        \"\"\"Queue a file for indexing.", "tokens": ["runs", "indexing", "in", "background", "thread", "class", "background", "indexer", "runs", "indexing", "in", "background", "thread", "def", "init", "self", "indexer", "indexer", "none", "initialize", "the", "background", "worker", "with", "an", "indexer", "instance", "args", "indexer", "indexer", "used", "to", "process", "queued", "files", "self", "indexer", "indexer", "self", "queue", "queue", "queue", "queue", "queue", "self", "thread", "optional", "threading", "thread", "none", "self", "running", "false", "def", "start", "self", "none", "start", "background", "indexing", "thread", "self", "running", "true", "self", "thread", "threading", "thread", "target", "self", "worker", "daemon", "true", "self", "thread", "start", "def", "stop", "self", "none", "stop", "background", "indexing", "self", "running", "false", "self", "queue", "put", "none", "sentinel", "to", "unblock", "if", "self", "thread", "self", "thread", "join", "timeout", "def", "queue", "file", "self", "path", "path", "none", "queue", "file", "for", "indexing"], "metadata": {"kind": "class", "chunk_index": "0", "has_docstring": "true", "last_modified": "1766231204.5707831"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/background_indexer.py::BackgroundIndexer::1", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/background_indexer.py::BackgroundIndexer", "content": "in(timeout=5.0)\n\n    def queue_file(self, path: Path) -> None:\n        \"\"\"Queue a file for indexing.\n\n        Args:\n            path: File path to enqueue for processing.\n        \"\"\"\n        self._queue.put(path)\n\n    def _worker(self) -> None:\n        \"\"\"Worker thread that processes the indexing queue.\"\"\"\n        while self._running:\n            try:\n                # Use timeout to allow checking self._running\n                path = self._queue.get(timeout=1.0)\n                if path is None:\n                    self._queue.task_done()\n                    break\n                self.indexer.index_file(path)\n                self._queue.task_done()\n            except queue.Empty:\n                continue\n            except Exception as e:\n                # Log error but continue\n                # In production, use high-fidelity logging\n                import logging\n                logging.error(f\"Background indexer error: {e}\")\n                self._queue.task_done()", "tokens": ["in", "timeout", "def", "queue", "file", "self", "path", "path", "none", "queue", "file", "for", "indexing", "args", "path", "file", "path", "to", "enqueue", "for", "processing", "self", "queue", "put", "path", "def", "worker", "self", "none", "worker", "thread", "that", "processes", "the", "indexing", "queue", "while", "self", "running", "try", "use", "timeout", "to", "allow", "checking", "self", "running", "path", "self", "queue", "get", "timeout", "if", "path", "is", "none", "self", "queue", "task", "done", "break", "self", "indexer", "index", "file", "path", "self", "queue", "task", "done", "except", "queue", "empty", "continue", "except", "exception", "as", "log", "error", "but", "continue", "in", "production", "use", "high", "fidelity", "logging", "import", "logging", "logging", "error", "background", "indexer", "error", "self", "queue", "task", "done"], "metadata": {"kind": "class", "chunk_index": "1", "has_docstring": "true", "last_modified": "1766231204.5707831"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/background_indexer.py::BackgroundIndexer.__init__::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/background_indexer.py::BackgroundIndexer.__init__", "content": "def __init__(self, indexer: Indexer) -> None\n\"\"\"Initialize the background worker with an Indexer instance.\n\nArgs:\n    indexer: Indexer used to process queued files.\"\"\"\n    def __init__(self, indexer: Indexer) -> None:\n        \"\"\"Initialize the background worker with an Indexer instance.\n\n        Args:\n            indexer: Indexer used to process queued files.\n        \"\"\"\n        self.indexer = indexer\n        self._queue: queue.Queue = queue.Queue()\n        self._thread: Optional[threading.Thread] = None\n        self._running = False", "tokens": ["def", "init", "self", "indexer", "indexer", "none", "initialize", "the", "background", "worker", "with", "an", "indexer", "instance", "args", "indexer", "indexer", "used", "to", "process", "queued", "files", "def", "init", "self", "indexer", "indexer", "none", "initialize", "the", "background", "worker", "with", "an", "indexer", "instance", "args", "indexer", "indexer", "used", "to", "process", "queued", "files", "self", "indexer", "indexer", "self", "queue", "queue", "queue", "queue", "queue", "self", "thread", "optional", "threading", "thread", "none", "self", "running", "false"], "metadata": {"kind": "method", "has_docstring": "true", "last_modified": "1766231204.5707831"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/background_indexer.py::BackgroundIndexer.start::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/background_indexer.py::BackgroundIndexer.start", "content": "def start(self) -> None\n\"\"\"Start background indexing thread.\"\"\"\n    def start(self) -> None:\n        \"\"\"Start background indexing thread.\"\"\"\n        self._running = True\n        self._thread = threading.Thread(target=self._worker, daemon=True)\n        self._thread.start()", "tokens": ["def", "start", "self", "none", "start", "background", "indexing", "thread", "def", "start", "self", "none", "start", "background", "indexing", "thread", "self", "running", "true", "self", "thread", "threading", "thread", "target", "self", "worker", "daemon", "true", "self", "thread", "start"], "metadata": {"kind": "method", "has_docstring": "true", "last_modified": "1766231204.5707831"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/background_indexer.py::BackgroundIndexer.stop::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/background_indexer.py::BackgroundIndexer.stop", "content": "def stop(self) -> None\n\"\"\"Stop background indexing.\"\"\"\n    def stop(self) -> None:\n        \"\"\"Stop background indexing.\"\"\"\n        self._running = False\n        self._queue.put(None)  # Sentinel to unblock\n        if self._thread:\n            self._thread.join(timeout=5.0)", "tokens": ["def", "stop", "self", "none", "stop", "background", "indexing", "def", "stop", "self", "none", "stop", "background", "indexing", "self", "running", "false", "self", "queue", "put", "none", "sentinel", "to", "unblock", "if", "self", "thread", "self", "thread", "join", "timeout"], "metadata": {"kind": "method", "has_docstring": "true", "last_modified": "1766231204.5707831"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/background_indexer.py::BackgroundIndexer.queue_file::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/background_indexer.py::BackgroundIndexer.queue_file", "content": "def queue_file(self, path: Path) -> None\n\"\"\"Queue a file for indexing.\n\nArgs:\n    path: File path to enqueue for processing.\"\"\"\n    def queue_file(self, path: Path) -> None:\n        \"\"\"Queue a file for indexing.\n\n        Args:\n            path: File path to enqueue for processing.\n        \"\"\"\n        self._queue.put(path)", "tokens": ["def", "queue", "file", "self", "path", "path", "none", "queue", "file", "for", "indexing", "args", "path", "file", "path", "to", "enqueue", "for", "processing", "def", "queue", "file", "self", "path", "path", "none", "queue", "file", "for", "indexing", "args", "path", "file", "path", "to", "enqueue", "for", "processing", "self", "queue", "put", "path"], "metadata": {"kind": "method", "has_docstring": "true", "last_modified": "1766231204.5707831"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/background_indexer.py::BackgroundIndexer._worker::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/background_indexer.py::BackgroundIndexer._worker", "content": "def _worker(self) -> None\n\"\"\"Worker thread that processes the indexing queue.\"\"\"\n    def _worker(self) -> None:\n        \"\"\"Worker thread that processes the indexing queue.\"\"\"\n        while self._running:\n            try:\n                # Use timeout to allow checking self._running\n                path = self._queue.get(timeout=1.0)\n                if path is None:\n                    self._queue.task_done()\n                    break\n                self.indexer.index_file(path)\n                self._queue.task_done()\n            except queue.Empty:\n                continue\n            except Exception as e:\n                # Log error but continue\n                # In production, use high-fidelity logging\n                import logging\n                logging.error(f\"Background indexer error: {e}\")\n                self._queue.task_done()", "tokens": ["def", "worker", "self", "none", "worker", "thread", "that", "processes", "the", "indexing", "queue", "def", "worker", "self", "none", "worker", "thread", "that", "processes", "the", "indexing", "queue", "while", "self", "running", "try", "use", "timeout", "to", "allow", "checking", "self", "running", "path", "self", "queue", "get", "timeout", "if", "path", "is", "none", "self", "queue", "task", "done", "break", "self", "indexer", "index", "file", "path", "self", "queue", "task", "done", "except", "queue", "empty", "continue", "except", "exception", "as", "log", "error", "but", "continue", "in", "production", "use", "high", "fidelity", "logging", "import", "logging", "logging", "error", "background", "indexer", "error", "self", "queue", "task", "done"], "metadata": {"kind": "method", "has_docstring": "true", "last_modified": "1766231204.5707831"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/indexer.py::module::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/indexer.py::module", "content": "\"\"\"Indexing pipeline for code chunks.\"\"\"", "tokens": ["indexing", "pipeline", "for", "code", "chunks"], "metadata": {"type": "module_header"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/indexer.py::imports::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/indexer.py::module", "content": "from __future__ import annotations\nfrom pathlib import Path\nfrom typing import Optional, Any\nfrom knowcode.storage.chunk_repository import InMemoryChunkRepository\nfrom knowcode.indexing.chunker import Chunker\nfrom knowcode.llm.embedding import EmbeddingProvider\nfrom knowcode.indexing.graph_builder import GraphBuilder\nfrom knowcode.indexing.scanner import Scanner\nfrom knowcode.storage.vector_store import VectorStore\nfrom knowcode.utils.logger import get_logger\n        import json\n        from dataclasses import asdict\n        import time\n        import json\n        from knowcode.models import CodeChunk\n        from knowcode.indexing.scanner import FileInfo", "tokens": ["from", "future", "import", "annotations", "from", "pathlib", "import", "path", "from", "typing", "import", "optional", "any", "from", "knowcode", "storage", "chunk", "repository", "import", "in", "memory", "chunk", "repository", "from", "knowcode", "indexing", "chunker", "import", "chunker", "from", "knowcode", "llm", "embedding", "import", "embedding", "provider", "from", "knowcode", "indexing", "graph", "builder", "import", "graph", "builder", "from", "knowcode", "indexing", "scanner", "import", "scanner", "from", "knowcode", "storage", "vector", "store", "import", "vector", "store", "from", "knowcode", "utils", "logger", "import", "get", "logger", "import", "json", "from", "dataclasses", "import", "asdict", "import", "time", "import", "json", "from", "knowcode", "models", "import", "code", "chunk", "from", "knowcode", "indexing", "scanner", "import", "file", "info"], "metadata": {"type": "imports"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/indexer.py::Indexer::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/indexer.py::Indexer", "content": "\"\"\"Orchestrates scan -> chunk -> embed -> index pipeline.\"\"\"\nclass Indexer:\n    \"\"\"Orchestrates scan -> chunk -> embed -> index pipeline.\"\"\"\n\n    def __init__(\n        self,\n        embedding_provider: EmbeddingProvider,\n        chunk_repo: Optional[InMemoryChunkRepository] = None,\n        vector_store: Optional[VectorStore] = None,\n    ) -> None:\n        \"\"\"Initialize an indexer with optional storage backends.\n\n        Args:\n            embedding_provider: Provider used to generate chunk embeddings.\n            chunk_repo: Optional chunk repository (defaults to in-memory).\n            vector_store: Optional vector store (defaults to FAISS-backed store).\n        \"\"\"\n        self.embedding_provider = embedding_provider\n        self.chunk_repo = chunk_repo or InMemoryChunkRepository()\n        self.vector_store = vector_store or VectorStore(dimension=embedding_provider.config.dimension)\n        self.chunker = Chunker()\n        self.manifest: dict[str, Any] = {}\n\n    def index_directory(se", "tokens": ["orchestrates", "scan", "chunk", "embed", "index", "pipeline", "class", "indexer", "orchestrates", "scan", "chunk", "embed", "index", "pipeline", "def", "init", "self", "embedding", "provider", "embedding", "provider", "chunk", "repo", "optional", "in", "memory", "chunk", "repository", "none", "vector", "store", "optional", "vector", "store", "none", "none", "initialize", "an", "indexer", "with", "optional", "storage", "backends", "args", "embedding", "provider", "provider", "used", "to", "generate", "chunk", "embeddings", "chunk", "repo", "optional", "chunk", "repository", "defaults", "to", "in", "memory", "vector", "store", "optional", "vector", "store", "defaults", "to", "faiss", "backed", "store", "self", "embedding", "provider", "embedding", "provider", "self", "chunk", "repo", "chunk", "repo", "or", "in", "memory", "chunk", "repository", "self", "vector", "store", "vector", "store", "or", "vector", "store", "dimension", "embedding", "provider", "config", "dimension", "self", "chunker", "chunker", "self", "manifest", "dict", "str", "any", "def", "index", "directory", "se"], "metadata": {"kind": "class", "chunk_index": "0", "has_docstring": "true", "last_modified": "1768185812.9930828"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/indexer.py::Indexer::1", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/indexer.py::Indexer", "content": "     self.chunker = Chunker()\n        self.manifest: dict[str, Any] = {}\n\n    def index_directory(self, root_dir: str | Path) -> int:\n        \"\"\"Index all supported files under a directory.\n\n        Args:\n            root_dir: Root directory to scan for supported files.\n\n        Returns:\n            Total number of chunks added to the index.\n        \"\"\"\n        root_path = Path(root_dir)\n        \n        # Use existing GraphBuilder to get semantic entities\n        builder = GraphBuilder()\n        builder.build_from_directory(root_path)\n        \n        # Extract files from scanner\n        scanner = Scanner(root_path)\n        files = scanner.scan_all()\n        \n        total_chunks = 0\n        for file_info in files:\n            # Build ParseResult-like data or use parser directly\n            # For simplicity in this Task, we use the Chunker which can take a ParseResult or we can adapt it.\n            # I'll use the graph builder's internal logic or build the parse results first.\n      ", "tokens": ["self", "chunker", "chunker", "self", "manifest", "dict", "str", "any", "def", "index", "directory", "self", "root", "dir", "str", "path", "int", "index", "all", "supported", "files", "under", "directory", "args", "root", "dir", "root", "directory", "to", "scan", "for", "supported", "files", "returns", "total", "number", "of", "chunks", "added", "to", "the", "index", "root", "path", "path", "root", "dir", "use", "existing", "graph", "builder", "to", "get", "semantic", "entities", "builder", "graph", "builder", "builder", "build", "from", "directory", "root", "path", "extract", "files", "from", "scanner", "scanner", "scanner", "root", "path", "files", "scanner", "scan", "all", "total", "chunks", "for", "file", "info", "in", "files", "build", "parse", "result", "like", "data", "or", "use", "parser", "directly", "for", "simplicity", "in", "this", "task", "we", "use", "the", "chunker", "which", "can", "take", "parse", "result", "or", "we", "can", "adapt", "it", "ll", "use", "the", "graph", "builder", "internal", "logic", "or", "build", "the", "parse", "results", "first"], "metadata": {"kind": "class", "chunk_index": "1", "has_docstring": "true", "last_modified": "1768185812.9930828"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/indexer.py::Indexer::2", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/indexer.py::Indexer", "content": ".\n            # I'll use the graph builder's internal logic or build the parse results first.\n            \n            # Re-parse file to get entities (ideally we reuse builder.entities but we need them per file)\n            # For now, let's assume we use the PythonParser etc via a helper\n            parse_result = builder._parse_file(file_info)\n            chunks = self.chunker.process_parse_result(parse_result)\n            \n            if not chunks:\n                continue\n                \n            # Process embeddings in batches\n            contents = [c.content for c in chunks]\n            embeddings = self.embedding_provider.embed(contents)\n            \n            for chunk, emb in zip(chunks, embeddings):\n                chunk.embedding = emb\n                self.chunk_repo.add(chunk)\n                self.vector_store.add(chunk.id, emb)\n                total_chunks += 1\n                \n        return total_chunks\n\n    def save(self, path: str | Path) -> None:\n        \"\"\"Pe", "tokens": ["ll", "use", "the", "graph", "builder", "internal", "logic", "or", "build", "the", "parse", "results", "first", "re", "parse", "file", "to", "get", "entities", "ideally", "we", "reuse", "builder", "entities", "but", "we", "need", "them", "per", "file", "for", "now", "let", "assume", "we", "use", "the", "python", "parser", "etc", "via", "helper", "parse", "result", "builder", "parse", "file", "file", "info", "chunks", "self", "chunker", "process", "parse", "result", "parse", "result", "if", "not", "chunks", "continue", "process", "embeddings", "in", "batches", "contents", "content", "for", "in", "chunks", "embeddings", "self", "embedding", "provider", "embed", "contents", "for", "chunk", "emb", "in", "zip", "chunks", "embeddings", "chunk", "embedding", "emb", "self", "chunk", "repo", "add", "chunk", "self", "vector", "store", "add", "chunk", "id", "emb", "total", "chunks", "return", "total", "chunks", "def", "save", "self", "path", "str", "path", "none", "pe"], "metadata": {"kind": "class", "chunk_index": "2", "has_docstring": "true", "last_modified": "1768185812.9930828"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/indexer.py::Indexer::3", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/indexer.py::Indexer", "content": "           \n        return total_chunks\n\n    def save(self, path: str | Path) -> None:\n        \"\"\"Persist vector index and chunk metadata to disk.\n\n        Args:\n            path: Directory path to write index files into.\n        \"\"\"\n        path = Path(path)\n        path.mkdir(parents=True, exist_ok=True)\n        \n        # Save vector store\n        self.vector_store.save(path / \"vectors\")\n        \n        # Save chunk metadata (BM25 tokens and content)\n        import json\n        metadata = {\n            \"chunks\": [\n                {\n                    \"id\": c.id,\n                    \"entity_id\": c.entity_id,\n                    \"content\": c.content,\n                    \"tokens\": c.tokens,\n                    \"metadata\": c.metadata\n                }\n                for c in self.chunk_repo._chunks.values()\n            ]\n        }\n        with open(path / \"chunks.json\", \"w\") as f:\n            json.dump(metadata, f)\n\n        # Save index manifest for compatibility checks at query time", "tokens": ["return", "total", "chunks", "def", "save", "self", "path", "str", "path", "none", "persist", "vector", "index", "and", "chunk", "metadata", "to", "disk", "args", "path", "directory", "path", "to", "write", "index", "files", "into", "path", "path", "path", "path", "mkdir", "parents", "true", "exist", "ok", "true", "save", "vector", "store", "self", "vector", "store", "save", "path", "vectors", "save", "chunk", "metadata", "bm25", "tokens", "and", "content", "import", "json", "metadata", "chunks", "id", "id", "entity", "id", "entity", "id", "content", "content", "tokens", "tokens", "metadata", "metadata", "for", "in", "self", "chunk", "repo", "chunks", "values", "with", "open", "path", "chunks", "json", "as", "json", "dump", "metadata", "save", "index", "manifest", "for", "compatibility", "checks", "at", "query", "time"], "metadata": {"kind": "class", "chunk_index": "3", "has_docstring": "true", "last_modified": "1768185812.9930828"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/indexer.py::Indexer::4", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/indexer.py::Indexer", "content": "        json.dump(metadata, f)\n\n        # Save index manifest for compatibility checks at query time.\n        from dataclasses import asdict\n        import time\n\n        self.manifest = {\n            \"version\": 1,\n            \"created_at\": int(time.time()),\n            \"embedding\": asdict(self.embedding_provider.config),\n            \"chunking\": asdict(self.chunker.config),\n        }\n        with open(path / \"index_manifest.json\", \"w\", encoding=\"utf-8\") as f:\n            json.dump(self.manifest, f, indent=2)\n\n    def load(self, path: str | Path) -> None:\n        \"\"\"Load the entire vector index and chunk metadata from disk.\n\n        Args:\n            path: Directory path containing previously saved index files.\n        \"\"\"\n        path = Path(path)\n        \n        # Load vector store\n        self.vector_store.load(path / \"vectors\")\n        \n        # Load manifest (optional, for compatibility checks).\n        import json\n        manifest_file = path / \"index_manifest.json\"\n        if ma", "tokens": ["json", "dump", "metadata", "save", "index", "manifest", "for", "compatibility", "checks", "at", "query", "time", "from", "dataclasses", "import", "asdict", "import", "time", "self", "manifest", "version", "created", "at", "int", "time", "time", "embedding", "asdict", "self", "embedding", "provider", "config", "chunking", "asdict", "self", "chunker", "config", "with", "open", "path", "index", "manifest", "json", "encoding", "utf", "as", "json", "dump", "self", "manifest", "indent", "def", "load", "self", "path", "str", "path", "none", "load", "the", "entire", "vector", "index", "and", "chunk", "metadata", "from", "disk", "args", "path", "directory", "path", "containing", "previously", "saved", "index", "files", "path", "path", "path", "load", "vector", "store", "self", "vector", "store", "load", "path", "vectors", "load", "manifest", "optional", "for", "compatibility", "checks", "import", "json", "manifest", "file", "path", "index", "manifest", "json", "if", "ma"], "metadata": {"kind": "class", "chunk_index": "4", "has_docstring": "true", "last_modified": "1768185812.9930828"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/indexer.py::Indexer::5", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/indexer.py::Indexer", "content": "lity checks).\n        import json\n        manifest_file = path / \"index_manifest.json\"\n        if manifest_file.exists():\n            with open(manifest_file, \"r\", encoding=\"utf-8\") as f:\n                self.manifest = json.load(f)\n\n        # Load chunks\n        from knowcode.models import CodeChunk\n        \n        chunks_file = path / \"chunks.json\"\n        if chunks_file.exists():\n            with open(chunks_file) as f:\n                data = json.load(f)\n                for c_data in data[\"chunks\"]:\n                    chunk = CodeChunk(**c_data)\n                    self.chunk_repo.add(chunk)\n                    \n    def index_file(self, file_path: str | Path) -> int:\n        \"\"\"Index a single file for incremental updates.\n\n        Args:\n            file_path: File path to process.\n\n        Returns:\n            Number of chunks created for the file.\n        \"\"\"\n        file_path = Path(file_path)\n        # Simplified for Task 3.6\n        builder = GraphBuilder()\n        from knowc", "tokens": ["lity", "checks", "import", "json", "manifest", "file", "path", "index", "manifest", "json", "if", "manifest", "file", "exists", "with", "open", "manifest", "file", "encoding", "utf", "as", "self", "manifest", "json", "load", "load", "chunks", "from", "knowcode", "models", "import", "code", "chunk", "chunks", "file", "path", "chunks", "json", "if", "chunks", "file", "exists", "with", "open", "chunks", "file", "as", "data", "json", "load", "for", "data", "in", "data", "chunks", "chunk", "code", "chunk", "data", "self", "chunk", "repo", "add", "chunk", "def", "index", "file", "self", "file", "path", "str", "path", "int", "index", "single", "file", "for", "incremental", "updates", "args", "file", "path", "file", "path", "to", "process", "returns", "number", "of", "chunks", "created", "for", "the", "file", "file", "path", "path", "file", "path", "simplified", "for", "task", "builder", "graph", "builder", "from", "knowc"], "metadata": {"kind": "class", "chunk_index": "5", "has_docstring": "true", "last_modified": "1768185812.9930828"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/indexer.py::Indexer::6", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/indexer.py::Indexer", "content": "ath(file_path)\n        # Simplified for Task 3.6\n        builder = GraphBuilder()\n        from knowcode.indexing.scanner import FileInfo\n        file_info = FileInfo(file_path, str(file_path), file_path.suffix, file_path.stat().st_size)\n        parse_result = builder._parse_file(file_info)\n        chunks = self.chunker.process_parse_result(parse_result)\n        \n        if chunks:\n            contents = [c.content for c in chunks]\n            embeddings = self.embedding_provider.embed(contents)\n            for chunk, emb in zip(chunks, embeddings):\n                chunk.embedding = emb\n                self.chunk_repo.add(chunk)\n                self.vector_store.add(chunk.id, emb)\n        return len(chunks)", "tokens": ["ath", "file", "path", "simplified", "for", "task", "builder", "graph", "builder", "from", "knowcode", "indexing", "scanner", "import", "file", "info", "file", "info", "file", "info", "file", "path", "str", "file", "path", "file", "path", "suffix", "file", "path", "stat", "st", "size", "parse", "result", "builder", "parse", "file", "file", "info", "chunks", "self", "chunker", "process", "parse", "result", "parse", "result", "if", "chunks", "contents", "content", "for", "in", "chunks", "embeddings", "self", "embedding", "provider", "embed", "contents", "for", "chunk", "emb", "in", "zip", "chunks", "embeddings", "chunk", "embedding", "emb", "self", "chunk", "repo", "add", "chunk", "self", "vector", "store", "add", "chunk", "id", "emb", "return", "len", "chunks"], "metadata": {"kind": "class", "chunk_index": "6", "has_docstring": "true", "last_modified": "1768185812.9930828"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/indexer.py::Indexer.__init__::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/indexer.py::Indexer.__init__", "content": "def __init__(self, embedding_provider: EmbeddingProvider, chunk_repo: Optional[InMemoryChunkRepository], vector_store: Optional[VectorStore]) -> None\n\"\"\"Initialize an indexer with optional storage backends.\n\nArgs:\n    embedding_provider: Provider used to generate chunk embeddings.\n    chunk_repo: Optional chunk repository (defaults to in-memory).\n    vector_store: Optional vector store (defaults to FAISS-backed store).\"\"\"\n    def __init__(\n        self,\n        embedding_provider: EmbeddingProvider,\n        chunk_repo: Optional[InMemoryChunkRepository] = None,\n        vector_store: Optional[VectorStore] = None,\n    ) -> None:\n        \"\"\"Initialize an indexer with optional storage backends.\n\n        Args:\n            embedding_provider: Provider used to generate chunk embeddings.\n            chunk_repo: Optional chunk repository (defaults to in-memory).\n            vector_store: Optional vector store (defaults to FAISS-backed store).\n        \"\"\"\n        self.embedding_provider = embeddi", "tokens": ["def", "init", "self", "embedding", "provider", "embedding", "provider", "chunk", "repo", "optional", "in", "memory", "chunk", "repository", "vector", "store", "optional", "vector", "store", "none", "initialize", "an", "indexer", "with", "optional", "storage", "backends", "args", "embedding", "provider", "provider", "used", "to", "generate", "chunk", "embeddings", "chunk", "repo", "optional", "chunk", "repository", "defaults", "to", "in", "memory", "vector", "store", "optional", "vector", "store", "defaults", "to", "faiss", "backed", "store", "def", "init", "self", "embedding", "provider", "embedding", "provider", "chunk", "repo", "optional", "in", "memory", "chunk", "repository", "none", "vector", "store", "optional", "vector", "store", "none", "none", "initialize", "an", "indexer", "with", "optional", "storage", "backends", "args", "embedding", "provider", "provider", "used", "to", "generate", "chunk", "embeddings", "chunk", "repo", "optional", "chunk", "repository", "defaults", "to", "in", "memory", "vector", "store", "optional", "vector", "store", "defaults", "to", "faiss", "backed", "store", "self", "embedding", "provider", "embeddi"], "metadata": {"kind": "method", "chunk_index": "0", "has_docstring": "true", "last_modified": "1768185812.9930828"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/indexer.py::Indexer.__init__::1", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/indexer.py::Indexer.__init__", "content": "vector store (defaults to FAISS-backed store).\n        \"\"\"\n        self.embedding_provider = embedding_provider\n        self.chunk_repo = chunk_repo or InMemoryChunkRepository()\n        self.vector_store = vector_store or VectorStore(dimension=embedding_provider.config.dimension)\n        self.chunker = Chunker()\n        self.manifest: dict[str, Any] = {}", "tokens": ["vector", "store", "defaults", "to", "faiss", "backed", "store", "self", "embedding", "provider", "embedding", "provider", "self", "chunk", "repo", "chunk", "repo", "or", "in", "memory", "chunk", "repository", "self", "vector", "store", "vector", "store", "or", "vector", "store", "dimension", "embedding", "provider", "config", "dimension", "self", "chunker", "chunker", "self", "manifest", "dict", "str", "any"], "metadata": {"kind": "method", "chunk_index": "1", "has_docstring": "true", "last_modified": "1768185812.9930828"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/indexer.py::Indexer.index_directory::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/indexer.py::Indexer.index_directory", "content": "def index_directory(self, root_dir: str | Path) -> int\n\"\"\"Index all supported files under a directory.\n\nArgs:\n    root_dir: Root directory to scan for supported files.\n\nReturns:\n    Total number of chunks added to the index.\"\"\"\n    def index_directory(self, root_dir: str | Path) -> int:\n        \"\"\"Index all supported files under a directory.\n\n        Args:\n            root_dir: Root directory to scan for supported files.\n\n        Returns:\n            Total number of chunks added to the index.\n        \"\"\"\n        root_path = Path(root_dir)\n        \n        # Use existing GraphBuilder to get semantic entities\n        builder = GraphBuilder()\n        builder.build_from_directory(root_path)\n        \n        # Extract files from scanner\n        scanner = Scanner(root_path)\n        files = scanner.scan_all()\n        \n        total_chunks = 0\n        for file_info in files:\n            # Build ParseResult-like data or use parser directly\n            # For simplicity in this Task, we use the C", "tokens": ["def", "index", "directory", "self", "root", "dir", "str", "path", "int", "index", "all", "supported", "files", "under", "directory", "args", "root", "dir", "root", "directory", "to", "scan", "for", "supported", "files", "returns", "total", "number", "of", "chunks", "added", "to", "the", "index", "def", "index", "directory", "self", "root", "dir", "str", "path", "int", "index", "all", "supported", "files", "under", "directory", "args", "root", "dir", "root", "directory", "to", "scan", "for", "supported", "files", "returns", "total", "number", "of", "chunks", "added", "to", "the", "index", "root", "path", "path", "root", "dir", "use", "existing", "graph", "builder", "to", "get", "semantic", "entities", "builder", "graph", "builder", "builder", "build", "from", "directory", "root", "path", "extract", "files", "from", "scanner", "scanner", "scanner", "root", "path", "files", "scanner", "scan", "all", "total", "chunks", "for", "file", "info", "in", "files", "build", "parse", "result", "like", "data", "or", "use", "parser", "directly", "for", "simplicity", "in", "this", "task", "we", "use", "the"], "metadata": {"kind": "method", "chunk_index": "0", "has_docstring": "true", "last_modified": "1768185812.9930828"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/indexer.py::Indexer.index_directory::1", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/indexer.py::Indexer.index_directory", "content": "ParseResult-like data or use parser directly\n            # For simplicity in this Task, we use the Chunker which can take a ParseResult or we can adapt it.\n            # I'll use the graph builder's internal logic or build the parse results first.\n            \n            # Re-parse file to get entities (ideally we reuse builder.entities but we need them per file)\n            # For now, let's assume we use the PythonParser etc via a helper\n            parse_result = builder._parse_file(file_info)\n            chunks = self.chunker.process_parse_result(parse_result)\n            \n            if not chunks:\n                continue\n                \n            # Process embeddings in batches\n            contents = [c.content for c in chunks]\n            embeddings = self.embedding_provider.embed(contents)\n            \n            for chunk, emb in zip(chunks, embeddings):\n                chunk.embedding = emb\n                self.chunk_repo.add(chunk)\n                self.vector_store.add(", "tokens": ["parse", "result", "like", "data", "or", "use", "parser", "directly", "for", "simplicity", "in", "this", "task", "we", "use", "the", "chunker", "which", "can", "take", "parse", "result", "or", "we", "can", "adapt", "it", "ll", "use", "the", "graph", "builder", "internal", "logic", "or", "build", "the", "parse", "results", "first", "re", "parse", "file", "to", "get", "entities", "ideally", "we", "reuse", "builder", "entities", "but", "we", "need", "them", "per", "file", "for", "now", "let", "assume", "we", "use", "the", "python", "parser", "etc", "via", "helper", "parse", "result", "builder", "parse", "file", "file", "info", "chunks", "self", "chunker", "process", "parse", "result", "parse", "result", "if", "not", "chunks", "continue", "process", "embeddings", "in", "batches", "contents", "content", "for", "in", "chunks", "embeddings", "self", "embedding", "provider", "embed", "contents", "for", "chunk", "emb", "in", "zip", "chunks", "embeddings", "chunk", "embedding", "emb", "self", "chunk", "repo", "add", "chunk", "self", "vector", "store", "add"], "metadata": {"kind": "method", "chunk_index": "1", "has_docstring": "true", "last_modified": "1768185812.9930828"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/indexer.py::Indexer.index_directory::2", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/indexer.py::Indexer.index_directory", "content": "nk.embedding = emb\n                self.chunk_repo.add(chunk)\n                self.vector_store.add(chunk.id, emb)\n                total_chunks += 1\n                \n        return total_chunks", "tokens": ["nk", "embedding", "emb", "self", "chunk", "repo", "add", "chunk", "self", "vector", "store", "add", "chunk", "id", "emb", "total", "chunks", "return", "total", "chunks"], "metadata": {"kind": "method", "chunk_index": "2", "has_docstring": "true", "last_modified": "1768185812.9930828"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/indexer.py::Indexer.save::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/indexer.py::Indexer.save", "content": "def save(self, path: str | Path) -> None\n\"\"\"Persist vector index and chunk metadata to disk.\n\nArgs:\n    path: Directory path to write index files into.\"\"\"\n    def save(self, path: str | Path) -> None:\n        \"\"\"Persist vector index and chunk metadata to disk.\n\n        Args:\n            path: Directory path to write index files into.\n        \"\"\"\n        path = Path(path)\n        path.mkdir(parents=True, exist_ok=True)\n        \n        # Save vector store\n        self.vector_store.save(path / \"vectors\")\n        \n        # Save chunk metadata (BM25 tokens and content)\n        import json\n        metadata = {\n            \"chunks\": [\n                {\n                    \"id\": c.id,\n                    \"entity_id\": c.entity_id,\n                    \"content\": c.content,\n                    \"tokens\": c.tokens,\n                    \"metadata\": c.metadata\n                }\n                for c in self.chunk_repo._chunks.values()\n            ]\n        }\n        with open(path / \"chunks.json\", \"", "tokens": ["def", "save", "self", "path", "str", "path", "none", "persist", "vector", "index", "and", "chunk", "metadata", "to", "disk", "args", "path", "directory", "path", "to", "write", "index", "files", "into", "def", "save", "self", "path", "str", "path", "none", "persist", "vector", "index", "and", "chunk", "metadata", "to", "disk", "args", "path", "directory", "path", "to", "write", "index", "files", "into", "path", "path", "path", "path", "mkdir", "parents", "true", "exist", "ok", "true", "save", "vector", "store", "self", "vector", "store", "save", "path", "vectors", "save", "chunk", "metadata", "bm25", "tokens", "and", "content", "import", "json", "metadata", "chunks", "id", "id", "entity", "id", "entity", "id", "content", "content", "tokens", "tokens", "metadata", "metadata", "for", "in", "self", "chunk", "repo", "chunks", "values", "with", "open", "path", "chunks", "json"], "metadata": {"kind": "method", "chunk_index": "0", "has_docstring": "true", "last_modified": "1768185812.9930828"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/indexer.py::Indexer.save::1", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/indexer.py::Indexer.save", "content": "n self.chunk_repo._chunks.values()\n            ]\n        }\n        with open(path / \"chunks.json\", \"w\") as f:\n            json.dump(metadata, f)\n\n        # Save index manifest for compatibility checks at query time.\n        from dataclasses import asdict\n        import time\n\n        self.manifest = {\n            \"version\": 1,\n            \"created_at\": int(time.time()),\n            \"embedding\": asdict(self.embedding_provider.config),\n            \"chunking\": asdict(self.chunker.config),\n        }\n        with open(path / \"index_manifest.json\", \"w\", encoding=\"utf-8\") as f:\n            json.dump(self.manifest, f, indent=2)", "tokens": ["self", "chunk", "repo", "chunks", "values", "with", "open", "path", "chunks", "json", "as", "json", "dump", "metadata", "save", "index", "manifest", "for", "compatibility", "checks", "at", "query", "time", "from", "dataclasses", "import", "asdict", "import", "time", "self", "manifest", "version", "created", "at", "int", "time", "time", "embedding", "asdict", "self", "embedding", "provider", "config", "chunking", "asdict", "self", "chunker", "config", "with", "open", "path", "index", "manifest", "json", "encoding", "utf", "as", "json", "dump", "self", "manifest", "indent"], "metadata": {"kind": "method", "chunk_index": "1", "has_docstring": "true", "last_modified": "1768185812.9930828"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/indexer.py::Indexer.load::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/indexer.py::Indexer.load", "content": "def load(self, path: str | Path) -> None\n\"\"\"Load the entire vector index and chunk metadata from disk.\n\nArgs:\n    path: Directory path containing previously saved index files.\"\"\"\n    def load(self, path: str | Path) -> None:\n        \"\"\"Load the entire vector index and chunk metadata from disk.\n\n        Args:\n            path: Directory path containing previously saved index files.\n        \"\"\"\n        path = Path(path)\n        \n        # Load vector store\n        self.vector_store.load(path / \"vectors\")\n        \n        # Load manifest (optional, for compatibility checks).\n        import json\n        manifest_file = path / \"index_manifest.json\"\n        if manifest_file.exists():\n            with open(manifest_file, \"r\", encoding=\"utf-8\") as f:\n                self.manifest = json.load(f)\n\n        # Load chunks\n        from knowcode.models import CodeChunk\n        \n        chunks_file = path / \"chunks.json\"\n        if chunks_file.exists():\n            with open(chunks_file) as f:\n       ", "tokens": ["def", "load", "self", "path", "str", "path", "none", "load", "the", "entire", "vector", "index", "and", "chunk", "metadata", "from", "disk", "args", "path", "directory", "path", "containing", "previously", "saved", "index", "files", "def", "load", "self", "path", "str", "path", "none", "load", "the", "entire", "vector", "index", "and", "chunk", "metadata", "from", "disk", "args", "path", "directory", "path", "containing", "previously", "saved", "index", "files", "path", "path", "path", "load", "vector", "store", "self", "vector", "store", "load", "path", "vectors", "load", "manifest", "optional", "for", "compatibility", "checks", "import", "json", "manifest", "file", "path", "index", "manifest", "json", "if", "manifest", "file", "exists", "with", "open", "manifest", "file", "encoding", "utf", "as", "self", "manifest", "json", "load", "load", "chunks", "from", "knowcode", "models", "import", "code", "chunk", "chunks", "file", "path", "chunks", "json", "if", "chunks", "file", "exists", "with", "open", "chunks", "file", "as"], "metadata": {"kind": "method", "chunk_index": "0", "has_docstring": "true", "last_modified": "1768185812.9930828"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/indexer.py::Indexer.load::1", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/indexer.py::Indexer.load", "content": "th / \"chunks.json\"\n        if chunks_file.exists():\n            with open(chunks_file) as f:\n                data = json.load(f)\n                for c_data in data[\"chunks\"]:\n                    chunk = CodeChunk(**c_data)\n                    self.chunk_repo.add(chunk)", "tokens": ["th", "chunks", "json", "if", "chunks", "file", "exists", "with", "open", "chunks", "file", "as", "data", "json", "load", "for", "data", "in", "data", "chunks", "chunk", "code", "chunk", "data", "self", "chunk", "repo", "add", "chunk"], "metadata": {"kind": "method", "chunk_index": "1", "has_docstring": "true", "last_modified": "1768185812.9930828"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/indexer.py::Indexer.index_file::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/indexer.py::Indexer.index_file", "content": "def index_file(self, file_path: str | Path) -> int\n\"\"\"Index a single file for incremental updates.\n\nArgs:\n    file_path: File path to process.\n\nReturns:\n    Number of chunks created for the file.\"\"\"\n    def index_file(self, file_path: str | Path) -> int:\n        \"\"\"Index a single file for incremental updates.\n\n        Args:\n            file_path: File path to process.\n\n        Returns:\n            Number of chunks created for the file.\n        \"\"\"\n        file_path = Path(file_path)\n        # Simplified for Task 3.6\n        builder = GraphBuilder()\n        from knowcode.indexing.scanner import FileInfo\n        file_info = FileInfo(file_path, str(file_path), file_path.suffix, file_path.stat().st_size)\n        parse_result = builder._parse_file(file_info)\n        chunks = self.chunker.process_parse_result(parse_result)\n        \n        if chunks:\n            contents = [c.content for c in chunks]\n            embeddings = self.embedding_provider.embed(contents)\n            for chunk, emb ", "tokens": ["def", "index", "file", "self", "file", "path", "str", "path", "int", "index", "single", "file", "for", "incremental", "updates", "args", "file", "path", "file", "path", "to", "process", "returns", "number", "of", "chunks", "created", "for", "the", "file", "def", "index", "file", "self", "file", "path", "str", "path", "int", "index", "single", "file", "for", "incremental", "updates", "args", "file", "path", "file", "path", "to", "process", "returns", "number", "of", "chunks", "created", "for", "the", "file", "file", "path", "path", "file", "path", "simplified", "for", "task", "builder", "graph", "builder", "from", "knowcode", "indexing", "scanner", "import", "file", "info", "file", "info", "file", "info", "file", "path", "str", "file", "path", "file", "path", "suffix", "file", "path", "stat", "st", "size", "parse", "result", "builder", "parse", "file", "file", "info", "chunks", "self", "chunker", "process", "parse", "result", "parse", "result", "if", "chunks", "contents", "content", "for", "in", "chunks", "embeddings", "self", "embedding", "provider", "embed", "contents", "for", "chunk", "emb"], "metadata": {"kind": "method", "chunk_index": "0", "has_docstring": "true", "last_modified": "1768185812.9930828"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/indexer.py::Indexer.index_file::1", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/indexer.py::Indexer.index_file", "content": "chunks]\n            embeddings = self.embedding_provider.embed(contents)\n            for chunk, emb in zip(chunks, embeddings):\n                chunk.embedding = emb\n                self.chunk_repo.add(chunk)\n                self.vector_store.add(chunk.id, emb)\n        return len(chunks)", "tokens": ["chunks", "embeddings", "self", "embedding", "provider", "embed", "contents", "for", "chunk", "emb", "in", "zip", "chunks", "embeddings", "chunk", "embedding", "emb", "self", "chunk", "repo", "add", "chunk", "self", "vector", "store", "add", "chunk", "id", "emb", "return", "len", "chunks"], "metadata": {"kind": "method", "chunk_index": "1", "has_docstring": "true", "last_modified": "1768185812.9930828"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/chunker.py::module::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/chunker.py::module", "content": "\"\"\"Code chunker for breaking down entities into searchable units.\"\"\"", "tokens": ["code", "chunker", "for", "breaking", "down", "entities", "into", "searchable", "units"], "metadata": {"type": "module_header"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/chunker.py::imports::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/chunker.py::module", "content": "from __future__ import annotations\nfrom pathlib import Path\nfrom typing import Optional\nfrom knowcode.data_models import ChunkingConfig, CodeChunk, ParseResult, Entity, EntityKind\nfrom knowcode.utils.tokenizer import tokenize_code\nfrom knowcode.utils.logger import get_logger", "tokens": ["from", "future", "import", "annotations", "from", "pathlib", "import", "path", "from", "typing", "import", "optional", "from", "knowcode", "data", "models", "import", "chunking", "config", "code", "chunk", "parse", "result", "entity", "entity", "kind", "from", "knowcode", "utils", "tokenizer", "import", "tokenize", "code", "from", "knowcode", "utils", "logger", "import", "get", "logger"], "metadata": {"type": "imports"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/chunker.py::Chunker::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/chunker.py::Chunker", "content": "\"\"\"Chunks code entities into smaller, searchable units.\"\"\"\nclass Chunker:\n    \"\"\"Chunks code entities into smaller, searchable units.\"\"\"\n\n    def __init__(self, config: Optional[ChunkingConfig] = None) -> None:\n        self.config = config or ChunkingConfig()\n        self.chunks: list[CodeChunk] = []\n\n    def process_parse_result(self, result: ParseResult) -> list[CodeChunk]:\n        \"\"\"Convert a ParseResult into a list of CodeChunk objects.\n\n        Args:\n            result: Parsed entities, relationships, and errors for a single file.\n\n        Returns:\n            List of generated CodeChunk objects in priority order.\n        \"\"\"\n        self.chunks = []  # Single initialization at start of process\n        \n        file_path = result.file_path\n        source_code = \"\"\n        \n        # Try to find module source code if available\n        module_entity = next((e for e in result.entities if e.kind == EntityKind.MODULE), None)\n        if module_entity and module_entity.source_code:\n    ", "tokens": ["chunks", "code", "entities", "into", "smaller", "searchable", "units", "class", "chunker", "chunks", "code", "entities", "into", "smaller", "searchable", "units", "def", "init", "self", "config", "optional", "chunking", "config", "none", "none", "self", "config", "config", "or", "chunking", "config", "self", "chunks", "list", "code", "chunk", "def", "process", "parse", "result", "self", "result", "parse", "result", "list", "code", "chunk", "convert", "parse", "result", "into", "list", "of", "code", "chunk", "objects", "args", "result", "parsed", "entities", "relationships", "and", "errors", "for", "single", "file", "returns", "list", "of", "generated", "code", "chunk", "objects", "in", "priority", "order", "self", "chunks", "single", "initialization", "at", "start", "of", "process", "file", "path", "result", "file", "path", "source", "code", "try", "to", "find", "module", "source", "code", "if", "available", "module", "entity", "next", "for", "in", "result", "entities", "if", "kind", "entity", "kind", "module", "none", "if", "module", "entity", "and", "module", "entity", "source", "code"], "metadata": {"kind": "class", "chunk_index": "0", "has_docstring": "true", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/chunker.py::Chunker::1", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/chunker.py::Chunker", "content": " if e.kind == EntityKind.MODULE), None)\n        if module_entity and module_entity.source_code:\n            source_code = module_entity.source_code\n        elif Path(file_path).exists():\n            source_code = Path(file_path).read_text(encoding=\"utf-8\")\n        \n        last_modified = None\n        if Path(file_path).exists():\n             last_modified = str(Path(file_path).stat().st_mtime)\n            \n        # 1. Module and Import Chunks\n        if source_code:\n            self._emit_module_chunks(file_path, source_code)\n            \n        # 2. Entity Chunks (Classes, Functions, Methods)\n        for entity in result.entities:\n            if entity.kind == EntityKind.MODULE:\n                continue\n            self._chunk_entity(entity, last_modified)\n            \n        return self.chunks\n\n    def _emit_module_chunks(self, file_path: str, source: str) -> None:\n        \"\"\"Extract module-level header and imports into dedicated chunks.\n\n        Args:\n            file_path: File", "tokens": ["if", "kind", "entity", "kind", "module", "none", "if", "module", "entity", "and", "module", "entity", "source", "code", "source", "code", "module", "entity", "source", "code", "elif", "path", "file", "path", "exists", "source", "code", "path", "file", "path", "read", "text", "encoding", "utf", "last", "modified", "none", "if", "path", "file", "path", "exists", "last", "modified", "str", "path", "file", "path", "stat", "st", "mtime", "module", "and", "import", "chunks", "if", "source", "code", "self", "emit", "module", "chunks", "file", "path", "source", "code", "entity", "chunks", "classes", "functions", "methods", "for", "entity", "in", "result", "entities", "if", "entity", "kind", "entity", "kind", "module", "continue", "self", "chunk", "entity", "entity", "last", "modified", "return", "self", "chunks", "def", "emit", "module", "chunks", "self", "file", "path", "str", "source", "str", "none", "extract", "module", "level", "header", "and", "imports", "into", "dedicated", "chunks", "args", "file", "path", "file"], "metadata": {"kind": "class", "chunk_index": "1", "has_docstring": "true", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/chunker.py::Chunker::2", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/chunker.py::Chunker", "content": "ct module-level header and imports into dedicated chunks.\n\n        Args:\n            file_path: File path used to namespace chunk IDs.\n            source: Full source code for the module.\n        \"\"\"\n        # Module Header\n        header = self._extract_module_header(source)\n        if header:\n            module_chunk = CodeChunk(\n                id=f\"{file_path}::module::0\",\n                entity_id=f\"{file_path}::module\",\n                content=header,\n                tokens=tokenize_code(header),\n                metadata={\"type\": \"module_header\"}\n            )\n            self.chunks.append(module_chunk)\n            \n        # Imports\n        imports = self._extract_imports(source)\n        if imports:\n            import_chunk = CodeChunk(\n                id=f\"{file_path}::imports::0\",\n                entity_id=f\"{file_path}::module\",\n                content=imports,\n                tokens=tokenize_code(imports),\n                metadata={\"type\": \"imports\"}\n            )\n         ", "tokens": ["ct", "module", "level", "header", "and", "imports", "into", "dedicated", "chunks", "args", "file", "path", "file", "path", "used", "to", "namespace", "chunk", "ids", "source", "full", "source", "code", "for", "the", "module", "module", "header", "header", "self", "extract", "module", "header", "source", "if", "header", "module", "chunk", "code", "chunk", "id", "file", "path", "module", "entity", "id", "file", "path", "module", "content", "header", "tokens", "tokenize", "code", "header", "metadata", "type", "module", "header", "self", "chunks", "append", "module", "chunk", "imports", "imports", "self", "extract", "imports", "source", "if", "imports", "import", "chunk", "code", "chunk", "id", "file", "path", "imports", "entity", "id", "file", "path", "module", "content", "imports", "tokens", "tokenize", "code", "imports", "metadata", "type", "imports"], "metadata": {"kind": "class", "chunk_index": "2", "has_docstring": "true", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/chunker.py::Chunker::3", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/chunker.py::Chunker", "content": " tokens=tokenize_code(imports),\n                metadata={\"type\": \"imports\"}\n            )\n            self.chunks.append(import_chunk)\n\n    def _extract_module_header(self, source: str) -> str:\n        \"\"\"Extract the leading module header and docstring block.\"\"\"\n        lines = source.splitlines()\n        header_lines = []\n        in_docstring = False\n        quote_type = None\n        \n        for line in lines:\n            stripped = line.strip()\n            if not stripped and not in_docstring:\n                continue\n            \n            # Simple docstring detection\n            if '\"\"\"' in stripped or \"'''\" in stripped:\n                if not in_docstring:\n                    in_docstring = True\n                    quote_type = '\"\"\"' if '\"\"\"' in stripped else \"'''\"\n                    header_lines.append(line)\n                    if stripped.count(quote_type) == 2:\n                        in_docstring = False\n                        break\n                else:\n                ", "tokens": ["tokens", "tokenize", "code", "imports", "metadata", "type", "imports", "self", "chunks", "append", "import", "chunk", "def", "extract", "module", "header", "self", "source", "str", "str", "extract", "the", "leading", "module", "header", "and", "docstring", "block", "lines", "source", "splitlines", "header", "lines", "in", "docstring", "false", "quote", "type", "none", "for", "line", "in", "lines", "stripped", "line", "strip", "if", "not", "stripped", "and", "not", "in", "docstring", "continue", "simple", "docstring", "detection", "if", "in", "stripped", "or", "in", "stripped", "if", "not", "in", "docstring", "in", "docstring", "true", "quote", "type", "if", "in", "stripped", "else", "header", "lines", "append", "line", "if", "stripped", "count", "quote", "type", "in", "docstring", "false", "break", "else"], "metadata": {"kind": "class", "chunk_index": "3", "has_docstring": "true", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/chunker.py::Chunker::4", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/chunker.py::Chunker", "content": "           in_docstring = False\n                        break\n                else:\n                    header_lines.append(line)\n                    in_docstring = False\n                    break\n            elif in_docstring:\n                header_lines.append(line)\n            elif stripped.startswith((\"import \", \"from \", \"class \", \"def \")):\n                # Stop at first code definition\n                break\n            else:\n                header_lines.append(line)\n                \n        return \"\\n\".join(header_lines).strip()\n\n    def _extract_imports(self, source: str) -> str:\n        \"\"\"Extract all import statements from the source.\"\"\"\n        lines = []\n        for line in source.splitlines():\n            stripped = line.strip()\n            if stripped.startswith((\"import \", \"from \")):\n                lines.append(line)\n        return \"\\n\".join(lines).strip()\n\n    def _chunk_entity(self, entity: Entity, last_modified: Optional[str] = None) -> None:\n        \"\"\"Create chunks", "tokens": ["in", "docstring", "false", "break", "else", "header", "lines", "append", "line", "in", "docstring", "false", "break", "elif", "in", "docstring", "header", "lines", "append", "line", "elif", "stripped", "startswith", "import", "from", "class", "def", "stop", "at", "first", "code", "definition", "break", "else", "header", "lines", "append", "line", "return", "join", "header", "lines", "strip", "def", "extract", "imports", "self", "source", "str", "str", "extract", "all", "import", "statements", "from", "the", "source", "lines", "for", "line", "in", "source", "splitlines", "stripped", "line", "strip", "if", "stripped", "startswith", "import", "from", "lines", "append", "line", "return", "join", "lines", "strip", "def", "chunk", "entity", "self", "entity", "entity", "last", "modified", "optional", "str", "none", "none", "create", "chunks"], "metadata": {"kind": "class", "chunk_index": "4", "has_docstring": "true", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/chunker.py::Chunker::5", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/chunker.py::Chunker", "content": "_entity(self, entity: Entity, last_modified: Optional[str] = None) -> None:\n        \"\"\"Create chunks for an entity and append them to the in-memory list.\n\n        Args:\n            entity: Entity to chunk (class, function, method, etc.).\n            last_modified: Optional timestamp used for ranking signals.\n        \"\"\"\n        content = \"\"\n        \n        if self.config.include_signatures and entity.signature:\n            content += entity.signature + \"\\n\"\n            \n        if self.config.include_docstrings and entity.docstring:\n            content += f'\"\"\"{entity.docstring}\"\"\"\\n'\n            \n        if entity.source_code:\n            content += entity.source_code\n        else:\n            content += entity.name\n            \n        # Sliding window chunking\n        has_docstring = \"true\" if entity.docstring else \"false\"\n\n        if len(content) <= self.config.max_chunk_size:\n            metadata = {\"kind\": entity.kind.value, \"has_docstring\": has_docstring}\n            if last_mo", "tokens": ["entity", "self", "entity", "entity", "last", "modified", "optional", "str", "none", "none", "create", "chunks", "for", "an", "entity", "and", "append", "them", "to", "the", "in", "memory", "list", "args", "entity", "entity", "to", "chunk", "class", "function", "method", "etc", "last", "modified", "optional", "timestamp", "used", "for", "ranking", "signals", "content", "if", "self", "config", "include", "signatures", "and", "entity", "signature", "content", "entity", "signature", "if", "self", "config", "include", "docstrings", "and", "entity", "docstring", "content", "entity", "docstring", "if", "entity", "source", "code", "content", "entity", "source", "code", "else", "content", "entity", "name", "sliding", "window", "chunking", "has", "docstring", "true", "if", "entity", "docstring", "else", "false", "if", "len", "content", "self", "config", "max", "chunk", "size", "metadata", "kind", "entity", "kind", "value", "has", "docstring", "has", "docstring", "if", "last", "mo"], "metadata": {"kind": "class", "chunk_index": "5", "has_docstring": "true", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/chunker.py::Chunker::6", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/chunker.py::Chunker", "content": "       metadata = {\"kind\": entity.kind.value, \"has_docstring\": has_docstring}\n            if last_modified:\n                metadata[\"last_modified\"] = last_modified\n\n            chunk = CodeChunk(\n                id=f\"{entity.id}::0\",\n                entity_id=entity.id,\n                content=content,\n                tokens=tokenize_code(content),\n                metadata=metadata\n            )\n            self.chunks.append(chunk)\n        else:\n            # multiple chunks\n            start = 0\n            chunk_index = 0\n            while start < len(content):\n                end = min(start + self.config.max_chunk_size, len(content))\n                chunk_content = content[start:end]\n                \n                metadata = {\n                    \"kind\": entity.kind.value,\n                    \"chunk_index\": str(chunk_index),\n                    \"has_docstring\": has_docstring,\n                }\n                if last_modified:\n                    metadata[\"last_modified\"] = la", "tokens": ["metadata", "kind", "entity", "kind", "value", "has", "docstring", "has", "docstring", "if", "last", "modified", "metadata", "last", "modified", "last", "modified", "chunk", "code", "chunk", "id", "entity", "id", "entity", "id", "entity", "id", "content", "content", "tokens", "tokenize", "code", "content", "metadata", "metadata", "self", "chunks", "append", "chunk", "else", "multiple", "chunks", "start", "chunk", "index", "while", "start", "len", "content", "end", "min", "start", "self", "config", "max", "chunk", "size", "len", "content", "chunk", "content", "content", "start", "end", "metadata", "kind", "entity", "kind", "value", "chunk", "index", "str", "chunk", "index", "has", "docstring", "has", "docstring", "if", "last", "modified", "metadata", "last", "modified", "la"], "metadata": {"kind": "class", "chunk_index": "6", "has_docstring": "true", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/chunker.py::Chunker::7", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/chunker.py::Chunker", "content": "              }\n                if last_modified:\n                    metadata[\"last_modified\"] = last_modified\n                \n                chunk = CodeChunk(\n                    id=f\"{entity.id}::{chunk_index}\",\n                    entity_id=entity.id,\n                    content=chunk_content,\n                    tokens=tokenize_code(chunk_content),\n                    metadata=metadata\n                )\n                self.chunks.append(chunk)\n                \n                if end == len(content):\n                    break\n                    \n                start += (self.config.max_chunk_size - self.config.overlap)\n                chunk_index += 1", "tokens": ["if", "last", "modified", "metadata", "last", "modified", "last", "modified", "chunk", "code", "chunk", "id", "entity", "id", "chunk", "index", "entity", "id", "entity", "id", "content", "chunk", "content", "tokens", "tokenize", "code", "chunk", "content", "metadata", "metadata", "self", "chunks", "append", "chunk", "if", "end", "len", "content", "break", "start", "self", "config", "max", "chunk", "size", "self", "config", "overlap", "chunk", "index"], "metadata": {"kind": "class", "chunk_index": "7", "has_docstring": "true", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/chunker.py::Chunker.__init__::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/chunker.py::Chunker.__init__", "content": "def __init__(self, config: Optional[ChunkingConfig]) -> None\n    def __init__(self, config: Optional[ChunkingConfig] = None) -> None:\n        self.config = config or ChunkingConfig()\n        self.chunks: list[CodeChunk] = []", "tokens": ["def", "init", "self", "config", "optional", "chunking", "config", "none", "def", "init", "self", "config", "optional", "chunking", "config", "none", "none", "self", "config", "config", "or", "chunking", "config", "self", "chunks", "list", "code", "chunk"], "metadata": {"kind": "method", "has_docstring": "false", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/chunker.py::Chunker.process_parse_result::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/chunker.py::Chunker.process_parse_result", "content": "def process_parse_result(self, result: ParseResult) -> list[CodeChunk]\n\"\"\"Convert a ParseResult into a list of CodeChunk objects.\n\nArgs:\n    result: Parsed entities, relationships, and errors for a single file.\n\nReturns:\n    List of generated CodeChunk objects in priority order.\"\"\"\n    def process_parse_result(self, result: ParseResult) -> list[CodeChunk]:\n        \"\"\"Convert a ParseResult into a list of CodeChunk objects.\n\n        Args:\n            result: Parsed entities, relationships, and errors for a single file.\n\n        Returns:\n            List of generated CodeChunk objects in priority order.\n        \"\"\"\n        self.chunks = []  # Single initialization at start of process\n        \n        file_path = result.file_path\n        source_code = \"\"\n        \n        # Try to find module source code if available\n        module_entity = next((e for e in result.entities if e.kind == EntityKind.MODULE), None)\n        if module_entity and module_entity.source_code:\n            source_code ", "tokens": ["def", "process", "parse", "result", "self", "result", "parse", "result", "list", "code", "chunk", "convert", "parse", "result", "into", "list", "of", "code", "chunk", "objects", "args", "result", "parsed", "entities", "relationships", "and", "errors", "for", "single", "file", "returns", "list", "of", "generated", "code", "chunk", "objects", "in", "priority", "order", "def", "process", "parse", "result", "self", "result", "parse", "result", "list", "code", "chunk", "convert", "parse", "result", "into", "list", "of", "code", "chunk", "objects", "args", "result", "parsed", "entities", "relationships", "and", "errors", "for", "single", "file", "returns", "list", "of", "generated", "code", "chunk", "objects", "in", "priority", "order", "self", "chunks", "single", "initialization", "at", "start", "of", "process", "file", "path", "result", "file", "path", "source", "code", "try", "to", "find", "module", "source", "code", "if", "available", "module", "entity", "next", "for", "in", "result", "entities", "if", "kind", "entity", "kind", "module", "none", "if", "module", "entity", "and", "module", "entity", "source", "code", "source", "code"], "metadata": {"kind": "method", "chunk_index": "0", "has_docstring": "true", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/chunker.py::Chunker.process_parse_result::1", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/chunker.py::Chunker.process_parse_result", "content": "Kind.MODULE), None)\n        if module_entity and module_entity.source_code:\n            source_code = module_entity.source_code\n        elif Path(file_path).exists():\n            source_code = Path(file_path).read_text(encoding=\"utf-8\")\n        \n        last_modified = None\n        if Path(file_path).exists():\n             last_modified = str(Path(file_path).stat().st_mtime)\n            \n        # 1. Module and Import Chunks\n        if source_code:\n            self._emit_module_chunks(file_path, source_code)\n            \n        # 2. Entity Chunks (Classes, Functions, Methods)\n        for entity in result.entities:\n            if entity.kind == EntityKind.MODULE:\n                continue\n            self._chunk_entity(entity, last_modified)\n            \n        return self.chunks", "tokens": ["kind", "module", "none", "if", "module", "entity", "and", "module", "entity", "source", "code", "source", "code", "module", "entity", "source", "code", "elif", "path", "file", "path", "exists", "source", "code", "path", "file", "path", "read", "text", "encoding", "utf", "last", "modified", "none", "if", "path", "file", "path", "exists", "last", "modified", "str", "path", "file", "path", "stat", "st", "mtime", "module", "and", "import", "chunks", "if", "source", "code", "self", "emit", "module", "chunks", "file", "path", "source", "code", "entity", "chunks", "classes", "functions", "methods", "for", "entity", "in", "result", "entities", "if", "entity", "kind", "entity", "kind", "module", "continue", "self", "chunk", "entity", "entity", "last", "modified", "return", "self", "chunks"], "metadata": {"kind": "method", "chunk_index": "1", "has_docstring": "true", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/chunker.py::Chunker._emit_module_chunks::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/chunker.py::Chunker._emit_module_chunks", "content": "def _emit_module_chunks(self, file_path: str, source: str) -> None\n\"\"\"Extract module-level header and imports into dedicated chunks.\n\nArgs:\n    file_path: File path used to namespace chunk IDs.\n    source: Full source code for the module.\"\"\"\n    def _emit_module_chunks(self, file_path: str, source: str) -> None:\n        \"\"\"Extract module-level header and imports into dedicated chunks.\n\n        Args:\n            file_path: File path used to namespace chunk IDs.\n            source: Full source code for the module.\n        \"\"\"\n        # Module Header\n        header = self._extract_module_header(source)\n        if header:\n            module_chunk = CodeChunk(\n                id=f\"{file_path}::module::0\",\n                entity_id=f\"{file_path}::module\",\n                content=header,\n                tokens=tokenize_code(header),\n                metadata={\"type\": \"module_header\"}\n            )\n            self.chunks.append(module_chunk)\n            \n        # Imports\n        imports = sel", "tokens": ["def", "emit", "module", "chunks", "self", "file", "path", "str", "source", "str", "none", "extract", "module", "level", "header", "and", "imports", "into", "dedicated", "chunks", "args", "file", "path", "file", "path", "used", "to", "namespace", "chunk", "ids", "source", "full", "source", "code", "for", "the", "module", "def", "emit", "module", "chunks", "self", "file", "path", "str", "source", "str", "none", "extract", "module", "level", "header", "and", "imports", "into", "dedicated", "chunks", "args", "file", "path", "file", "path", "used", "to", "namespace", "chunk", "ids", "source", "full", "source", "code", "for", "the", "module", "module", "header", "header", "self", "extract", "module", "header", "source", "if", "header", "module", "chunk", "code", "chunk", "id", "file", "path", "module", "entity", "id", "file", "path", "module", "content", "header", "tokens", "tokenize", "code", "header", "metadata", "type", "module", "header", "self", "chunks", "append", "module", "chunk", "imports", "imports", "sel"], "metadata": {"kind": "method", "chunk_index": "0", "has_docstring": "true", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/chunker.py::Chunker._emit_module_chunks::1", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/chunker.py::Chunker._emit_module_chunks", "content": " )\n            self.chunks.append(module_chunk)\n            \n        # Imports\n        imports = self._extract_imports(source)\n        if imports:\n            import_chunk = CodeChunk(\n                id=f\"{file_path}::imports::0\",\n                entity_id=f\"{file_path}::module\",\n                content=imports,\n                tokens=tokenize_code(imports),\n                metadata={\"type\": \"imports\"}\n            )\n            self.chunks.append(import_chunk)", "tokens": ["self", "chunks", "append", "module", "chunk", "imports", "imports", "self", "extract", "imports", "source", "if", "imports", "import", "chunk", "code", "chunk", "id", "file", "path", "imports", "entity", "id", "file", "path", "module", "content", "imports", "tokens", "tokenize", "code", "imports", "metadata", "type", "imports", "self", "chunks", "append", "import", "chunk"], "metadata": {"kind": "method", "chunk_index": "1", "has_docstring": "true", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/chunker.py::Chunker._extract_module_header::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/chunker.py::Chunker._extract_module_header", "content": "def _extract_module_header(self, source: str) -> str\n\"\"\"Extract the leading module header and docstring block.\"\"\"\n    def _extract_module_header(self, source: str) -> str:\n        \"\"\"Extract the leading module header and docstring block.\"\"\"\n        lines = source.splitlines()\n        header_lines = []\n        in_docstring = False\n        quote_type = None\n        \n        for line in lines:\n            stripped = line.strip()\n            if not stripped and not in_docstring:\n                continue\n            \n            # Simple docstring detection\n            if '\"\"\"' in stripped or \"'''\" in stripped:\n                if not in_docstring:\n                    in_docstring = True\n                    quote_type = '\"\"\"' if '\"\"\"' in stripped else \"'''\"\n                    header_lines.append(line)\n                    if stripped.count(quote_type) == 2:\n                        in_docstring = False\n                        break\n                else:\n                    header_lines.append", "tokens": ["def", "extract", "module", "header", "self", "source", "str", "str", "extract", "the", "leading", "module", "header", "and", "docstring", "block", "def", "extract", "module", "header", "self", "source", "str", "str", "extract", "the", "leading", "module", "header", "and", "docstring", "block", "lines", "source", "splitlines", "header", "lines", "in", "docstring", "false", "quote", "type", "none", "for", "line", "in", "lines", "stripped", "line", "strip", "if", "not", "stripped", "and", "not", "in", "docstring", "continue", "simple", "docstring", "detection", "if", "in", "stripped", "or", "in", "stripped", "if", "not", "in", "docstring", "in", "docstring", "true", "quote", "type", "if", "in", "stripped", "else", "header", "lines", "append", "line", "if", "stripped", "count", "quote", "type", "in", "docstring", "false", "break", "else", "header", "lines", "append"], "metadata": {"kind": "method", "chunk_index": "0", "has_docstring": "true", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/chunker.py::Chunker._extract_module_header::1", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/chunker.py::Chunker._extract_module_header", "content": " = False\n                        break\n                else:\n                    header_lines.append(line)\n                    in_docstring = False\n                    break\n            elif in_docstring:\n                header_lines.append(line)\n            elif stripped.startswith((\"import \", \"from \", \"class \", \"def \")):\n                # Stop at first code definition\n                break\n            else:\n                header_lines.append(line)\n                \n        return \"\\n\".join(header_lines).strip()", "tokens": ["false", "break", "else", "header", "lines", "append", "line", "in", "docstring", "false", "break", "elif", "in", "docstring", "header", "lines", "append", "line", "elif", "stripped", "startswith", "import", "from", "class", "def", "stop", "at", "first", "code", "definition", "break", "else", "header", "lines", "append", "line", "return", "join", "header", "lines", "strip"], "metadata": {"kind": "method", "chunk_index": "1", "has_docstring": "true", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/chunker.py::Chunker._extract_imports::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/chunker.py::Chunker._extract_imports", "content": "def _extract_imports(self, source: str) -> str\n\"\"\"Extract all import statements from the source.\"\"\"\n    def _extract_imports(self, source: str) -> str:\n        \"\"\"Extract all import statements from the source.\"\"\"\n        lines = []\n        for line in source.splitlines():\n            stripped = line.strip()\n            if stripped.startswith((\"import \", \"from \")):\n                lines.append(line)\n        return \"\\n\".join(lines).strip()", "tokens": ["def", "extract", "imports", "self", "source", "str", "str", "extract", "all", "import", "statements", "from", "the", "source", "def", "extract", "imports", "self", "source", "str", "str", "extract", "all", "import", "statements", "from", "the", "source", "lines", "for", "line", "in", "source", "splitlines", "stripped", "line", "strip", "if", "stripped", "startswith", "import", "from", "lines", "append", "line", "return", "join", "lines", "strip"], "metadata": {"kind": "method", "has_docstring": "true", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/chunker.py::Chunker._chunk_entity::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/chunker.py::Chunker._chunk_entity", "content": "def _chunk_entity(self, entity: Entity, last_modified: Optional[str]) -> None\n\"\"\"Create chunks for an entity and append them to the in-memory list.\n\nArgs:\n    entity: Entity to chunk (class, function, method, etc.).\n    last_modified: Optional timestamp used for ranking signals.\"\"\"\n    def _chunk_entity(self, entity: Entity, last_modified: Optional[str] = None) -> None:\n        \"\"\"Create chunks for an entity and append them to the in-memory list.\n\n        Args:\n            entity: Entity to chunk (class, function, method, etc.).\n            last_modified: Optional timestamp used for ranking signals.\n        \"\"\"\n        content = \"\"\n        \n        if self.config.include_signatures and entity.signature:\n            content += entity.signature + \"\\n\"\n            \n        if self.config.include_docstrings and entity.docstring:\n            content += f'\"\"\"{entity.docstring}\"\"\"\\n'\n            \n        if entity.source_code:\n            content += entity.source_code\n        else:\n          ", "tokens": ["def", "chunk", "entity", "self", "entity", "entity", "last", "modified", "optional", "str", "none", "create", "chunks", "for", "an", "entity", "and", "append", "them", "to", "the", "in", "memory", "list", "args", "entity", "entity", "to", "chunk", "class", "function", "method", "etc", "last", "modified", "optional", "timestamp", "used", "for", "ranking", "signals", "def", "chunk", "entity", "self", "entity", "entity", "last", "modified", "optional", "str", "none", "none", "create", "chunks", "for", "an", "entity", "and", "append", "them", "to", "the", "in", "memory", "list", "args", "entity", "entity", "to", "chunk", "class", "function", "method", "etc", "last", "modified", "optional", "timestamp", "used", "for", "ranking", "signals", "content", "if", "self", "config", "include", "signatures", "and", "entity", "signature", "content", "entity", "signature", "if", "self", "config", "include", "docstrings", "and", "entity", "docstring", "content", "entity", "docstring", "if", "entity", "source", "code", "content", "entity", "source", "code", "else"], "metadata": {"kind": "method", "chunk_index": "0", "has_docstring": "true", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/chunker.py::Chunker._chunk_entity::1", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/chunker.py::Chunker._chunk_entity", "content": "  \n        if entity.source_code:\n            content += entity.source_code\n        else:\n            content += entity.name\n            \n        # Sliding window chunking\n        has_docstring = \"true\" if entity.docstring else \"false\"\n\n        if len(content) <= self.config.max_chunk_size:\n            metadata = {\"kind\": entity.kind.value, \"has_docstring\": has_docstring}\n            if last_modified:\n                metadata[\"last_modified\"] = last_modified\n\n            chunk = CodeChunk(\n                id=f\"{entity.id}::0\",\n                entity_id=entity.id,\n                content=content,\n                tokens=tokenize_code(content),\n                metadata=metadata\n            )\n            self.chunks.append(chunk)\n        else:\n            # multiple chunks\n            start = 0\n            chunk_index = 0\n            while start < len(content):\n                end = min(start + self.config.max_chunk_size, len(content))\n                chunk_content = content[start:end]\n   ", "tokens": ["if", "entity", "source", "code", "content", "entity", "source", "code", "else", "content", "entity", "name", "sliding", "window", "chunking", "has", "docstring", "true", "if", "entity", "docstring", "else", "false", "if", "len", "content", "self", "config", "max", "chunk", "size", "metadata", "kind", "entity", "kind", "value", "has", "docstring", "has", "docstring", "if", "last", "modified", "metadata", "last", "modified", "last", "modified", "chunk", "code", "chunk", "id", "entity", "id", "entity", "id", "entity", "id", "content", "content", "tokens", "tokenize", "code", "content", "metadata", "metadata", "self", "chunks", "append", "chunk", "else", "multiple", "chunks", "start", "chunk", "index", "while", "start", "len", "content", "end", "min", "start", "self", "config", "max", "chunk", "size", "len", "content", "chunk", "content", "content", "start", "end"], "metadata": {"kind": "method", "chunk_index": "1", "has_docstring": "true", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/chunker.py::Chunker._chunk_entity::2", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/chunker.py::Chunker._chunk_entity", "content": "t + self.config.max_chunk_size, len(content))\n                chunk_content = content[start:end]\n                \n                metadata = {\n                    \"kind\": entity.kind.value,\n                    \"chunk_index\": str(chunk_index),\n                    \"has_docstring\": has_docstring,\n                }\n                if last_modified:\n                    metadata[\"last_modified\"] = last_modified\n                \n                chunk = CodeChunk(\n                    id=f\"{entity.id}::{chunk_index}\",\n                    entity_id=entity.id,\n                    content=chunk_content,\n                    tokens=tokenize_code(chunk_content),\n                    metadata=metadata\n                )\n                self.chunks.append(chunk)\n                \n                if end == len(content):\n                    break\n                    \n                start += (self.config.max_chunk_size - self.config.overlap)\n                chunk_index += 1", "tokens": ["self", "config", "max", "chunk", "size", "len", "content", "chunk", "content", "content", "start", "end", "metadata", "kind", "entity", "kind", "value", "chunk", "index", "str", "chunk", "index", "has", "docstring", "has", "docstring", "if", "last", "modified", "metadata", "last", "modified", "last", "modified", "chunk", "code", "chunk", "id", "entity", "id", "chunk", "index", "entity", "id", "entity", "id", "content", "chunk", "content", "tokens", "tokenize", "code", "chunk", "content", "metadata", "metadata", "self", "chunks", "append", "chunk", "if", "end", "len", "content", "break", "start", "self", "config", "max", "chunk", "size", "self", "config", "overlap", "chunk", "index"], "metadata": {"kind": "method", "chunk_index": "2", "has_docstring": "true", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/graph_builder.py::module::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/graph_builder.py::module", "content": "\"\"\"Graph builder that orchestrates parsing and constructs the semantic graph.\"\"\"", "tokens": ["graph", "builder", "that", "orchestrates", "parsing", "and", "constructs", "the", "semantic", "graph"], "metadata": {"type": "module_header"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/graph_builder.py::imports::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/graph_builder.py::module", "content": "from __future__ import annotations\nfrom pathlib import Path\nfrom typing import Optional\nfrom knowcode.data_models import Entity, ParseResult, Relationship\nfrom knowcode.parsers import MarkdownParser, PythonParser, YamlParser\nfrom knowcode.parsers.javascript_parser import JavaScriptParser\nfrom knowcode.parsers.java_parser import JavaParser\nfrom knowcode.indexing.scanner import FileInfo, Scanner\nfrom knowcode.analysis.signals import CoverageProcessor\nfrom knowcode.analysis.temporal import TemporalAnalyzer", "tokens": ["from", "future", "import", "annotations", "from", "pathlib", "import", "path", "from", "typing", "import", "optional", "from", "knowcode", "data", "models", "import", "entity", "parse", "result", "relationship", "from", "knowcode", "parsers", "import", "markdown", "parser", "python", "parser", "yaml", "parser", "from", "knowcode", "parsers", "javascript", "parser", "import", "java", "script", "parser", "from", "knowcode", "parsers", "java", "parser", "import", "java", "parser", "from", "knowcode", "indexing", "scanner", "import", "file", "info", "scanner", "from", "knowcode", "analysis", "signals", "import", "coverage", "processor", "from", "knowcode", "analysis", "temporal", "import", "temporal", "analyzer"], "metadata": {"type": "imports"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/graph_builder.py::GraphBuilder::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/graph_builder.py::GraphBuilder", "content": "\"\"\"Builds semantic graph from source files.\"\"\"\nclass GraphBuilder:\n    \"\"\"Builds semantic graph from source files.\"\"\"\n\n    def __init__(self) -> None:\n        \"\"\"Initialize the graph builder with parsers.\"\"\"\n        self.python_parser = PythonParser()\n        self.markdown_parser = MarkdownParser()\n        self.yaml_parser = YamlParser()\n        self.js_parser = JavaScriptParser()\n        self.java_parser = JavaParser()\n\n        self.entities: dict[str, Entity] = {}\n        self.relationships: list[Relationship] = []\n        self.errors: list[str] = []\n\n    def build_from_directory(\n        self,\n        root_dir: str | Path,\n        additional_ignores: Optional[list[str]] = None,\n        analyze_temporal: bool = False,\n        coverage_path: Optional[Path] = None,\n    ) -> \"GraphBuilder\":\n        \"\"\"Build graph by scanning and parsing a directory.\n\n        Args:\n            root_dir: Root directory to scan.\n            additional_ignores: Additional patterns to ignore.\n\n        Return", "tokens": ["builds", "semantic", "graph", "from", "source", "files", "class", "graph", "builder", "builds", "semantic", "graph", "from", "source", "files", "def", "init", "self", "none", "initialize", "the", "graph", "builder", "with", "parsers", "self", "python", "parser", "python", "parser", "self", "markdown", "parser", "markdown", "parser", "self", "yaml", "parser", "yaml", "parser", "self", "js", "parser", "java", "script", "parser", "self", "java", "parser", "java", "parser", "self", "entities", "dict", "str", "entity", "self", "relationships", "list", "relationship", "self", "errors", "list", "str", "def", "build", "from", "directory", "self", "root", "dir", "str", "path", "additional", "ignores", "optional", "list", "str", "none", "analyze", "temporal", "bool", "false", "coverage", "path", "optional", "path", "none", "graph", "builder", "build", "graph", "by", "scanning", "and", "parsing", "directory", "args", "root", "dir", "root", "directory", "to", "scan", "additional", "ignores", "additional", "patterns", "to", "ignore", "return"], "metadata": {"kind": "class", "chunk_index": "0", "has_docstring": "true", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/graph_builder.py::GraphBuilder::1", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/graph_builder.py::GraphBuilder", "content": "ot directory to scan.\n            additional_ignores: Additional patterns to ignore.\n\n        Returns:\n            Self for method chaining.\n        \"\"\"\n        scanner = Scanner(\n            root_dir=root_dir,\n            respect_gitignore=True,\n            additional_ignores=additional_ignores,\n        )\n\n        files = scanner.scan_all()\n        \n        # Static Analysis\n        self.build_from_files(files)\n\n        # Temporal Analysis\n        if analyze_temporal:\n            temporal_analyzer = TemporalAnalyzer(root_dir)\n            result = temporal_analyzer.analyze_history()\n            self._merge_result(result)\n            \n        # Coverage Analysis\n        if coverage_path:\n            coverage_processor = CoverageProcessor(root_dir)\n            result = coverage_processor.process_cobertura(coverage_path)\n            self._merge_result(result)\n            \n        return self\n\n    def build_from_files(self, files: list[FileInfo]) -> \"GraphBuilder\":\n        \"\"\"Build graph f", "tokens": ["ot", "directory", "to", "scan", "additional", "ignores", "additional", "patterns", "to", "ignore", "returns", "self", "for", "method", "chaining", "scanner", "scanner", "root", "dir", "root", "dir", "respect", "gitignore", "true", "additional", "ignores", "additional", "ignores", "files", "scanner", "scan", "all", "static", "analysis", "self", "build", "from", "files", "files", "temporal", "analysis", "if", "analyze", "temporal", "temporal", "analyzer", "temporal", "analyzer", "root", "dir", "result", "temporal", "analyzer", "analyze", "history", "self", "merge", "result", "result", "coverage", "analysis", "if", "coverage", "path", "coverage", "processor", "coverage", "processor", "root", "dir", "result", "coverage", "processor", "process", "cobertura", "coverage", "path", "self", "merge", "result", "result", "return", "self", "def", "build", "from", "files", "self", "files", "list", "file", "info", "graph", "builder", "build", "graph"], "metadata": {"kind": "class", "chunk_index": "1", "has_docstring": "true", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/graph_builder.py::GraphBuilder::2", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/graph_builder.py::GraphBuilder", "content": "f\n\n    def build_from_files(self, files: list[FileInfo]) -> \"GraphBuilder\":\n        \"\"\"Build graph from a list of files.\n\n        Args:\n            files: List of FileInfo objects to parse.\n\n        Returns:\n            Self for method chaining.\n        \"\"\"\n        for file_info in files:\n            parse_result = self._parse_file(file_info)\n            self._merge_result(parse_result)\n\n        # Resolve references after all files are parsed\n        self._resolve_references()\n\n        return self\n\n    def _parse_file(self, file_info: FileInfo) -> ParseResult:\n        \"\"\"Parse a single file based on its extension.\"\"\"\n        if file_info.extension == \".py\":\n            return self.python_parser.parse_file(file_info.path)\n        elif file_info.extension == \".md\":\n            return self.markdown_parser.parse_file(file_info.path)\n        elif file_info.extension in {\".yaml\", \".yml\"}:\n            return self.yaml_parser.parse_file(file_info.path)\n        elif file_info.extension in {\".js", "tokens": ["def", "build", "from", "files", "self", "files", "list", "file", "info", "graph", "builder", "build", "graph", "from", "list", "of", "files", "args", "files", "list", "of", "file", "info", "objects", "to", "parse", "returns", "self", "for", "method", "chaining", "for", "file", "info", "in", "files", "parse", "result", "self", "parse", "file", "file", "info", "self", "merge", "result", "parse", "result", "resolve", "references", "after", "all", "files", "are", "parsed", "self", "resolve", "references", "return", "self", "def", "parse", "file", "self", "file", "info", "file", "info", "parse", "result", "parse", "single", "file", "based", "on", "its", "extension", "if", "file", "info", "extension", "py", "return", "self", "python", "parser", "parse", "file", "file", "info", "path", "elif", "file", "info", "extension", "md", "return", "self", "markdown", "parser", "parse", "file", "file", "info", "path", "elif", "file", "info", "extension", "in", "yaml", "yml", "return", "self", "yaml", "parser", "parse", "file", "file", "info", "path", "elif", "file", "info", "extension", "in", "js"], "metadata": {"kind": "class", "chunk_index": "2", "has_docstring": "true", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/graph_builder.py::GraphBuilder::3", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/graph_builder.py::GraphBuilder", "content": "        return self.yaml_parser.parse_file(file_info.path)\n        elif file_info.extension in {\".js\", \".ts\"}:\n            return self.js_parser.parse_file(file_info.path)\n        elif file_info.extension == \".java\":\n            return self.java_parser.parse_file(file_info.path)\n        else:\n            return ParseResult(\n                file_path=str(file_info.path),\n                entities=[],\n                relationships=[],\n                errors=[f\"Unsupported file type: {file_info.extension}\"],\n            )\n\n    def _merge_result(self, result: ParseResult) -> None:\n        \"\"\"Merge parse result into the graph.\"\"\"\n        for entity in result.entities:\n            self.entities[entity.id] = entity\n\n        self.relationships.extend(result.relationships)\n        self.errors.extend(result.errors)\n\n    def _resolve_references(self) -> None:\n        \"\"\"Resolve reference-based relationships to actual entity IDs.\n        \n        Some parsers (like Tree-sitter) may produce relation", "tokens": ["return", "self", "yaml", "parser", "parse", "file", "file", "info", "path", "elif", "file", "info", "extension", "in", "js", "ts", "return", "self", "js", "parser", "parse", "file", "file", "info", "path", "elif", "file", "info", "extension", "java", "return", "self", "java", "parser", "parse", "file", "file", "info", "path", "else", "return", "parse", "result", "file", "path", "str", "file", "info", "path", "entities", "relationships", "errors", "unsupported", "file", "type", "file", "info", "extension", "def", "merge", "result", "self", "result", "parse", "result", "none", "merge", "parse", "result", "into", "the", "graph", "for", "entity", "in", "result", "entities", "self", "entities", "entity", "id", "entity", "self", "relationships", "extend", "result", "relationships", "self", "errors", "extend", "result", "errors", "def", "resolve", "references", "self", "none", "resolve", "reference", "based", "relationships", "to", "actual", "entity", "ids", "some", "parsers", "like", "tree", "sitter", "may", "produce", "relation"], "metadata": {"kind": "class", "chunk_index": "3", "has_docstring": "true", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/graph_builder.py::GraphBuilder::4", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/graph_builder.py::GraphBuilder", "content": "ionships to actual entity IDs.\n        \n        Some parsers (like Tree-sitter) may produce relationships pointing to \n        'ref::SomeName' because they don't know the full qualified name at parse time.\n        This pass iterates through all relationships and attempts to link these \n        placeholders to concrete Entity IDs in the graph.\n        \"\"\"\n        resolved_relationships: list[Relationship] = []\n\n        for rel in self.relationships:\n            # Check if target is a reference that needs resolution\n            if rel.target_id.startswith(\"ref::\"):\n                ref_name = rel.target_id[5:]  # Remove \"ref::\" prefix\n                resolved_id = self._find_entity_by_name(ref_name)\n                if resolved_id:\n                    resolved_relationships.append(\n                        Relationship(\n                            source_id=rel.source_id,\n                            target_id=resolved_id,\n                            kind=rel.kind,\n                          ", "tokens": ["ionships", "to", "actual", "entity", "ids", "some", "parsers", "like", "tree", "sitter", "may", "produce", "relationships", "pointing", "to", "ref", "some", "name", "because", "they", "don", "know", "the", "full", "qualified", "name", "at", "parse", "time", "this", "pass", "iterates", "through", "all", "relationships", "and", "attempts", "to", "link", "these", "placeholders", "to", "concrete", "entity", "ids", "in", "the", "graph", "resolved", "relationships", "list", "relationship", "for", "rel", "in", "self", "relationships", "check", "if", "target", "is", "reference", "that", "needs", "resolution", "if", "rel", "target", "id", "startswith", "ref", "ref", "name", "rel", "target", "id", "remove", "ref", "prefix", "resolved", "id", "self", "find", "entity", "by", "name", "ref", "name", "if", "resolved", "id", "resolved", "relationships", "append", "relationship", "source", "id", "rel", "source", "id", "target", "id", "resolved", "id", "kind", "rel", "kind"], "metadata": {"kind": "class", "chunk_index": "4", "has_docstring": "true", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/graph_builder.py::GraphBuilder::5", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/graph_builder.py::GraphBuilder", "content": "        target_id=resolved_id,\n                            kind=rel.kind,\n                            metadata=rel.metadata,\n                        )\n                    )\n                else:\n                    # Keep as unresolved reference\n                    resolved_relationships.append(rel)\n            else:\n                resolved_relationships.append(rel)\n\n        self.relationships = resolved_relationships\n\n    def _find_entity_by_name(self, name: str) -> Optional[str]:\n        \"\"\"Find entity ID by name or qualified name.\"\"\"\n        # Exact match on name or qualified_name\n        for entity_id, entity in self.entities.items():\n            if entity.name == name or entity.qualified_name == name:\n                return entity_id\n\n        # Try matching the last part of qualified names\n        for entity_id, entity in self.entities.items():\n            if entity.qualified_name.endswith(f\".{name}\"):\n                return entity_id\n\n        return None\n\n    def get_entity(self", "tokens": ["target", "id", "resolved", "id", "kind", "rel", "kind", "metadata", "rel", "metadata", "else", "keep", "as", "unresolved", "reference", "resolved", "relationships", "append", "rel", "else", "resolved", "relationships", "append", "rel", "self", "relationships", "resolved", "relationships", "def", "find", "entity", "by", "name", "self", "name", "str", "optional", "str", "find", "entity", "id", "by", "name", "or", "qualified", "name", "exact", "match", "on", "name", "or", "qualified", "name", "for", "entity", "id", "entity", "in", "self", "entities", "items", "if", "entity", "name", "name", "or", "entity", "qualified", "name", "name", "return", "entity", "id", "try", "matching", "the", "last", "part", "of", "qualified", "names", "for", "entity", "id", "entity", "in", "self", "entities", "items", "if", "entity", "qualified", "name", "endswith", "name", "return", "entity", "id", "return", "none", "def", "get", "entity", "self"], "metadata": {"kind": "class", "chunk_index": "5", "has_docstring": "true", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/graph_builder.py::GraphBuilder::6", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/graph_builder.py::GraphBuilder", "content": "endswith(f\".{name}\"):\n                return entity_id\n\n        return None\n\n    def get_entity(self, entity_id: str) -> Optional[Entity]:\n        \"\"\"Get entity by ID.\"\"\"\n        return self.entities.get(entity_id)\n\n    def get_entities_by_kind(self, kind: str) -> list[Entity]:\n        \"\"\"Get all entities of a specific kind.\"\"\"\n        return [e for e in self.entities.values() if e.kind.value == kind]\n\n    def get_outgoing_relationships(self, entity_id: str) -> list[Relationship]:\n        \"\"\"Get all relationships where entity is the source.\"\"\"\n        return [r for r in self.relationships if r.source_id == entity_id]\n\n    def get_incoming_relationships(self, entity_id: str) -> list[Relationship]:\n        \"\"\"Get all relationships where entity is the target.\"\"\"\n        return [r for r in self.relationships if r.target_id == entity_id]\n\n    def search_entities(self, pattern: str) -> list[Entity]:\n        \"\"\"Search entities by name pattern (case-insensitive substring).\"\"\"\n        pattern_l", "tokens": ["endswith", "name", "return", "entity", "id", "return", "none", "def", "get", "entity", "self", "entity", "id", "str", "optional", "entity", "get", "entity", "by", "id", "return", "self", "entities", "get", "entity", "id", "def", "get", "entities", "by", "kind", "self", "kind", "str", "list", "entity", "get", "all", "entities", "of", "specific", "kind", "return", "for", "in", "self", "entities", "values", "if", "kind", "value", "kind", "def", "get", "outgoing", "relationships", "self", "entity", "id", "str", "list", "relationship", "get", "all", "relationships", "where", "entity", "is", "the", "source", "return", "for", "in", "self", "relationships", "if", "source", "id", "entity", "id", "def", "get", "incoming", "relationships", "self", "entity", "id", "str", "list", "relationship", "get", "all", "relationships", "where", "entity", "is", "the", "target", "return", "for", "in", "self", "relationships", "if", "target", "id", "entity", "id", "def", "search", "entities", "self", "pattern", "str", "list", "entity", "search", "entities", "by", "name", "pattern", "case", "insensitive", "substring", "pattern"], "metadata": {"kind": "class", "chunk_index": "6", "has_docstring": "true", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/graph_builder.py::GraphBuilder::7", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/graph_builder.py::GraphBuilder", "content": "tity]:\n        \"\"\"Search entities by name pattern (case-insensitive substring).\"\"\"\n        pattern_lower = pattern.lower()\n        return [\n            e for e in self.entities.values()\n            if pattern_lower in e.name.lower()\n            or pattern_lower in e.qualified_name.lower()\n        ]\n\n    def stats(self) -> dict[str, int]:\n        \"\"\"Return statistics about the graph.\"\"\"\n        kind_counts: dict[str, int] = {}\n        for entity in self.entities.values():\n            kind = entity.kind.value\n            kind_counts[kind] = kind_counts.get(kind, 0) + 1\n\n        rel_counts: dict[str, int] = {}\n        for rel in self.relationships:\n            kind = rel.kind.value\n            rel_counts[kind] = rel_counts.get(kind, 0) + 1\n\n        return {\n            \"total_entities\": len(self.entities),\n            \"total_relationships\": len(self.relationships),\n            \"total_errors\": len(self.errors),\n            **{f\"entities_{k}\": v for k, v in kind_counts.items()},\n           ", "tokens": ["tity", "search", "entities", "by", "name", "pattern", "case", "insensitive", "substring", "pattern", "lower", "pattern", "lower", "return", "for", "in", "self", "entities", "values", "if", "pattern", "lower", "in", "name", "lower", "or", "pattern", "lower", "in", "qualified", "name", "lower", "def", "stats", "self", "dict", "str", "int", "return", "statistics", "about", "the", "graph", "kind", "counts", "dict", "str", "int", "for", "entity", "in", "self", "entities", "values", "kind", "entity", "kind", "value", "kind", "counts", "kind", "kind", "counts", "get", "kind", "rel", "counts", "dict", "str", "int", "for", "rel", "in", "self", "relationships", "kind", "rel", "kind", "value", "rel", "counts", "kind", "rel", "counts", "get", "kind", "return", "total", "entities", "len", "self", "entities", "total", "relationships", "len", "self", "relationships", "total", "errors", "len", "self", "errors", "entities", "for", "in", "kind", "counts", "items"], "metadata": {"kind": "class", "chunk_index": "7", "has_docstring": "true", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/graph_builder.py::GraphBuilder::8", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/graph_builder.py::GraphBuilder", "content": "\": len(self.errors),\n            **{f\"entities_{k}\": v for k, v in kind_counts.items()},\n            **{f\"relationships_{k}\": v for k, v in rel_counts.items()},\n        }", "tokens": ["len", "self", "errors", "entities", "for", "in", "kind", "counts", "items", "relationships", "for", "in", "rel", "counts", "items"], "metadata": {"kind": "class", "chunk_index": "8", "has_docstring": "true", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/graph_builder.py::GraphBuilder.__init__::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/graph_builder.py::GraphBuilder.__init__", "content": "def __init__(self) -> None\n\"\"\"Initialize the graph builder with parsers.\"\"\"\n    def __init__(self) -> None:\n        \"\"\"Initialize the graph builder with parsers.\"\"\"\n        self.python_parser = PythonParser()\n        self.markdown_parser = MarkdownParser()\n        self.yaml_parser = YamlParser()\n        self.js_parser = JavaScriptParser()\n        self.java_parser = JavaParser()\n\n        self.entities: dict[str, Entity] = {}\n        self.relationships: list[Relationship] = []\n        self.errors: list[str] = []", "tokens": ["def", "init", "self", "none", "initialize", "the", "graph", "builder", "with", "parsers", "def", "init", "self", "none", "initialize", "the", "graph", "builder", "with", "parsers", "self", "python", "parser", "python", "parser", "self", "markdown", "parser", "markdown", "parser", "self", "yaml", "parser", "yaml", "parser", "self", "js", "parser", "java", "script", "parser", "self", "java", "parser", "java", "parser", "self", "entities", "dict", "str", "entity", "self", "relationships", "list", "relationship", "self", "errors", "list", "str"], "metadata": {"kind": "method", "has_docstring": "true", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/graph_builder.py::GraphBuilder.build_from_directory::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/graph_builder.py::GraphBuilder.build_from_directory", "content": "def build_from_directory(self, root_dir: str | Path, additional_ignores: Optional[list[str]], analyze_temporal: bool, coverage_path: Optional[Path]) -> 'GraphBuilder'\n\"\"\"Build graph by scanning and parsing a directory.\n\nArgs:\n    root_dir: Root directory to scan.\n    additional_ignores: Additional patterns to ignore.\n\nReturns:\n    Self for method chaining.\"\"\"\n    def build_from_directory(\n        self,\n        root_dir: str | Path,\n        additional_ignores: Optional[list[str]] = None,\n        analyze_temporal: bool = False,\n        coverage_path: Optional[Path] = None,\n    ) -> \"GraphBuilder\":\n        \"\"\"Build graph by scanning and parsing a directory.\n\n        Args:\n            root_dir: Root directory to scan.\n            additional_ignores: Additional patterns to ignore.\n\n        Returns:\n            Self for method chaining.\n        \"\"\"\n        scanner = Scanner(\n            root_dir=root_dir,\n            respect_gitignore=True,\n            additional_ignores=additional_ignores,\n", "tokens": ["def", "build", "from", "directory", "self", "root", "dir", "str", "path", "additional", "ignores", "optional", "list", "str", "analyze", "temporal", "bool", "coverage", "path", "optional", "path", "graph", "builder", "build", "graph", "by", "scanning", "and", "parsing", "directory", "args", "root", "dir", "root", "directory", "to", "scan", "additional", "ignores", "additional", "patterns", "to", "ignore", "returns", "self", "for", "method", "chaining", "def", "build", "from", "directory", "self", "root", "dir", "str", "path", "additional", "ignores", "optional", "list", "str", "none", "analyze", "temporal", "bool", "false", "coverage", "path", "optional", "path", "none", "graph", "builder", "build", "graph", "by", "scanning", "and", "parsing", "directory", "args", "root", "dir", "root", "directory", "to", "scan", "additional", "ignores", "additional", "patterns", "to", "ignore", "returns", "self", "for", "method", "chaining", "scanner", "scanner", "root", "dir", "root", "dir", "respect", "gitignore", "true", "additional", "ignores", "additional", "ignores"], "metadata": {"kind": "method", "chunk_index": "0", "has_docstring": "true", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/graph_builder.py::GraphBuilder.build_from_directory::1", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/graph_builder.py::GraphBuilder.build_from_directory", "content": "ir=root_dir,\n            respect_gitignore=True,\n            additional_ignores=additional_ignores,\n        )\n\n        files = scanner.scan_all()\n        \n        # Static Analysis\n        self.build_from_files(files)\n\n        # Temporal Analysis\n        if analyze_temporal:\n            temporal_analyzer = TemporalAnalyzer(root_dir)\n            result = temporal_analyzer.analyze_history()\n            self._merge_result(result)\n            \n        # Coverage Analysis\n        if coverage_path:\n            coverage_processor = CoverageProcessor(root_dir)\n            result = coverage_processor.process_cobertura(coverage_path)\n            self._merge_result(result)\n            \n        return self", "tokens": ["ir", "root", "dir", "respect", "gitignore", "true", "additional", "ignores", "additional", "ignores", "files", "scanner", "scan", "all", "static", "analysis", "self", "build", "from", "files", "files", "temporal", "analysis", "if", "analyze", "temporal", "temporal", "analyzer", "temporal", "analyzer", "root", "dir", "result", "temporal", "analyzer", "analyze", "history", "self", "merge", "result", "result", "coverage", "analysis", "if", "coverage", "path", "coverage", "processor", "coverage", "processor", "root", "dir", "result", "coverage", "processor", "process", "cobertura", "coverage", "path", "self", "merge", "result", "result", "return", "self"], "metadata": {"kind": "method", "chunk_index": "1", "has_docstring": "true", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/graph_builder.py::GraphBuilder.build_from_files::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/graph_builder.py::GraphBuilder.build_from_files", "content": "def build_from_files(self, files: list[FileInfo]) -> 'GraphBuilder'\n\"\"\"Build graph from a list of files.\n\nArgs:\n    files: List of FileInfo objects to parse.\n\nReturns:\n    Self for method chaining.\"\"\"\n    def build_from_files(self, files: list[FileInfo]) -> \"GraphBuilder\":\n        \"\"\"Build graph from a list of files.\n\n        Args:\n            files: List of FileInfo objects to parse.\n\n        Returns:\n            Self for method chaining.\n        \"\"\"\n        for file_info in files:\n            parse_result = self._parse_file(file_info)\n            self._merge_result(parse_result)\n\n        # Resolve references after all files are parsed\n        self._resolve_references()\n\n        return self", "tokens": ["def", "build", "from", "files", "self", "files", "list", "file", "info", "graph", "builder", "build", "graph", "from", "list", "of", "files", "args", "files", "list", "of", "file", "info", "objects", "to", "parse", "returns", "self", "for", "method", "chaining", "def", "build", "from", "files", "self", "files", "list", "file", "info", "graph", "builder", "build", "graph", "from", "list", "of", "files", "args", "files", "list", "of", "file", "info", "objects", "to", "parse", "returns", "self", "for", "method", "chaining", "for", "file", "info", "in", "files", "parse", "result", "self", "parse", "file", "file", "info", "self", "merge", "result", "parse", "result", "resolve", "references", "after", "all", "files", "are", "parsed", "self", "resolve", "references", "return", "self"], "metadata": {"kind": "method", "has_docstring": "true", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/graph_builder.py::GraphBuilder._parse_file::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/graph_builder.py::GraphBuilder._parse_file", "content": "def _parse_file(self, file_info: FileInfo) -> ParseResult\n\"\"\"Parse a single file based on its extension.\"\"\"\n    def _parse_file(self, file_info: FileInfo) -> ParseResult:\n        \"\"\"Parse a single file based on its extension.\"\"\"\n        if file_info.extension == \".py\":\n            return self.python_parser.parse_file(file_info.path)\n        elif file_info.extension == \".md\":\n            return self.markdown_parser.parse_file(file_info.path)\n        elif file_info.extension in {\".yaml\", \".yml\"}:\n            return self.yaml_parser.parse_file(file_info.path)\n        elif file_info.extension in {\".js\", \".ts\"}:\n            return self.js_parser.parse_file(file_info.path)\n        elif file_info.extension == \".java\":\n            return self.java_parser.parse_file(file_info.path)\n        else:\n            return ParseResult(\n                file_path=str(file_info.path),\n                entities=[],\n                relationships=[],\n                errors=[f\"Unsupported file type: {file_info.", "tokens": ["def", "parse", "file", "self", "file", "info", "file", "info", "parse", "result", "parse", "single", "file", "based", "on", "its", "extension", "def", "parse", "file", "self", "file", "info", "file", "info", "parse", "result", "parse", "single", "file", "based", "on", "its", "extension", "if", "file", "info", "extension", "py", "return", "self", "python", "parser", "parse", "file", "file", "info", "path", "elif", "file", "info", "extension", "md", "return", "self", "markdown", "parser", "parse", "file", "file", "info", "path", "elif", "file", "info", "extension", "in", "yaml", "yml", "return", "self", "yaml", "parser", "parse", "file", "file", "info", "path", "elif", "file", "info", "extension", "in", "js", "ts", "return", "self", "js", "parser", "parse", "file", "file", "info", "path", "elif", "file", "info", "extension", "java", "return", "self", "java", "parser", "parse", "file", "file", "info", "path", "else", "return", "parse", "result", "file", "path", "str", "file", "info", "path", "entities", "relationships", "errors", "unsupported", "file", "type", "file", "info"], "metadata": {"kind": "method", "chunk_index": "0", "has_docstring": "true", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/graph_builder.py::GraphBuilder._parse_file::1", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/graph_builder.py::GraphBuilder._parse_file", "content": "s=[],\n                relationships=[],\n                errors=[f\"Unsupported file type: {file_info.extension}\"],\n            )", "tokens": ["relationships", "errors", "unsupported", "file", "type", "file", "info", "extension"], "metadata": {"kind": "method", "chunk_index": "1", "has_docstring": "true", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/graph_builder.py::GraphBuilder._merge_result::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/graph_builder.py::GraphBuilder._merge_result", "content": "def _merge_result(self, result: ParseResult) -> None\n\"\"\"Merge parse result into the graph.\"\"\"\n    def _merge_result(self, result: ParseResult) -> None:\n        \"\"\"Merge parse result into the graph.\"\"\"\n        for entity in result.entities:\n            self.entities[entity.id] = entity\n\n        self.relationships.extend(result.relationships)\n        self.errors.extend(result.errors)", "tokens": ["def", "merge", "result", "self", "result", "parse", "result", "none", "merge", "parse", "result", "into", "the", "graph", "def", "merge", "result", "self", "result", "parse", "result", "none", "merge", "parse", "result", "into", "the", "graph", "for", "entity", "in", "result", "entities", "self", "entities", "entity", "id", "entity", "self", "relationships", "extend", "result", "relationships", "self", "errors", "extend", "result", "errors"], "metadata": {"kind": "method", "has_docstring": "true", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/graph_builder.py::GraphBuilder._resolve_references::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/graph_builder.py::GraphBuilder._resolve_references", "content": "def _resolve_references(self) -> None\n\"\"\"Resolve reference-based relationships to actual entity IDs.\n\nSome parsers (like Tree-sitter) may produce relationships pointing to \n'ref::SomeName' because they don't know the full qualified name at parse time.\nThis pass iterates through all relationships and attempts to link these \nplaceholders to concrete Entity IDs in the graph.\"\"\"\n    def _resolve_references(self) -> None:\n        \"\"\"Resolve reference-based relationships to actual entity IDs.\n        \n        Some parsers (like Tree-sitter) may produce relationships pointing to \n        'ref::SomeName' because they don't know the full qualified name at parse time.\n        This pass iterates through all relationships and attempts to link these \n        placeholders to concrete Entity IDs in the graph.\n        \"\"\"\n        resolved_relationships: list[Relationship] = []\n\n        for rel in self.relationships:\n            # Check if target is a reference that needs resolution\n            if rel.", "tokens": ["def", "resolve", "references", "self", "none", "resolve", "reference", "based", "relationships", "to", "actual", "entity", "ids", "some", "parsers", "like", "tree", "sitter", "may", "produce", "relationships", "pointing", "to", "ref", "some", "name", "because", "they", "don", "know", "the", "full", "qualified", "name", "at", "parse", "time", "this", "pass", "iterates", "through", "all", "relationships", "and", "attempts", "to", "link", "these", "placeholders", "to", "concrete", "entity", "ids", "in", "the", "graph", "def", "resolve", "references", "self", "none", "resolve", "reference", "based", "relationships", "to", "actual", "entity", "ids", "some", "parsers", "like", "tree", "sitter", "may", "produce", "relationships", "pointing", "to", "ref", "some", "name", "because", "they", "don", "know", "the", "full", "qualified", "name", "at", "parse", "time", "this", "pass", "iterates", "through", "all", "relationships", "and", "attempts", "to", "link", "these", "placeholders", "to", "concrete", "entity", "ids", "in", "the", "graph", "resolved", "relationships", "list", "relationship", "for", "rel", "in", "self", "relationships", "check", "if", "target", "is", "reference", "that", "needs", "resolution", "if", "rel"], "metadata": {"kind": "method", "chunk_index": "0", "has_docstring": "true", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/graph_builder.py::GraphBuilder._resolve_references::1", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/graph_builder.py::GraphBuilder._resolve_references", "content": "elationships:\n            # Check if target is a reference that needs resolution\n            if rel.target_id.startswith(\"ref::\"):\n                ref_name = rel.target_id[5:]  # Remove \"ref::\" prefix\n                resolved_id = self._find_entity_by_name(ref_name)\n                if resolved_id:\n                    resolved_relationships.append(\n                        Relationship(\n                            source_id=rel.source_id,\n                            target_id=resolved_id,\n                            kind=rel.kind,\n                            metadata=rel.metadata,\n                        )\n                    )\n                else:\n                    # Keep as unresolved reference\n                    resolved_relationships.append(rel)\n            else:\n                resolved_relationships.append(rel)\n\n        self.relationships = resolved_relationships", "tokens": ["elationships", "check", "if", "target", "is", "reference", "that", "needs", "resolution", "if", "rel", "target", "id", "startswith", "ref", "ref", "name", "rel", "target", "id", "remove", "ref", "prefix", "resolved", "id", "self", "find", "entity", "by", "name", "ref", "name", "if", "resolved", "id", "resolved", "relationships", "append", "relationship", "source", "id", "rel", "source", "id", "target", "id", "resolved", "id", "kind", "rel", "kind", "metadata", "rel", "metadata", "else", "keep", "as", "unresolved", "reference", "resolved", "relationships", "append", "rel", "else", "resolved", "relationships", "append", "rel", "self", "relationships", "resolved", "relationships"], "metadata": {"kind": "method", "chunk_index": "1", "has_docstring": "true", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/graph_builder.py::GraphBuilder._find_entity_by_name::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/graph_builder.py::GraphBuilder._find_entity_by_name", "content": "def _find_entity_by_name(self, name: str) -> Optional[str]\n\"\"\"Find entity ID by name or qualified name.\"\"\"\n    def _find_entity_by_name(self, name: str) -> Optional[str]:\n        \"\"\"Find entity ID by name or qualified name.\"\"\"\n        # Exact match on name or qualified_name\n        for entity_id, entity in self.entities.items():\n            if entity.name == name or entity.qualified_name == name:\n                return entity_id\n\n        # Try matching the last part of qualified names\n        for entity_id, entity in self.entities.items():\n            if entity.qualified_name.endswith(f\".{name}\"):\n                return entity_id\n\n        return None", "tokens": ["def", "find", "entity", "by", "name", "self", "name", "str", "optional", "str", "find", "entity", "id", "by", "name", "or", "qualified", "name", "def", "find", "entity", "by", "name", "self", "name", "str", "optional", "str", "find", "entity", "id", "by", "name", "or", "qualified", "name", "exact", "match", "on", "name", "or", "qualified", "name", "for", "entity", "id", "entity", "in", "self", "entities", "items", "if", "entity", "name", "name", "or", "entity", "qualified", "name", "name", "return", "entity", "id", "try", "matching", "the", "last", "part", "of", "qualified", "names", "for", "entity", "id", "entity", "in", "self", "entities", "items", "if", "entity", "qualified", "name", "endswith", "name", "return", "entity", "id", "return", "none"], "metadata": {"kind": "method", "has_docstring": "true", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/graph_builder.py::GraphBuilder.get_entity::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/graph_builder.py::GraphBuilder.get_entity", "content": "def get_entity(self, entity_id: str) -> Optional[Entity]\n\"\"\"Get entity by ID.\"\"\"\n    def get_entity(self, entity_id: str) -> Optional[Entity]:\n        \"\"\"Get entity by ID.\"\"\"\n        return self.entities.get(entity_id)", "tokens": ["def", "get", "entity", "self", "entity", "id", "str", "optional", "entity", "get", "entity", "by", "id", "def", "get", "entity", "self", "entity", "id", "str", "optional", "entity", "get", "entity", "by", "id", "return", "self", "entities", "get", "entity", "id"], "metadata": {"kind": "method", "has_docstring": "true", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/graph_builder.py::GraphBuilder.get_entities_by_kind::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/graph_builder.py::GraphBuilder.get_entities_by_kind", "content": "def get_entities_by_kind(self, kind: str) -> list[Entity]\n\"\"\"Get all entities of a specific kind.\"\"\"\n    def get_entities_by_kind(self, kind: str) -> list[Entity]:\n        \"\"\"Get all entities of a specific kind.\"\"\"\n        return [e for e in self.entities.values() if e.kind.value == kind]", "tokens": ["def", "get", "entities", "by", "kind", "self", "kind", "str", "list", "entity", "get", "all", "entities", "of", "specific", "kind", "def", "get", "entities", "by", "kind", "self", "kind", "str", "list", "entity", "get", "all", "entities", "of", "specific", "kind", "return", "for", "in", "self", "entities", "values", "if", "kind", "value", "kind"], "metadata": {"kind": "method", "has_docstring": "true", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/graph_builder.py::GraphBuilder.get_outgoing_relationships::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/graph_builder.py::GraphBuilder.get_outgoing_relationships", "content": "def get_outgoing_relationships(self, entity_id: str) -> list[Relationship]\n\"\"\"Get all relationships where entity is the source.\"\"\"\n    def get_outgoing_relationships(self, entity_id: str) -> list[Relationship]:\n        \"\"\"Get all relationships where entity is the source.\"\"\"\n        return [r for r in self.relationships if r.source_id == entity_id]", "tokens": ["def", "get", "outgoing", "relationships", "self", "entity", "id", "str", "list", "relationship", "get", "all", "relationships", "where", "entity", "is", "the", "source", "def", "get", "outgoing", "relationships", "self", "entity", "id", "str", "list", "relationship", "get", "all", "relationships", "where", "entity", "is", "the", "source", "return", "for", "in", "self", "relationships", "if", "source", "id", "entity", "id"], "metadata": {"kind": "method", "has_docstring": "true", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/graph_builder.py::GraphBuilder.get_incoming_relationships::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/graph_builder.py::GraphBuilder.get_incoming_relationships", "content": "def get_incoming_relationships(self, entity_id: str) -> list[Relationship]\n\"\"\"Get all relationships where entity is the target.\"\"\"\n    def get_incoming_relationships(self, entity_id: str) -> list[Relationship]:\n        \"\"\"Get all relationships where entity is the target.\"\"\"\n        return [r for r in self.relationships if r.target_id == entity_id]", "tokens": ["def", "get", "incoming", "relationships", "self", "entity", "id", "str", "list", "relationship", "get", "all", "relationships", "where", "entity", "is", "the", "target", "def", "get", "incoming", "relationships", "self", "entity", "id", "str", "list", "relationship", "get", "all", "relationships", "where", "entity", "is", "the", "target", "return", "for", "in", "self", "relationships", "if", "target", "id", "entity", "id"], "metadata": {"kind": "method", "has_docstring": "true", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/graph_builder.py::GraphBuilder.search_entities::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/graph_builder.py::GraphBuilder.search_entities", "content": "def search_entities(self, pattern: str) -> list[Entity]\n\"\"\"Search entities by name pattern (case-insensitive substring).\"\"\"\n    def search_entities(self, pattern: str) -> list[Entity]:\n        \"\"\"Search entities by name pattern (case-insensitive substring).\"\"\"\n        pattern_lower = pattern.lower()\n        return [\n            e for e in self.entities.values()\n            if pattern_lower in e.name.lower()\n            or pattern_lower in e.qualified_name.lower()\n        ]", "tokens": ["def", "search", "entities", "self", "pattern", "str", "list", "entity", "search", "entities", "by", "name", "pattern", "case", "insensitive", "substring", "def", "search", "entities", "self", "pattern", "str", "list", "entity", "search", "entities", "by", "name", "pattern", "case", "insensitive", "substring", "pattern", "lower", "pattern", "lower", "return", "for", "in", "self", "entities", "values", "if", "pattern", "lower", "in", "name", "lower", "or", "pattern", "lower", "in", "qualified", "name", "lower"], "metadata": {"kind": "method", "has_docstring": "true", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/graph_builder.py::GraphBuilder.stats::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/graph_builder.py::GraphBuilder.stats", "content": "def stats(self) -> dict[str, int]\n\"\"\"Return statistics about the graph.\"\"\"\n    def stats(self) -> dict[str, int]:\n        \"\"\"Return statistics about the graph.\"\"\"\n        kind_counts: dict[str, int] = {}\n        for entity in self.entities.values():\n            kind = entity.kind.value\n            kind_counts[kind] = kind_counts.get(kind, 0) + 1\n\n        rel_counts: dict[str, int] = {}\n        for rel in self.relationships:\n            kind = rel.kind.value\n            rel_counts[kind] = rel_counts.get(kind, 0) + 1\n\n        return {\n            \"total_entities\": len(self.entities),\n            \"total_relationships\": len(self.relationships),\n            \"total_errors\": len(self.errors),\n            **{f\"entities_{k}\": v for k, v in kind_counts.items()},\n            **{f\"relationships_{k}\": v for k, v in rel_counts.items()},\n        }", "tokens": ["def", "stats", "self", "dict", "str", "int", "return", "statistics", "about", "the", "graph", "def", "stats", "self", "dict", "str", "int", "return", "statistics", "about", "the", "graph", "kind", "counts", "dict", "str", "int", "for", "entity", "in", "self", "entities", "values", "kind", "entity", "kind", "value", "kind", "counts", "kind", "kind", "counts", "get", "kind", "rel", "counts", "dict", "str", "int", "for", "rel", "in", "self", "relationships", "kind", "rel", "kind", "value", "rel", "counts", "kind", "rel", "counts", "get", "kind", "return", "total", "entities", "len", "self", "entities", "total", "relationships", "len", "self", "relationships", "total", "errors", "len", "self", "errors", "entities", "for", "in", "kind", "counts", "items", "relationships", "for", "in", "rel", "counts", "items"], "metadata": {"kind": "method", "has_docstring": "true", "last_modified": "1766236633.3722243"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/monitor.py::module::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/monitor.py::module", "content": "\"\"\"File system monitor for live re-indexing.\"\"\"", "tokens": ["file", "system", "monitor", "for", "live", "re", "indexing"], "metadata": {"type": "module_header"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/monitor.py::imports::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/monitor.py::module", "content": "from __future__ import annotations\nfrom pathlib import Path\nfrom typing import Optional, TYPE_CHECKING\n    from watchdog.observers import Observer\n    from watchdog.events import FileSystemEventHandler\n    from knowcode.indexing.background_indexer import BackgroundIndexer", "tokens": ["from", "future", "import", "annotations", "from", "pathlib", "import", "path", "from", "typing", "import", "optional", "type", "checking", "from", "watchdog", "observers", "import", "observer", "from", "watchdog", "events", "import", "file", "system", "event", "handler", "from", "knowcode", "indexing", "background", "indexer", "import", "background", "indexer"], "metadata": {"type": "imports"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/monitor.py::FileMonitor::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/monitor.py::FileMonitor", "content": "\"\"\"Watches for file changes to trigger re-indexing.\"\"\"\nclass FileMonitor:\n    \"\"\"Watches for file changes to trigger re-indexing.\"\"\"\n\n    def __init__(self, root_dir: str | Path, background_indexer: Optional[\"BackgroundIndexer\"] = None) -> None:\n        \"\"\"Initialize a file system monitor.\n\n        Args:\n            root_dir: Root directory to watch.\n            background_indexer: Optional background indexer to notify on changes.\n        \"\"\"\n        self.root_dir = Path(root_dir)\n        self.background_indexer = background_indexer\n        self.observer = None\n\n    def start(self) -> None:\n        \"\"\"Start watching the directory for changes.\"\"\"\n        if not Observer:\n            print(\"watchdog not installed. Watch mode disabled.\")\n            return\n\n        event_handler = IndexingHandler(self.background_indexer)\n        self.observer = Observer()\n        self.observer.schedule(event_handler, str(self.root_dir), recursive=True)\n        self.observer.start()\n\n    def stop(self) -> ", "tokens": ["watches", "for", "file", "changes", "to", "trigger", "re", "indexing", "class", "file", "monitor", "watches", "for", "file", "changes", "to", "trigger", "re", "indexing", "def", "init", "self", "root", "dir", "str", "path", "background", "indexer", "optional", "background", "indexer", "none", "none", "initialize", "file", "system", "monitor", "args", "root", "dir", "root", "directory", "to", "watch", "background", "indexer", "optional", "background", "indexer", "to", "notify", "on", "changes", "self", "root", "dir", "path", "root", "dir", "self", "background", "indexer", "background", "indexer", "self", "observer", "none", "def", "start", "self", "none", "start", "watching", "the", "directory", "for", "changes", "if", "not", "observer", "print", "watchdog", "not", "installed", "watch", "mode", "disabled", "return", "event", "handler", "indexing", "handler", "self", "background", "indexer", "self", "observer", "observer", "self", "observer", "schedule", "event", "handler", "str", "self", "root", "dir", "recursive", "true", "self", "observer", "start", "def", "stop", "self"], "metadata": {"kind": "class", "chunk_index": "0", "has_docstring": "true", "last_modified": "1768185812.9930828"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/monitor.py::FileMonitor::1", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/monitor.py::FileMonitor", "content": "t_handler, str(self.root_dir), recursive=True)\n        self.observer.start()\n\n    def stop(self) -> None:\n        \"\"\"Stop watching and join the observer thread.\"\"\"\n        if self.observer:\n            self.observer.stop()\n            self.observer.join()", "tokens": ["handler", "str", "self", "root", "dir", "recursive", "true", "self", "observer", "start", "def", "stop", "self", "none", "stop", "watching", "and", "join", "the", "observer", "thread", "if", "self", "observer", "self", "observer", "stop", "self", "observer", "join"], "metadata": {"kind": "class", "chunk_index": "1", "has_docstring": "true", "last_modified": "1768185812.9930828"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/monitor.py::FileMonitor.__init__::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/monitor.py::FileMonitor.__init__", "content": "def __init__(self, root_dir: str | Path, background_indexer: Optional['BackgroundIndexer']) -> None\n\"\"\"Initialize a file system monitor.\n\nArgs:\n    root_dir: Root directory to watch.\n    background_indexer: Optional background indexer to notify on changes.\"\"\"\n    def __init__(self, root_dir: str | Path, background_indexer: Optional[\"BackgroundIndexer\"] = None) -> None:\n        \"\"\"Initialize a file system monitor.\n\n        Args:\n            root_dir: Root directory to watch.\n            background_indexer: Optional background indexer to notify on changes.\n        \"\"\"\n        self.root_dir = Path(root_dir)\n        self.background_indexer = background_indexer\n        self.observer = None", "tokens": ["def", "init", "self", "root", "dir", "str", "path", "background", "indexer", "optional", "background", "indexer", "none", "initialize", "file", "system", "monitor", "args", "root", "dir", "root", "directory", "to", "watch", "background", "indexer", "optional", "background", "indexer", "to", "notify", "on", "changes", "def", "init", "self", "root", "dir", "str", "path", "background", "indexer", "optional", "background", "indexer", "none", "none", "initialize", "file", "system", "monitor", "args", "root", "dir", "root", "directory", "to", "watch", "background", "indexer", "optional", "background", "indexer", "to", "notify", "on", "changes", "self", "root", "dir", "path", "root", "dir", "self", "background", "indexer", "background", "indexer", "self", "observer", "none"], "metadata": {"kind": "method", "has_docstring": "true", "last_modified": "1768185812.9930828"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/monitor.py::FileMonitor.start::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/monitor.py::FileMonitor.start", "content": "def start(self) -> None\n\"\"\"Start watching the directory for changes.\"\"\"\n    def start(self) -> None:\n        \"\"\"Start watching the directory for changes.\"\"\"\n        if not Observer:\n            print(\"watchdog not installed. Watch mode disabled.\")\n            return\n\n        event_handler = IndexingHandler(self.background_indexer)\n        self.observer = Observer()\n        self.observer.schedule(event_handler, str(self.root_dir), recursive=True)\n        self.observer.start()", "tokens": ["def", "start", "self", "none", "start", "watching", "the", "directory", "for", "changes", "def", "start", "self", "none", "start", "watching", "the", "directory", "for", "changes", "if", "not", "observer", "print", "watchdog", "not", "installed", "watch", "mode", "disabled", "return", "event", "handler", "indexing", "handler", "self", "background", "indexer", "self", "observer", "observer", "self", "observer", "schedule", "event", "handler", "str", "self", "root", "dir", "recursive", "true", "self", "observer", "start"], "metadata": {"kind": "method", "has_docstring": "true", "last_modified": "1768185812.9930828"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/monitor.py::FileMonitor.stop::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/monitor.py::FileMonitor.stop", "content": "def stop(self) -> None\n\"\"\"Stop watching and join the observer thread.\"\"\"\n    def stop(self) -> None:\n        \"\"\"Stop watching and join the observer thread.\"\"\"\n        if self.observer:\n            self.observer.stop()\n            self.observer.join()", "tokens": ["def", "stop", "self", "none", "stop", "watching", "and", "join", "the", "observer", "thread", "def", "stop", "self", "none", "stop", "watching", "and", "join", "the", "observer", "thread", "if", "self", "observer", "self", "observer", "stop", "self", "observer", "join"], "metadata": {"kind": "method", "has_docstring": "true", "last_modified": "1768185812.9930828"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/monitor.py::IndexingHandler::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/monitor.py::IndexingHandler", "content": "\"\"\"Handles file system events for indexing.\"\"\"\nclass IndexingHandler(FileSystemEventHandler):\n    \"\"\"Handles file system events for indexing.\"\"\"\n\n    def __init__(self, background_indexer: Optional[\"BackgroundIndexer\"]) -> None:\n        \"\"\"Initialize the handler with an optional background indexer.\n\n        Args:\n            background_indexer: Worker responsible for indexing changed files.\n        \"\"\"\n        self.background_indexer = background_indexer\n\n    def on_modified(self, event):\n        \"\"\"Handle modified file events.\"\"\"\n        if not event.is_directory:\n            self._handle_change(event.src_path)\n\n    def on_created(self, event):\n        \"\"\"Handle created file events.\"\"\"\n        if not event.is_directory:\n            self._handle_change(event.src_path)\n\n    def _handle_change(self, path_str: str) -> None:\n        \"\"\"Queue a file for indexing if it is a supported source type.\"\"\"\n        if self.background_indexer:\n            path = Path(path_str)\n            # Basic ext", "tokens": ["handles", "file", "system", "events", "for", "indexing", "class", "indexing", "handler", "file", "system", "event", "handler", "handles", "file", "system", "events", "for", "indexing", "def", "init", "self", "background", "indexer", "optional", "background", "indexer", "none", "initialize", "the", "handler", "with", "an", "optional", "background", "indexer", "args", "background", "indexer", "worker", "responsible", "for", "indexing", "changed", "files", "self", "background", "indexer", "background", "indexer", "def", "on", "modified", "self", "event", "handle", "modified", "file", "events", "if", "not", "event", "is", "directory", "self", "handle", "change", "event", "src", "path", "def", "on", "created", "self", "event", "handle", "created", "file", "events", "if", "not", "event", "is", "directory", "self", "handle", "change", "event", "src", "path", "def", "handle", "change", "self", "path", "str", "str", "none", "queue", "file", "for", "indexing", "if", "it", "is", "supported", "source", "type", "if", "self", "background", "indexer", "path", "path", "path", "str", "basic", "ext"], "metadata": {"kind": "class", "chunk_index": "0", "has_docstring": "true", "last_modified": "1768185812.9930828"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/monitor.py::IndexingHandler::1", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/monitor.py::IndexingHandler", "content": "pe.\"\"\"\n        if self.background_indexer:\n            path = Path(path_str)\n            # Basic extension filtering\n            if path.suffix in {\".py\", \".js\", \".ts\", \".java\", \".md\", \".yml\", \".yaml\"}:\n                self.background_indexer.queue_file(path)", "tokens": ["pe", "if", "self", "background", "indexer", "path", "path", "path", "str", "basic", "extension", "filtering", "if", "path", "suffix", "in", "py", "js", "ts", "java", "md", "yml", "yaml", "self", "background", "indexer", "queue", "file", "path"], "metadata": {"kind": "class", "chunk_index": "1", "has_docstring": "true", "last_modified": "1768185812.9930828"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/monitor.py::IndexingHandler.__init__::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/monitor.py::IndexingHandler.__init__", "content": "def __init__(self, background_indexer: Optional['BackgroundIndexer']) -> None\n\"\"\"Initialize the handler with an optional background indexer.\n\nArgs:\n    background_indexer: Worker responsible for indexing changed files.\"\"\"\n    def __init__(self, background_indexer: Optional[\"BackgroundIndexer\"]) -> None:\n        \"\"\"Initialize the handler with an optional background indexer.\n\n        Args:\n            background_indexer: Worker responsible for indexing changed files.\n        \"\"\"\n        self.background_indexer = background_indexer", "tokens": ["def", "init", "self", "background", "indexer", "optional", "background", "indexer", "none", "initialize", "the", "handler", "with", "an", "optional", "background", "indexer", "args", "background", "indexer", "worker", "responsible", "for", "indexing", "changed", "files", "def", "init", "self", "background", "indexer", "optional", "background", "indexer", "none", "initialize", "the", "handler", "with", "an", "optional", "background", "indexer", "args", "background", "indexer", "worker", "responsible", "for", "indexing", "changed", "files", "self", "background", "indexer", "background", "indexer"], "metadata": {"kind": "method", "has_docstring": "true", "last_modified": "1768185812.9930828"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/monitor.py::IndexingHandler.on_modified::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/monitor.py::IndexingHandler.on_modified", "content": "def on_modified(self, event)\n\"\"\"Handle modified file events.\"\"\"\n    def on_modified(self, event):\n        \"\"\"Handle modified file events.\"\"\"\n        if not event.is_directory:\n            self._handle_change(event.src_path)", "tokens": ["def", "on", "modified", "self", "event", "handle", "modified", "file", "events", "def", "on", "modified", "self", "event", "handle", "modified", "file", "events", "if", "not", "event", "is", "directory", "self", "handle", "change", "event", "src", "path"], "metadata": {"kind": "method", "has_docstring": "true", "last_modified": "1768185812.9930828"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/monitor.py::IndexingHandler.on_created::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/monitor.py::IndexingHandler.on_created", "content": "def on_created(self, event)\n\"\"\"Handle created file events.\"\"\"\n    def on_created(self, event):\n        \"\"\"Handle created file events.\"\"\"\n        if not event.is_directory:\n            self._handle_change(event.src_path)", "tokens": ["def", "on", "created", "self", "event", "handle", "created", "file", "events", "def", "on", "created", "self", "event", "handle", "created", "file", "events", "if", "not", "event", "is", "directory", "self", "handle", "change", "event", "src", "path"], "metadata": {"kind": "method", "has_docstring": "true", "last_modified": "1768185812.9930828"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/monitor.py::IndexingHandler._handle_change::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/indexing/monitor.py::IndexingHandler._handle_change", "content": "def _handle_change(self, path_str: str) -> None\n\"\"\"Queue a file for indexing if it is a supported source type.\"\"\"\n    def _handle_change(self, path_str: str) -> None:\n        \"\"\"Queue a file for indexing if it is a supported source type.\"\"\"\n        if self.background_indexer:\n            path = Path(path_str)\n            # Basic extension filtering\n            if path.suffix in {\".py\", \".js\", \".ts\", \".java\", \".md\", \".yml\", \".yaml\"}:\n                self.background_indexer.queue_file(path)", "tokens": ["def", "handle", "change", "self", "path", "str", "str", "none", "queue", "file", "for", "indexing", "if", "it", "is", "supported", "source", "type", "def", "handle", "change", "self", "path", "str", "str", "none", "queue", "file", "for", "indexing", "if", "it", "is", "supported", "source", "type", "if", "self", "background", "indexer", "path", "path", "path", "str", "basic", "extension", "filtering", "if", "path", "suffix", "in", "py", "js", "ts", "java", "md", "yml", "yaml", "self", "background", "indexer", "queue", "file", "path"], "metadata": {"kind": "method", "has_docstring": "true", "last_modified": "1768185812.9930828"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/api/main.py::module::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/api/main.py::module", "content": "\"\"\"Main entry point for the KnowCode FastAPI server.\"\"\"", "tokens": ["main", "entry", "point", "for", "the", "know", "code", "fast", "api", "server"], "metadata": {"type": "module_header"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/api/main.py::imports::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/api/main.py::module", "content": "from pathlib import Path\nimport uvicorn\nfrom fastapi import FastAPI\nfrom . import api\nfrom knowcode.service import KnowCodeService\n        from knowcode.indexing.background_indexer import BackgroundIndexer\n        from knowcode.indexing.monitor import FileMonitor", "tokens": ["from", "pathlib", "import", "path", "import", "uvicorn", "from", "fastapi", "import", "fast", "api", "from", "import", "api", "from", "knowcode", "service", "import", "know", "code", "service", "from", "knowcode", "indexing", "background", "indexer", "import", "background", "indexer", "from", "knowcode", "indexing", "monitor", "import", "file", "monitor"], "metadata": {"type": "imports"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/api/main.py::create_app::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/api/main.py::create_app", "content": "def create_app(store_path: str, watch: bool) -> FastAPI\n\"\"\"Create and configure the FastAPI application.\n\nArgs:\n    store_path: File or directory containing the knowledge store.\n    watch: Whether to enable background file watching and re-indexing.\n\nReturns:\n    Configured FastAPI application instance.\"\"\"\ndef create_app(store_path: str = \".\", watch: bool = False) -> FastAPI:\n    \"\"\"Create and configure the FastAPI application.\n\n    Args:\n        store_path: File or directory containing the knowledge store.\n        watch: Whether to enable background file watching and re-indexing.\n\n    Returns:\n        Configured FastAPI application instance.\n    \"\"\"\n    app = FastAPI(\n        title=\"KnowCode API\",\n        description=\"Local intelligence server for Codebase Knowledge Graph\",\n        version=\"2.0.0\",\n    )\n\n    # Initialize service\n    service = KnowCodeService(store_path=store_path)\n    api._service = service\n    \n    if watch:\n        from knowcode.indexing.background_indexer import Ba", "tokens": ["def", "create", "app", "store", "path", "str", "watch", "bool", "fast", "api", "create", "and", "configure", "the", "fast", "api", "application", "args", "store", "path", "file", "or", "directory", "containing", "the", "knowledge", "store", "watch", "whether", "to", "enable", "background", "file", "watching", "and", "re", "indexing", "returns", "configured", "fast", "api", "application", "instance", "def", "create", "app", "store", "path", "str", "watch", "bool", "false", "fast", "api", "create", "and", "configure", "the", "fast", "api", "application", "args", "store", "path", "file", "or", "directory", "containing", "the", "knowledge", "store", "watch", "whether", "to", "enable", "background", "file", "watching", "and", "re", "indexing", "returns", "configured", "fast", "api", "application", "instance", "app", "fast", "api", "title", "know", "code", "api", "description", "local", "intelligence", "server", "for", "codebase", "knowledge", "graph", "version", "initialize", "service", "service", "know", "code", "service", "store", "path", "store", "path", "api", "service", "service", "if", "watch", "from", "knowcode", "indexing", "background", "indexer", "import", "ba"], "metadata": {"kind": "function", "chunk_index": "0", "has_docstring": "true", "last_modified": "1766231204.5701377"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/api/main.py::create_app::1", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/api/main.py::create_app", "content": "pi._service = service\n    \n    if watch:\n        from knowcode.indexing.background_indexer import BackgroundIndexer\n        from knowcode.indexing.monitor import FileMonitor\n        \n        indexer = service.get_indexer()\n        bg_indexer = BackgroundIndexer(indexer)\n        bg_indexer.start()\n        \n        # Determine watch root (directory where store is, or current dir)\n        watch_root = Path(store_path).parent if Path(store_path).is_file() else Path(store_path)\n        monitor = FileMonitor(watch_root, bg_indexer)\n        monitor.start()\n        \n        # Store on app state to keep alive\n        app.state.monitor = monitor\n        app.state.bg_indexer = bg_indexer\n\n    app.include_router(api.router)\n\n    return app", "tokens": ["pi", "service", "service", "if", "watch", "from", "knowcode", "indexing", "background", "indexer", "import", "background", "indexer", "from", "knowcode", "indexing", "monitor", "import", "file", "monitor", "indexer", "service", "get", "indexer", "bg", "indexer", "background", "indexer", "indexer", "bg", "indexer", "start", "determine", "watch", "root", "directory", "where", "store", "is", "or", "current", "dir", "watch", "root", "path", "store", "path", "parent", "if", "path", "store", "path", "is", "file", "else", "path", "store", "path", "monitor", "file", "monitor", "watch", "root", "bg", "indexer", "monitor", "start", "store", "on", "app", "state", "to", "keep", "alive", "app", "state", "monitor", "monitor", "app", "state", "bg", "indexer", "bg", "indexer", "app", "include", "router", "api", "router", "return", "app"], "metadata": {"kind": "function", "chunk_index": "1", "has_docstring": "true", "last_modified": "1766231204.5701377"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/api/main.py::start_server::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/api/main.py::start_server", "content": "def start_server(host: str, port: int, store_path: str, watch: bool)\n\"\"\"Start the uvicorn server with the configured app.\n\nArgs:\n    host: Bind address for the server.\n    port: Port to listen on.\n    store_path: Knowledge store location used by the API.\n    watch: Whether to enable background file monitoring.\"\"\"\ndef start_server(host: str = \"127.0.0.1\", port: int = 8000, store_path: str = \".\", watch: bool = False):\n    \"\"\"Start the uvicorn server with the configured app.\n\n    Args:\n        host: Bind address for the server.\n        port: Port to listen on.\n        store_path: Knowledge store location used by the API.\n        watch: Whether to enable background file monitoring.\n    \"\"\"\n    app = create_app(store_path=store_path, watch=watch)\n    uvicorn.run(app, host=host, port=port)", "tokens": ["def", "start", "server", "host", "str", "port", "int", "store", "path", "str", "watch", "bool", "start", "the", "uvicorn", "server", "with", "the", "configured", "app", "args", "host", "bind", "address", "for", "the", "server", "port", "port", "to", "listen", "on", "store", "path", "knowledge", "store", "location", "used", "by", "the", "api", "watch", "whether", "to", "enable", "background", "file", "monitoring", "def", "start", "server", "host", "str", "127", "port", "int", "8000", "store", "path", "str", "watch", "bool", "false", "start", "the", "uvicorn", "server", "with", "the", "configured", "app", "args", "host", "bind", "address", "for", "the", "server", "port", "port", "to", "listen", "on", "store", "path", "knowledge", "store", "location", "used", "by", "the", "api", "watch", "whether", "to", "enable", "background", "file", "monitoring", "app", "create", "app", "store", "path", "store", "path", "watch", "watch", "uvicorn", "run", "app", "host", "host", "port", "port"], "metadata": {"kind": "function", "has_docstring": "true", "last_modified": "1766231204.5701377"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/api/__init__.py::module::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/api/__init__.py::module", "content": "\"\"\"API package for KnowCode server modules.\"\"\"", "tokens": ["api", "package", "for", "know", "code", "server", "modules"], "metadata": {"type": "module_header"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/api/api.py::module::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/api/api.py::module", "content": "\"\"\"FastAPI endpoints for KnowCode.\"\"\"", "tokens": ["fast", "api", "endpoints", "for", "know", "code"], "metadata": {"type": "module_header"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/api/api.py::imports::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/api/api.py::module", "content": "from fastapi import APIRouter, Depends, HTTPException, Query\nfrom typing import Any, Optional\nfrom pydantic import BaseModel\nfrom enum import Enum\nfrom knowcode.service import KnowCodeService\nfrom knowcode.data_models import TaskType", "tokens": ["from", "fastapi", "import", "apirouter", "depends", "httpexception", "query", "from", "typing", "import", "any", "optional", "from", "pydantic", "import", "base", "model", "from", "enum", "import", "enum", "from", "knowcode", "service", "import", "know", "code", "service", "from", "knowcode", "data", "models", "import", "task", "type"], "metadata": {"type": "imports"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/api/api.py::get_service::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/api/api.py::get_service", "content": "def get_service() -> KnowCodeService\n\"\"\"Return the global service instance or raise if uninitialized.\"\"\"\ndef get_service() -> KnowCodeService:\n    \"\"\"Return the global service instance or raise if uninitialized.\"\"\"\n    if _service is None:\n        raise HTTPException(status_code=503, detail=\"Service not initialized\")\n    return _service", "tokens": ["def", "get", "service", "know", "code", "service", "return", "the", "global", "service", "instance", "or", "raise", "if", "uninitialized", "def", "get", "service", "know", "code", "service", "return", "the", "global", "service", "instance", "or", "raise", "if", "uninitialized", "if", "service", "is", "none", "raise", "httpexception", "status", "code", "503", "detail", "service", "not", "initialized", "return", "service"], "metadata": {"kind": "function", "has_docstring": "true", "last_modified": "1768185812.9927197"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/api/api.py::TaskTypeParam::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/api/api.py::TaskTypeParam", "content": "\"\"\"Task type for context prioritization.\"\"\"\nclass TaskTypeParam(str, Enum):\n    \"\"\"Task type for context prioritization.\"\"\"\n    explain = \"explain\"\n    debug = \"debug\"\n    extend = \"extend\"\n    review = \"review\"\n    locate = \"locate\"\n    general = \"general\"", "tokens": ["task", "type", "for", "context", "prioritization", "class", "task", "type", "param", "str", "enum", "task", "type", "for", "context", "prioritization", "explain", "explain", "debug", "debug", "extend", "extend", "review", "review", "locate", "locate", "general", "general"], "metadata": {"kind": "class", "has_docstring": "true", "last_modified": "1768185812.9927197"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/api/api.py::SearchResult::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/api/api.py::SearchResult", "content": "\"\"\"Response model for entity search results.\"\"\"\nclass SearchResult(BaseModel):\n    \"\"\"Response model for entity search results.\"\"\"\n    id: str\n    kind: str\n    name: str\n    qualified_name: str\n    file: str\n    line: int", "tokens": ["response", "model", "for", "entity", "search", "results", "class", "search", "result", "base", "model", "response", "model", "for", "entity", "search", "results", "id", "str", "kind", "str", "name", "str", "qualified", "name", "str", "file", "str", "line", "int"], "metadata": {"kind": "class", "has_docstring": "true", "last_modified": "1768185812.9927197"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/api/api.py::ContextResponse::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/api/api.py::ContextResponse", "content": "\"\"\"Response model for synthesized entity context.\"\"\"\nclass ContextResponse(BaseModel):\n    \"\"\"Response model for synthesized entity context.\"\"\"\n    entity_id: str\n    context_text: str\n    total_tokens: int\n    truncated: bool\n    included_entities: list[str]\n    task_type: str = \"general\"\n    sufficiency_score: float = 0.0", "tokens": ["response", "model", "for", "synthesized", "entity", "context", "class", "context", "response", "base", "model", "response", "model", "for", "synthesized", "entity", "context", "entity", "id", "str", "context", "text", "str", "total", "tokens", "int", "truncated", "bool", "included", "entities", "list", "str", "task", "type", "str", "general", "sufficiency", "score", "float"], "metadata": {"kind": "class", "has_docstring": "true", "last_modified": "1768185812.9927197"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/api/api.py::ChunkResult::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/api/api.py::ChunkResult", "content": "\"\"\"Response model for a retrieved chunk.\"\"\"\nclass ChunkResult(BaseModel):\n    \"\"\"Response model for a retrieved chunk.\"\"\"\n    id: str\n    content: str\n    entity_id: str\n    score: float", "tokens": ["response", "model", "for", "retrieved", "chunk", "class", "chunk", "result", "base", "model", "response", "model", "for", "retrieved", "chunk", "id", "str", "content", "str", "entity", "id", "str", "score", "float"], "metadata": {"kind": "class", "has_docstring": "true", "last_modified": "1768185812.9927197"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/api/api.py::QueryRequest::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/api/api.py::QueryRequest", "content": "\"\"\"Request model for semantic search queries.\"\"\"\nclass QueryRequest(BaseModel):\n    \"\"\"Request model for semantic search queries.\"\"\"\n    query: str\n    limit: Optional[int] = 5\n    expand_deps: Optional[bool] = True\n    task_type: Optional[TaskTypeParam] = TaskTypeParam.general", "tokens": ["request", "model", "for", "semantic", "search", "queries", "class", "query", "request", "base", "model", "request", "model", "for", "semantic", "search", "queries", "query", "str", "limit", "optional", "int", "expand", "deps", "optional", "bool", "true", "task", "type", "optional", "task", "type", "param", "task", "type", "param", "general"], "metadata": {"kind": "class", "has_docstring": "true", "last_modified": "1768185812.9927197"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/api/api.py::QueryResponse::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/api/api.py::QueryResponse", "content": "\"\"\"Response model for semantic search queries.\"\"\"\nclass QueryResponse(BaseModel):\n    \"\"\"Response model for semantic search queries.\"\"\"\n    chunks: list[ChunkResult]\n    total: int\n    task_type: str = \"general\"", "tokens": ["response", "model", "for", "semantic", "search", "queries", "class", "query", "response", "base", "model", "response", "model", "for", "semantic", "search", "queries", "chunks", "list", "chunk", "result", "total", "int", "task", "type", "str", "general"], "metadata": {"kind": "class", "has_docstring": "true", "last_modified": "1768185812.9927197"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/api/api.py::health::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/api/api.py::health", "content": "def health() -> dict[str, str]\n\"\"\"Check if the server is running and reachable.\"\"\"\ndef health() -> dict[str, str]:\n    \"\"\"Check if the server is running and reachable.\"\"\"\n    return {\"status\": \"ok\"}", "tokens": ["def", "health", "dict", "str", "str", "check", "if", "the", "server", "is", "running", "and", "reachable", "def", "health", "dict", "str", "str", "check", "if", "the", "server", "is", "running", "and", "reachable", "return", "status", "ok"], "metadata": {"kind": "function", "has_docstring": "true", "last_modified": "1768185812.9927197"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/api/api.py::get_stats::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/api/api.py::get_stats", "content": "def get_stats(service: KnowCodeService) -> dict[str, Any]\n\"\"\"Returns statistics about the number of entities and relationships in the graph.\"\"\"\ndef get_stats(service: KnowCodeService = Depends(get_service)) -> dict[str, Any]:\n    \"\"\"Returns statistics about the number of entities and relationships in the graph.\"\"\"\n    return service.get_stats()", "tokens": ["def", "get", "stats", "service", "know", "code", "service", "dict", "str", "any", "returns", "statistics", "about", "the", "number", "of", "entities", "and", "relationships", "in", "the", "graph", "def", "get", "stats", "service", "know", "code", "service", "depends", "get", "service", "dict", "str", "any", "returns", "statistics", "about", "the", "number", "of", "entities", "and", "relationships", "in", "the", "graph", "return", "service", "get", "stats"], "metadata": {"kind": "function", "has_docstring": "true", "last_modified": "1768185812.9927197"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/api/api.py::query_context::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/api/api.py::query_context", "content": "def query_context(request: QueryRequest, service: KnowCodeService) -> QueryResponse\n\"\"\"Execute semantic search and return relevant code chunks with context.\"\"\"\ndef query_context(\n    request: QueryRequest,\n    service: KnowCodeService = Depends(get_service)\n) -> QueryResponse:\n    \"\"\"Execute semantic search and return relevant code chunks with context.\"\"\"\n    engine = service.get_search_engine()\n    chunks = engine.search(\n        query=request.query,\n        limit=request.limit or 5,\n        expand_deps=request.expand_deps if request.expand_deps is not None else True\n    )\n    \n    results = [\n        ChunkResult(\n            id=c.id,\n            content=c.content,\n            entity_id=c.entity_id,\n            score=0.0 # Score not easily exposed from engine currently\n        )\n        for c in chunks\n    ]\n    \n    return QueryResponse(\n        chunks=results,\n        total=len(results),\n        task_type=request.task_type.value if request.task_type else \"general\"\n    )", "tokens": ["def", "query", "context", "request", "query", "request", "service", "know", "code", "service", "query", "response", "execute", "semantic", "search", "and", "return", "relevant", "code", "chunks", "with", "context", "def", "query", "context", "request", "query", "request", "service", "know", "code", "service", "depends", "get", "service", "query", "response", "execute", "semantic", "search", "and", "return", "relevant", "code", "chunks", "with", "context", "engine", "service", "get", "search", "engine", "chunks", "engine", "search", "query", "request", "query", "limit", "request", "limit", "or", "expand", "deps", "request", "expand", "deps", "if", "request", "expand", "deps", "is", "not", "none", "else", "true", "results", "chunk", "result", "id", "id", "content", "content", "entity", "id", "entity", "id", "score", "score", "not", "easily", "exposed", "from", "engine", "currently", "for", "in", "chunks", "return", "query", "response", "chunks", "results", "total", "len", "results", "task", "type", "request", "task", "type", "value", "if", "request", "task", "type", "else", "general"], "metadata": {"kind": "function", "has_docstring": "true", "last_modified": "1768185812.9927197"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/api/api.py::search::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/api/api.py::search", "content": "def search(q: str, service: KnowCodeService) -> list[Any]\n\"\"\"Search for entities matching the given query string.\"\"\"\ndef search(\n    q: str = Query(..., min_length=1, description=\"Search pattern (substring match on name or qualified name)\"),\n    service: KnowCodeService = Depends(get_service)\n) -> list[Any]:\n    \"\"\"Search for entities matching the given query string.\"\"\"\n    return service.search(q)", "tokens": ["def", "search", "str", "service", "know", "code", "service", "list", "any", "search", "for", "entities", "matching", "the", "given", "query", "string", "def", "search", "str", "query", "min", "length", "description", "search", "pattern", "substring", "match", "on", "name", "or", "qualified", "name", "service", "know", "code", "service", "depends", "get", "service", "list", "any", "search", "for", "entities", "matching", "the", "given", "query", "string", "return", "service", "search"], "metadata": {"kind": "function", "has_docstring": "true", "last_modified": "1768185812.9927197"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/api/api.py::get_context::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/api/api.py::get_context", "content": "def get_context(target: str, max_tokens: int, task_type: TaskTypeParam, service: KnowCodeService) -> Any\n\"\"\"Generates a synthesized context bundle for an entity, optimized for LLM consumption.\n\nThe task_type parameter enables task-specific context prioritization:\n- explain: Prioritizes docstrings, signatures, and callees for understanding\n- debug: Prioritizes source code and callers for tracing issues\n- extend: Prioritizes patterns, children, and signatures for adding code\n- review: Prioritizes changes, callers, and callees for impact analysis\n- locate: Minimal context, just location info\n- general: Balanced context (default)\n\nReturns sufficiency_score (0.0-1.0) indicating if context is sufficient for local answering.\"\"\"\ndef get_context(\n    target: str = Query(..., min_length=1, description=\"Entity ID or name to get context for\"),\n    max_tokens: int = Query(2000, description=\"Maximum amount of tokens allowed in the returned context\"),\n    task_type: TaskTypeParam = Query(TaskTypePara", "tokens": ["def", "get", "context", "target", "str", "max", "tokens", "int", "task", "type", "task", "type", "param", "service", "know", "code", "service", "any", "generates", "synthesized", "context", "bundle", "for", "an", "entity", "optimized", "for", "llm", "consumption", "the", "task", "type", "parameter", "enables", "task", "specific", "context", "prioritization", "explain", "prioritizes", "docstrings", "signatures", "and", "callees", "for", "understanding", "debug", "prioritizes", "source", "code", "and", "callers", "for", "tracing", "issues", "extend", "prioritizes", "patterns", "children", "and", "signatures", "for", "adding", "code", "review", "prioritizes", "changes", "callers", "and", "callees", "for", "impact", "analysis", "locate", "minimal", "context", "just", "location", "info", "general", "balanced", "context", "default", "returns", "sufficiency", "score", "indicating", "if", "context", "is", "sufficient", "for", "local", "answering", "def", "get", "context", "target", "str", "query", "min", "length", "description", "entity", "id", "or", "name", "to", "get", "context", "for", "max", "tokens", "int", "query", "2000", "description", "maximum", "amount", "of", "tokens", "allowed", "in", "the", "returned", "context", "task", "type", "task", "type", "param", "query", "task", "type", "para"], "metadata": {"kind": "function", "chunk_index": "0", "has_docstring": "true", "last_modified": "1768185812.9927197"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/api/api.py::get_context::1", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/api/api.py::get_context", "content": "mount of tokens allowed in the returned context\"),\n    task_type: TaskTypeParam = Query(TaskTypeParam.general, description=\"Task type for context prioritization\"),\n    service: KnowCodeService = Depends(get_service)\n) -> Any:\n    \"\"\"Generates a synthesized context bundle for an entity, optimized for LLM consumption.\n    \n    The task_type parameter enables task-specific context prioritization:\n    - explain: Prioritizes docstrings, signatures, and callees for understanding\n    - debug: Prioritizes source code and callers for tracing issues\n    - extend: Prioritizes patterns, children, and signatures for adding code\n    - review: Prioritizes changes, callers, and callees for impact analysis\n    - locate: Minimal context, just location info\n    - general: Balanced context (default)\n    \n    Returns sufficiency_score (0.0-1.0) indicating if context is sufficient for local answering.\n    \"\"\"\n    try:\n        # Convert API enum to data model enum\n        data_task_type = TaskType(task_type.", "tokens": ["mount", "of", "tokens", "allowed", "in", "the", "returned", "context", "task", "type", "task", "type", "param", "query", "task", "type", "param", "general", "description", "task", "type", "for", "context", "prioritization", "service", "know", "code", "service", "depends", "get", "service", "any", "generates", "synthesized", "context", "bundle", "for", "an", "entity", "optimized", "for", "llm", "consumption", "the", "task", "type", "parameter", "enables", "task", "specific", "context", "prioritization", "explain", "prioritizes", "docstrings", "signatures", "and", "callees", "for", "understanding", "debug", "prioritizes", "source", "code", "and", "callers", "for", "tracing", "issues", "extend", "prioritizes", "patterns", "children", "and", "signatures", "for", "adding", "code", "review", "prioritizes", "changes", "callers", "and", "callees", "for", "impact", "analysis", "locate", "minimal", "context", "just", "location", "info", "general", "balanced", "context", "default", "returns", "sufficiency", "score", "indicating", "if", "context", "is", "sufficient", "for", "local", "answering", "try", "convert", "api", "enum", "to", "data", "model", "enum", "data", "task", "type", "task", "type", "task", "type"], "metadata": {"kind": "function", "chunk_index": "1", "has_docstring": "true", "last_modified": "1768185812.9927197"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/api/api.py::get_context::2", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/api/api.py::get_context", "content": "\n    try:\n        # Convert API enum to data model enum\n        data_task_type = TaskType(task_type.value)\n        return service.get_context(target, max_tokens=max_tokens, task_type=data_task_type)\n    except ValueError as e:\n        raise HTTPException(status_code=404, detail=str(e))", "tokens": ["try", "convert", "api", "enum", "to", "data", "model", "enum", "data", "task", "type", "task", "type", "task", "type", "value", "return", "service", "get", "context", "target", "max", "tokens", "max", "tokens", "task", "type", "data", "task", "type", "except", "value", "error", "as", "raise", "httpexception", "status", "code", "404", "detail", "str"], "metadata": {"kind": "function", "chunk_index": "2", "has_docstring": "true", "last_modified": "1768185812.9927197"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/api/api.py::reload_store::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/api/api.py::reload_store", "content": "def reload_store(service: KnowCodeService) -> dict[str, str]\n\"\"\"Reload the knowledge store from disk.\"\"\"\ndef reload_store(service: KnowCodeService = Depends(get_service)) -> dict[str, str]:\n    \"\"\"Reload the knowledge store from disk.\"\"\"\n    try:\n        service.reload()\n        return {\"status\": \"reloaded\"}\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))", "tokens": ["def", "reload", "store", "service", "know", "code", "service", "dict", "str", "str", "reload", "the", "knowledge", "store", "from", "disk", "def", "reload", "store", "service", "know", "code", "service", "depends", "get", "service", "dict", "str", "str", "reload", "the", "knowledge", "store", "from", "disk", "try", "service", "reload", "return", "status", "reloaded", "except", "exception", "as", "raise", "httpexception", "status", "code", "500", "detail", "str"], "metadata": {"kind": "function", "has_docstring": "true", "last_modified": "1768185812.9927197"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/api/api.py::get_entity::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/api/api.py::get_entity", "content": "def get_entity(entity_id: str, service: KnowCodeService) -> Any\n\"\"\"Get raw entity details.\"\"\"\ndef get_entity(\n    entity_id: str,\n    service: KnowCodeService = Depends(get_service)\n) -> Any:\n    \"\"\"Get raw entity details.\"\"\"\n    details = service.get_entity_details(entity_id)\n    if not details:\n        raise HTTPException(status_code=404, detail=f\"Entity not found: {entity_id}\")\n    return details", "tokens": ["def", "get", "entity", "entity", "id", "str", "service", "know", "code", "service", "any", "get", "raw", "entity", "details", "def", "get", "entity", "entity", "id", "str", "service", "know", "code", "service", "depends", "get", "service", "any", "get", "raw", "entity", "details", "details", "service", "get", "entity", "details", "entity", "id", "if", "not", "details", "raise", "httpexception", "status", "code", "404", "detail", "entity", "not", "found", "entity", "id", "return", "details"], "metadata": {"kind": "function", "has_docstring": "true", "last_modified": "1768185812.9927197"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/api/api.py::get_callers::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/api/api.py::get_callers", "content": "def get_callers(entity_id: str, service: KnowCodeService) -> list[Any]\n\"\"\"Find all entities that call the specified entity.\"\"\"\ndef get_callers(\n    entity_id: str,\n    service: KnowCodeService = Depends(get_service)\n) -> list[Any]:\n    \"\"\"Find all entities that call the specified entity.\"\"\"\n    return service.get_callers(entity_id)", "tokens": ["def", "get", "callers", "entity", "id", "str", "service", "know", "code", "service", "list", "any", "find", "all", "entities", "that", "call", "the", "specified", "entity", "def", "get", "callers", "entity", "id", "str", "service", "know", "code", "service", "depends", "get", "service", "list", "any", "find", "all", "entities", "that", "call", "the", "specified", "entity", "return", "service", "get", "callers", "entity", "id"], "metadata": {"kind": "function", "has_docstring": "true", "last_modified": "1768185812.9927197"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/api/api.py::get_callees::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/api/api.py::get_callees", "content": "def get_callees(entity_id: str, service: KnowCodeService) -> list[Any]\n\"\"\"Find all entities called by the specified entity.\"\"\"\ndef get_callees(\n    entity_id: str,\n    service: KnowCodeService = Depends(get_service)\n) -> list[Any]:\n    \"\"\"Find all entities called by the specified entity.\"\"\"\n    return service.get_callees(entity_id)", "tokens": ["def", "get", "callees", "entity", "id", "str", "service", "know", "code", "service", "list", "any", "find", "all", "entities", "called", "by", "the", "specified", "entity", "def", "get", "callees", "entity", "id", "str", "service", "know", "code", "service", "depends", "get", "service", "list", "any", "find", "all", "entities", "called", "by", "the", "specified", "entity", "return", "service", "get", "callees", "entity", "id"], "metadata": {"kind": "function", "has_docstring": "true", "last_modified": "1768185812.9927197"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/api/api.py::DirectionParam::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/api/api.py::DirectionParam", "content": "\"\"\"Direction for call graph traversal.\"\"\"\nclass DirectionParam(str, Enum):\n    \"\"\"Direction for call graph traversal.\"\"\"\n    callers = \"callers\"\n    callees = \"callees\"", "tokens": ["direction", "for", "call", "graph", "traversal", "class", "direction", "param", "str", "enum", "direction", "for", "call", "graph", "traversal", "callers", "callers", "callees", "callees"], "metadata": {"kind": "class", "has_docstring": "true", "last_modified": "1768185812.9927197"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/api/api.py::trace_calls::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/api/api.py::trace_calls", "content": "def trace_calls(entity_id: str, direction: DirectionParam, depth: int, max_results: int, service: KnowCodeService) -> list[dict[str, Any]]\n\"\"\"Multi-hop call graph traversal.\n\nTraverse the call graph from a starting entity to find all callers or callees\nup to the specified depth. Each result includes the call_depth indicating\nhow many hops from the starting entity.\"\"\"\ndef trace_calls(\n    entity_id: str,\n    direction: DirectionParam = Query(DirectionParam.callees, description=\"Direction: callers or callees\"),\n    depth: int = Query(1, ge=1, le=5, description=\"Traversal depth (1-5)\"),\n    max_results: int = Query(50, ge=1, le=100, description=\"Max results\"),\n    service: KnowCodeService = Depends(get_service)\n) -> list[dict[str, Any]]:\n    \"\"\"Multi-hop call graph traversal.\n    \n    Traverse the call graph from a starting entity to find all callers or callees\n    up to the specified depth. Each result includes the call_depth indicating\n    how many hops from the starting entity.\n    \"\"\"", "tokens": ["def", "trace", "calls", "entity", "id", "str", "direction", "direction", "param", "depth", "int", "max", "results", "int", "service", "know", "code", "service", "list", "dict", "str", "any", "multi", "hop", "call", "graph", "traversal", "traverse", "the", "call", "graph", "from", "starting", "entity", "to", "find", "all", "callers", "or", "callees", "up", "to", "the", "specified", "depth", "each", "result", "includes", "the", "call", "depth", "indicating", "how", "many", "hops", "from", "the", "starting", "entity", "def", "trace", "calls", "entity", "id", "str", "direction", "direction", "param", "query", "direction", "param", "callees", "description", "direction", "callers", "or", "callees", "depth", "int", "query", "ge", "le", "description", "traversal", "depth", "max", "results", "int", "query", "50", "ge", "le", "100", "description", "max", "results", "service", "know", "code", "service", "depends", "get", "service", "list", "dict", "str", "any", "multi", "hop", "call", "graph", "traversal", "traverse", "the", "call", "graph", "from", "starting", "entity", "to", "find", "all", "callers", "or", "callees", "up", "to", "the", "specified", "depth", "each", "result", "includes", "the", "call", "depth", "indicating", "how", "many", "hops", "from", "the", "starting", "entity"], "metadata": {"kind": "function", "chunk_index": "0", "has_docstring": "true", "last_modified": "1768185812.9927197"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/api/api.py::trace_calls::1", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/api/api.py::trace_calls", "content": ". Each result includes the call_depth indicating\n    how many hops from the starting entity.\n    \"\"\"\n    return service.store.trace_calls(\n        entity_id,\n        direction=direction.value,\n        depth=depth,\n        max_results=max_results\n    )", "tokens": ["each", "result", "includes", "the", "call", "depth", "indicating", "how", "many", "hops", "from", "the", "starting", "entity", "return", "service", "store", "trace", "calls", "entity", "id", "direction", "direction", "value", "depth", "depth", "max", "results", "max", "results"], "metadata": {"kind": "function", "chunk_index": "1", "has_docstring": "true", "last_modified": "1768185812.9927197"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/api/api.py::get_impact::0", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/api/api.py::get_impact", "content": "def get_impact(entity_id: str, max_depth: int, service: KnowCodeService) -> dict[str, Any]\n\"\"\"Analyze the impact of modifying or deleting an entity.\n\nReturns:\n- direct_dependents: Entities that directly depend on this entity\n- transitive_dependents: Entities affected through the dependency chain\n- affected_files: Files that would need review\n- risk_score: 0.0-1.0 indicating modification risk\"\"\"\ndef get_impact(\n    entity_id: str,\n    max_depth: int = Query(3, ge=1, le=5, description=\"Max depth for transitive analysis\"),\n    service: KnowCodeService = Depends(get_service)\n) -> dict[str, Any]:\n    \"\"\"Analyze the impact of modifying or deleting an entity.\n    \n    Returns:\n    - direct_dependents: Entities that directly depend on this entity\n    - transitive_dependents: Entities affected through the dependency chain\n    - affected_files: Files that would need review\n    - risk_score: 0.0-1.0 indicating modification risk\n    \"\"\"\n    return service.store.get_impact(entity_id, max_depth=max_", "tokens": ["def", "get", "impact", "entity", "id", "str", "max", "depth", "int", "service", "know", "code", "service", "dict", "str", "any", "analyze", "the", "impact", "of", "modifying", "or", "deleting", "an", "entity", "returns", "direct", "dependents", "entities", "that", "directly", "depend", "on", "this", "entity", "transitive", "dependents", "entities", "affected", "through", "the", "dependency", "chain", "affected", "files", "files", "that", "would", "need", "review", "risk", "score", "indicating", "modification", "risk", "def", "get", "impact", "entity", "id", "str", "max", "depth", "int", "query", "ge", "le", "description", "max", "depth", "for", "transitive", "analysis", "service", "know", "code", "service", "depends", "get", "service", "dict", "str", "any", "analyze", "the", "impact", "of", "modifying", "or", "deleting", "an", "entity", "returns", "direct", "dependents", "entities", "that", "directly", "depend", "on", "this", "entity", "transitive", "dependents", "entities", "affected", "through", "the", "dependency", "chain", "affected", "files", "files", "that", "would", "need", "review", "risk", "score", "indicating", "modification", "risk", "return", "service", "store", "get", "impact", "entity", "id", "max", "depth", "max"], "metadata": {"kind": "function", "chunk_index": "0", "has_docstring": "true", "last_modified": "1768185812.9927197"}}, {"id": "/home/deeog/Desktop/KnowCode/src/knowcode/api/api.py::get_impact::1", "entity_id": "/home/deeog/Desktop/KnowCode/src/knowcode/api/api.py::get_impact", "content": "0 indicating modification risk\n    \"\"\"\n    return service.store.get_impact(entity_id, max_depth=max_depth)", "tokens": ["indicating", "modification", "risk", "return", "service", "store", "get", "impact", "entity", "id", "max", "depth", "max", "depth"], "metadata": {"kind": "function", "chunk_index": "1", "has_docstring": "true", "last_modified": "1768185812.9927197"}}, {"id": "/home/deeog/Desktop/KnowCode/.agent/rules/context.md::module::0", "entity_id": "/home/deeog/Desktop/KnowCode/.agent/rules/context.md::module", "content": "---\ntrigger: always_on\n---\nAlways call the tool retrieve_context_for_query before answering.\nUse task_type=auto, max_tokens=3000, limit_entities=3, expand_deps=true.\nIf sufficiency_score >= 0.88 and context_text is non-empty, answer ONLY from context_text.\nDo not call other tools or request more context.\nIf sufficiency_score < 0.88, then proceed with a full LLM answer.", "tokens": ["trigger", "always", "on", "always", "call", "the", "tool", "retrieve", "context", "for", "query", "before", "answering", "use", "task", "type", "auto", "max", "tokens", "3000", "limit", "entities", "expand", "deps", "true", "if", "sufficiency", "score", "88", "and", "context", "text", "is", "non", "empty", "answer", "only", "from", "context", "text", "do", "not", "call", "other", "tools", "or", "request", "more", "context", "if", "sufficiency", "score", "88", "then", "proceed", "with", "full", "llm", "answer"], "metadata": {"type": "module_header"}}, {"id": "/home/deeog/Desktop/KnowCode/.agent/rules/context.md::context::0", "entity_id": "/home/deeog/Desktop/KnowCode/.agent/rules/context.md::context", "content": "\"\"\"---\ntrigger: always_on\n---\"\"\"\ncontext", "tokens": ["trigger", "always", "on", "context"], "metadata": {"kind": "document", "has_docstring": "true", "last_modified": "1768288799.223795"}}]}